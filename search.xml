<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Example</title>
    <url>/post/10323.html</url>
    <content><![CDATA[<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>This is a test page!</p>
<a id="more"></a>
<p><img src="/images/code_c++.jpg" alt="test"></p>
<h3 id="站点构建："><a href="#站点构建：" class="headerlink" title="站点构建："></a>站点构建：<a href="https://travis-ci.org/Winddoing/Winddoing.github.io" target="_blank" rel="noopener"><img src="https://travis-ci.org/Winddoing/Winddoing.github.io.svg?branch=web_source" alt="Build Status"></a></h3><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<h3 id="站点设置"><a href="#站点设置" class="headerlink" title="站点设置"></a>站点设置</h3><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">配置：</a><br><a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">图标选择：</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>travis-ci</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Github搭建博客的简单记录</title>
    <url>/post/32555.html</url>
    <content><![CDATA[<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><ul>
<li>自从想写博客开始，就一直在找一个网站写一些自己的博文。把自己的在学习中的一些体验与心得记录下来。之前在一些网站上注册过一些<a href="http://blog.csdn.net/sdreamq" target="_blank" rel="noopener">博客</a>，可是广告太多了，文本格式编排很麻烦。后来看到了<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门</a>这篇文章，就一直想这搭建一个这样的博客，终于在这个寒假接近尾声之际搭建好了。其中遇到了各种麻烦真是一言难尽，在这里简单记录一些搭建过程。</li>
</ul>
<h3 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h3><h5 id="1-安装jekyll进行博客站点的本地预览"><a href="#1-安装jekyll进行博客站点的本地预览" class="headerlink" title="1. 安装jekyll进行博客站点的本地预览"></a>1. 安装<a href="http://jekyllrb.com/" target="_blank" rel="noopener">jekyll</a>进行博客站点的本地预览</h5><ul>
<li>jekyll的安装需要提前安装ruby</li>
<li>$ sudo apt-get ruby1.9.1-dev</li>
<li>$ gem install rdiscount</li>
<li>$ gem install RedCloth</li>
</ul>
<a id="more"></a>
<h5 id="2-安装Git将站点文件提交到Github"><a href="#2-安装Git将站点文件提交到Github" class="headerlink" title="2. 安装Git将站点文件提交到Github"></a>2. 安装Git将站点文件提交到<a href="http://github.com" target="_blank" rel="noopener">Github</a></h5><ul>
<li>在本地站点库目录下</li>
<li>$ git init</li>
<li>$ git add .</li>
<li>$ git commit -m “first page”</li>
<li>$ git remote add origin <a href="https://github.com/username/username.github.com.git" target="_blank" rel="noopener">https://github.com/username/username.github.com.git</a></li>
<li>$ git push -u origin master</li>
</ul>
<h5 id="3-利用jekyll进行本地预览"><a href="#3-利用jekyll进行本地预览" class="headerlink" title="3. 利用jekyll进行本地预览"></a>3. 利用jekyll进行本地预览</h5><ul>
<li><p>终端执行：</p>
</li>
<li><p>$ jekyll serve</p>
<p>然后在浏览器访问[<a href="http://0.0.0.0:4000/]" target="_blank" rel="noopener">http://0.0.0.0:4000/]</a></p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>本站主题是直接从<a href="https://github.com/december" target="_blank" rel="noopener">Luyf</a>clone下来的。</li>
<li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门</a></li>
<li><a href="http://blog.it580.com/%E4%BD%BF%E7%94%A8jekyll%E5%9C%A8github%E4%B8%8A%E6%9E%B6%E8%AE%BEblog/" target="_blank" rel="noopener">使用Jekyll在GitHub上架设Blog</a></li>
<li><a href="http://www.soimort.org/posts/101/" target="_blank" rel="noopener">像黑客一样写博客——Jekyll入门</a></li>
<li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版) </a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Github简单使用命令</title>
    <url>/post/56471.html</url>
    <content><![CDATA[<h3 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h3><ul>
<li><p>初始化（init）一个新的版本库，然后将目录中的所有文件纳入管理，Git把这个过程称为stage，最后以快照的方式提交所有文件。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &apos;initial commit&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>创建一个新的分支（branch），将它检出（checkout）为活动分支，然后就可以编辑、载入和提交新的快照。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch featureA</span><br><span class="line">$ git checkout featureA</span><br><span class="line"># (edit files)</span><br><span class="line">$ git add (files)</span><br><span class="line">$ git commit -m &apos;add feature A&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参与GitHub上的开源项目"><a href="#参与GitHub上的开源项目" class="headerlink" title="参与GitHub上的开源项目"></a>参与GitHub上的开源项目</h3><ul>
<li><p>先将托管在GitHub上的项目克隆（clone）到本地，做过更改之后推送回GitHub，然后发送一个pull请求，项目的维护者就会收到邮件通知。 在GitHub上fork（拷贝一份到你的版本库列表）项目：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/my-user/project</span><br><span class="line">$ cd project</span><br><span class="line"># (edit files)</span><br><span class="line">$ git add (files)</span><br><span class="line">$ git commit -m &apos;Explain what I changed&apos;</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式(regular expression) [^,*]与[^,]*区别</title>
    <url>/post/10189.html</url>
    <content><![CDATA[<h3 id="正则表达式-Regular-Expression-与-区别："><a href="#正则表达式-Regular-Expression-与-区别：" class="headerlink" title="正则表达式(Regular Expression) [^,]与[^,]区别："></a>正则表达式(Regular Expression) [^,<em>]与[^,]</em>区别：</h3><ol>
<li><p>$ sed ‘s/[^,]*/{&amp;}/‘ example.txt</p>
<p><img src="/assets/img/article-image/2014-03-06/01.png" alt="01"></p>
</li>
<li><p>$ sed ‘s/[^,*]/{&amp;}/‘ example.txt</p>
<p><img src="/assets/img/article-image/2014-03-06/02.png" alt="02"></p>
</li>
</ol>
<h4 id="使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：compu-t将匹配字符u一次或多次。"><a href="#使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：compu-t将匹配字符u一次或多次。" class="headerlink" title="使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：compu*t将匹配字符u一次或多次。"></a>使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：compu*t将匹配字符u一次或多次。</h4><p>  <img src="/assets/img/article-image/2014-03-06/03.png" alt="03"></p>
<ul>
<li>只匹配[ ] 内字符。可以是一个单字符，也可以是字符序列</li>
<li>[]在指定模式匹配的范围或限制方面很有用。结合使用*与[ ]更是有益，</li>
<li>例如:[ A - Z a - Z ] <em>将匹配所有单词
</em>注意* :^符号的使用，当直接用在第一个括号里，意指否定或不匹配括号里内容。</li>
</ul>
<h4 id="如-a-zA-Z-匹配任一非字母型字符，而-0-9-匹配任一非数字型字符。"><a href="#如-a-zA-Z-匹配任一非字母型字符，而-0-9-匹配任一非数字型字符。" class="headerlink" title="如:[^a-zA-Z]匹配任一非字母型字符，而[ ^ 0 - 9 ]匹配任一非数字型字符。"></a>如:[^a-zA-Z]匹配任一非字母型字符，而[ ^ 0 - 9 ]匹配任一非数字型字符。</h4><ul>
<li>$ sed ‘s/[^,*]/{&amp;}/‘ example.txt</li>
<li><p>表示把开头不是一个或多个“，”时的第一个字符加上{}</p>
<p><img src="/assets/img/article-image/2014-03-06/04.png" alt="04"></p>
</li>
</ul>
<p>只对第一个字符“1”加上了{}，主要原因是[ ]内的字符一次只匹配一个。</p>
<ul>
<li><p>表示把不是“，”之前的所有字符串，加上{}</p>
<p><img src="/assets/img/article-image/2014-03-06/05.png" alt="05"></p>
</li>
</ul>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><ul>
<li>原文本文件 example.txt<br>102,John Smith,IT Manager<br>103,Raj Reddy,Sysadmin<br>104,Anand Ram,Developer<br>105,Jane Miller,Sales Manager<br>,123<br>,lin,feng<br>,,,sss</li>
</ul>
<h4 id="截取非数字的所有字符-–失败"><a href="#截取非数字的所有字符-–失败" class="headerlink" title="截取非数字的所有字符  –失败"></a>截取非数字的所有字符  –失败</h4><ul>
<li><p>$ sed ‘s/[^0-9]*/ /‘ example.txt</p>
<p><img src="/assets/img/article-image/2014-03-06/06.png" alt="06"></p>
</li>
</ul>
<ul>
<li>失败原因：[^0-9]表示匹配一非数字型字符，而[^0-9]*表示一或多个非数字型字符，但只要有一个字符匹配成立，就进行替换。</li>
</ul>
<h4 id="截取非数字的所有字符-–成功"><a href="#截取非数字的所有字符-–成功" class="headerlink" title="截取非数字的所有字符  –成功"></a>截取非数字的所有字符  –成功</h4><ul>
<li><p>$ sed ‘s/[^0-9].*/ /‘ example.txt</p>
<p><img src="/assets/img/article-image/2014-03-06/07.png" alt="07"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>对目前学习的简单回顾与规划</title>
    <url>/post/16809.html</url>
    <content><![CDATA[<h3 id="我的大学"><a href="#我的大学" class="headerlink" title="我的大学"></a>我的大学</h3><ul>
<li>现在回想起来，已经来到沈阳快有两年了。在他乡的我应该算是很幸运了，有亲人、朋友的照顾，谢谢你们。同时，遇到了我的室友，是我和他们一起度过这段时光。我们在一起二过，呵呵呵。也许在大学的每一个宿舍里都有一群，可以陪你一起二的人。他们使你的大学生活有了不一样的记忆。我真是太不争气了，想着想着就不知道，怎么写了。其实今天也没有想着，写一些琐碎的事。可是当写下了标题后，就想说点啥。可是又不知道从何写起，等以后准备好了以后再写一篇“我的大学”。<a id="more"></a>
</li>
</ul>
<h3 id="我的学习"><a href="#我的学习" class="headerlink" title="我的学习"></a>我的学习</h3><ul>
<li><p>在高中的时候，听别人说在大学就可以轻松了。可是，现在真的“轻松”了吗？想学点东西有时可真是累，不知道学的有没有用。可是当你知道自己学的东西，是自己以后的可能从业方向时，有一次一次的坚持不下来。而有开始反问自己，呵呵呵，想着想着我都感到自己好笑了。我记得好像有人说过“人本身就是一个矛盾体”，是不是我这个矛盾体太大了。</p>
</li>
<li><p>还记得我在大一的时候，由于没有电脑上网时间不多。对一些专业方面的事，不大了解，只是听老师给我们讲的一些。那时周末没事干就去图书馆找一些小说看，现在想来那时抱着一本喜欢的小说还是挺不错的。记得看过的第一本小说是《伏藏》作者现在已经忘了，主要是通过西藏活佛仓央嘉措和他的情人与情歌的故事，写出了活佛与他的大爱，“伏藏”伏下的不是对世人的愤怒，而是大爱。现在已经很久没看过小说了，去年快放寒假的时候，在当当网买了一本《失控》，最坑人的是它从北京邮到沈阳整整用了八天时间。那时听说这本书不错，所以就买了。现在有时间了看看，实在是太难消化了，里面存在着大量的专业知识。不过是非常不错的一本书。</p>
</li>
<li><p>说了这么半天废话，写点正事。给自己一个总结，一个方向</p>
<ol>
<li>一直想学一些Linux方面的知识，想继续走下去。从以前的一些简单操作与日常管理和Gcc、makefile等，到现在想学习的shell、网络编程、与嵌入式Linux。</li>
<li>上学期学习完C++后，感觉对面向对象编程理解不深，想通过学习Qt编程加以巩固。</li>
<li>好好学习操作系统、微机原理，同时也希望这学期不在挂科</li>
</ol>
</li>
</ul>
<h3 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h3><ul>
<li>上面的一点东西都是自己，的一些简单想法和愿望吧。已经很久没写过东西了，现在都不会写了。用了一个下午才写了这篇随笔吧，也只能说是随笔了。可是让人想了很多，这也许是写博客的一个好处吧，给自己一个思考的时间。我一直在思考学习技术层次的东西到底有用吗，在大学我们到底学的是什么。技术这个东西只要你肯花时间和精力，一定会学会成为高手。在自己以后的工作中可以独挡一面吧。我现在还是一名学生，没有工作过可能有些观点不正确。</li>
<li>技术的学习可能就像是学功夫（我也是个功夫迷，喜欢成龙、李连杰），学功夫只会一些招式，成不了大师。它们都有一些内功心法提高自己的修为与功夫。我想学技术也应该差不多，我们应该思考一个命令、一个算法、一种模式背后所存在的方法和哲学吧。今天无意中看到这篇<a href="http://www.cnblogs.com/tcjiaan/p/3529358.html#!comments" target="_blank" rel="noopener">文章</a>感触很深。就像里面说的我们认识了解一个事物，应该深入到它所存在的价值和背后的哲学，而不是简单的理解一些表象的东西。这样才可以真正提高自身的能力。</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>动态分配二维数组</title>
    <url>/post/42179.html</url>
    <content><![CDATA[<h3 id="动态创建"><a href="#动态创建" class="headerlink" title="动态创建"></a>动态创建</h3><ul>
<li><p>动态数组是指在声明时没有确定数组大小的数组；当要用它时，C语言中用malloc语句重新指出数组的大小。使用动态数组的优点是可以根据用户需要，有效利用存储空间。</p>
</li>
<li><p>有时根据题意需得根据输入的二维数来动态的创建二维数组，那么此时就不能想以前一样直接定义多少行多少列了。因为不知道行列多少，假如设定太大浪费空间，申请太小完成不了程序的数据存储。因此需要合理的开辟二维空间。</p>
<a id="more"></a>
<h3 id="动态数组与静态数组的对比"><a href="#动态数组与静态数组的对比" class="headerlink" title="动态数组与静态数组的对比"></a>动态数组与静态数组的对比</h3></li>
</ul>
<blockquote>
<p>对于静态数组，其创建非常方便，使用完也无需释放，要引用也简单，但是创建后无法改变其大小是其致命弱点！<br>对于动态数组，其创建麻烦，使用完必须由程序员自己释放，否则严重会引起内存泄露。但其使用非常灵活，能根据程序需要动态分配大小。</p>
</blockquote>
<h3 id="遵循原则"><a href="#遵循原则" class="headerlink" title="遵循原则"></a>遵循原则</h3><blockquote>
<p>申请的时候从外层往里层，逐层申请；<br>释放的时候从里层往外层，逐层释放。</p>
</blockquote>
<h3 id="构建所需指针"><a href="#构建所需指针" class="headerlink" title="构建所需指针"></a>构建所需指针</h3><blockquote>
<p>对于构建一维动态数组，需要一维指针；<br>对于二维，则需要一维，二维指针；<br>三维需要一，二，三维指针；<br>依此类推。</p>
</blockquote>
<ul>
<li>以下的两种方法都可以建立动态的二维空间数组。</li>
</ul>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><ul>
<li><p>使用指针动态分配</p>
<pre><code>int i,j;
int r,c;
int **a;  //创建二维指针来指向数组
scanf(&quot;%d%d&quot;,&amp;r,&amp;c);
a  = (int **) malloc(sizeof(int *) * r);//注意申请的指针格式
for (j=0;j&lt;r;j++){
a[j] = (int *) malloc(sizeof(int) * c);
……
……
}
</code></pre></li>
<li><p>释放为：</p>
<pre><code>for (j=0;j&lt;r;j++)
 free(a[j]);//先释放一维指针
 free(a);//最后释放我二维指针
</code></pre></li>
</ul>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><ul>
<li><p>建立链表来存放二维数组。</p>
<pre><code>typedef struct arr
{
    int *array;
}arr;
main()
{
    arr *array1;
    int rowx,rowy;
    int i,j,k=0;
    scanf(&quot;%d %d&quot;,&amp;rowx,&amp;rowy);
    array1=(arr *)malloc(sizeof(arr)*rowx);//创建链表数组
    for(i=0;i&lt;rowx;i++)
                //再在每一个链表中创建一维数组，这样整体就构成二维数组
        array1[i].array=(int *)malloc(sizeof(int)*rowy);
……
……
</code></pre></li>
<li><p>释放同上：</p>
<pre><code>for (j=0;j&lt;rowx;j++)
 free(array1[j].array);
 free(array);

｝
</code></pre></li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    int n1,n2,n3;
    int ***array;
    int i,j,k;

    puts(&quot;输入一维长度:&quot;);
    scanf(&quot;%d&quot;,&amp;n1);
    puts(&quot;输入二维长度:&quot;);
    scanf(&quot;%d&quot;,&amp;n2);
    puts(&quot;输入三维长度:&quot;);
    scanf(&quot;%d&quot;,&amp;n3);

    array=(int***)malloc(n1*sizeof(int**));//第一维
    for(i=0; i&lt;n1; i++)
    {
        array[i]=(int**)malloc(n2*sizeof(int*)); //第二维
        for(j=0;j&lt;n2;j++)
        {
            array[i][j]=(int*)malloc(n3*sizeof(int)); //第三维
            for(k=0;k&lt;n3;k++)
            {
                array[i][j][k]=i+j+k+1;
                printf(&quot;%d\t&quot;,array[i][j][k]);
            }
            puts(&quot;&quot;);
        }
        puts(&quot;&quot;);
    }
    for(i=0;i&lt;n1;i++)
    {
        for(j=0;j&lt;n2;j++)
        {
            free(array[i][j]);//释放第三维指针
        }
    }
    for(i=0;i&lt;n1;i++)
    {
        free(array[i]);//释放第二维指针
    }
    free(array);//释放第一维指针

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态分配</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机延时函数简单分析</title>
    <url>/post/3878.html</url>
    <content><![CDATA[<h3 id="初识延时程序"><a href="#初识延时程序" class="headerlink" title="初识延时程序"></a>初识延时程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> xms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;</span><br><span class="line">  	<span class="keyword">for</span>(i=xms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    	<span class="keyword">for</span>(j=<span class="number">112</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用此函数可以达到我们想要的延时，使二极管发生闪烁。这也是我刚学单片机的小白，遇到的第一个问题。为什么要用延时，难道仅仅是为了闪烁，它还有啥作用；当我们调用delay(500)时，它到底延时了多长时间。。。。<a id="more"></a></li>
<li>由于是自学所以只能靠自己了，通过查阅参考书和在网上搜索，自己也算理解一点。现在就将自己理解的记录一下，就当做笔记了</li>
</ul>
<h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><ol>
<li><p><strong>振荡周期：</strong>也称时钟周期，是指为单片机提供时钟脉冲信号的振荡源的周期，两个相邻同方向峰值之间的时间,一个时钟周期 ＝晶振的倒数。。</p>
</li>
<li><p><strong>状态周期：</strong>每个状态周期为时钟周期的2倍，是振荡周期经二分频后得到的。</p>
</li>
<li><p><strong>机器周期：</strong>指单片机完成一个基本操作所花费的时间，一般使用微秒来计量单片机的运行速度，12Mhz的频率，其周期为1/12乘10的-6方s,那么1个机器周期就是它的12倍，即1us。51 单片机的一个机器周期包括12个时钟振荡周期，也就是说如果51 单片机采用12MHz 晶振，那么执行一个机器周期就只需要1μs；如果采用的是6MHz 的晶振，那么执行一个机器周期就需要2 μs。</p>
</li>
<li><p><strong>指令周期：</strong>指单片机执行一条指令所需要的时间，一般利用单片机的机器周期来计量指令周期。在51 单片机里有单周期指令（执行这条指令只需一个机器周期），双周期指令（执行这条指令只需要两个机器周期），四周期指令（执行这条指令需要四个机器周期）。除了乘、除两条指令是四周期指令，其余均为单周期或双周期指令。也就是说，如果51 单片机采用的是12MHz 晶振，那么它执行一条指令一般只需<br>1~2 微秒的时间；如果采用的是6MH 晶振，执行一条指令一般就需2~4 微秒的时间。</p>
</li>
</ol>
<ul>
<li>MCS-51单片机的一个机器周期=6个状态周期=12个时钟周期</li>
</ul>
<h3 id="为什么要用延时"><a href="#为什么要用延时" class="headerlink" title="为什么要用延时"></a>为什么要用延时</h3><ol>
<li>时序是描述对象之间发送消息的时间顺序显示多个对象之间的动态协作，这样就需要等待，等待就可以通过延时子程序实现。</li>
<li>为了单纯的等待，比如交通信号灯的控制，红灯绿灯黄灯都有时间控制，亮的长短就要由延时程序控制，或者CPU速度快于外设速度时，就需要用延时程序做等待！</li>
<li>为了某些时序逻辑器件的时序要求。</li>
</ol>
<h3 id="延时的具体实现方法"><a href="#延时的具体实现方法" class="headerlink" title="延时的具体实现方法"></a>延时的具体实现方法</h3><ul>
<li>在单片机编程里面并没有真正的延时指令，从上面的概念中我们知道单片机每执行一条指令都需要一定的时间，所以要达到延时的效果，只须让单片机不断地执行没有具体实际意义的指令，从而达到了延时。</li>
</ul>
<h4 id="汇编语言中基本的延时语句"><a href="#汇编语言中基本的延时语句" class="headerlink" title="汇编语言中基本的延时语句"></a>汇编语言中基本的延时语句</h4><ol>
<li><p>数据传送指令 MOV<br>数据传送指令功能是将数据从一个地方复制、拷贝到另一个地方。</p>
<pre><code>MOV R7，#80H   ；将数据80H
</code></pre><p>送到寄存器R7，这时寄存器R7里面存放着80H，就单这条指令而言并没有任何实际意义，而执行该指令则需要一个机器周期。</p>
</li>
<li>空操作指令 NOP<br>空操作指令功能只是让单片机执行没有意义的操作，消耗一个机器周期。</li>
<li><p>循环转移指令 DJNZ<br>循环转移指令功能是将第一个数进行减1 并判断是否为0，不为0 则转移到指定地点；为0 则往下执行。</p>
<pre><code>DJNZ R7，KK ；
</code></pre><p>将寄存器R7 的内容减1 并判断寄存器R7 里的内容减完1 后是否为0<br>如果不为0 则转移到地址标号为KK 的地方；<br>如果为0 则执行下一条指令。这条指令需要2个机器周期。<br>利用以上三条指令的组合就可以比较精确地编写出所需要的延时程序。</p>
</li>
</ol>
<h4 id="C51下的延时语句"><a href="#C51下的延时语句" class="headerlink" title="C51下的延时语句"></a>C51下的延时语句</h4><ol>
<li>使用空的for循环，可以多层嵌套，比如上面给出的例子</li>
<li>使用while()语句</li>
</ol>
<ul>
<li><strong>注意：</strong>在C51中定义循环变量时，尽量采用无符号整型；for，while循环变量体变量采用减减方法。</li>
</ul>
<h3 id="延时程序时间的计算"><a href="#延时程序时间的计算" class="headerlink" title="延时程序时间的计算"></a>延时程序时间的计算</h3><h4 id="汇编指令的时间计算"><a href="#汇编指令的时间计算" class="headerlink" title="汇编指令的时间计算"></a>汇编指令的时间计算</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	MOV R6，   #<span class="number">20</span></span><br><span class="line">D1：MOV R7，   #<span class="number">248</span></span><br><span class="line">      	DNJZ R7，$ <span class="comment">//循环248次，共用248X2us,</span></span><br><span class="line">      	DNJZ R6，D1</span><br></pre></td></tr></table></figure>
<ul>
<li>我觉得应该从最后往前算，在MOR R7，#248执行一次前提下，用时1X2us,然后循环减248，用时248X2us,故共用时[2+2X248]us。<br>然而又由于DNJZ R6，D1，上面的过程又循环20次，故上面的循环最终用时20X[2+2X248]us。<br>接着注意到单纯DNJZ R6，D1会用时20X2=40us<br>最后注意过执行唯一一次的  MOV R6，#20会用时1X2us。</li>
</ul>
<h4 id="C51延时函数的计算"><a href="#C51延时函数的计算" class="headerlink" title="C51延时函数的计算"></a>C51延时函数的计算</h4><ul>
<li>500ms延时子程序程序:.(晶振12MHz,一个机器周期1us.一条指令周期2us)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay500ms</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">15</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">202</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">         <span class="keyword">for</span>(k=<span class="number">81</span>;k&gt;<span class="number">0</span>;k--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>计算分析:程序共有三层循环</li>
</ul>
<ol>
<li>一层循环n:R5<em>2 = 81</em>2 = 162us  DJNZ 2us</li>
<li>二层循环m:R6<em>(n+3) = 202</em>165 = 33330us  DJNZ 2us + R5赋值 1us = 3us</li>
<li>三层循环: R7<em>(m+3) = 15</em>33333 = 499995us DJNZ 2us + R6赋值 1us = 3us</li>
</ol>
<ul>
<li>循环外: 5us [子程序调用 2us + 子程序返回 2us + R7赋值 1us = 5us ]</li>
<li><p>延时总时间 = 三层循环 + 循环外 = 499995+5 = 500 000us =500ms</p>
</li>
<li><p><strong>所以开头给出来得延时函数delay(500)时间，循环外+ 两层循环 = 5+112<em>2</em>500us = 56005us = 56.005ms =0.056005s</strong></p>
</li>
<li><p><em>1s延时子程序 :</em></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay1s</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> h,i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(h=<span class="number">5</span>;h&gt;<span class="number">0</span>;h--)</span><br><span class="line"> 		<span class="keyword">for</span>(i=<span class="number">4</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    		<span class="keyword">for</span>(j=<span class="number">116</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    			<span class="keyword">for</span>(k=<span class="number">214</span>;k&gt;<span class="number">0</span>;k--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间计算</li>
</ul>
<blockquote>
<p>time = 2<em>214</em>116<em>4</em>5 + 5 = 992 965us = 0.992965s ≈ 1s</p>
</blockquote>
<h3 id="51单片机数据类型大小测试"><a href="#51单片机数据类型大小测试" class="headerlink" title="51单片机数据类型大小测试"></a>51单片机数据类型大小测试</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit led1=P1^<span class="number">0</span>;</span><br><span class="line">sbit led2=P1^<span class="number">1</span>;</span><br><span class="line">sbit led4=P1^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> char_size, int_size;</span><br><span class="line"></span><br><span class="line">    char_size = <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">	int_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(char_size==<span class="number">1</span>)   <span class="comment">//测试char占一个字节</span></span><br><span class="line">		led1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(int_size==<span class="number">2</span>)    <span class="comment">//测试int 占两个字节</span></span><br><span class="line">		led2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>硬件设计</tag>
        <tag>51</tag>
      </tags>
  </entry>
  <entry>
    <title>vmware文件共享</title>
    <url>/post/36698.html</url>
    <content><![CDATA[<ul>
<li>看这破网速实在是蛋疼，200多兆的更新文件，下载了半个小时。闲来无事就随便写写，这次不知道咋了。一个VMware tool安装完居然找不到共享文件夹。网上找半天解决办法，照着来一遍吧，最简单可是设置成功后，只要系统一挂起或是重启，好像共享有关闭了。写到这突然觉得是不是，重启后VMware共享服务给关了，没有办法自动重启服务。现在想试试可已经重新安装了一遍VMware tool，将open-vm-dkms工具更新后，看能不能重新挂载hgfs文件。<a id="more"></a>
呵呵，这就是现在蛋疼的地方，第一次使用apt-get upgarde 软件名 更新软件，以为是只更新单独软件，谁知道更新了423个软件包。这就是我们小白的痛苦吧，也不敢中断怕软件更新不完整，开个玩笑，呵呵。软件更新是先下载，在进行更新软件操作，我现在正在下载。这个月流量刚开始这点流量不是事。只是希望更新完后，共享文件可以顺利挂载mount -t vmhgfs .host:/ /mnt/hgfs 一个回车OK。vmhgfs表示文件系统类型，VMware虚拟操作系统与宿主机之间共享的特定文件类型。根据monut命令的格式，.host:/ 应该表示需要挂载的文件，没加共享文件名，表示VMware共享的所有宿主机的文件。在虚拟操作系统ubuntu 12.10 下可以使用vmware-hgfsclient命令查看宿主机共享文件名。</li>
<li>终于快下载完了，边写边搜边想，感觉还是不能显示共享文件夹，安装完了试试在说吧。</li>
<li>文件共享终于成功了，还是网络的力量大啊呵呵呵。</li>
</ul>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>很久没有更新过了</title>
    <url>/post/20021.html</url>
    <content><![CDATA[<p>今天看看已经很久没有更新过博客了，最开始的时候想自己搭建一个小窝写一写自己的所思所想。</p>
<p>经过这段时间的培训，笔记做了很多的整理，可是总感觉少了点什么？</p>
<p>或许是对某写问题得到深入思索吧，在这里以后不仅记录对技术的实现更应该写写背后思索</p>
<p>继续开始做吧，我的无线网卡驱动移植难吗，下次就是分析一下无线网卡的移植和方法</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>rt73网卡的移植</title>
    <url>/post/58471.html</url>
    <content><![CDATA[<p>经过对RT73类网卡驱动源码的几次编译，修改了多出报错信息之后，还是无法完成移植。最终还是用了友善之臂提供的<a href="/src/toolchains/usb-wifi-kits-for-mini2440-linux-2.6.32.2-20100728.tar.gz">usb-wifi-kits-for-mini2440-linux-2.6.32.2-20100728.tar.gz</a>工具集。</p>
<pre><code>#tar zxvf usb-wifi-kits-for-mini2440-linux-2.6.32.2-20100728.tar.gz -C /
</code></pre><a id="more"></a>
<p>根据友善之臂提供的<a href="/src/toolchains/基于mini2440的USB无线网卡使用指南-20100729.pdf">文档</a>，解压完直接使用scan-wifi、start-wifi等命令就可以使用该无线网卡，可是我使用scan-wifi时搜索不到任何热点。</p>
<p>最后在网上找根据这篇<a href="http://linux.chinaunix.net/techdoc/install/2009/03/26/1105858.shtml" target="_blank" rel="noopener">文章</a>,给开发板安装了<a href="/src/toolchains/wireless_tools.29.tar.gz">iwconfig</a>工具，并重新配置了一下。</p>
<pre><code># ifconfig rausb0 inet 192.168.1.77 up
# route add default gw 192.168.1.1
# iwconfig rausb0 essid &quot;linuxer&quot;
# iwconfig rausb0 mode mananed
# iwconfig rausb0 channel 6
</code></pre><p>scan-wifi成功</p>
<p>这里做简单的记录为保存这几个工具，以备日后再用</p>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>rt73</tag>
        <tag>arm</tag>
        <tag>网卡</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】micro2440 移植boa服务器</title>
    <url>/post/62852.html</url>
    <content><![CDATA[<p>Boa是一种非常小巧的Web服务器，其可执行代码只有大约60KB左右。作为一种单任务Web服务器，Boa只能依次完成用户的请求，而不会fork出新的进程来处理并发连接请求。但Boa支持CGI，能够为CGI程序fork出一个进程来执行。Boa的设计目标是速度和安全。<br>　　<br>下面结合网上一些文档,及自己的实验给大家介绍一下Boa服务器移植的具体操作步骤。<br>　　<br>环境<br>    主机：redhat linux<br>    目标：Micro2440开发板</p>
 <a id="more"></a>
<h3 id="1-下载Boa源码"><a href="#1-下载Boa源码" class="headerlink" title="1.下载Boa源码"></a>1.下载Boa源码</h3><p>下载地址: <a href="http://www.boa.org/" target="_blank" rel="noopener">http://www.boa.org/</a><br>最新发行版本： 0.94.13<br>下载 boa-0.94.13.tar.gz<br>将其拷贝到/opt/FriendlyARM/boa文件夹（自己创建的FriendlyARM/boa目录）解压：# tar xzf boa-0.94.13.tar.gz</p>
<h3 id="2-修改文件"><a href="#2-修改文件" class="headerlink" title="2.修改文件"></a>2.修改文件</h3><h4 id="1-修改boa-0-94-13的-src-compat-h文件"><a href="#1-修改boa-0-94-13的-src-compat-h文件" class="headerlink" title="(1)修改boa-0.94.13的 src/compat.h文件"></a>(1)修改boa-0.94.13的 src/compat.h文件</h4><p>　　找到</p>
<pre><code>#define TIMEZONE_OFFSET(foo) foo##-&gt;tm_gmtoff
</code></pre><p>　　修改成</p>
<pre><code>#define TIMEZONE_OFFSET(foo) (foo)-&gt;tm_gmtoff
</code></pre><p>　　否则会出现错误：</p>
<pre><code>util.c:100:1: error: pasting &quot;t&quot; and &quot;-&gt;&quot; does not give a valid preprocessing token make: *** [util.o] 错误 1
</code></pre><h4 id="2-修改boa-0-94-13的src-log-c"><a href="#2-修改boa-0-94-13的src-log-c" class="headerlink" title="(2)修改boa-0.94.13的src/log.c"></a>(2)修改boa-0.94.13的src/log.c</h4><p>　　注释掉</p>
<pre><code>if (dup2(error_log, STDERR_FILENO) == -1) {
    DIE(&quot;unable to dup2 the error log&quot;);
}
</code></pre><p>　　为：</p>
<pre><code>/*if (dup2(error_log, STDERR_FILENO) == -1) {
DIE(&quot;unable to dup2 the error log&quot;);
}*/
</code></pre><p>　　否则会出现错误：</p>
<pre><code>log.c:73 unable to dup2 the error log:bad file deor
</code></pre><h4 id="3-修改boa-0-94-13的src-boa-c"><a href="#3-修改boa-0-94-13的src-boa-c" class="headerlink" title="(3)修改boa-0.94.13的src/boa.c"></a>(3)修改boa-0.94.13的src/boa.c</h4><p>　　注释掉下面两句话：</p>
<pre><code>if (passwdbuf == NULL) {
    DIE(”getpwuid”);
}
if (initgroups(passwdbuf-&gt;pw_name, passwdbuf-&gt;pw_gid) == -1) {
    DIE(”initgroups”);
}
</code></pre><p>　　为</p>
<pre><code>#if 0
if (passwdbuf == NULL) {
    DIE(”getpwuid”);
}
if (initgroups(passwdbuf-&gt;pw_name, passwdbuf-&gt;pw_gid) == -1) {
    DIE(”initgroups”);
}
#endif
</code></pre><p>　　否则会出现错误：</p>
<pre><code>boa.c:211 - getpwuid: No such file or directory
</code></pre><p>　　注释掉下面语句：</p>
<pre><code>if (setuid(0) != -1) {
    DIE(”icky Linux kernel bug!”);
}
</code></pre><p>　　为</p>
<pre><code>#if 0
if (setuid(0) != -1) {
    DIE(”icky Linux kernel bug!”);
}
#endif
</code></pre><p>　　否则会出现问题：<br>        boa.c:228 - icky Linux kernel bug!: No such file or directory</p>
<h3 id="3、生成Makefile文件"><a href="#3、生成Makefile文件" class="headerlink" title="3、生成Makefile文件"></a>3、生成Makefile文件</h3><p>　　执行：</p>
<p>　　#cd /opt/FriendlyARM/boa/boa-0.94.13/src<br>　　#./configure</p>
<h3 id="4、修改Makefile"><a href="#4、修改Makefile" class="headerlink" title="4、修改Makefile"></a>4、修改Makefile</h3><p>　　#cd /opt/FriendlyARM/boa/boa-0.94.13/src</p>
<p>　　vim Makefile</p>
<p>　　修改CC = gcc 为 CC = arm-linux-gcc<br>　　修改CPP = gcc -E 为 CC = arm-linux-gcc -E</p>
<h3 id="5、编译"><a href="#5、编译" class="headerlink" title="5、编译"></a>5、编译</h3><p>　　还是在/opt/FriendlyARM/boa/boa-0.94.13/src目录下</p>
<pre><code>#make

ls -l boa
-rwxr-xr-x 1 root root 189223 Jun 26 09:02 boa
</code></pre><p>　　然后为生成的二进制文件boa瘦身</p>
<pre><code>arm-linux-strip boa

ls -l boa
-rwxr-xr-x 1 root root 59120 Jun 26 09:03 boa
</code></pre><p>　　可以发现boa的大小前后差距很大这为我们节省了很大的空间</p>
<h3 id="6、Boa的配置"><a href="#6、Boa的配置" class="headerlink" title="6、Boa的配置"></a>6、Boa的配置</h3><p>　　这一步的工作也在电脑虚拟机上完成。<br>　　在boa-0.94.13目录下已有一个示例boa.conf，可以在其基础上进行修改。如下：</p>
<p>　　#vi boa.conf</p>
<h4 id="1-Group的修改"><a href="#1-Group的修改" class="headerlink" title="(1)Group的修改"></a>(1)Group的修改</h4><p>　　修改 Group nogroup<br>　　为 Group 0</p>
<h4 id="2-user的修改"><a href="#2-user的修改" class="headerlink" title="(2)user的修改"></a>(2)user的修改</h4><p>　　修改 User nobody<br>　　为 User 0<br>    或者统一设置为<br>        User root<br>        Group root</p>
<h4 id="3-ScriptAlias的修改"><a href="#3-ScriptAlias的修改" class="headerlink" title="(3)ScriptAlias的修改"></a>(3)ScriptAlias的修改</h4><p>　　修改ScriptAlias/cgi-bin/ /usr/lib/cgi-bin/<br>　　为 ScriptAlias/cgi-bin/ /www/cgi-bin/</p>
<h4 id="5-DoucmentRoot的修改"><a href="#5-DoucmentRoot的修改" class="headerlink" title="(5)DoucmentRoot的修改"></a>(5)DoucmentRoot的修改</h4><p>　　修改DoucmentRoot /var/www<br>　　为DoucmentRoot /www</p>
<h4 id="6-ServerName的设置"><a href="#6-ServerName的设置" class="headerlink" title="(6)ServerName的设置"></a>(6)ServerName的设置</h4><p>　　修改#ServerName <a href="http://www.your.org.here" target="_blank" rel="noopener">www.your.org.here</a><br>　　为 ServerName <a href="http://www.your.org.here" target="_blank" rel="noopener">www.your.org.here</a><br>　　否则会出现错误“gethostbyname::No such file or directory”</p>
<h4 id="7-AccessLog修改"><a href="#7-AccessLog修改" class="headerlink" title="(7)AccessLog修改"></a>(7)AccessLog修改</h4><p>　　修改AccessLog /var/log/boa/access_log<br>　　为#AccessLog /var/log/boa/access_log<br>否则会出现错误提示：“unable to dup2 the error log: Bad file deor”</p>
<h3 id="7、以下配置和boa-conf的配置有关，都是在mini2440开发板的ARM根文件系统中创建："><a href="#7、以下配置和boa-conf的配置有关，都是在mini2440开发板的ARM根文件系统中创建：" class="headerlink" title="7、以下配置和boa.conf的配置有关，都是在mini2440开发板的ARM根文件系统中创建："></a>7、以下配置和boa.conf的配置有关，都是在mini2440开发板的ARM根文件系统中创建：</h3><p>　　创建目录/etc/boa并且把主机的boa可执行文件（/opt/FriendlyARM/boa/boa-0.94.13/src） 和 boa.conf（/opt/FriendlyARM/boa/boa-0.94.13）拷贝到这个目录下</p>
<p>　　#mkdir /etc/boa</p>
<p><strong>注</strong>：boa.conf配置文件必须放在/etc/boa中。boa可执行文件位置可随意，否则启动boa将报错。</p>
<blockquote>
<p>Could not chdir to “/etc/boa”: aborting</p>
</blockquote>
<p>　　创建HTML文档的主目录/www</p>
<p>　　#mkdir /www</p>
<p>　　创建CGI脚本所在录 /www/cgi-bin</p>
<pre><code>    #mkdir /www/cgi-bin

在www下添加测试主页index.html

    &lt;head&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;
    &lt;title&gt;Test Boa&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello BOA&lt;br&gt;
    &lt;/body&gt;
    &lt;/html&gt;


创建日志文件夹 /var/log

    #mkdir /var/log
</code></pre><h3 id="8-执行boa服务器"><a href="#8-执行boa服务器" class="headerlink" title="8.执行boa服务器"></a>8.执行boa服务器</h3><p>进入/etc/boa目录，修改boa的执行权限，</p>
<pre><code>#chmod +x boa
#./boa
</code></pre><p>开启boa</p>
<h3 id="9-在windows-xp-ie输入开发板的ip（http-192-168-1-230）地址，即可访问到mini2440的默认网页。"><a href="#9-在windows-xp-ie输入开发板的ip（http-192-168-1-230）地址，即可访问到mini2440的默认网页。" class="headerlink" title="9.在windows xp ie输入开发板的ip（http://192.168.1.230）地址，即可访问到mini2440的默认网页。"></a>9.在windows xp ie输入开发板的ip（<a href="http://192.168.1.230）地址，即可访问到mini2440的默认网页。" target="_blank" rel="noopener">http://192.168.1.230）地址，即可访问到mini2440的默认网页。</a></h3>]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>boa</tag>
      </tags>
  </entry>
  <entry>
    <title>移植mjpg-streamer</title>
    <url>/post/50611.html</url>
    <content><![CDATA[<p>Mjpg‐streamer是一个开源软件，用于从webcam摄像头采集图像，把它们以流的形式通过基于ip的网络传输到浏览器如Firefox，Cambozola，VLC播放器，Windows的移动设备或者其他拥有浏览器的移动设备</p>
<p>移植Mjpg-streamer需要libjpeg库，因此要先移植libjpeg<br><a id="more"></a></p>
<h3 id="1-移植jpeg"><a href="#1-移植jpeg" class="headerlink" title="1.移植jpeg"></a>1.移植jpeg</h3><h4 id="a-从http-lt-www-ijg-org-files-gt-下载jpeg源码包；"><a href="#a-从http-lt-www-ijg-org-files-gt-下载jpeg源码包；" class="headerlink" title="a. 从http:&lt;//www.ijg.org/files/&gt;下载jpeg源码包；"></a>a. 从http:&lt;//<a href="http://www.ijg.org/files/&gt;下载jpeg源码包；" target="_blank" rel="noopener">www.ijg.org/files/&gt;下载jpeg源码包；</a></h4><h4 id="b-解压，进入其目录"><a href="#b-解压，进入其目录" class="headerlink" title="b. 解压，进入其目录"></a>b. 解压，进入其目录</h4><pre><code>tar zxvf jpegsrc.v9a.tar.gz
cd  /work/embedded/video/jpeg-9a
</code></pre><h4 id="c-配置源码，（具体配置项可以运行命令-configure-–help看看是什么意思，根据实际情况修改）"><a href="#c-配置源码，（具体配置项可以运行命令-configure-–help看看是什么意思，根据实际情况修改）" class="headerlink" title="c. 配置源码，（具体配置项可以运行命令./configure –help看看是什么意思，根据实际情况修改）"></a>c. 配置源码，（具体配置项可以运行命令./configure –help看看是什么意思，根据实际情况修改）</h4><pre><code>#./configure CC=arm-linux-gcc --host=arm-unknown-linux --prefix=/work/embedded/video/jpeg --enable-shared --enable-static
</code></pre><p>其中/work/embedded/video/jpeg是编译后安装的目录，根据实际情况修改</p>
<h4 id="d-编译："><a href="#d-编译：" class="headerlink" title="d. 编译："></a>d. 编译：</h4><pre><code>#make
</code></pre><h4 id="e-安装："><a href="#e-安装：" class="headerlink" title="e. 安装："></a>e. 安装：</h4><pre><code>#make install
</code></pre><h4 id="f-拷贝库文件到开发板文件系统"><a href="#f-拷贝库文件到开发板文件系统" class="headerlink" title="f. 拷贝库文件到开发板文件系统"></a>f. 拷贝库文件到开发板文件系统</h4><p>将/work/embedded/video/jpeg-9a/jpeg<br>目录下全部文件拷贝到开发板文件系统/work/embedded/rootfs/usr/local/mjpg-streamer下(此目录为mjpg-streamer在开发板的安装目录，当然你也可以把它放在开发板的/lib/目录下）</p>
<pre><code>cp lib/* /work/embedded/rootfs/lib/
</code></pre><h3 id="2-移植mjpg-streamer"><a href="#2-移植mjpg-streamer" class="headerlink" title="2. 移植mjpg-streamer"></a>2. 移植mjpg-streamer</h3><h4 id="a-下载源码，在https-sourceforge-net-projects-mjpg-streamer-下载的源码"><a href="#a-下载源码，在https-sourceforge-net-projects-mjpg-streamer-下载的源码" class="headerlink" title="a. 下载源码，在https://sourceforge.net/projects/mjpg-streamer/下载的源码"></a>a. 下载源码，在<a href="https://sourceforge.net/projects/mjpg-streamer/下载的源码" target="_blank" rel="noopener">https://sourceforge.net/projects/mjpg-streamer/下载的源码</a></h4><pre><code>#tar zxvf mjpg-streamer-r63.tar.gz
</code></pre><h4 id="b-修改plugins-input-uvc-Makfile"><a href="#b-修改plugins-input-uvc-Makfile" class="headerlink" title="b. 修改plugins/input_uvc/Makfile"></a>b. 修改plugins/input_uvc/Makfile</h4><pre><code>CFLAGS = -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC
</code></pre><p>为（即添加头文件-I）</p>
<pre><code>CFLAGS += -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC -I/work/embedded/v    ideo/jpeg-9a/jpeg/include
</code></pre><p>修改</p>
<pre><code>$(CC) $(CFLAGS) -ljpeg -o $@ input_uvc.c v4l2uvc.lo jpeg_utils.lo dynctrl.lo
</code></pre><p>为(即添加库文件-L)</p>
<pre><code>$(CC) $(CFLAGS) -ljpeg -L/work/embedded/video/jpeg-9a/jpeg/lib  -o $@     input_uvc.c v4l2uvc.lo jpeg_utils.lo dynctrl.lo
</code></pre><h4 id="c-编译"><a href="#c-编译" class="headerlink" title="c. 编译"></a>c. 编译</h4><pre><code>#make CC=arm-linux-gcc
</code></pre><h4 id="d-建立mjpg-streamer安装目录"><a href="#d-建立mjpg-streamer安装目录" class="headerlink" title="d. 建立mjpg-streamer安装目录"></a>d. 建立mjpg-streamer安装目录</h4><pre><code>mkdir /work/embedded/rootfs/usr/local/mjpg-streamer
cp *.so /work/embedded/rootfs/usr/local/mjpg-streamer
cp mjpg-stream /work/embedded/rootfs/usr/local/mjpg-streamer
</code></pre><p>将源码目录中的start.sh到/work/embedded/rootfs/mjpg-streamer目录下，www目录下的所有文件拷贝到/work/embedded/rootfs/www下，然后就可以测试啦</p>
<h4 id="e-在开发板中运行-start-sh"><a href="#e-在开发板中运行-start-sh" class="headerlink" title="e. 在开发板中运行./start.sh"></a>e. 在开发板中运行./start.sh</h4><p>修改start.sh脚本文件</p>
<pre><code>./mjpg_streamer -o &quot;output_http.so -w ./www&quot;
</code></pre><p>具体的修改方法可以根据start.sh文件中的注释或查看mjpg-streamer的帮助</p>
<pre><code>./mjpg_streamer --help
</code></pre><p>参考文章：</p>
<blockquote>
<p><a href="http://www.linuxidc.com/Linux/2012-02/54797p4.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-02/54797p4.htm</a><br><a href="http://blog.chinaunix.net/uid-27070031-id-3458957.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-27070031-id-3458957.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>mjpg-streamer</tag>
      </tags>
  </entry>
  <entry>
    <title>m-jpeg技术</title>
    <url>/post/60991.html</url>
    <content><![CDATA[<p>M-JPEG是一种基于静态图像压缩技术JPEG发展起来的动态图像压缩技术，可以生成序列化的运动图像。其主要特点是基本不考虑视频流中不同帧之间的变化，只单独对某一帧进行压缩，其压缩倍数为20~80倍，适合静态画面的压缩，分辨率可从352×288到704×576。以往的JPEG压缩技术是直接处理整个画面，所以要等到整个压缩档案传输完成才开始进行解压缩成影像画面，而这样的方式造成传输一个高解析画面时须耗时数十秒甚至数分钟。而新一代的M-JPEG是采取渐层式技术，先传输低解析的图档，然后再补送细部之资料，使画面品质改善。<br><a id="more"></a></p>
<p>M-JPEG压缩技术可以获取清晰度很高的视频图像，而且可以灵活设置每路的视频清晰度和压缩帧数。因期压缩后之格式可读单一画面，所以可以任意剪接。</p>
<p>M-JPEG因采用帧内压缩方式也适于视频编辑。 M-JPEG的主要缺点是压缩效率低，M-JPEG算法是根据每一帧图像的内容进行压缩，而不是根据相邻帧图像之间的差异来进行压缩，因此造成了大量冗余信息被重复存储，存储占用的空间大到每帧8~15K字节，最好也只能做到每帧3K字节，但如果因此而采用高压缩比则视频质量会严重降低。</p>
<p>JPEG是应用相当普遍的文件格式，能使图像占用最少的的空间，又能显示极佳的效果，在设计网页时，一般将文件存储为JPEG格式。 如果一幅彩色图片所占空间比较大，则可以将它存成压缩格式，以减小所占空间，如果此格式用于输出或印刷，那就需要解压缩</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>m-jpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>boa服务器的配置与cgic移植</title>
    <url>/post/54877.html</url>
    <content><![CDATA[<p>上次在开发板上成功移植完boa服务器，最近使用C语言进行CGI编程，只在宿主机上搭建CGI的测试环境。</p>
<h3 id="BOA服务器的配置："><a href="#BOA服务器的配置：" class="headerlink" title="BOA服务器的配置："></a>BOA服务器的配置：</h3><blockquote>
<p>Port：boa服务器监听的端口，默认的端口是80。如果端口小于1024，则必须是  root用户启动服务器。</p>
</blockquote>
<blockquote>
<p>Listen：绑定的ip地址。不使用这个参数时，将绑定所有的地址。</p>
</blockquote>
<blockquote>
<p><strong>User</strong>：连接到服务器的客户端的身份，可以是用户名或UID。</p>
</blockquote>
<blockquote>
<p><strong>Group</strong>：连接到服务器的客户端的组，可以是组名或GID。</p>
</blockquote>
<blockquote>
<p>ServerAdmin：服务器出故障时要通知的邮箱地址。<br><a id="more"></a></p>
</blockquote>
<blockquote>
<p>ErrorLog：指定错误日志文件。如果路径没有以”/“开始，则相对于ServerRoot路径。没有配置时默 认的文件是/dev/stderr。若不想记录日志，指定文件为/dev/null。</p>
</blockquote>
<blockquote>
<p><strong>AccessLog</strong>：设置存取日志文件，与ErrorLog类似。</p>
</blockquote>
<blockquote>
<p>UseLocaltime：设置使用本地时间，使用UTC时注释这个参数。这个参数没有值。</p>
</blockquote>
<blockquote>
<p>VerboseCGILogs：在错误日志文件中记录CGI启动和停止时间，若不记录，注释这个参数。这个参数没有值。</p>
</blockquote>
<blockquote>
<p>ServerName：指定服务器的名称，当客户端使用gethostname + gethostbyname时返回给客户端。</p>
</blockquote>
<blockquote>
<p>VirtualHost：虚拟主机开关。使用此参数，则会在DocumentRoot设定的目录添加一个ip地址作为新的DocumentRoot来处理客户端的请求。如DocumentRoot设置为/var/www，则<a href="http://localhost/转换" target="_blank" rel="noopener">http://localhost/转换</a> 成/var/www/127.0.0.1/，若注释此参数，则为/var/www/。</p>
</blockquote>
<blockquote>
<p><strong>DocumentRoot</strong>：HTML文件的根目录（也就是网站的目录,使用yum安装的话，为/var/www/boa/html）。</p>
</blockquote>
<blockquote>
<p>DirectoryIndex：网站访问的第一个网页，默认是index.html（如果使用yum安装的话，地址为：/var/www/boa/html/index.html ）</p>
</blockquote>
<blockquote>
<p>UserDir：指定用户目录。</p>
</blockquote>
<blockquote>
<p>DirectoryIndex：指定预生成目录信息的文件，注释此变量将使用DirectoryMaker变量。这个变量也就是设置默认主页的文件名。</p>
</blockquote>
<blockquote>
<p>DirectoryMaker：指定用于生成目录的程序，注释此变量将不允许列目录。</p>
</blockquote>
<blockquote>
<p>DirectoryCache：当DirectoryIndex文件不存在，而DirecotryMaker又被注释掉时，将列出这个参数指定目录给客户端。</p>
</blockquote>
<blockquote>
<p>KeepAliveMax：每个连接允许的请求数量。如果将此值设为” 0 “，将不限制请求的数目。</p>
</blockquote>
<blockquote>
<p>KeepAliveTimeOut：在关闭持久连接前等待下一个请求的秒数。（秒）。</p>
</blockquote>
<blockquote>
<p>MimeTypes：设置包含mimetypes信息的文件，一般是/etc/mime.types。</p>
</blockquote>
<blockquote>
<p>DefaultType：默认的mimetype类型，一般是text/html。</p>
</blockquote>
<blockquote>
<p>CGIPath：相当于给CGI程序使用的$PATH变量。</p>
</blockquote>
<blockquote>
<p>SinglePostLimit：一次POST允许最大的字节数，默认是1MB。</p>
</blockquote>
<blockquote>
<p>AddType: 增加MimeType没有指定的类型，例: AddType type extension [extension …]。要使用cgi，必须添加cgi类型：AddType application/x-httpd-cgi cgi</p>
</blockquote>
<blockquote>
<p>Redirect：重定向文件。</p>
</blockquote>
<blockquote>
<p>Aliases：指定路径的别名。</p>
</blockquote>
<blockquote>
<p><strong><em>ScriptAlias</em></strong>：指定脚本路径的虚拟路径。</p>
</blockquote>
<p>移植boa配置文件只修改强调的部分，具体修改方法参考转载的上文。</p>
<h2 id="移植CGIC库"><a href="#移植CGIC库" class="headerlink" title="移植CGIC库"></a>移植CGIC库</h2><h3 id="1-下载cgic库源码"><a href="#1-下载cgic库源码" class="headerlink" title="1.下载cgic库源码"></a>1.<a href="/src/cgic205.tar.gz">下载</a>cgic库源码</h3><h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h3><pre><code>#tar zxvf cgic205.tar.gz
</code></pre><h3 id="3-修改Markfile"><a href="#3-修改Markfile" class="headerlink" title="3.修改Markfile"></a>3.修改Markfile</h3><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><h5 id="ARM开发板移植"><a href="#ARM开发板移植" class="headerlink" title="ARM开发板移植"></a>ARM开发板移植</h5><pre><code>CC=arm-linux-gcc
AR=arm-linux-ar
RANLIB=arm-linux-ranlib
</code></pre><h5 id="宿主机测试"><a href="#宿主机测试" class="headerlink" title="宿主机测试"></a>宿主机测试</h5><pre><code>CC=gcc
AR=ar
RANLIB=ranlib
</code></pre><h4 id="markfile部分"><a href="#markfile部分" class="headerlink" title="markfile部分"></a>markfile部分</h4><pre><code>gcc cgictest.o -o cgictest.cgi ${LIBS}
</code></pre><p>修改为：</p>
<pre><code>$(CC) $(CFLAGS) cgictest.o -o cgictest.cgi ${LIBS}

gcc capture.o -o capture ${LIBS}
</code></pre><p>修改为：</p>
<pre><code>$(CC) $(CFLAGS) capture.o -o capture ${LIBS}
</code></pre><p>宿主机测试只是为了练习CGI编写。</p>
<h2 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h2><h3 id="1-在宿主机上测试安装CGIC时，修改了Markfile的编译器CC选项为arm-linux-gcc"><a href="#1-在宿主机上测试安装CGIC时，修改了Markfile的编译器CC选项为arm-linux-gcc" class="headerlink" title="1.在宿主机上测试安装CGIC时，修改了Markfile的编译器CC选项为arm-linux-gcc"></a>1.在宿主机上测试安装CGIC时，修改了Markfile的编译器CC选项为arm-linux-gcc</h3><blockquote>
<p>出现502错误：The CGI was not CGI/1.1 compliant.</p>
</blockquote>
<p>整了我好长时间<br>主要还是不细心，同时在遇到问题解决问题的时候不应该盲目，为了解决错误而去找答案<br>应该先捋一捋自己做事的过程，看看有没有出差。</p>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>boa</tag>
        <tag>cgic</tag>
      </tags>
  </entry>
  <entry>
    <title>更新时间戳</title>
    <url>/post/31965.html</url>
    <content><![CDATA[<h3 id="时间戳不相同时更新命令："><a href="#时间戳不相同时更新命令：" class="headerlink" title="时间戳不相同时更新命令："></a>时间戳不相同时更新命令：</h3><p>第一种：</p>
<pre><code>touch  *
</code></pre><p>第二种：（文件很多）</p>
<pre><code>find . -type f -exec touch {} \;
</code></pre>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title>mini2440基于boa服务器通过web控制gpio</title>
    <url>/post/63421.html</url>
    <content><![CDATA[<p>本文是基于BOA服务器，通过CGI（通用网管接口）控制开发板的GPIO。CGI通用网关接口是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。</p>
<p>在这里以控制LED为例。</p>
<p><img src="/images/boa-led.png" alt="led控制图"><br><a id="more"></a></p>
<h3 id="1-客户端控制界面"><a href="#1-客户端控制界面" class="headerlink" title="1.客户端控制界面"></a>1.客户端控制界面</h3><p>采用CGI将浏览器端的控制信息传到boa服务器端,index.html文件</p>
<pre><code>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
&lt;title&gt;web控制mini2440开发板led&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=&quot;center&quot;&gt;基于mini2440的web控制GPIO口&lt;/h1&gt;
&lt;form action=&quot;/cgi-bin/cgi_led.cgi&quot; method=&quot;get&quot;&gt;
&lt;p align=&quot;center&quot;&gt;led的测试工作&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;请输入需要控制的led &lt;input type=&quot;text&quot; name=&quot;led_control&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;请输入控制led的动作 &lt;input type=&quot;text&quot; name=&quot;led_state&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;sure&quot;/&gt;
&lt;input type=&quot;reset&quot; value=&quot;back&quot;/&gt;
&lt;/p&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><img src="/images/boa-led-web.png" alt="web截图"></p>
<h3 id="2-服务器端数据处理"><a href="#2-服务器端数据处理" class="headerlink" title="2.服务器端数据处理"></a>2.服务器端数据处理</h3><p>通过客户端浏览器的from表单将，控制信息提交到服务器，服务器获取数据并通过有名管道将控制数据传给调用LED驱动的控制程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIFO <span class="meta-string">"/www/myfifo"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* data;   <span class="comment">//定义一个指针用于指向QUERY_STRING存放的内容</span></span><br><span class="line">    <span class="keyword">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">int</span> fd, nwrite;</span><br><span class="line">    <span class="keyword">int</span> led_control, led_state;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Content-type: text/html\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;html&gt;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;head&gt;&lt;title&gt;cgi led demo&lt;/title&gt;&lt;/head&gt;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;body&gt;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;p&gt;led is setted successful! you can watch the led's change&lt;/p&gt;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;p&gt;&lt;a herf=index.html&gt;&lt;button&gt;get back&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;/body&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">    data = getenv(<span class="string">"QUERY_STRING"</span>);   <span class="comment">//getenv()读取环境变量的当前值的函数</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buff, data);</span><br><span class="line">    fd = <span class="built_in">open</span>(MYFIFO, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open fifo file error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((nwrite = <span class="built_in">write</span>(fd, buff, <span class="keyword">sizeof</span>(buff))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nWrite data error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sscanf</span>(buff,<span class="string">"led_control=%d&amp;led_state=%d"</span>,&amp;led_control,&amp;led_state)!=<span class="number">2</span>)</span><br><span class="line">    &#123;   <span class="comment">//利用sscnaf（）函数的特点将环境变量分别提取出led_control和led_state这两个值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"&lt;p&gt;please input right"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"&lt;/p&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;p&gt;led_control = %d,led_state =  %d&lt;/p&gt;"</span>, led_control, led_state);</span><br><span class="line">    <span class="keyword">if</span>(led_control&gt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"&lt;p&gt;Please input 0&lt;=led_control&lt;=3!"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"&lt;/p&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(led_state&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"&lt;p&gt;Please input 0&lt;=led_state&lt;=1!"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"&lt;/p&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;/html&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-控制端（GPIO驱动调用）"><a href="#3-控制端（GPIO驱动调用）" class="headerlink" title="3.控制端（GPIO驱动调用）"></a>3.控制端（GPIO驱动调用）</h3><p>通过管道接受到控制数据，调用驱动程序实现对LED灯的控制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/micro2440_leds.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIFO <span class="meta-string">"/www/myfifo"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_DEVICE  <span class="meta-string">"/dev/led4s"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> led_fd, fifo_fd, led_control,led_state, nread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">leds_stat</span> <span class="title">oneStat</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buff[MAX_BUFFER_SIZE];  <span class="comment">//定义一个指针用于指向QUERY_STRING存放的内容</span></span><br><span class="line">    led_fd = <span class="built_in">open</span>(LEDS_DEVICE, O_RDWR);  <span class="comment">//打开led设备</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == led_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open led device"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == access(MYFIFO, F_OK))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((mkfifo(MYFIFO, <span class="number">0666</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Connot create fifo file\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fifo_fd = <span class="built_in">open</span>(MYFIFO, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fifo_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open fifo file error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//memset(buff, 0, sizeof(buff));使用会使控制数据出错</span></span><br><span class="line">        <span class="keyword">if</span>((nread = <span class="built_in">read</span>(fifo_fd, buff, <span class="keyword">sizeof</span>(buff))) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"Read data error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sscanf</span>(buff,<span class="string">"led_control=%d&amp;led_state=%d"</span>,&amp;led_control,&amp;led_state)!=<span class="number">2</span>)</span><br><span class="line">        &#123;   <span class="comment">//利用sscnaf（）函数的特点将环境变量分别提取出led_control和led_state这两个值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"please input right \n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(led_control&gt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Please input 0&lt;=led_control&lt;=3!"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(led_state&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Please input 0&lt;=led_state&lt;=1!"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        oneStat.led_nr = led_control;</span><br><span class="line">        oneStat.led_st = led_state;</span><br><span class="line">        ioctl(led_fd, LEDS_SET_ONE, &amp;oneStat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(led_fd);</span><br><span class="line">    <span class="built_in">close</span>(fifo_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>本文主要参考<a href="http://blog.csdn.net/rwzhou1/article/details/23381811" target="_blank" rel="noopener">http://blog.csdn.net/rwzhou1/article/details/23381811</a>，采用管道的方式将数据的获取与功能的实现分离，更有利于对GPIO的控制。由于对LED驱动自己编写的跟上文中的有所不同，只有通过管道的方式实现。</p>
<p>在使用GET获取环境变量时，只能将getenv(“QUERY_STRING”);赋予字符指针，不能使用使用字符数组。</p>
<p>在使用管道的时候，由于管道数据传输为半双通因此在管道的两端只能赋予某一种权限，如读端以只读权限打开，写端以只写权限打开。如果某一端以读写权限打开程序将一直阻塞数据无法传输（刚开始习惯性的当做文件，直接以读写权限打开出错）。</p>
<p>控制端从管道读取数据时，将数据保存到字符数组中。在读取之前不能使用memset(buff, 0, sizeof(buff));函数将数组清零，如果数组清零接受到的数据与发送的数据信息相同，但大小不同会在数据解析的时候会出错，无法实现控制。</p>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>boa</tag>
        <tag>s3c2440</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>micro2440开发板启动linux</title>
    <url>/post/32798.html</url>
    <content><![CDATA[<h3 id="1-Micro2440移植Linux2-6的流程"><a href="#1-Micro2440移植Linux2-6的流程" class="headerlink" title="1.Micro2440移植Linux2.6的流程"></a>1.Micro2440移植Linux2.6的流程</h3><blockquote>
<blockquote>
<p>移植uboot-&gt;移植内核-&gt;移植文件系统</p>
</blockquote>
</blockquote>
<p>这里只记录在开发板启动时，移植的基本步骤：</p>
<h3 id="2-烧写Linux内核镜像"><a href="#2-烧写Linux内核镜像" class="headerlink" title="2.烧写Linux内核镜像"></a>2.烧写Linux内核镜像</h3><h4 id="a-修改uboot环境变量"><a href="#a-修改uboot环境变量" class="headerlink" title="a.修改uboot环境变量"></a>a.修改uboot环境变量</h4><pre><code>setenv bootargs &apos;root=/dev/mtdblock2 noinitrd console=ttySAC0,115200&apos;

setenv bootcmd &apos;nand read 0x30008000 0x200000 0x400000;bootm&apos;
</code></pre><p><strong>注</strong>：<br>root=/dev/mtdblock2指定根文件系统路径，/dev/mtdblock2表示在nandflash的第三块分区中（第一块分区用0表示）。<br>bootm指使用uImage引导<br>修改完uboot引导命令后，就制作uImage<br><a id="more"></a></p>
<h4 id="b-制作内核镜像"><a href="#b-制作内核镜像" class="headerlink" title="b.制作内核镜像"></a>b.制作内核镜像</h4><p>根据自己项目的需求的开发板的设计，剪裁linux内核进行编译。linux内核编译完有两种不同格式的内核镜像（uImage和zImage）。<br>uImage和zImage的区别：</p>
<blockquote>
<p>这两个都是内核，zImage是真正的内核，在内存中的地址0x30008000；而uImage是包含64字节头的内核，在头中存放着bootargs环境变量，在内存中的地址0x30007fc0<br>![uImage和zImage区别]（/images/uImage-zImage.PNG）</p>
</blockquote>
<p>到这时你就要选择到底使用哪个镜像了，这里根据你uboot的环境变量bootcmd判断。</p>
<h4 id="c-选择镜像"><a href="#c-选择镜像" class="headerlink" title="c.选择镜像"></a>c.选择镜像</h4><h5 id="烧写zImage"><a href="#烧写zImage" class="headerlink" title="烧写zImage"></a>烧写zImage</h5><p>到这里想那就烧写正真的内核吧zImage，我们uboot中也是在0x30008000内存地址中启动的，将zImage烧写到nandflash启动开发板，内核启动错。</p>
<pre><code>Starting kernel ...

test:machid:805306624
test: bi_boot_params:0x31f5bfb8
test:starting 1
data abort
pc : [&lt;30008008&gt;]          lr : [&lt;31f98ba4&gt;]
sp : 31f5ba94  ip : 30008000     fp : 31f5bca4
r10: 00000000  r9 : 00000001     r8 : 31f5bfdc
r7 : 00000000  r6 : 31fcbd1c     r5 : 31f5c83d  r4 : 00000000
r3 : 31f5bfb8  r2 : 30000100     r1 : 000000c1  r0 : 00000000
Flags: nZCv  IRQs off  FIQs off  Mode SVC_32
Resetting CPU ...
</code></pre><p>内核不断重启就是进不去，是因为缺失内核的一个头部信息，需要添加64字节的内核头，zImage也需要添加。<br>怎么添加头呢，需要什么工具？<br>编译完成uboot已经提供的这个工具<strong>mkimage</strong><br>工具使用参数解析：</p>
<pre><code>-A指定cpu体系结构
-O指定是什么操作系统
-T指定映像类型，如standalone、kernel、ramdisk、multi、firmware、script、filesystem等
-C指定映像压缩方式，如none(不压缩)、gzip、bzip2。这里不对uImage进行压缩
-a指定映象在内存中的加载地址，映象下载到内存中时，要按照用MKIMAGE制作映象时，这个参数所指定的地址值来下载
-e 指定映象运行的入口点地址，这个地址就是-a参数指定的值加上0x40（因为前面有个MKIMAGE添加的0x40个字节的头）
-n 指定映象名
-d 指定制作映象的源文件
</code></pre><p>添加所需头信息：</p>
<pre><code>16:23 [root@linfeng boot]#mkimage -n &apos;linux-2.6&apos; -A arm -O linux -T kernel -C none -a 0x30008000 -e 0x30008040 -d zImage zImage.img
</code></pre><p>正真内核烧写这么麻烦那就以后使用uImage</p>
<h5 id="烧写uImage"><a href="#烧写uImage" class="headerlink" title="烧写uImage"></a>烧写uImage</h5><p>将uImage镜像直接烧写到nandflash，启动开发板，无法启动。<br>不着急刚才uboot环境变量还没有修改过来呢，重新进入uboot修改环境变量</p>
<pre><code>setenv bootcmd &apos;nand read 0x30007fc0 0x200000 0x400000;bootm&apos;
</code></pre><p>=====<br><strong>经过第二次的内核烧写测试，使用该方法也不可行，同样会报出内核恐慌错误</strong><br>现在可以正常启动，成功进入内核后有出现：</p>
<pre><code>yaffs: dev is 32505858 name is &quot;mtdblock2&quot;
yaffs: passed flags &quot;&quot;
yaffs: Attempting MTD mount on 31.2, &quot;mtdblock2&quot;
yaffs: auto selecting yaffs2
yaffs_read_super: isCheckpointed 0
VFS: Mounted root (yaffs filesystem) on device 31:2.
Freeing init memory: 156K
Warning: unable to open an initial console.
Kernel panic - not syncing: No init found.  Try passing init= option to kerne.
Backtrace:
[&lt;c00341cc&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0329f3c&gt;] (dump_stack+0x18/0x)
r7:00000000one_wire_status: 4
 r6:00000000 r5:c001f308 r4:c0481c50
[&lt;c0329f24&gt;] (dump_stack+0x0/0x1c) from [&lt;c0329f8c&gt;] (panic+0x4c/0x114)
[&lt;c0329f40&gt;] (panic+0x0/0x114) from [&lt;c002f598&gt;] (init_post+0xa8/0x10c)
r3:00000000 r2:c393a100one_wire_status: 4
 r1:c393a200 r0:c03db74c
[&lt;c002f4f0&gt;] (init_post+0x0/0x10c) from [&lt;c00084b4&gt;] (kernel_init+0xe4/0x114)
r5:c001f308 r4:c04813e0
[&lt;c00083d0&gt;] (kernel_init+0x0/0x114) from [&lt;c004bbbc&gt;] (do_exit+0x0/0x620)
 r5:00000000 r4:00000000
</code></pre><p>这是没有找到yaffs文件系统，因为你还没有移植呢</p>
<h3 id="移植yaffs文件系统"><a href="#移植yaffs文件系统" class="headerlink" title="移植yaffs文件系统"></a>移植yaffs文件系统</h3><p>将你自己做好的文件系统使用<a href="/src/toolchains/mkyaffs2image.tgz">mkyaffs2image</a>工具制作出文件系统镜像。可是这时使用nand write 0x30008000 0x600000 0x2100000进行烧写后，开发板启动后同样进不到文件系统。<br>正确的烧写命令：</p>
<pre><code>nand write.yaffs 0x30008000 0x600000 0x2100000
</code></pre><hr>
<p><strong>写入yaffs文件系统时，下载的文件系统有多大。就烧写多大，但是大小必须是2k倍</strong></p>
<h3 id="烧写的方式"><a href="#烧写的方式" class="headerlink" title="烧写的方式"></a>烧写的方式</h3><p>通过tftp将uboot、kernel、文件系统下载到0x30008000这块可读可写的内存中，然后使用nand相关命令进行操作。<br><strong>nandflash操作命令：</strong></p>
<blockquote>
<p>nand - NAND sub-system</p>
</blockquote>
<p>  Usage:<br>  nand info - show available NAND devices<br>  nand device [dev] - show or set current device<br>  nand read - addr off|partition size<br>  nand write - addr off|partition size<br>      read/write ‘size’ bytes starting at offset ‘off’<br>      to/from memory address ‘addr’, skipping bad blocks.<br>  nand erase [clean] [off size] - erase ‘size’ bytes from<br>      offset ‘off’ (entire device if not specified)<br>  nand read[.yaffs[1]] is not provide temporarily!<br>  nand write[.yaffs[1]]    addr off size - write the <code>size&#39; byte yaffs image stg
     at offset</code>off’ from memory address `addr’ (.yaffs1 for 512+16 NAND)<br>  nand bad - show bad blocks<br>  nand dump[.oob] off - dump page<br>  nand scrub - really clean NAND erasing bad blocks (UNSAFE)<br>  nand markbad off […] - mark bad block(s) at offset (UNSAFE)<br>  nand biterr off - make a bit error at offset (UNSAFE)</p>
<h3 id="附：NSF文件系统启动时，uboot环境变量的设置"><a href="#附：NSF文件系统启动时，uboot环境变量的设置" class="headerlink" title="附：NSF文件系统启动时，uboot环境变量的设置"></a>附：NSF文件系统启动时，uboot环境变量的设置</h3><pre><code>setenv bootargs &apos;noinitrd console=ttySAC0,115200 init=/linuxrc root=/dev/nfs nfsroot=192.168.11.11:/work/embedded/rootfs ip=192.168.11.22:192.168.11.11:192.168.11.11:255.255.255.0:micro2440.arm9.net:eth0&apos;


setenv bootcmd &apos;tftp 0x30007fc0 uImage ; bootm&apos;
</code></pre>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>url链接中汉字乱码转utf-8和gb2312</title>
    <url>/post/34196.html</url>
    <content><![CDATA[<p>在使用URL向服务器提交数据的时候，如果我们提交的数据中存在汉字，就会出现下列情况<br><a href="http://192.168.11.22/cgi-bin/serial.cgi?type=text&amp;text=%C9%DB%CD%FB%C8%A8" target="_blank" rel="noopener">http://192.168.11.22/cgi-bin/serial.cgi?type=text&amp;text=%C9%DB%CD%FB%C8%A8</a></p>
<p>%C9%DB%CD%FB%C8%A8代表着什么，不是我们想要的数据，那它是什么呢？</p>
<p>去除所有%号：C9DBCDFBC8A8使用<a href="/src/汉字内码查询.exe_modify">汉字内码查询</a>可以看到<br><img src="/images/汉字内码.png" alt="hanzi"><br><a id="more"></a></p>
<h3 id="将汉字内码转成一个汉字"><a href="#将汉字内码转成一个汉字" class="headerlink" title="将汉字内码转成一个汉字"></a>将汉字内码转成一个汉字</h3><ol>
<li><p>gb2312<br> 两个字节表示一个汉字</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
       char str[3];

       str[0]=201; /*201为C9的十进制值*/
       str[1]=219; /*219为DB的十进制值*/
       str[2]=&apos;\0&apos;;
       printf(&quot;C9DB的汉字的值为:%s&quot;,str);
       return 0;
}
</code></pre><p>注：在终端先可以正确输出‘邵’，（使用gb2312编码，在linux下输出乱码，Windows下正常输出）</p>
</li>
<li><p>utf-8<br> 三个字节表示一个汉字</p>
<h3 id="多个汉字输出"><a href="#多个汉字输出" class="headerlink" title="多个汉字输出"></a>多个汉字输出</h3><pre><code>/*将十六进制数转为十进制*/
int hex_to_decade(char * s)
{
    char *digits=&quot;0123456789ABCDEF&quot;;

    /*判断大小写，小写的话转为大写，达到统一*/
    if (islower (s[0]))
        s[0]=toupper(s[0]);
    if (islower (s[1]))
        s[1]=toupper(s[1]);

    return 16*(strchr(digits,s[0])-strchr(digits,&apos;0&apos;))+(strchr(digits,s[1])-strchr(digits,&apos;0&apos;));
}
void url_to_gb_or_utf(char *get_url, char *return_gb_or_utf)
{
    int url_position;/*用来保存get_url的位置*/
    int return_position;/*用来保存解码后的字符串的位置*/
    int url_len;/*用来保存get_url的长度*/
    char tmp[2];/*保存%后面的十六进制字符*/
    url_len = strlen(get_url);
    return_position = 0;

    fprintf(stdout, &quot;length=%d\n&quot;, url_len);
    for ( url_position = 0; url_position &lt; url_len; )
    {
        /*如果是%将它后面的十六进制字符考到数组里*/
        if ( get_url[url_position] == &apos;%&apos; ){
            tmp[0] = get_url[url_position+1];/*第一个十六进制字符*/
            tmp[1] = get_url[url_position+2];/*第二个*/
        //  tmp[2] = &apos;\0&apos;;  **串口通信中会出现乱码，结尾必须不能有其他字符**

            url_position+= 3; /*使url_position跳到的下一个%*/
            /*将十六进制数转为十进制后考入要返回的数组里*/

            return_gb_or_utf[return_position] = hex_to_decade(tmp);
            fprintf(stdout, &quot;------%d\n&quot;, return_gb_or_utf[return_position] );
        }
        /*如果不是特殊字符，如英文，数字那么直接返回*/
        else{
            return_gb_or_utf[return_position] = get_url[url_position];
            url_position++;
        }
        return_position++;
    }

    return_gb_or_utf[return_position] = 0;
}
</code></pre></li>
</ol>
<p><strong>**</strong>十六进制转十进制可使用：<strong>strtol函数</strong></p>
<h3 id="汉字编码"><a href="#汉字编码" class="headerlink" title="汉字编码"></a>汉字编码</h3><ol>
<li>UTF-8：Unicode TransformationFormat-8bit，允许含BOM，但通常不含BOM。是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用24为（三个字节）来编码。</li>
<li>GBK是国家标准GB2312基础上扩容后兼容GB2312的标准。GBK的文字编码是用双字节来表示的，即不论中、英文字符均使用双字节来表示，为了区分中文，将其最高位都设定成1。GBK包含全部中文字符，是国家编码，通用性比UTF8差，不过UTF8占用的数据库比GBD大。</li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下字符串操作常用函数</title>
    <url>/post/43508.html</url>
    <content><![CDATA[<h3 id="字符串长度函数"><a href="#字符串长度函数" class="headerlink" title="字符串长度函数"></a>字符串长度函数</h3><pre><code>size_t strlen(const char *string);
</code></pre><h3 id="不受限制的字符串函数"><a href="#不受限制的字符串函数" class="headerlink" title="不受限制的字符串函数"></a>不受限制的字符串函数</h3><pre><code>char *strcpy(char *dst, const char *src);
char *strcat(char *dst, const char *src);
int strcmp(const char *s1, const char *s2);
</code></pre><a id="more"></a>
<h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><pre><code>/*
 + 功能：查找字符串s中首次出现字符c的位置
 + 说明：返回首次出现c的位置的指针，如果s中不存在c则返回NULL。
 */
char *strchr(const char *str, int ch);
//同上
char *strrchr(const char *str, int ch);
</code></pre><h3 id="大小写字符转换函数"><a href="#大小写字符转换函数" class="headerlink" title="大小写字符转换函数"></a>大小写字符转换函数</h3><pre><code>int tolower(int ch);
int toupper(int ch);
</code></pre><h3 id="内存操作函数"><a href="#内存操作函数" class="headerlink" title="内存操作函数"></a>内存操作函数</h3><pre><code>void *memcpy(void *dst, const void *src, size_t length);
void *memmove(void *dst, const void *src, size_t length);
void *memcmp(const void *a, const void *b, size_t length);
void *memset(void *a, int ch, size_t length);
</code></pre><p><strong>不断更新</strong></p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>micro2440数据传输--串口通信</title>
    <url>/post/15606.html</url>
    <content><![CDATA[<p>这段时间经过这次对比赛的准备，使用到了串口通信。或许这是最简单的通信方式吧，想弄清楚简单的数据传输协议。比较经典的i2c、CAN等数据传输，到以后的usb、ZigBee的数据传输。在这里先聊一聊串口的数据传输。</p>
<p>在Micro2440开发板上进行串口通信，要做的第一步便是串口驱动。这次我的开发板已经移植好了串口驱动。我只需进行操作，这里简单记录串口的基本操作 <strong>收数据</strong>、<strong>发数据</strong>以后用起来也方便，驱动下次分析。<br><a id="more"></a></p>
<h3 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h3><p><strong>分类</strong>：同步串口通信（SPI）、异步串口通信（UART）</p>
<p>同步串行是指SPI（Serial Peripheral interface）的缩写，顾名思义就是串行外围设备接口。SPI总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息，TRM450是SPI接口。</p>
<p>异步串行是指UART（Universal Asynchronous Receiver/Transmitter），通用异步接收/发送。UART是一个并行输入成为串行输出的芯片，通常集成在主板上。UART包含TTL电平的串口和RS232电平的串口。 TTL电平是3.3V的，而RS232是负逻辑电平，它定义+5~+12V为低电平，而-12~-5V为高电平，MDS2710、MDS SD4、EL805等是RS232接口，EL806有TTL接口。</p>
<h3 id="串口数据传输的特点"><a href="#串口数据传输的特点" class="headerlink" title="串口数据传输的特点"></a>串口数据传输的特点</h3><p>1.传输速度慢，数据量不大，数据一位一位的顺序传输</p>
<p>2.支持双向通信，只需一对数据线,也可以一根单向通信</p>
<pre><code>TXD  ---------&gt; RXD

RXD  &lt;--------- TXD

GND  &lt;--------&gt; GND
</code></pre><h3 id="串口的参数配置"><a href="#串口的参数配置" class="headerlink" title="串口的参数配置"></a>串口的参数配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int set_opt(int fd, int nSpeed, int nBits, char nEvent, int nStop)</span><br><span class="line">&#123;</span><br><span class="line">    struct termios newtio;</span><br><span class="line">    struct termios oldtio;</span><br><span class="line"></span><br><span class="line">    if(tcgetattr(fd,&amp;oldtio) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;SetupSerial 2&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;newtio,sizeof(newtio));</span><br><span class="line">    newtio.c_cflag |= CLOCAL |CREAD;</span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE;</span><br><span class="line"></span><br><span class="line">    switch(nBits)</span><br><span class="line">    &#123;</span><br><span class="line">        case 7:</span><br><span class="line">            newtio.c_cflag |= CS7;</span><br><span class="line">            break;</span><br><span class="line">        case 8:</span><br><span class="line">            newtio.c_cflag |= CS8;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch(nEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        case &apos;O&apos;:</span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag |= PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            break;</span><br><span class="line">        case &apos;E&apos;:</span><br><span class="line">            newtio.c_iflag |= (INPCK |ISTRIP);</span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">            break;</span><br><span class="line">        case &apos;N&apos;:</span><br><span class="line">            newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch(nSpeed)</span><br><span class="line">    &#123;</span><br><span class="line">        case 2400:</span><br><span class="line">            cfsetispeed(&amp;newtio,B2400);</span><br><span class="line">            cfsetospeed(&amp;newtio,B2400);</span><br><span class="line">            break;</span><br><span class="line">        case 4800:</span><br><span class="line">            cfsetispeed(&amp;newtio,B4800);</span><br><span class="line">            cfsetospeed(&amp;newtio,B4800);</span><br><span class="line">            break;</span><br><span class="line">        case 9600:</span><br><span class="line">            cfsetispeed(&amp;newtio,B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio,B9600);</span><br><span class="line">            break;</span><br><span class="line">        case 115200:</span><br><span class="line">            cfsetispeed(&amp;newtio,B115200);</span><br><span class="line">            cfsetospeed(&amp;newtio,B115200);</span><br><span class="line">            break;</span><br><span class="line">        case 460800:</span><br><span class="line">            cfsetispeed(&amp;newtio,B460800);</span><br><span class="line">            cfsetospeed(&amp;newtio,B460800);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            cfsetispeed(&amp;newtio,B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio,B9600);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(nStop == 1)&#123;</span><br><span class="line">        newtio.c_cflag &amp;= ~CSTOPB;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(nStop ==2)&#123;</span><br><span class="line">        newtio.c_cflag |= CSTOPB;</span><br><span class="line">    &#125;</span><br><span class="line">    newtio.c_cc[VTIME] = 0;</span><br><span class="line">    newtio.c_cc[VMIN] = 0;</span><br><span class="line"></span><br><span class="line">    tcflush(fd,TCIFLUSH);</span><br><span class="line">    if((tcsetattr(fd,TCSANOW,&amp;newtio)) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;com set error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;set done!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int open_port(int fd,int comport)</span><br><span class="line">&#123;</span><br><span class="line">    char *dev[]=&#123;&quot;/dev/ttySAC0&quot;,&quot;/dev/ttySAC1&quot;,&quot;/dev/ttySAC2&quot;&#125;;</span><br><span class="line">    long vdisable;</span><br><span class="line">    if(comport == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(&quot;/dev/ttySAC0&quot;,O_RDWR|O_NOCTTY|O_NDELAY);</span><br><span class="line">        if(fd == -1)&#123;</span><br><span class="line">            perror(&quot;Can&apos;t Open Serial Port&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if(comport == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(&quot;/dev/ttySAC1&quot;,O_RDWR|O_NOCTTY|O_NDELAY);</span><br><span class="line">        if(fd == -1)&#123;</span><br><span class="line">            perror(&quot;Can&apos;t Open Serial Port&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if(comport == 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(&quot;/dev/ttySAC2&quot;,O_RDWR|O_NOCTTY|O_NDELAY);</span><br><span class="line">        if(fd == -1)&#123;</span><br><span class="line">            perror(&quot;Can&apos;t Open Serial Port&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(fcntl(fd,F_SETFL,0) &lt; 0)&#123;</span><br><span class="line">        printf(&quot;fcntl failed\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;fcntl=%d\n&quot;,fcntl(fd,F_SETFL,0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(isatty(STDIN_FILENO) == 0)&#123;</span><br><span class="line">        printf(&quot;standard input is not a terminal device\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;isatty sucess!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;fd-open=%d\n&quot;,fd);</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###接收串口数据</p>
<pre><code>nread = read(fd,buff,n)；
</code></pre><h3 id="发送串口数据"><a href="#发送串口数据" class="headerlink" title="发送串口数据"></a>发送串口数据</h3><pre><code>nwrite = write(fd,buff,length);
</code></pre><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>上面两个程序可以完成数据的收发，在具体的项目中在串口的数据传输中多种数据的传输时，会涉及到一些简单的数据处理，需要自定义一些协议。这时串口数据的收发必须精确的每个字符，不能多一个也不能少一个。</p>
<p>read、write函数，它们读写的字符必须精准，在write时写入数据的大小必须和字符串的大小一致。在送单一的数据时，对写数据大小不做要求可是在自定义协议中数据的大小关系到对方的解析。</p>
<p>这次使用的数据格式：FD 00 06 02 00 31 33 33 C8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char Speaker(char CMD,char par,char * pString)</span><br><span class="line">&#123;</span><br><span class="line">    char headOfFrame[5];</span><br><span class="line">    char length;         //定义字符串长度</span><br><span class="line">    char ecc = 0;        //定义校验字节</span><br><span class="line">    int i = 0;</span><br><span class="line">    if (pString == NULL) //空字符串</span><br><span class="line">        return 1;</span><br><span class="line">    headOfFrame[0]=0XFD;       //构造帧头FD</span><br><span class="line">    headOfFrame[1]=0X00;       //构造数据区长度的高字节</span><br><span class="line">    length = strlen(pString);  //需要发送文本的长度</span><br><span class="line">    headOfFrame[2]=length+3;   //构造数据区长度的低字节</span><br><span class="line">    headOfFrame[3]=CMD;        //构造命令字：合成播放命令</span><br><span class="line">    headOfFrame[4]=par;        //构造命令参数：编码格式为GB2312</span><br><span class="line">    for(i=0;i&lt;5;i++)           //依次发送构造好的5个帧头字节</span><br><span class="line">    &#123;</span><br><span class="line">        ecc=ecc^(headOfFrame[i]); //对发送的字节进行异或校验</span><br><span class="line">        write(fd,&amp;headOfFrame[i],1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;length;i++)         //依次发送待合成的文本数据</span><br><span class="line">    &#123;</span><br><span class="line">        ecc=ecc^(*pString);</span><br><span class="line">        write(fd,pString,1);</span><br><span class="line">        pString ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(fd,&amp;ecc,1);    //最后发送校验和</span><br><span class="line">    return 0; //成功返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
        <tag>串口</tag>
      </tags>
  </entry>
  <entry>
    <title>Cortex-A8平台实验</title>
    <url>/post/36419.html</url>
    <content><![CDATA[<p>毕业的时候有把A8板子拿了过来，之前由于没有源程序（光盘丢失找不到资料）对它的开发和实验都一直没有做过，它上面的资源很多不想让它就静静的放着浪费。虽然已经很久没有接触ARM平台了，但是它与MIPS的上层基本原理相似，所以最近想倒腾它，希望可以把linux系统跑起来，也不枉失去它在我手中的价值嘿嘿嘿。在这里简单记录实验的过程和中间的少许思考吧。</p>
<a id="more"></a>
<h2 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h2><ul>
<li>开发板：Cortex-A8</li>
<li>开发系统：Linux machine 4.2.0-27-generic #32~14.04.1-Ubuntu SMP</li>
<li><del>uboot：u-boot-2016-07</del></li>
<li>uboot：u-boot-v2014.07-rc4</li>
<li>linux：linux-4.0.9</li>
<li>文件系统：buildroot<blockquote>
<p>在实际的操作中可能会有所变动，不断更新 <a href="https://github.com/EmDepTeam" target="_blank" rel="noopener">DebugCode</a></p>
</blockquote>
</li>
</ul>
<h2 id="交叉编译工具"><a href="#交叉编译工具" class="headerlink" title="交叉编译工具"></a>交叉编译工具</h2><p>作为嵌入式开发交叉编译工具链是必不可少的，主要是为了在宿主机（PC）上，开发目标机（arm开发板）中可以运行的程序。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>这里选择<a href="https://launchpadlibrarian.net/268330503/gcc-arm-none-eabi-5_4-2016q2-20160622-linux.tar.bz2" target="_blank" rel="noopener">gcc-arm-none-eabi-5_4-2016q2-20160622-linux.tar.bz2</a></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>由于PC中从在多个交叉编译工具链，这里采用脚本envsetup.sh设置，每进入一个终端需要运行其脚本进行配置，方可使用该编译工具链。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">MY_PWD=`pwd`</span><br><span class="line"></span><br><span class="line">PATH=$PATH:$MY_PWD/gcc-arm-none-eabi-5_4-2016q2/bin</span><br><span class="line">CROSS_COMPILE=arm-none-eabi-</span><br><span class="line"></span><br><span class="line">export PATH CROSS_COMPILE</span><br><span class="line"></span><br><span class="line">echo $PATH</span><br><span class="line">echo $CROSS_COMPILE</span><br></pre></td></tr></table></figure></p>
<p>设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source envsetup.sh</span><br></pre></td></tr></table></figure></p>
<h2 id="uboot移植"><a href="#uboot移植" class="headerlink" title="uboot移植"></a>uboot移植</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ol>
<li>查找Cortex-A8相关的README，进行参考，全局搜索</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep "Cortex-A8" . -rn</span><br></pre></td></tr></table></figure>
<p>./doc/README.s5pc1xx中有Cortex-A8的相关说明，结合该文档进行最初的编译。</p>
<p><del>2. 根据README.s5pc1xx的步骤配置编译</del></p>
<p>将出现以下错误：</p>
<blockquote>
<p>lib/asm-offsets.c:1:0: error: bad value (armv5) for -march= switch</p>
</blockquote>
<p>出现这个错误的原因是我们没有为uboot指定交叉编译工具链，它依然用自己默认的gcc进行编译，有怎么会找到armv5呢。</p>
<p><del>3. 指定交叉编译工具链</del><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE=arm-none-eabi-</span><br><span class="line">export CROSS_COMPILE</span><br></pre></td></tr></table></figure></p>
<p>为了以后方便使用可将以上两句命令添加到envsetup.sh脚本中。<br>参考：./README — 4963 Building the Software:</p>
<h4 id="改变uboot版本"><a href="#改变uboot版本" class="headerlink" title="改变uboot版本"></a>改变uboot版本</h4><blockquote>
<p>最新的uboot采用图形界面的配置方式及增加了设备树的配置，由于对这两方面都不太了解尤其设备树，根据自己比较熟悉的使用方式，选择u-boot-v2014.07-rc4。设备树等uboot可以正常启动后在深入学习添加。</p>
</blockquote>
<h4 id="选择默认配置编译"><a href="#选择默认配置编译" class="headerlink" title="选择默认配置编译"></a>选择默认配置编译</h4><ol>
<li>选择配置</li>
</ol>
<p>根据README在boards.cfg选择smdkc100，后续在此基础上进行移植</p>
<ol start="2">
<li>指定编译器</li>
</ol>
<p>根据上文（3. 指定交叉编译工具链）即可</p>
<ol start="3">
<li>编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make smdkc100_config</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>顺利编译通过，接下来将添加spl和uboot</p>
<h4 id="添加自己配置"><a href="#添加自己配置" class="headerlink" title="添加自己配置"></a>添加自己配置</h4><ol>
<li><p>添加配置文件s5pv210.h</p>
<pre><code>cp include/configs/smdkc100.h include/configs/s5pv210.h
</code></pre></li>
<li><p>添加编译配置boards.cfg</p>
<pre><code>Active  arm         armv7          s5pc1xx     samsung   smdkc100   s5pv210      Winddoing &lt;winddoing@sina.cn&gt;
</code></pre></li>
</ol>
<h3 id="添加SPL阶段"><a href="#添加SPL阶段" class="headerlink" title="添加SPL阶段"></a>添加SPL阶段</h3><p>在uboot中SPL阶段的控制是通过spl/Makefile中的CONFIG_SPL_BUILD宏控制</p>
<h2 id="使用最新的uboot"><a href="#使用最新的uboot" class="headerlink" title="使用最新的uboot"></a>使用最新的uboot</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ol>
<li><p>指定编译工具链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CROSS_COMPILE</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用相关配置测试工具链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$make s5pc210_universal_defconfig</span><br><span class="line">$make -j12</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="添加自定义配置"><a href="#添加自定义配置" class="headerlink" title="添加自定义配置"></a>添加自定义配置</h3><p>在<code>s5pc210_universal_defconfig</code>配置基础上修改。</p>
<h4 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h4><ol>
<li>拷贝现有相关配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cp include/configs/s5pc210_universal.h include/configs/s5pc210_a8.h</span><br><span class="line">$cp configs/s5pc210_universal_defconfig configs/s5pc210_a8_defconfig</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.添加板级<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board/samsung/cortex-a8/</span><br><span class="line">configs/s5pc210_a8_defconfig</span><br><span class="line">include/configs/s5pc210_a8.h</span><br></pre></td></tr></table></figure></p>
<h4 id="添加SPL"><a href="#添加SPL" class="headerlink" title="添加SPL"></a>添加SPL</h4><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./tools/mkexynosspl  spl/u-boot-spl.bin spl/qt210-spl.bin</span><br><span class="line">make[1]: ./tools/mkexynosspl: Command not found</span><br><span class="line">scripts/Makefile.spl:283: recipe for target &apos;spl/qt210-spl.bin&apos; failed</span><br><span class="line">make[1]: *** [spl/qt210-spl.bin] Error 127</span><br><span class="line">Makefile:1508: recipe for target &apos;spl/u-boot-spl&apos; failed</span><br><span class="line">make: *** [spl/u-boot-spl] Error 2</span><br></pre></td></tr></table></figure>
<p>这是个可执行文件是在make时自动增加头信息用的</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/gjianw217/article/details/79939889" target="_blank" rel="noopener">【u-boot-2016到s5pv210】1.1 自定义板卡ok210</a></li>
<li><a href="https://blog.csdn.net/keyue123/article/details/53072164" target="_blank" rel="noopener">u-boot-2016.09移植(3)-u-boot-spl.bin</a></li>
<li><a href="https://blog.csdn.net/Config_init/article/details/53373423" target="_blank" rel="noopener">u-boot-2016.11移植uboot-spl.bin</a></li>
<li><a href="https://blog.csdn.net/weixin_39655765/article/details/80058644" target="_blank" rel="noopener">u-boot v2018.01 启动流程分析</a></li>
</ul>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/JerryGou/article/details/79027479" target="_blank" rel="noopener">S5PV210开发版配置</a></li>
</ul>
]]></content>
      <categories>
        <category>Cortex-A8</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>cortex-a8</tag>
        <tag>uboot</tag>
        <tag>linux</tag>
        <tag>bulidroot</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ANR分析</title>
    <url>/post/35493.html</url>
    <content><![CDATA[<blockquote>
<p>ANR是<code>Application Not Response</code>的简写就是应用没有响应。Android应用主线程卡住的时候系统会提示用户是否需要结束掉此App，这是Android系统优化用户体验的一种做法，类似的Windows系统也有类似“程序没有响应”的提示。就是<strong>主线程无法及时响应用户输入</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E/ActivityManager(  373): ANR in com.android.settings (com.android.settings/.Settings)</span><br><span class="line">E/ActivityManager(  373): PID: 803</span><br><span class="line">E/ActivityManager(  373): Reason: Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol>
<li>主线程被阻塞</li>
<li>主线程有耗时操作,比如IO</li>
<li>主线程异常操作比如Thread.sleep,Thread.wait</li>
<li>(Activity)应用在5秒内没有响应用户输入（例如键盘输入, 触摸屏幕等）</li>
<li>BroadcastReceiver10秒钟没有响应</li>
<li>获取不到CPU时间片（CPU太满了）</li>
</ol>
<h3 id="CPU占有率100"><a href="#CPU占有率100" class="headerlink" title="CPU占有率100%"></a>CPU占有率100%</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E/ActivityManager(  373): ANR in com.android.settings (com.android.settings/.Settings)</span><br><span class="line">E/ActivityManager(  373): PID: 803</span><br><span class="line">E/ActivityManager(  373): Reason: Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)</span><br><span class="line">	Load: 1.43 / 2.3 / 1.84</span><br><span class="line">	//表示ANR发生之前的一段时间内的CPU使用率，并不是某一时刻的值</span><br><span class="line">	CPU usage from 810ms to -13732ms ago:</span><br><span class="line">	63% 803/com.android.settings: 17% user + 45% kernel / faults: 3557 minor 225 major</span><br><span class="line">	55% 373/system_server: 22% user + 33% kernel / faults: 3423 minor</span><br><span class="line">	...</span><br><span class="line">	1% 569/android.process.acore: 0% user + 1% kernel / faults: 1 minor</span><br><span class="line">	1% 777/Binder_4: 0% user + 1% kernel</span><br><span class="line">100% TOTAL: 39% user + 60% kernel</span><br></pre></td></tr></table></figure>
<h2 id="traces-memory"><a href="#traces-memory" class="headerlink" title="traces memory"></a>traces memory</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Heap: 15% free, 1338KB/`1585KB`; 51388 objects</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虚拟机堆会动态扩展，<code>1585KB</code>代表堆扩展到的大小，1338KB代表堆上使用的大小，15%是使用的百分比, 51388创建的对象数量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. //Total number of allocations 170340</span><br><span class="line">2. //Total bytes allocated 13MB</span><br><span class="line">3. //Free memory 247KB</span><br><span class="line">4. //Free memory until GC 247KB</span><br><span class="line">5. //Free memory until OOME 62MB</span><br><span class="line">6. //Total memory `1585KB`</span><br><span class="line">7. //Max memory 64MB</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>进程创建到现在一共创建的对象数</li>
<li>进程创建到现在一共申请的内存</li>
<li>不扩展堆的情况下可用的内存</li>
<li>可回收的大小</li>
<li>还能扩展多少内存达到Max memory</li>
<li><code>堆扩展</code>后的大小</li>
<li>进程最多能申请的内存</li>
</ol>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/tabactivity/article/details/52945343" target="_blank" rel="noopener">ANR机制以及问题分析</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ART编译预优化</title>
    <url>/post/40126.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enable dex-preoptimization to speed up the first boot sequence</span><br><span class="line"># of an SDK AVD. Note that this operation only works on Linux for now</span><br><span class="line">ifeq ($(HOST_OS),linux)</span><br><span class="line">	ifeq ($(WITH_DEXPREOPT),)</span><br><span class="line">		WITH_DEXPREOPT := true</span><br><span class="line">	endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<blockquote>
<p>device/xxx/xxx/BoardConfig.mk</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">WITH_DEXPREOPT</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">true</td>
<td style="text-align:center">system image 就会被预先优化. 由于在启动时不再需要进行app的dex文件进行优化(dex2oat操作)从而提升其启动速度.</td>
</tr>
<tr>
<td style="text-align:center">false</td>
<td style="text-align:center">禁止预编译优化，在系统启动时编译</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h2><p>ART兼容Dalvik.也就是说ART 能运行”dex”(Dalvik执行文件).因此对Androidapp的开发者来说,他们没有什么区别.两者最大的区别是:ART把JIT(Just-in-Time)变成了AOT(Ahead-of-Time).JIT需要在每次运行app时都需要执行一遍,而AOT 只需要执行一次,而后续再运行此app是不需要再执行,其明显提高了性能.当然ART 这样做,也是有代价的,那就是以空间换时间.ART能对应用的所有code做优化,其把bitcode 编译为ELF文件.而ELF文件也往往比odex文件大很多.而JIT<br>只能对local/method做优化.ART的另一个缺点是其第一次执行优化时需要更长的时间.这也是导致第一次开机时间过长的原因</p>
<h2 id="dex2oat"><a href="#dex2oat" class="headerlink" title="dex2oat"></a>dex2oat</h2><p><code>dex2oat</code>顾名思义dex file to oat file，就是在新旧两种运行时文件的转换。</p>
<blockquote>
<p><code>dex</code>文件字节码，（多个class每个文件都有的共有信息合成一体）<br><code>oat</code>文件格式:ELF</p>
</blockquote>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol>
<li>优化开机速度，减少启动时间(不是第一次)</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/u010164190/article/details/51463492" target="_blank" rel="noopener">Android 开机速度优化—–ART 预先优化</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>动态指令</title>
    <url>/post/40422.html</url>
    <content><![CDATA[<p>通过程序动态生成指令，然后进行执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> +------------&gt; +-------+ &lt;--+生成指令，写入buffer</span><br><span class="line"> |              |       |</span><br><span class="line"> +              |       |</span><br><span class="line">PC              |       |</span><br><span class="line">                | buffer|</span><br><span class="line">                |       |</span><br><span class="line">                |       |</span><br><span class="line">                |       |</span><br><span class="line">                +-------+</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> *InstBuf;</span><br><span class="line">InstBuf = (<span class="keyword">uint32_t</span>)<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>: i++) &#123;</span><br><span class="line">	InstBuf[i] = <span class="number">0x03e00008</span>; <span class="comment">/* JR RA */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*f)(<span class="keyword">void</span>);</span><br><span class="line">f = (<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(InstBuf);</span><br><span class="line">(*f)();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title>进程迁移</title>
    <url>/post/62989.html</url>
    <content><![CDATA[<p>进程迁移就是将一个进程从当前位置移动到指定的处理器上。它的基本思想是在进程执行过程中移动它，使得它在另一个计算机上继续存取它的所有资源并继续运行，而且不必知道运行进程或任何与其它相互作用的进程的知识就可以启动进程迁移操作，这意味着迁移是透明的。</p>
<blockquote>
<p>进程迁移是支持负载平衡和高容错性的一种非常有效的手段。</p>
</blockquote>
<a id="more"></a>
<ol>
<li><p>动态负载平衡：将进程迁移到负载轻或空闲的节点上，充分利用可用资源，通过减少节点间负载的差异来全面提高性能。</p>
</li>
<li><p>容错性和高可用性：某节点出现故障时，通过将进程迁移到其它节点继续恢复运行，这将极大的提高系统的可靠性和可用性。在某些关键性应用中，这一点尤为重要。</p>
</li>
<li><p>并行文件IO：将进程迁移到文件服务器上进行IO，而不是通过传统的从文件服务器通过网络将数据传输给进程。对于那些需向文件服务器请求大量数据的进程，这将有效的减少了通讯量，极大的提高效率。</p>
</li>
<li><p>充分利用特殊资源：进程可以通过迁移来利用某节点上独特的硬件或软件能力。</p>
</li>
<li><p>内存导引（Memory Ushering）机制：当一个节点耗尽它的主存时，Memory Ushering机制将允许进程迁移到其它拥有空闲内存的节点，而不是让该节点频繁地进行分页或和外存进行交换。这种方式适合于负载较为均衡，但内存使用存在差异或内存物理配置存在差异的系统。</p>
</li>
</ol>
<h2 id="Task-migration-LTP"><a href="#Task-migration-LTP" class="headerlink" title="Task migration(LTP)"></a>Task migration(LTP)</h2><blockquote>
<p>ltp-full-20140115/testcases/kernel/controllers/cpuctl/cpuctl_test02.c</p>
</blockquote>
<p>通过cgroup将两个cgroup同两个物理核进行绑定，然后在两个cgroup中的tasks中进行两个进程ID的移动，从而进行进程的迁移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t cgroup -o cpuset cgroup /mnt</span><br><span class="line">cd /mnt</span><br><span class="line">#创建子cgroup，cpu0, cpu1</span><br><span class="line">mkdir cpu0 cpu1</span><br><span class="line">#将CPU0绑定到子cgroup.cpu0</span><br><span class="line">cd cpu0</span><br><span class="line">echo 0 &gt; cpuset.cpus</span><br><span class="line">#将CPU1绑定到子cgroup.cpu1</span><br><span class="line">cd cpu1</span><br><span class="line">echo 1 &gt; cpuset.cpus</span><br><span class="line"></span><br><span class="line">#进程迁移</span><br><span class="line">echo PID0 &gt; /mnt/cpu0/tasks</span><br><span class="line">或</span><br><span class="line">echo PID1 &gt; /mnt/cpu1/tasks</span><br></pre></td></tr></table></figure>
<h2 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a><a href="https://winddoing.github.io/2018/02/28/app_cgroup/">Cgroup</a></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://segmentfault.com/a/1190000006917884" target="_blank" rel="noopener">Linux Cgroup系列（01）：Cgroup概述</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>Namespace</title>
    <url>/post/31401.html</url>
    <content><![CDATA[<p>容器，cgroup，namespace之间的关系：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       +-------------------------------------+</span><br><span class="line">       |                                     |</span><br><span class="line">       |            容器                     |   用户空间</span><br><span class="line">       +-------------------------------------+</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">       +--------------+  +-------------------+</span><br><span class="line">       |  cgroup fs   |  |  syscall（clone） |</span><br><span class="line">       +------+-------+  +---------+---------+</span><br><span class="line">              ^                    ^</span><br><span class="line">       +------+------+   +---------+---------+</span><br><span class="line">       |  cgroup     |   |    namespace      |   内核空间</span><br><span class="line">       +-------------+   +-------------------+</span><br><span class="line">       +-------------+   +-------------------+</span><br><span class="line">       |             |   |                   |</span><br><span class="line">       |     CPU     |   |    PID，IPC，     |</span><br><span class="line">       |    内存资源 |   |    网络等资源     |</span><br><span class="line">       |             |   |                   |</span><br><span class="line">       |             |   |                   |</span><br><span class="line">       +-------------+   +-------------------+</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h2><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace又称为命名空间，它主要做访问隔离。其原理是针对一类资源进行抽象，并将其封装在一起提供给一个容器使用，对于这类资源，因为每个容器都有自己的抽象，而他们彼此之间是不可见的，所以就可以做到访问隔离。可以让每一个进程具有独立的<code>PID</code>，<code>IPC</code>和<code>网络空间</code>。</p>
<blockquote>
<p>通过执行clone系统调用可以划分命名空间，主要是根据clone的第3个参数flags标志进行设置</p>
</blockquote>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li><code>clone()</code>: 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。</li>
<li><code>unshare()</code>: 使某进程脱离某个namespace</li>
<li><code>setns()</code>: 把某进程加入到某个namespace</li>
</ul>
<h3 id="资源划分"><a href="#资源划分" class="headerlink" title="资源划分"></a>资源划分</h3><table>
<thead>
<tr>
<th style="text-align:center">名 称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CLONE_NEWIPC</td>
<td style="text-align:center">划分IPC（进程间通信）命名空间，信号量，共享内存，消息队列，等进程间通信的资源</td>
</tr>
<tr>
<td style="text-align:center">CLONE_NEWNET</td>
<td style="text-align:center">划分网络命令空间，分配网络接口</td>
</tr>
<tr>
<td style="text-align:center">CLONE_NEWNS</td>
<td style="text-align:center">划分挂载命名空间。与chroot同样分配新的根文件系统</td>
</tr>
<tr>
<td style="text-align:center">CLONE_NEWPID</td>
<td style="text-align:center">划分PID命名空间。分配新的进程ID空间</td>
</tr>
<tr>
<td style="text-align:center">CLONE_NEWUTS</td>
<td style="text-align:center">划分UTS(主机名)命名空间。分配新的UTS空间</td>
</tr>
</tbody>
</table>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><p>创建一个子进程，后续的命名空间的划分在此基础上操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024*1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in child process \n"</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"process start: \n"</span>);</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"end \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UTS命名空间（CLONE-NEWUTS）"><a href="#UTS命名空间（CLONE-NEWUTS）" class="headerlink" title="UTS命名空间（CLONE_NEWUTS）"></a>UTS命名空间（CLONE_NEWUTS）</h4><p>UTS命名空间，提供了主机名和域名的隔离。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024*1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">	<span class="string">"/bin/bash"</span>,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"in child process \n"</span>);</span><br><span class="line">	sethostname(<span class="string">"NewNameSpace"</span>, <span class="number">20</span>); <span class="comment">//设置新的主机名</span></span><br><span class="line">	execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"process start: \n"</span>);</span><br><span class="line">	<span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUTS|SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">	waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"end \n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;user@ingenic-xxx:~/namespace$ sudo ./a.out</span><br><span class="line">&gt;process start:</span><br><span class="line">&gt;in child process</span><br><span class="line">&gt;root@NewNameSpace:~/namespace# echo $HOSTNAME</span><br><span class="line">&gt;NewNameSpace</span><br><span class="line">&gt;root@NewNameSpace:~/namespace# exit</span><br><span class="line">&gt;exit</span><br><span class="line">&gt;end</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="IPC命名空间（CLONE-NEWIPC）"><a href="#IPC命名空间（CLONE-NEWIPC）" class="headerlink" title="IPC命名空间（CLONE_NEWIPC）"></a>IPC命名空间（CLONE_NEWIPC）</h4><p>IPC Namespace 是用来隔离 System V IPC 和POSIX message queues.每一个IPC Namespace都有他们自己的System V IPC 和POSIX message queue。</p>
<p>验证：消息队列</p>
<ul>
<li><p>ipcs查看队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ipcs -q</span><br></pre></td></tr></table></figure>
</li>
<li><p>ipcmk创建队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ipcmk -Q</span><br></pre></td></tr></table></figure>
</li>
<li><p>ipcrm删除队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ipcrm -q 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="PID命名空间（CLONE-NEWPID）"><a href="#PID命名空间（CLONE-NEWPID）" class="headerlink" title="PID命名空间（CLONE_NEWPID）"></a>PID命名空间（CLONE_NEWPID）</h4><p>PID namespace是用来隔离进程 id。同样的一个进程在不同的 PID Namespace 里面可以拥有不同的 PID。空间内的PID 是独立分配的，意思就是命名空间内的虚拟 PID 可能会与命名空间外的 PID 相冲突，于是命名空间内的 PID 映射到命名空间外时会使用另外一个 PID。比如说，命名空间内第一个 PID 为1，而在命名空间外就是该 PID 已被 init 进程所使用。</p>
<p>验证： <code>echo $$</code></p>
<blockquote>
<p>在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。</p>
</blockquote>
<h4 id="mount命名空间（CLONE-NEWNS）"><a href="#mount命名空间（CLONE-NEWNS）" class="headerlink" title="mount命名空间（CLONE_NEWNS）"></a>mount命名空间（CLONE_NEWNS）</h4><p>进程运行时可以将挂载点与系统分离，使用这个功能时，我们可以达到 chroot 的功能进程运行时可以将挂载点与系统分离，使用这个功能时，可以达到 chroot 的功能</p>
<blockquote>
<p>在通过<code>CLONE_NEWNS</code>创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。</p>
</blockquote>
<h3 id="小应用"><a href="#小应用" class="headerlink" title="小应用"></a>小应用</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/linhaifeng/p/6657119.html" target="_blank" rel="noopener">网络虚拟化基础一：linux名称空间Namespaces</a></li>
</ol>
]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
  <entry>
    <title>ASOC之DPCM</title>
    <url>/post/14697.html</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>audio</tag>
        <tag>dpcm</tag>
      </tags>
  </entry>
  <entry>
    <title>音频接口I2S</title>
    <url>/post/25782.html</url>
    <content><![CDATA[<blockquote>
<p>I2S(Inter—IC Sound)总线, 又称 集成电路内置音频总线，是飞利浦公司为数字音频设备之间的音频数据传输而制定的一种总线标准，该总线专责于音频设备之间的数据传输，广泛应用于各种多媒体系统。它采用了沿独立的导线传输时钟与数据信号的设计，通过将数据和时钟信号分离，避免了因时差诱发的失真，为用户节省了购买抵抗音频抖动的专业设备的费用。</p>
</blockquote>
<a id="more"></a>
<h2 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h2><p>三个主要的信号线<br><img src="/images/audio/i2s-sycle.png" alt="i2s-sycle"></p>
<h3 id="BCLK"><a href="#BCLK" class="headerlink" title="BCLK"></a>BCLK</h3><blockquote>
<p>时钟是方波的形式</p>
</blockquote>
<p>串行时钟SCLK，也叫位时钟（BCLK），即对应数字音频的每一位数据，SCLK都有1个脉冲。<code>SCLK的频率=2×采样频率×采样位数</code>。</p>
<p>如采样频率=44.1Khz  采样位数=24bit</p>
<p>SCLK = 2 <em> 44.1kHz </em> 24 = 2.1168MHz</p>
<h3 id="LRCLK"><a href="#LRCLK" class="headerlink" title="LRCLK"></a>LRCLK</h3><p>帧时钟LRCK，(也称WS)，用于切换左右声道的数据。LRCK为“1”表示正在传输的是<code>右声道</code>的数据，为“0”则表示正在传输的是<code>左声道</code>的数据。<code>LRCK的频率 = 采样频率</code>。<br>在目前的测试中主要为SYNC_CLK</p>
<p>LRCLK=44.1kHz</p>
<h3 id="SDATA"><a href="#SDATA" class="headerlink" title="SDATA"></a>SDATA</h3><p>串行数据SDATA，就是用二进制补码表示的音频数据。</p>
<h2 id="数据格式—–I2S"><a href="#数据格式—–I2S" class="headerlink" title="数据格式—–I2S"></a>数据格式—–I2S</h2><h3 id="I2S"><a href="#I2S" class="headerlink" title="I2S"></a>I2S</h3><p><img src="/images/audio/I2S.png" alt="I2S"></p>
<h3 id="LJ-Left-Justified"><a href="#LJ-Left-Justified" class="headerlink" title="LJ (Left Justified)"></a>LJ (Left Justified)</h3><p><img src="/images/audio/I2S-LJ.png" alt="I2S-LJ"></p>
<h3 id="RJ-Left-Justified"><a href="#RJ-Left-Justified" class="headerlink" title="RJ (Left Justified)"></a>RJ (Left Justified)</h3><p><img src="/images/audio/I2S-RJ.png" alt="I2S-RJ"></p>
<h2 id="I2S–八声道"><a href="#I2S–八声道" class="headerlink" title="I2S–八声道"></a>I2S–八声道</h2><p><img src="/images/2019/02/i2s_channel_8.png" alt="i2s_channel_8"></p>
<blockquote>
<p>i2s normal mode</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.t-firefly.com/download/firefly-rk3288/docs/TRM/rk3288-chapter-16-i2s-pcm-controller-(8-channel" target="_blank" rel="noopener">16I2S/PCM Controller (8 channel)</a>.pdf)</li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>audio</tag>
        <tag>i2s</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio ALSA数据传输</title>
    <url>/post/6516.html</url>
    <content><![CDATA[<p>在ALSA数据传输中，主要出现错误<code>underrun</code>和<code>overrun</code></p>
<blockquote>
<p>DDR —&gt; buffer —&gt; digital singal</p>
</blockquote>
<a id="more"></a>
<h2 id="overrun"><a href="#overrun" class="headerlink" title="overrun"></a>overrun</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MIC --&gt; DMIC(控制器) --&gt; DDR(RAM) --&gt; Flash</span><br></pre></td></tr></table></figure>
<p>在<code>录音</code>时由于录音数据过快会产生<code>overrun</code>现象</p>
<h2 id="underrun"><a href="#underrun" class="headerlink" title="underrun"></a>underrun</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flash --&gt; DDR --&gt; I2S --&gt; Codec --&gt; spk</span><br></pre></td></tr></table></figure>
<p>在<code>放音</code>时由于用户层的音频数据到DDR中的速度比控制器到codec放出的速度慢,出现<code>underrun</code></p>
<h3 id="断音"><a href="#断音" class="headerlink" title="断音"></a>断音</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+        +----+</span><br><span class="line">|      |        |    |       +---------+    +-----+</span><br><span class="line">|      |        |    | DMA   |         |    |     |</span><br><span class="line">| flash+--------&gt; DDR+-------&gt; buffer  +----&gt;codec|</span><br><span class="line">|      |        |    |       +---------+    +-----+</span><br><span class="line">+------+        +----+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从flash到DDR的速度，比数据从DDR通过DMA到buffer的速度慢，导致出现断音<code>underrun</code></p>
</blockquote>
<ol>
<li>DMA没有及时的从DDR中将数据搬到FIFO</li>
<li>DDR中申请的buffer不够大</li>
<li>DDR中的buffer没有数据</li>
</ol>
<p>假如播放的是音乐格式是采样率为192KHz，采样宽度为24bit，声道为2，驱动中的buffer大小为1M bytes（256 pages），FIFO深度为64 entry，DDR为150MHz（假如cpu和DDR间的数据拷贝仅仅为200M bytes/s）</p>
<ul>
<li>DDR</li>
</ul>
<p>那么1s播放出去的声音数据为192000 <em> 24 </em> 2/8(bytes)=1152000 bytes，而拷贝到buffer的数据为200Mbytes，即每10ms播放1152bytes,进入buffer的数据为2M bytes,而buffer仅仅有1M空间，所以播放完1 <em> 1024 </em> 1024 / 1152 =910次，即910 * 10ms=9s中内需要将程序调度回来，显然这是没有太大问题，因为我们的系统中不可能跑910个线程的。也就是说驱动中的buffer为1M byte的空间是没有问题的。</p>
<ul>
<li>FIFO</li>
</ul>
<p>fifo为64个entry，那么存放的音频数据仅仅是64 * 24=1536 bits=192bytes，播放完这些数据需要的时间是192/115.2 (ms)=1.67ms, 也就是说需要播放完fifo中的数据后的2ms内就要把数据添加到fifo中，如果这段时间没有做到这一点，那么就断音了</p>
<h2 id="xrun"><a href="#xrun" class="headerlink" title="xrun"></a>xrun</h2>]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>audio</tag>
        <tag>alsa</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>块设备驱动</title>
    <url>/post/51792.html</url>
    <content><![CDATA[<p>块设备传输数据的固定长度为一个sector,因此，输入、输出调度器和块设备的驱动必须管理扇区的数据。<strong>虚拟文件系统-&gt;磁盘设备的中间映射层</strong>，它使用一种逻辑单元来管理磁盘数据，这种逻辑单元被称之为“Block”,一个块相当于一个文件系统里面的最小磁盘存储单元。</p>
<h2 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h2><ul>
<li><p>块设备（blockdevice）</p>
<p>是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的，他使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>字符设备（Character device）</p>
<p>是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。他不具备缓冲区，所以对这种设备的读写是实时的。</p>
</li>
</ul>
<h2 id="块设备的驱动框架"><a href="#块设备的驱动框架" class="headerlink" title="块设备的驱动框架"></a>块设备的驱动框架</h2><p><img src="/images/block.png" alt="块设备驱动框架"></p>
<blockquote>
<p>块设备的应用在Linux中是一个完整的子系统。</p>
</blockquote>
<p>在Linux中，驱动对块设备的输入或输出(I/O)操作，都会向块设备发出一个请求，在驱动中用request结构体描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些I/O请求添加到队列中（即：请求队列），在驱动中用request_queue结构体描述。在向块设备提交这些请求前内核会先执行请求的合并和排序预操作，以提高访问的效率，然后再由内核中的I/O调度程序子系统来负责提交  I/O 请求，  调度程序将磁盘资源分配给系统中所有挂起的块 I/O  请求，其工作是管理块设备的请求队列，决定队列中的请求的排列顺序以及什么时候派发请求到设备。</p>
<p>由通用块层(Generic Block Layer)负责维持一个I/O请求在上层文件系统与底层物理磁盘之间的关系。在通用块层中，通常用一个bio结构体来对应一个I/O请求。</p>
<p>Linux提供了一个gendisk数据结构体，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在gendisk中有一个类似字符设备中file_operations的硬件操作结构指针，是block_device_operations结构体。</p>
<p>当多个请求提交给块设备时，执行效率依赖于请求的顺序。如果所有的请求是同一个方向（如：写数据），执行效率是最大的。内核在调用块设备驱动程序例程处理请求之前，先收集I/O请求并将请求排序，然后，将连续扇区操作的多个请求进行合并以提高执行效率（内核算法会自己做，不用你管），对I/O请求排序的算法称为电梯算法（elevator algorithm）。电梯算法在I/O调度层完成。内核提供了不同类型的电梯算法.</p>
<h3 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h3><p>1 noop（实现简单的FIFO，基本的直接合并与排序）,<br>2 anticipatory（延迟I/O请求，进行临界区的优化排序），<br>3 Deadline（针对anticipatory缺点进行改善，降低延迟时间）,<br>4 Cfq（均匀分配I/O带宽，公平机制）<br>PS：其实IO调度层（包括请求合并排序算法）是不需要用户管的，内核已经做好</p>
<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><p>block_device:      描述一个分区或整个磁盘对内核的一个块设备实例<br>gendisk:               描述一个通用硬盘（generic hard disk）对象。<br>hd_struct:             描述分区应有的分区信息<br>bio:                        描述块数据传送时怎样完成填充或读取块给driver<br>request:                描述向内核请求一个列表准备做队列处理。<br>request_queue:  描述内核申请request资源建立请求链表并填写BIO形成队列。</p>
<h2 id="驱动的实现"><a href="#驱动的实现" class="headerlink" title="驱动的实现"></a>驱动的实现</h2>]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>块设备</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C驱动</title>
    <url>/post/28337.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                          +---------+</span><br><span class="line">+----------+              |         |</span><br><span class="line">| CPU      |              |  codec1 |</span><br><span class="line">|          |              +-+-----+-+</span><br><span class="line">|      +---+                |     |                       +------+</span><br><span class="line">|      |I2C|                |     |                       |      |</span><br><span class="line">|      |   &lt;----------------------------------------------+ codec|</span><br><span class="line">|      |   &lt;----------------------v-----------------------+      |</span><br><span class="line">|      +---+                                              |      |</span><br><span class="line">|          |                                              +------+</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<p>I2C: 以1根串行数据线<code>（SDA）</code>和1根串行时钟线<code>（SCL）</code>实 现了双工的同步数据传输。具有接口线少，控制方式简化，器件封装形式小，通信速率较高等优点。在主从通信中，可以有多个I2C总线器件同时接到I2C总线上，通过<code>地址</code>来识别通信对象, <code>应答</code>来互通数据及命令。</p>
<p>速度模式：</p>
<ul>
<li>标准模式下可达到<code>100Kbps</code></li>
<li>快速模式下可达到<code>400Kbps</code></li>
<li>高速模式下达到<code>4Mbps</code></li>
</ul>
<a id="more"></a>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><h2 id="设备定义（DTS）"><a href="#设备定义（DTS）" class="headerlink" title="设备定义（DTS）"></a>设备定义（DTS）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;i2c4 &#123;</span><br><span class="line">	status = &quot;okay&quot;;</span><br><span class="line">	clock-frequency = &lt;100000&gt;;</span><br><span class="line">	timeout = &lt;1000&gt;;</span><br><span class="line">	pinctrl-names = &quot;default&quot;;</span><br><span class="line">	pinctrl-0 = &lt;&amp;i2c4_pd&gt;;</span><br><span class="line"></span><br><span class="line">	ak4458: dac@0x10 &#123;</span><br><span class="line">		compatible = &quot;asahi-kasei,ak4458&quot;;</span><br><span class="line">		status = &quot;okay&quot;;</span><br><span class="line">		reg = &lt;0x10&gt;;</span><br><span class="line">		reset-gpios = &lt;&amp;gpd 7 GPIO_ACTIVE_HIGH INGENIC_GPIO_NOBIAS&gt;;</span><br><span class="line">		xxmute-gpios = &lt;&amp;gpc 4 GPIO_ACTIVE_HIGH INGENIC_GPIO_NOBIAS&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="acpi"><a href="#acpi" class="headerlink" title="acpi"></a>acpi</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.wowotech.net/linux_kenrel/i2c_consumer.html" target="_blank" rel="noopener">Linux I2C framework(3)_I2C consumer</a></li>
<li><a href="https://blog.csdn.net/ASKLW/article/details/77834077" target="_blank" rel="noopener">示波器分析I2C时序波形图</a></li>
<li><a href="https://blog.csdn.net/smallmuou/article/details/7183656" target="_blank" rel="noopener">I2C设备调试及波形分析</a></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>driver</tag>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞，非阻塞</title>
    <url>/post/63673.html</url>
    <content><![CDATA[<p>在mmc子系统自带的测试中数据的读写有<code>阻塞</code>和<code>非阻塞</code>两种，这里主要将这两种IO的操作进一步做简单的总结，来加深自己的理解。同时，也将在学习过程中又接触到的<code>同步</code>和<code>异步</code>记录在此。</p>
<h2 id="阻塞IO-block-IO"><a href="#阻塞IO-block-IO" class="headerlink" title="阻塞IO(block IO)"></a>阻塞IO(block IO)</h2><blockquote>
<p>阻塞操作是指在执行设备操作时，若不能获取资源，则挂起进程直到满足可操作的条件后再进行操作。</p>
</blockquote>
<p>在进行阻塞的IO操作时，如果没有可用的资源，当前进程将进入睡眠模式，它将CPU资源让给其他进程，但是由于会进入睡眠状态，因此在我们得到资源可以利用时（设备驱动中一般中断的方式得到该状态，因为在硬件资源发生变化是一般都会产生中断），必须将休眠的进程再次唤醒进行后续的操作。</p>
<h2 id="非阻塞IO-unblock-IO"><a href="#非阻塞IO-unblock-IO" class="headerlink" title="非阻塞IO(unblock IO)"></a>非阻塞IO(unblock IO)</h2><blockquote>
<p>非阻塞操作进程在不能进行设备操作时，并不挂起，它要么放弃，要么不停的查询，直到可以进行操作为止</p>
</blockquote>
<p>这种方式是不断的查询当前资源的状态，不断的尝试，将消耗大量的CPU资源。</p>
]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>阻塞io</tag>
      </tags>
  </entry>
  <entry>
    <title>C代码片段</title>
    <url>/post/16839.html</url>
    <content><![CDATA[<p>记录一些遇到代码片段：</p>
<a id="more"></a>
<h2 id="去掉字符串末尾多余字符：回车-空格"><a href="#去掉字符串末尾多余字符：回车-空格" class="headerlink" title="去掉字符串末尾多余字符：回车 空格"></a>去掉字符串末尾多余字符：回车 空格</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clean_string</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">const</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *start = str;</span><br><span class="line">	<span class="keyword">char</span> *<span class="built_in">end</span> = str;</span><br><span class="line">	<span class="keyword">char</span> *p = str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(*p) &#123;</span><br><span class="line">		<span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">			<span class="keyword">if</span>(str != start) &#123;</span><br><span class="line">			*start = *p;</span><br><span class="line">			start++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			*start = *p;</span><br><span class="line">			start++;</span><br><span class="line">			<span class="built_in">end</span> = start;</span><br><span class="line">		&#125;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	*<span class="built_in">end</span> = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成随机数：-异或"><a href="#生成随机数：-异或" class="headerlink" title="生成随机数： 异或"></a>生成随机数： 异或</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">seedrand_val2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rand_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//秒(tv.tv_sec)和微秒(tv.tv_usec)和进程ID的位进行异或操作生成随机数</span></span><br><span class="line">	rand_val = tv.tv_sec^tv.tv_usec^getpid();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s: rand_val=%d\n"</span>, __func__, rand_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伪随机数：rand"><a href="#伪随机数：rand" class="headerlink" title="伪随机数：rand"></a>伪随机数：rand</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srand((unsigned)time(NULL));</span><br><span class="line"></span><br><span class="line">#define MIN_BANDWIDTH   60</span><br><span class="line">#define MAX_BANDWIDTH   200</span><br><span class="line">#define random() (MIN_BANDWIDTH + (int)((double)rand() / ((double)RAND_MAX+1.0) * (MAX_BANDWIDTH - MIN_BANDWIDTH)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>随机范围：60~200</p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>uImage dump成反汇编</title>
    <url>/post/17694.html</url>
    <content><![CDATA[<blockquote>
<p>通过Linux调试使用的uImage文件,进行反汇编查看CPU的具体执行指令</p>
</blockquote>
<a id="more"></a>
<h2 id="uImage的组成"><a href="#uImage的组成" class="headerlink" title="uImage的组成"></a>uImage的组成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+-----------------------------+</span><br><span class="line">|      |                             |</span><br><span class="line">|  64k |          zImage             |</span><br><span class="line">|      |                             |</span><br><span class="line">+------+-----------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>如果时zImage可以直接进行解压操作</p>
<h3 id="去除64k头信息"><a href="#去除64k头信息" class="headerlink" title="去除64k头信息"></a>去除64k头信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=uImage of=Image.gz bs=1 skip=64</span><br></pre></td></tr></table></figure>
<h3 id="zip解压"><a href="#zip解压" class="headerlink" title="zip解压"></a>zip解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunzip Image.gz</span><br></pre></td></tr></table></figure>
<p>生成’Image’,CPU执行的二进制代码</p>
<h2 id="获取二进制的执行指令码"><a href="#获取二进制的执行指令码" class="headerlink" title="获取二进制的执行指令码"></a>获取二进制的执行指令码</h2><blockquote>
<p>通过gcc的工具将二进制的指令码反汇编,CPU的取指是以word进行,也就是每一个wrod对应一条指令</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>],<span class="string">"r"</span>);</span><br><span class="line">	FILE *ofp = fopen(argv[<span class="number">2</span>],<span class="string">"wt"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">"#include &lt;stdio.h&gt;\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">"int main(int argc, char *argv[])\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">"&#123;"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">"\tasm volatile ("</span>);</span><br><span class="line">	<span class="keyword">while</span>(!feof(ifp))&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> d;</span><br><span class="line">		fread(&amp;d,<span class="number">1</span>,<span class="number">4</span>,ifp);</span><br><span class="line">		<span class="built_in">fprintf</span>(ofp,<span class="string">"\t\t\".word 0x%08x   \\t\\n\"\n"</span>,d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">"\t);"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">"return 0;"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">"&#125;"</span>);</span><br><span class="line">	fclose(ifp);</span><br><span class="line">	fclose(ofp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc m.c -o m</span><br><span class="line"></span><br><span class="line">./m Image Image.c</span><br></pre></td></tr></table></figure>
<p>Image.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(		<span class="string">".word 0x00000000   \t\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">".word 0x00000000   \t\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">".word 0x00000000   \t\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">".word 0x00000000   \t\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">".word 0x00000000   \t\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">".word 0x00000000   \t\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		...</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$mips-linux-gnu-gcc Image.c -o Image</span><br><span class="line">$mips-linux-gnu-objdump -Dz Image &gt; Image.S</span><br></pre></td></tr></table></figure>
<p>Image.S</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00400640 &lt;main&gt;:</span><br><span class="line">400640:   27bdfff8    addiu   sp,sp,-8</span><br><span class="line">400644:   afbe0004    sw  s8,4(sp)</span><br><span class="line">400648:   03a0f025    move    s8,sp</span><br><span class="line">40064c:   afc40008    sw  a0,8(s8)</span><br><span class="line">400650:   afc5000c    sw  a1,12(s8)</span><br><span class="line">400654:   00000000    nop</span><br><span class="line">...</span><br><span class="line">400a54:   3c05805f    lui a1,0x805f &lt;==== Load Address: 80010000</span><br><span class="line">400a58:   3c06805f    lui a2,0x805f</span><br><span class="line">400a5c:   aca404cc    sw  a0,1228(a1)</span><br><span class="line">400a60:   24c60444    addiu   a2,a2,1092</span><br><span class="line">400a64:   0804078d    j   101e34 &lt;_DYNAMIC-0x2fe384&gt;</span><br><span class="line">400a68:   24a504cc    addiu   a1,a1,1228</span><br><span class="line">400a6c:   3c028065    lui v0,0x8065</span><br><span class="line">400a70:   90422000    lbu v0,8192(v0)</span><br></pre></td></tr></table></figure>
<p><em>注意</em>:无法进行函数跳转的判断</p>
<h2 id="将PC指针替换成内核入口地址"><a href="#将PC指针替换成内核入口地址" class="headerlink" title="将PC指针替换成内核入口地址"></a>将PC指针替换成内核入口地址</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">fp = open(<span class="string">"Image.S"</span>,<span class="string">"r"</span>)</span><br><span class="line">iaddr = <span class="number">0x80010000</span></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fp.readlines():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"400654: 00000000"</span> <span class="keyword">in</span> line:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        s = line.split(<span class="string">":"</span>)</span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">1</span>:</span><br><span class="line">            addr = s[<span class="number">0</span>]</span><br><span class="line">            data = s[<span class="number">1</span>]</span><br><span class="line">            print(<span class="string">"%08x:\t %s"</span> % (iaddr,s[<span class="number">1</span>])),</span><br><span class="line">            iaddr = iaddr + <span class="number">4</span></span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python a.py &gt; uImage.S</span><br></pre></td></tr></table></figure>
<p><em>注意</em>:文件权限问题,可以无法读取文件数据</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="uImage-S"><a href="#uImage-S" class="headerlink" title="uImage.S"></a>uImage.S</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">800103f8:       00000000    nop</span><br><span class="line">800103fc:       00000000    nop</span><br><span class="line">80010400:       3c05805f    lui a1,0x805f</span><br><span class="line">80010404:       3c06805f    lui a2,0x805f</span><br><span class="line">80010408:       aca404cc    sw  a0,1228(a1)</span><br><span class="line">8001040c:       24c60444    addiu   a2,a2,1092</span><br><span class="line">80010410:       0804078d    j   101e34 &lt;_DYNAMIC-0x2fe384&gt;</span><br><span class="line">80010414:       24a504cc    addiu   a1,a1,1228</span><br></pre></td></tr></table></figure>
<h3 id="vmlinux-S"><a href="#vmlinux-S" class="headerlink" title="vmlinux.S"></a>vmlinux.S</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80010400 &lt;run_init_process&gt;:</span><br><span class="line">80010400:   3c05805f    lui a1,0x805f</span><br><span class="line">80010404:   3c06805f    lui a2,0x805f</span><br><span class="line">80010408:   aca404cc    sw  a0,1228(a1)</span><br><span class="line">8001040c:   24c60444    addiu   a2,a2,1092</span><br><span class="line">80010410:   0804078d    j   80101e34 &lt;do_execve&gt;</span><br><span class="line">80010414:   24a504cc    addiu   a1,a1,1228</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>umage</tag>
        <tag>反汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ext4文件系统扩容</title>
    <url>/post/38978.html</url>
    <content><![CDATA[<p>ext4文件系统在制作时，已将大小进行固定，但是在实际的使用过程中，由于后续的测试和使用导致文件系统的空间不足，而同时有不想重新进行文件系统的制作，只是单纯的进行容量的扩展</p>
<a id="more"></a>
<h2 id="查看现有ext4文件系统"><a href="#查看现有ext4文件系统" class="headerlink" title="查看现有ext4文件系统"></a>查看现有ext4文件系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t ext4 roofs.ext4 tmp</span><br></pre></td></tr></table></figure>
<h2 id="resize2fs"><a href="#resize2fs" class="headerlink" title="resize2fs"></a>resize2fs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resize2fs -h</span><br><span class="line">resize2fs 1.44.1 (24-Mar-2018)</span><br><span class="line">Usage: resize2fs [-d debug_flags] [-f] [-F] [-M] [-P] [-p] device [-b|-s|new_size] [-S RAID-stride] [-z undo_file]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$man resize2fs</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-d</code></td>
<td style="text-align:center">打开调试特性</td>
</tr>
<tr>
<td style="text-align:center"><code>-f</code></td>
<td style="text-align:center">强制执行，覆盖一些通常强制执行的安全检查</td>
</tr>
<tr>
<td style="text-align:center"><code>-F</code></td>
<td style="text-align:center">执行之前，刷新文件系统的缓冲区</td>
</tr>
<tr>
<td style="text-align:center"><code>-M</code></td>
<td style="text-align:center">将文件系统缩小到最小值</td>
</tr>
<tr>
<td style="text-align:center"><code>-p</code></td>
<td style="text-align:center">显示已经完成任务的百分比</td>
</tr>
<tr>
<td style="text-align:center"><code>-P</code></td>
<td style="text-align:center">显示文件系统的最小值</td>
</tr>
</tbody>
</table>
<h3 id="显示文件系统最小值"><a href="#显示文件系统最小值" class="headerlink" title="显示文件系统最小值"></a>显示文件系统最小值</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resize2fs -P  rootfs.ext4</span><br><span class="line">resize2fs 1.44.1 (24-Mar-2018)</span><br><span class="line">Estimated minimum size of the filesystem: 5161</span><br></pre></td></tr></table></figure>
<h3 id="文件系统扩展容量："><a href="#文件系统扩展容量：" class="headerlink" title="文件系统扩展容量："></a>文件系统扩展容量：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resize2fs system.ext4 300000</span><br><span class="line">resize2fs system.ext4 300M</span><br></pre></td></tr></table></figure>
<blockquote>
<p>文件系统大小: 300MB，单位可以使用<code>k</code>、<code>M</code>、<code>G</code></p>
</blockquote>
<h2 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h2><h3 id="创建空的文件系统"><a href="#创建空的文件系统" class="headerlink" title="创建空的文件系统"></a>创建空的文件系统</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=new_roofs.ext4 bs=1M count=300</span><br><span class="line">mkfs.ext4 new_roofs.ext4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>文件系统大小：300M</p>
</blockquote>
<h3 id="现有文件系统的拷贝"><a href="#现有文件系统的拷贝" class="headerlink" title="现有文件系统的拷贝"></a>现有文件系统的拷贝</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t ext4 roofs.ext4 tmp</span><br><span class="line">mount -t ext4 new_roofs.ext4 tmp1</span><br><span class="line">cp tmp/* tmp1 -arpdf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>ext4</tag>
      </tags>
  </entry>
  <entry>
    <title>ext4文件系统变为只读</title>
    <url>/post/31493.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 7965.955384] EXT4-fs error (device mmcblk0p7): ext4_mb_generate_buddy:758: group 3, block bitmap and bg descriptor inconsistent: 1901 vs 1900 free clusters</span><br><span class="line">[ 7965.963826] EXT4-fs (mmcblk0p7): Remounting filesystem read-only</span><br><span class="line">[ 7965.975652] EXT4-fs (mmcblk0p7): ext4_writepages: jbd2_start: 2147483644 pages, ino 6032; err -30</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>ext4文件系统bug，在linux4.6.7中以修复。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit d123a55f85f5116d686dac80c768ee5c34ec8e06</span><br><span class="line">Author: Vegard Nossum &lt;vegard.nossum@oracle.com&gt;</span><br><span class="line">Date:   Thu Jul 14 23:21:35 2016 -0400</span><br><span class="line"></span><br><span class="line">    ext4: short-cut orphan cleanup on error</span><br><span class="line"></span><br><span class="line">    commit c65d5c6c81a1f27dec5f627f67840726fcd146de upstream.</span><br><span class="line"></span><br><span class="line">    If we encounter a filesystem error during orphan cleanup, we should stop.</span><br><span class="line">    Otherwise, we may end up in an infinite loop where the same inode is</span><br><span class="line">    processed again and again.</span><br><span class="line"></span><br><span class="line">        EXT4-fs (loop0): warning: checktime reached, running e2fsck is recommended</span><br><span class="line">        EXT4-fs error (device loop0): ext4_mb_generate_buddy:758: group 2, block bitmap and bg descriptor inconsistent: 6117 vs 0 free clusters</span><br><span class="line">        Aborting journal on device loop0-8.</span><br><span class="line">        EXT4-fs (loop0): Remounting filesystem read-only</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_free_blocks:4895: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_do_update_inode:4893: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_do_update_inode:4893: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_ext_remove_space:3068: IO failure</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_ext_truncate:4667: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_orphan_del:2927: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_do_update_inode:4893: Journal has aborted</span><br><span class="line">        EXT4-fs (loop0): Inode 16 (00000000618192a0): orphan list check failed!</span><br><span class="line">        [...]</span><br><span class="line">        EXT4-fs (loop0): Inode 16 (0000000061819748): orphan list check failed!</span><br><span class="line">        [...]</span><br><span class="line">        EXT4-fs (loop0): Inode 16 (0000000061819bf0): orphan list check failed!</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">    See-also: c9eb13a9105 (&quot;ext4: fix hang when processing corrupted orphaned inode list&quot;)</span><br><span class="line">    Cc: Jan Kara &lt;jack@suse.cz&gt;</span><br><span class="line">    Signed-off-by: Vegard Nossum &lt;vegard.nossum@oracle.com&gt;</span><br><span class="line">    Signed-off-by: Theodore Ts&apos;o &lt;tytso@mit.edu&gt;</span><br><span class="line">    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</span><br><span class="line"></span><br><span class="line">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span><br><span class="line">index 089821b..7fca76b 100644</span><br><span class="line">--- a/fs/ext4/super.c</span><br><span class="line">+++ b/fs/ext4/super.c</span><br><span class="line">@@ -2277,6 +2277,16 @@ static void ext4_orphan_cleanup(struct super_block *sb,</span><br><span class="line">        while (es-&gt;s_last_orphan) &#123;</span><br><span class="line">                struct inode *inode;</span><br><span class="line"></span><br><span class="line">+               /*</span><br><span class="line">+                * We may have encountered an error during cleanup; if</span><br><span class="line">+                * so, skip the rest.</span><br><span class="line">+                */</span><br><span class="line">+               if (EXT4_SB(sb)-&gt;s_mount_state &amp; EXT4_ERROR_FS) &#123;</span><br><span class="line">+                       jbd_debug(1, &quot;Skipping orphan recovery on fs with errors.\n&quot;);</span><br><span class="line">+                       es-&gt;s_last_orphan = 0;</span><br><span class="line">+                       break;</span><br><span class="line">+               &#125;</span><br><span class="line">+</span><br><span class="line">                inode = ext4_orphan_get(sb, le32_to_cpu(es-&gt;s_last_orphan));</span><br><span class="line">                if (IS_ERR(inode)) &#123;</span><br><span class="line">                        es-&gt;s_last_orphan = 0;</span><br></pre></td></tr></table></figure>
<p><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.6.7" target="_blank" rel="noopener">linux v4.x ChangeLog-4.6.7</a></p>
<h2 id="产生的原因："><a href="#产生的原因：" class="headerlink" title="产生的原因："></a>产生的原因：</h2>]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>ext4</tag>
      </tags>
  </entry>
  <entry>
    <title>arm交叉编译工具</title>
    <url>/post/64642.html</url>
    <content><![CDATA[<h2 id="编译工具命名规则"><a href="#编译工具命名规则" class="headerlink" title="编译工具命名规则"></a>编译工具命名规则</h2><blockquote>
<p>交叉编译工具链的命名规则为：arch [-vendor] [-os] [-(gnu)eabi]</p>
</blockquote>
<ul>
<li>arch - 体系架构，如ARM，MIPS</li>
<li>vendor - 工具链提供商</li>
<li>os - 目标操作系统</li>
<li>eabi - 嵌入式应用二进制接口（Embedded Application Binary Interface）</li>
</ul>
<p>根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如</p>
<a id="more"></a>
<h3 id="arm-none-eabi："><a href="#arm-none-eabi：" class="headerlink" title="arm-none-eabi："></a>arm-none-eabi：</h3><p>这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork(2)。他使用的是newlib这个专用于嵌入式系统的C库。<br>arm-none-linux-eabi：用于Linux的，使用Glibc</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="arm-none-eabi-gcc"><a href="#arm-none-eabi-gcc" class="headerlink" title="arm-none-eabi-gcc"></a>arm-none-eabi-gcc</h3><p>（ARM architecture，no vendor，not target an operating system，complies with the ARM EABI）<br>用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application），一般适合 ARM7、Cortex-M 和 Cortex-R 内核的芯片使用，所以不支持那些跟操作系统关系密切的函数，比如fork(2)，他使用的是 newlib 这个专用于嵌入式系统的C库。</p>
<h3 id="arm-none-linux-gnueabi-gcc"><a href="#arm-none-linux-gnueabi-gcc" class="headerlink" title="arm-none-linux-gnueabi-gcc"></a>arm-none-linux-gnueabi-gcc</h3><p>(ARM architecture, no vendor, creates binaries that run on the Linux operating system, and uses the GNU EABI)<br>主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、linux应用等。arm-none-linux-gnueabi基于GCC，使用Glibc库，经过 Codesourcery 公司优化过推出的编译器。arm-none-linux-gnueabi-xxx 交叉编译工具的浮点运算非常优秀。一般ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的会用到。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="arm-none-eabi-gcc-1"><a href="#arm-none-eabi-gcc-1" class="headerlink" title="arm-none-eabi-gcc"></a>arm-none-eabi-gcc</h3><p>地址：<a href="https://launchpad.net/gcc-arm-embedded" target="_blank" rel="noopener">https://launchpad.net/gcc-arm-embedded</a><br><strong>注</strong>:在a8中使用该编译工具（gcc-arm-none-eabi-5_4-2016q2），编译uboot在uboot启动时，对nand进行初始化无法成功。</p>
<h3 id="arm-none-linux-gnueabi-gcc-1"><a href="#arm-none-linux-gnueabi-gcc-1" class="headerlink" title="arm-none-linux-gnueabi-gcc"></a>arm-none-linux-gnueabi-gcc</h3><p>Mentor官方下载地址（需要注册，注册之后官方会发送一个下载地址到邮箱里面）<br>地址：<a href="http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/evaluations/" target="_blank" rel="noopener">http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/evaluations</a><br>网盘下载：<a href="http://www.veryarm.com/arm-none-linux-gnueabi-gcc" target="_blank" rel="noopener">http://www.veryarm.com/arm-none-linux-gnueabi-gcc</a></p>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>交叉编译工具</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/post/32902.html</url>
    <content><![CDATA[<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>有限状态机（Finite State Machine或者Finite State Automata)是软件领域中一种重要的工具，很多东西的模型实际上就是有限状态机。</p>
<a id="more"></a>
<h3 id="FSM的实现方式："><a href="#FSM的实现方式：" class="headerlink" title="FSM的实现方式："></a>FSM的实现方式：</h3><ol>
<li>switch/case或者if/else</li>
</ol>
<p>这无意是最直观的方式，使用一堆条件判断，会编程的人都可以做到，对简单小巧的状态机来说最合适，但是毫无疑问，这样的方式比较原始，对庞大的状态机难以维护。</p>
<ol start="2">
<li>状态表</li>
</ol>
<p>维护一个二维状态表，横坐标表示当前状态，纵坐标表示输入，表中一个元素存储下一个状态和对应的操作。这一招易于维护，但是运行时间和存储空间的代价较大。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有限状态机(finite state machine)是一个数学概念，如果把它运用于程序中，可以发挥很大的作用。它是一种协议，用于有限数量的子程序(“状态”)的发展变化。每个子程序进行一些处理并选择下一种状态(通常取决于下一段输入)。</p>
<p>有限状态机(FSM)可以用作程序的控制结构。FSM对于那些基于输入的在几个不同的可选动作中进行循环的程序尤其合适。投币售货机就是FSM的一个好例子。另外一个你可以想到的复杂的例子就是你正在用的东西，想到了吗？没错，就是操作系统。在投币售货机的例子中，输入是硬币，输出是待售商品，售货机有”接受硬币”，”选择商品”，”发送商品”和”找零钱”等几种状态。</p>
<p>它的基本思路是用一张表保存所有可能的状态，并列出进入每个状态时可能执行的所有动作，其中最后一个动作就是计算(通常在当前状态和下一次输入字符的基础上，另外再经过一次表查询)下一个应该进入的状态。你从一个”初始状态”开始。在这一过程中，翻译表可能告诉你进入了一个错误状态，直到到达结束状态。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如我们定义了小明一天的状态如下</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">	GET_UP,</span><br><span class="line">	GO_TO_SCHOOL,</span><br><span class="line">	HAVE_LUNCH,</span><br><span class="line">	DO_HOMEWORK,</span><br><span class="line">	SLEEP,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">	EVENT1 = <span class="number">1</span>,</span><br><span class="line">	EVENT2,</span><br><span class="line">	EVENT3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FsmTable_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> event;   <span class="comment">//事件</span></span><br><span class="line">	<span class="keyword">int</span> CurState;  <span class="comment">//当前状态</span></span><br><span class="line">	<span class="keyword">void</span> (*eventActFun)();  <span class="comment">//函数指针</span></span><br><span class="line">	<span class="keyword">int</span> NextState;  <span class="comment">//下一个状态</span></span><br><span class="line">&#125;FsmTable_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FSM_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	FsmTable_t* FsmTable;   <span class="comment">//指向的状态表</span></span><br><span class="line">	<span class="keyword">int</span> curState;  <span class="comment">//FSM当前所处的状态</span></span><br><span class="line">&#125;FSM_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_max_num;  <span class="comment">//状态表里含有的状态个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"xiao ming gets up!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Go2School</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"xiao ming goes to school!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HaveLunch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"xiao ming has lunch!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoHomework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"xiao ming does homework!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Go2Bed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"xiao ming goes to bed!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*状态机注册*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSM_Regist</span><span class="params">(FSM_t* pFsm, FsmTable_t* pTable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pFsm-&gt;FsmTable = pTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*状态迁移*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSM_StateTransfer</span><span class="params">(FSM_t* pFsm, <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pFsm-&gt;curState = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*事件处理*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSM_EventHandle</span><span class="params">(FSM_t* pFsm, <span class="keyword">int</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FsmTable_t* pActTable = pFsm-&gt;FsmTable;</span><br><span class="line">	<span class="keyword">void</span> (*eventActFun)() = <span class="literal">NULL</span>;  <span class="comment">//函数指针初始化为空</span></span><br><span class="line">	<span class="keyword">int</span> NextState;</span><br><span class="line">	<span class="keyword">int</span> CurState = pFsm-&gt;curState;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//标识是否满足条件</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*获取当前动作函数*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;g_max_num; i++) &#123;</span><br><span class="line">		<span class="comment">//当且仅当当前状态下来个指定的事件，我才执行它</span></span><br><span class="line">		<span class="keyword">if</span> (event == pActTable[i].event &amp;&amp;</span><br><span class="line">				CurState == pActTable[i].CurState) &#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			eventActFun = pActTable[i].eventActFun;</span><br><span class="line">			NextState = pActTable[i].NextState;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		<span class="comment">/*动作执行*/</span></span><br><span class="line">		<span class="keyword">if</span> (eventActFun) &#123;</span><br><span class="line">			eventActFun();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//跳转到下一个状态</span></span><br><span class="line">		FSM_StateTransfer(pFsm, NextState);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// do nothing</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FsmTable_t XiaoMingTable[] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//&#123;到来的事件，当前的状态，将要要执行的函数，下一个状态&#125;</span></span><br><span class="line">	&#123; EVENT1,  SLEEP,           GetUp,        GET_UP &#125;,</span><br><span class="line">	&#123; EVENT2,  GET_UP,          Go2School,    GO_TO_SCHOOL &#125;,</span><br><span class="line">	&#123; EVENT3,  GO_TO_SCHOOL,    HaveLunch,    HAVE_LUNCH &#125;,</span><br><span class="line">	&#123; EVENT1,  HAVE_LUNCH,      DoHomework,   DO_HOMEWORK &#125;,</span><br><span class="line">	&#123; EVENT2,  DO_HOMEWORK,     Go2Bed,       SLEEP &#125;,</span><br><span class="line">	<span class="comment">//add your codes here</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化FSM</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitFsm</span><span class="params">(FSM_t* pFsm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_max_num = <span class="keyword">sizeof</span>(XiaoMingTable) / <span class="keyword">sizeof</span>(FsmTable_t);</span><br><span class="line">	pFsm-&gt;curState = SLEEP;</span><br><span class="line">	FSM_Regist(pFsm, XiaoMingTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*event == <span class="number">3</span>) &#123;</span><br><span class="line">		*event = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		(*event)++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FSM_t fsm;</span><br><span class="line">	InitFsm(&amp;fsm);</span><br><span class="line">	<span class="keyword">int</span> event = EVENT1;</span><br><span class="line">	<span class="comment">//小明的一天,周而复始的一天又一天，进行着相同的活动</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"event %d is coming...\n"</span>, event);</span><br><span class="line">		FSM_EventHandle(&amp;fsm, event);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"fsm current state %d\n"</span>, fsm.curState);</span><br><span class="line">		test(&amp;event);</span><br><span class="line">		sleep(<span class="number">1</span>);  <span class="comment">//休眠1秒，方便观察</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>fsm</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC</title>
    <url>/post/54464.html</url>
    <content><![CDATA[<p>GCC的使用和相关特性。</p>
<a id="more"></a>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__builtin_xxx(x)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GCC includes built-in versions of many of the functions in the standard C library. The versions prefixed with <code>__builtin_</code> will always be treated as having the same meaning as the C library function even if you specify the <code>-fno-builtin</code> option.</p>
</blockquote>
<p><a href="http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html" target="_blank" rel="noopener">gcc内置函数</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>void __builtin___clear_cache (void *begin, void *end)</code></td>
<td style="text-align:left">刷新指令Cache (iCache), MIPS使用<code>synci</code>指令</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>int __builtin_clz (unsigned int x)</code></td>
<td style="text-align:left">从最高有效位开始，返回x中前导0位的数量。 如果x为0，则结果未定义</td>
<td style="text-align:left">a = __builtin_clz(5) = 29</td>
</tr>
<tr>
<td style="text-align:left"><code>int __builtin_popcount (unsigned int x)</code></td>
<td style="text-align:left">返回x中1的个数</td>
<td style="text-align:left">a = __builtin_popcount(5) = 2</td>
</tr>
</tbody>
</table>
<h2 id="编译时警告信息"><a href="#编译时警告信息" class="headerlink" title="编译时警告信息"></a>编译时警告信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -O3&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wl,--no-as-needed&quot;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -std=gnu99&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -g&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -O3&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -W&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wall&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wextra&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-unused&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-unused-parameter&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -D_GNU_SOURCE&quot;)</span><br></pre></td></tr></table></figure>
<p>详细参数信息说明及更多的参数<a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options" target="_blank" rel="noopener">Options to Request or Suppress Warnings</a></p>
<h2 id="Optimization-Levels（优化等级）"><a href="#Optimization-Levels（优化等级）" class="headerlink" title="Optimization Levels（优化等级）"></a>Optimization Levels（优化等级）</h2><p>启用优化会使编译器尝试以牺牲编译时间和调试程序的能力为代价来提高性能和/或代码大小。如果您使用多个<code>-O</code>选项，无论是否有级别编号，最后一个这样的选项是有效的。</p>
<p>默认是优化关闭。 这导致了最快的编译时间，但 GNAT 绝对不尝试优化，并且生成的程序比启用优化时更大更慢。 您可以使用 -O 开关（允许的形式是 -O0、-O1 -O2、-O3 和 -Os）到 gcc 来控制优化级别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">等级</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-O0</code></td>
<td style="text-align:left">无优化（默认）； 生成未优化的代码，但编译时间最快。请注意，即使指定了“无优化”，许多其他编译器也会进行大量优化。 对于 gcc，如果执行时间有任何问题，将 -O0 用于生产是非常不寻常的，因为 -O0 意味着（几乎）没有优化。 在进行性能比较时，应该记住 gcc 和其他编译器之间的这种差异。</td>
</tr>
<tr>
<td style="text-align:center"><code>-O1</code></td>
<td style="text-align:left">适度优化； 优化得相当好，但不会显着缩短编译时间。</td>
</tr>
<tr>
<td style="text-align:center"><code>-O2</code></td>
<td style="text-align:left">全面优化； 生成高度优化的代码并具有最慢的编译时间。</td>
</tr>
<tr>
<td style="text-align:center"><code>-O3</code></td>
<td style="text-align:left"><code>-O2</code>的完全优化； 还使用更积极的自动内联单元内的子程序（子程序内联）并尝试矢量化循环。</td>
</tr>
<tr>
<td style="text-align:center"><code>-Os</code></td>
<td style="text-align:left">优化结果程序的空间使用（代码和数据）。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gnat_ugn/Optimization-Levels.html#Optimization-Levels" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gnat_ugn/Optimization-Levels.html#Optimization-Levels</a></p>
</blockquote>
<h3 id="优化参数的具体优化范围"><a href="#优化参数的具体优化范围" class="headerlink" title="优化参数的具体优化范围"></a>优化参数的具体优化范围</h3><p>通过<code>gcc -Q --help=optimizers</code>命令可以查询优化等级的具体做了哪些优化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -Q --<span class="built_in">help</span>=optimizers -O3</span></span><br><span class="line">The following options control optimizations:</span><br><span class="line">  -O&lt;number&gt;                  		</span><br><span class="line">  -Ofast                      		</span><br><span class="line">  -Og                         		</span><br><span class="line">  -Os                         		</span><br><span class="line">  -faggressive-loop-optimizations 	[enabled]</span><br><span class="line">  -falign-functions           		[enabled]</span><br><span class="line">  -falign-jumps               		[enabled]</span><br><span class="line">  -falign-labels              		[enabled]</span><br><span class="line">  -falign-loops               		[enabled]</span><br><span class="line">  -fasynchronous-unwind-tables 		[enabled]</span><br><span class="line">  -fbranch-count-reg          		[enabled]</span><br><span class="line">  -fbranch-probabilities      		[disabled]</span><br><span class="line">  -fbranch-target-load-optimize 	[disabled]</span><br><span class="line">  -fbranch-target-load-optimize2 	[disabled]</span><br><span class="line">  -fbtr-bb-exclusive          		[disabled]</span><br><span class="line">  -fcaller-saves              		[enabled]</span><br><span class="line">  -fcombine-stack-adjustments 		[enabled]</span><br><span class="line">  -fcommon                    		[enabled]</span><br><span class="line">  -fcompare-elim              		[enabled]</span><br><span class="line">  -fconserve-stack            		[disabled]</span><br><span class="line">  -fcprop-registers           		[enabled]</span><br><span class="line">  -fcrossjumping              		[enabled]</span><br><span class="line">  -fcse-follow-jumps          		[enabled]</span><br><span class="line">  -fcx-fortran-rules          		[disabled]</span><br><span class="line">  -fcx-limited-range          		[disabled]</span><br><span class="line">  -fdata-sections             		[disabled]</span><br><span class="line">  -fdce                       		[enabled]</span><br><span class="line">  -fdefer-pop                 		[enabled]</span><br><span class="line">  -fdelayed-branch            		[disabled]</span><br><span class="line">  -fdelete-null-pointer-checks 		[enabled]</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>有关gcc优化的更多详细信息，请参考gcc的官方文档:</p>
<blockquote>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options</a></p>
</blockquote>
<h2 id="Compiler-Switches"><a href="#Compiler-Switches" class="headerlink" title="Compiler Switches"></a>Compiler Switches</h2><blockquote>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gnat_ugn/Alphabetical-List-of-All-Switches.html#Alphabetical-List-of-All-Switches" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gnat_ugn/Alphabetical-List-of-All-Switches.html#Alphabetical-List-of-All-Switches</a></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/index.html#SEC_Contents" target="_blank" rel="noopener">Using the GNU Compiler Collection (GCC)</a>—gcc在线文档</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-9.4.0/gnat_ugn.pdf" target="_blank" rel="noopener">GNAT User’s Guide for Native Platforms</a> — gcc编译参数</li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>builtin_xxx</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC编译器的优化： fprefetch-loop-arrays</title>
    <url>/post/14105.html</url>
    <content><![CDATA[<blockquote>
<p>以MIPS架构为基础进行分析<br>预取指令：<code>pref</code></p>
</blockquote>
<p>指令预取，是指提前将所需要的数据取出来，在使用时可用</p>
<a id="more"></a>
<h2 id="for-loop"><a href="#for-loop" class="headerlink" title="for loop"></a>for loop</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> aa[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(<span class="string">"ssnop\n\t"</span>);</span><br><span class="line">	__asm__ __volatile__(<span class="string">"ssnop\n\t"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">		aa[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(<span class="string">"ssnop\n\t"</span>);</span><br><span class="line">	__asm__ __volatile__(<span class="string">"ssnop\n\t"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;mips-linux-gnu-gcc -c for_loop.c -o for_loop.o</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="反汇编："><a href="#反汇编：" class="headerlink" title="反汇编："></a>反汇编：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mips-linux-gnu-objdump -d for_loop.o &gt; for_loop.s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000 &lt;func&gt;:</span><br><span class="line">   0:   27bdffe8    addiu   sp,sp,-24</span><br><span class="line">   4:   afbe0014    sw  s8,20(sp)</span><br><span class="line">   8:   03a0f025    move    s8,sp</span><br><span class="line">   c:   00000040    ssnop</span><br><span class="line">  10:   00000040    ssnop</span><br><span class="line">  14:   afc00008    sw  zero,8(s8)</span><br><span class="line">  18:   1000000b    b   48 &lt;func+0x48&gt;</span><br><span class="line">  1c:   00000000    nop</span><br><span class="line">  20:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  24:   304300ff    andi    v1,v0,0xff</span><br><span class="line">  28:   3c020000    lui v0,0x0</span><br><span class="line">  2c:   24440000    addiu   a0,v0,0</span><br><span class="line">  30:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  34:   00821021    addu    v0,a0,v0</span><br><span class="line">  38:   a0430000    sb  v1,0(v0)</span><br><span class="line">  3c:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  40:   24420001    addiu   v0,v0,1</span><br><span class="line">  44:   afc20008    sw  v0,8(s8)</span><br><span class="line">  48:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  4c:   28421000    slti    v0,v0,4096</span><br><span class="line">  50:   1440fff3    bnez    v0,20 &lt;func+0x20&gt;</span><br><span class="line">  54:   00000000    nop</span><br><span class="line">  58:   00000040    ssnop</span><br><span class="line">  5c:   00000040    ssnop</span><br><span class="line">  60:   00001025    move    v0,zero</span><br><span class="line">  64:   03c0e825    move    sp,s8</span><br><span class="line">  68:   8fbe0014    lw  s8,20(sp)</span><br><span class="line">  6c:   27bd0018    addiu   sp,sp,24</span><br><span class="line">  70:   03e00008    jr  ra</span><br><span class="line">  74:   00000000    nop</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>for循环的优化，对大数组的赋值</p>
<p><code>-fprefetch-loop-arrays</code> 生成数组预读取指令，对于使用巨大数组的程序可以加快代码执行速度，适合数据库相关的大型软件等</p>
<p>gcc默认没有开预取指令的优化，需要通过<code>-O3</code></p>
<h3 id="编译：-1"><a href="#编译：-1" class="headerlink" title="编译："></a>编译：</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;mips-linux-gnu-gcc -c for_loop.c -o for_loop.o -O3 -fprefetch-loop-arrays</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="反汇编：-1"><a href="#反汇编：-1" class="headerlink" title="反汇编："></a>反汇编：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000 &lt;func&gt;:</span><br><span class="line">   0:   27bdff00    addiu   sp,sp,-256</span><br><span class="line">   4:   afbe00fc    sw  s8,252(sp)</span><br><span class="line">   ...</span><br><span class="line">  24:   afb000dc    sw  s0,220(sp)</span><br><span class="line">  28:   00000040    ssnop</span><br><span class="line">  2c:   00000040    ssnop</span><br><span class="line">  30:   3c020000    lui v0,0x0</span><br><span class="line">  34:   00002025    move    a0,zero</span><br><span class="line">  38:   00001825    move    v1,zero</span><br><span class="line">  3c:   24460000    addiu   a2,v0,0</span><br><span class="line">  40:   306200ff    andi    v0,v1,0xff</span><br><span class="line">  44:   afa20008    sw  v0,8(sp)</span><br><span class="line">  ...</span><br><span class="line">  a0:   afbe0054    sw  s8,84(sp)</span><br><span class="line">  a4:   24960019    addiu   s6,a0,25</span><br><span class="line">  a8:   00d7f021    addu    s8,a2,s7</span><br><span class="line">  ac:   93b70010    lbu s7,16(sp)</span><br><span class="line">  b0:   24820004    addiu   v0,a0,4</span><br><span class="line">  ...</span><br><span class="line">  424:   a0b40000    sb  s4,0(a1)</span><br><span class="line">  428:   8fa500a8    lw  a1,168(sp)</span><br><span class="line">  42c:   93b40010    lbu s4,16(sp)</span><br><span class="line">  430:   a0b40000    sb  s4,0(a1)</span><br><span class="line">  434:   8fa500ac    lw  a1,172(sp)</span><br><span class="line">  ...</span><br><span class="line">  474:   a12a0000    sb  t2,0(t1)</span><br><span class="line">  478:   a0e80000    sb  t0,0(a3)</span><br><span class="line">  47c:   a0450000    sb  a1,0(v0)</span><br><span class="line">  480:   24020fe0    li  v0,4064</span><br><span class="line">  484:   1462feee    bne v1,v0,40 &lt;func+0x40&gt;</span><br><span class="line">  488:   24051000    li  a1,4096</span><br><span class="line">  48c:   304400ff    andi    a0,v0,0xff</span><br><span class="line">  490:   00c21821    addu    v1,a2,v0</span><br><span class="line">  494:   24420001    addiu   v0,v0,1</span><br><span class="line">  498:   1445fffc    bne v0,a1,48c &lt;func+0x48c&gt;</span><br><span class="line">  49c:   a0640000    sb  a0,0(v1)</span><br><span class="line">  4a0:   00000040    ssnop</span><br><span class="line">  4a4:   00000040    ssnop</span><br><span class="line">  4a8:   00001025    move    v0,zero</span><br><span class="line">  4ac:   8fbe00fc    lw  s8,252(sp)</span><br><span class="line">  4b0:   8fb700f8    lw  s7,248(sp)</span><br><span class="line">  ...</span><br><span class="line">  4cc:   8fb000dc    lw  s0,220(sp)</span><br><span class="line">  4d0:   03e00008    jr  ra</span><br><span class="line">  4d4:   27bd0100    addiu   sp,sp,256</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<h2 id="for语句汇编"><a href="#for语句汇编" class="headerlink" title="for语句汇编"></a>for语句汇编</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, a;</span><br><span class="line"></span><br><span class="line">    __asm__  __volatile__(<span class="string">"ssnop\n\t"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">88</span>; i++)</span><br><span class="line">        a = i;</span><br><span class="line">    __asm__  __volatile__(<span class="string">"ssnop\n\t"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000 &lt;func&gt;:</span><br><span class="line">   0:   27bdffe8    addiu   sp,sp,-24</span><br><span class="line">   4:   afbe0014    sw  s8,20(sp)</span><br><span class="line">   8:   03a0f025    move    s8,sp</span><br><span class="line">   c:   00000040    ssnop</span><br><span class="line">  10:   afc00008    sw  zero,8(s8)		//1. i = 0;</span><br><span class="line">  14:   10000006    b   30 &lt;func+0x30&gt;	//2. 跳转到0x30，判断i,如果小于88进行（4）循环</span><br><span class="line">  18:   00000000    nop</span><br><span class="line">  1c:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  20:   afc2000c    sw  v0,12(s8)</span><br><span class="line">  24:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  28:   24420001    addiu   v0,v0,1	//3. i++</span><br><span class="line">  2c:   afc20008    sw  v0,8(s8)</span><br><span class="line">  30:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  34:   28420058    slti    v0,v0,88</span><br><span class="line">  38:   1440fff8    bnez    v0,1c &lt;func+0x1c&gt;	//4. 如果i小于88,跳转到0x1c进行循环</span><br><span class="line">  3c:   00000000    nop</span><br><span class="line">  40:   00000040    ssnop</span><br><span class="line">  44:   00000000    nop</span><br><span class="line">  48:   03c0e825    move    sp,s8</span><br><span class="line">  4c:   8fbe0014    lw  s8,20(sp)</span><br><span class="line">  50:   27bd0018    addiu   sp,sp,24</span><br><span class="line">  54:   03e00008    jr  ra</span><br><span class="line">  58:   00000000    nop</span><br><span class="line">  5c:   00000000    nop</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>用户空间的GPIO操作</title>
    <url>/post/50599.html</url>
    <content><![CDATA[<p>用户空间的GPIO的操作</p>
<a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> sys/class/gpio/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">export      gpiochip0   gpiochip32  gpiochip64  gpiochip96  unexport</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 33 &gt; <span class="built_in">export</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">export      gpiochip0   gpiochip64  unexport</span><br><span class="line">gpio33      gpiochip32  gpiochip96</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> gpio33/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">active_low  edge        subsystem   value</span><br><span class="line">direction   power       uevent</span><br></pre></td></tr></table></figure>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><blockquote>
<p>support “in” and “out”</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "in" &gt; direction</span><br></pre></td></tr></table></figure>
<h2 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h2><blockquote>
<p>support “both” or “none”, “rising”, “falling” edge trigger”</p>
</blockquote>
<p>上升沿中断</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "rising" &gt; edge</span><br></pre></td></tr></table></figure>
<p>下降沿中断</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "falling" &gt; edge</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>gpio</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/16107.html</url>
    <content><![CDATA[<p>welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>! this is your very first post. check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. if you get any problems when using hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">github</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>vanxum</title>
    <url>/post/4813.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/post/42863.html</url>
    <content><![CDATA[<p>小米<br><a id="more"></a></p>
<h2 id="MMC"><a href="#MMC" class="headerlink" title="MMC"></a>MMC</h2><p>整体框架</p>
<p>emmc协议的初始化流程（sd，sdio），之间的不同区别差异</p>
<h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h2><p>协议，时序图（示波器的抓取）</p>
<p>驱动框架以及使用，device tree的使用</p>
<h2 id="alsa"><a href="#alsa" class="headerlink" title="alsa"></a>alsa</h2><p>整体结构图，工作流程</p>
<p>数据传输，环形buffer，实现，xrun，overrun和underrun</p>
<h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><p>OOM产生的原因：内存没了</p>
<p>OOM的处理流程，杀死进程，是内核态还是用户态？被杀死的进程依据是什么？</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li><p>伙伴系统<br>大块内存的申请，算法原理 Buddy system</p>
</li>
<li><p>slab<br>小块内存（小于1page）申请<br><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/" target="_blank" rel="noopener">Linux slab 分配器剖析</a></p>
</li>
<li><p>页表<br>linux内核支持几级页表，mips cpu使用几级页表，其中寻址的原理</p>
</li>
<li><p>cache</p>
</li>
</ul>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><ul>
<li>request_irq()</li>
<li>request_thread_irq()</li>
</ul>
<p>中断为什么要线程化？</p>
<p>提高实时性。</p>
<p>不能睡眠，为啥？如果睡眠会发生什么？</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ul>
<li><p>信号量<br>实现，与信号的区别</p>
</li>
<li><p>spinlock<br>实现，arm64，x86，mips的关键结构体，实现的原理<br>spinlock中不能睡眠，如果存在sleep会怎么样？中断上下文，进程上下文之前的切换区别？</p>
</li>
<li><p>mutex<br>实现，作用的范围？<br>与spinlock的区别？</p>
</li>
<li><p>读写锁</p>
</li>
</ul>
<p>用处，实现，应用场景？</p>
<h2 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h2><ul>
<li>抢占与spinlock之间的关系？</li>
<li>关闭抢占后，让出CPU的方法？ schedule</li>
</ul>
<h2 id="Android的启动"><a href="#Android的启动" class="headerlink" title="Android的启动"></a>Android的启动</h2><p>android启动进入桌面</p>
<h2 id="系统的整体启动"><a href="#系统的整体启动" class="headerlink" title="系统的整体启动"></a>系统的整体启动</h2><p>bootram-&gt;spl-&gt;uboot-&gt;kernel-&gt;fs</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>实现</p>
<ul>
<li>ext4文件系统的掉电保护</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>内核常见问题</title>
    <url>/post/57226.html</url>
    <content><![CDATA[<p>常见错误的总结；</p>
<a id="more"></a>
<h2 id="Unhandled-kernel-unaligned-access"><a href="#Unhandled-kernel-unaligned-access" class="headerlink" title="Unhandled kernel unaligned access"></a>Unhandled kernel unaligned access</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><ol>
<li>数据被冲掉(也就是其他数据的覆盖)</li>
<li>DDR出错(除非新调试的内存,不然机率很小)</li>
</ol>
<h3 id="alignment-fault的代码编写方式"><a href="#alignment-fault的代码编写方式" class="headerlink" title="alignment fault的代码编写方式"></a>alignment fault的代码编写方式</h3><h4 id="指针转换："><a href="#指针转换：" class="headerlink" title="指针转换："></a>指针转换：</h4><p>将低位宽类型的指针转换为高位宽类型的指针，如：将<code>char *</code> 转为<code>int *</code>，或将<code>void *</code>转为结构体指针。这类操作是导致alignment fault的最主要的来源，在分析定位问题时，需要特别关注。对于出现异常却又必须这样使用的场景，对这类转换后的指针进行访问时，如果不能确认其对应的地址是对齐的，则应该使用memcpy访问(memcpy方式不存在对齐问题)。另外，建议转换后立即使用，不要将其传递到其他函数和模块，防止扩展，带来潜在的问题。</p>
<h4 id="使用packed属性或者编译选项"><a href="#使用packed属性或者编译选项" class="headerlink" title="使用packed属性或者编译选项"></a>使用packed属性或者编译选项</h4><p>这样的操作会关闭编译器的自动填充功能，从而使结构体中各个字段紧凑排列，如果排列时未处理好对齐，则可能导致alignment fault。一些场景下(内核中也较常见)确实需要用户自行紧凑排列结构体，可节省空间(在内存资源稀缺的场景下，很有用)，此时需要特别关注对齐问题，建议通过填充的方法尽量对齐，如此可能会导致空间浪费，但是会提升访问性能，典型的“以空间换时间”的思路。如果对空间有强烈要求，而可以接受性能损失，也可以不考虑对齐，不做padding，但在访问这些结构体的数据时，需要全部使用memcpy的方式。</p>
<h2 id="BUG-soft-lockup-CPU-0-stuck-for-22s"><a href="#BUG-soft-lockup-CPU-0-stuck-for-22s" class="headerlink" title="BUG: soft lockup - CPU#0 stuck for 22s!"></a>BUG: soft lockup - CPU#0 stuck for 22s!</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h3><ol>
<li>死锁</li>
<li>死循环</li>
</ol>
<h2 id="not-syncing-softlockup-hung-tasks"><a href="#not-syncing-softlockup-hung-tasks" class="headerlink" title="not syncing: softlockup: hung tasks"></a>not syncing: softlockup: hung tasks</h2>]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ASLR</title>
    <url>/post/4177.html</url>
    <content><![CDATA[<blockquote>
<p><code>ASLR</code>（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p>
</blockquote>
<a id="more"></a>
<h2 id="控制接口"><a href="#控制接口" class="headerlink" title="控制接口"></a>控制接口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<p><code>randomize_va_space</code>的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">randomize_va_space</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">关闭</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>mmap base</code>、<code>stack</code>、<code>vdso page</code>将随机化。这意味着.so文件将被加载到随机地址。链接时指定了<code>-pie</code>选项的可执行程序，其代码段加载地址将被随机化。randomize_va_space缺省为1。此时heap没有随机化</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">在1的基础上增加了<code>heap</code>随机化。配置内核时如果禁用<code>CONFIG_COMPAT_BRK</code>，randomize_va_space缺省为2。</td>
</tr>
</tbody>
</table>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat  /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -n kernel.randomize_va_space</span><br></pre></td></tr></table></figure>
<h3 id="设置（关闭）"><a href="#设置（关闭）" class="headerlink" title="设置（关闭）"></a>设置（关闭）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://www.inforsec.org/wp/?p=1009" target="_blank" rel="noopener">地址空间布局随机化(ASLR)增强研究综述</a>
</em><a href="http://ww2.cs.fsu.edu/~ychen/paper/Remix_slides.pdf" target="_blank" rel="noopener">Remix: On-demand Live Randomization</a></p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>aslr</tag>
      </tags>
  </entry>
  <entry>
    <title>内存屏障</title>
    <url>/post/15089.html</url>
    <content><![CDATA[<blockquote>
<p>Memory barrier能够让<code>CPU</code>或<code>编译器</code>在内存访问上有序。一个Memory barrier之前的<strong>内存访问操作必定先于其之后的完成</strong>。</p>
</blockquote>
<p>程序在运行时内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问行为出现的理由是为了提升程序运行时的性能.</p>
<p>Linux kernel doc: <a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">memory-barriers</a></p>
<p>内存乱序访问主要发生在两个阶段：</p>
<ul>
<li>编译时，编译器优化导致内存乱序访问（指令重排）</li>
<li>运行时，多CPU间交互引起内存乱序访问</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wmb()       fast_wmb()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rmb()       fast_rmb()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mb()        fast_mb()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iob()       fast_iob()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> smp_mb()  __asm__ __volatile__(<span class="meta-string">"sync"</span> : : :<span class="meta-string">"memory"</span>)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> smp_rmb() __asm__ __volatile__(<span class="meta-string">"sync"</span> : : :<span class="meta-string">"memory"</span>)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> smp_wmb() __asm__ __volatile__(<span class="meta-string">"sync"</span> : : :<span class="meta-string">"memory"</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[MIPS] file: arch/mips/include/asm/barrier.h</p>
</blockquote>
<a id="more"></a>
<h2 id="smp-mb"><a href="#smp-mb" class="headerlink" title="smp_mb"></a>smp_mb</h2><p>作用对象：CPU与CPU</p>
<h2 id="mb"><a href="#mb" class="headerlink" title="mb"></a>mb</h2><p>作用对象：CPU与IO</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/world_hello_100/article/details/50131497" target="_blank" rel="noopener">理解 Memory barrier（内存屏障）</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>mem</tag>
        <tag>barrier</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu_cache_init与rixi</title>
    <url>/post/30991.html</url>
    <content><![CDATA[<p><code>cpu_cache_init</code>接口：</p>
<ul>
<li>初始化cache（r4k_cache_init）</li>
<li>设置cache的保护权限（setup_protection_map）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel_start</span><br><span class="line">	\-&gt;setup_arch</span><br><span class="line">		\-&gt;cpu_cache_init()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/mm/cache.c</p>
</blockquote>
<a id="more"></a>
<h2 id="r4k-cache-init"><a href="#r4k-cache-init" class="headerlink" title="r4k_cache_init"></a>r4k_cache_init</h2><h2 id="setup-protection-map"><a href="#setup-protection-map" class="headerlink" title="setup_protection_map"></a>setup_protection_map</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setup_protection_map</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cpu_has_rixi) &#123;</span><br><span class="line">        protection_map[<span class="number">0</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">1</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC);</span><br><span class="line">        protection_map[<span class="number">2</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">3</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC);</span><br><span class="line">        protection_map[<span class="number">4</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">5</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT);</span><br><span class="line">        protection_map[<span class="number">6</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">7</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT);</span><br><span class="line"></span><br><span class="line">        protection_map[<span class="number">8</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">9</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC);</span><br><span class="line">        protection_map[<span class="number">10</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_WRITE | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">11</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_WRITE);</span><br><span class="line">        protection_map[<span class="number">12</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">13</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT);</span><br><span class="line">        protection_map[<span class="number">14</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_WRITE  | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">15</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_WRITE);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        protection_map[<span class="number">0</span>] = PAGE_NONE;</span><br><span class="line">        protection_map[<span class="number">1</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">2</span>] = PAGE_COPY;</span><br><span class="line">        protection_map[<span class="number">3</span>] = PAGE_COPY;</span><br><span class="line">        protection_map[<span class="number">4</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">5</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">6</span>] = PAGE_COPY;</span><br><span class="line">        protection_map[<span class="number">7</span>] = PAGE_COPY;</span><br><span class="line">        protection_map[<span class="number">8</span>] = PAGE_NONE;</span><br><span class="line">        protection_map[<span class="number">9</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">10</span>] = PAGE_SHARED;</span><br><span class="line">        protection_map[<span class="number">11</span>] = PAGE_SHARED;</span><br><span class="line">        protection_map[<span class="number">12</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">13</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">14</span>] = PAGE_SHARED;</span><br><span class="line">        protection_map[<span class="number">15</span>] = PAGE_SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setup_protection_map</code>函数主要是对<code>protection_map</code>结构体数组的初始化<br>cpu_has_rixi: 需要CPU中rixi的硬件支持</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* description of effects of mapping type and prot in current implementation.</span></span><br><span class="line"><span class="comment"> * this is due to the limited x86 page protection hardware.  The expected</span></span><br><span class="line"><span class="comment"> * behavior is in parens:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * map_type prot</span></span><br><span class="line"><span class="comment"> *      PROT_NONE   PROT_READ   PROT_WRITE  PROT_EXEC</span></span><br><span class="line"><span class="comment"> * MAP_SHARED   r: (no) no  r: (yes) yes    r: (no) yes r: (no) yes</span></span><br><span class="line"><span class="comment"> *      w: (no) no  w: (no) no  w: (yes) yes    w: (no) no</span></span><br><span class="line"><span class="comment"> *      x: (no) no  x: (no) yes x: (no) yes x: (yes) yes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MAP_PRIVATE  r: (no) no  r: (yes) yes    r: (no) yes r: (no) yes</span></span><br><span class="line"><span class="comment"> *      w: (no) no  w: (no) no  w: (copy) copy  w: (no) no</span></span><br><span class="line"><span class="comment"> *      x: (no) no  x: (no) yes x: (no) yes x: (yes) yes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">pgprot_t</span> protection_map[<span class="number">16</span>] = &#123;</span><br><span class="line">    __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,</span><br><span class="line">    __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: mm/mmap.c</p>
</blockquote>
<p><code>protection_map</code>定义16种内存访问权限，其中映射类型<code>MAP_PRIVATE</code>和<code>MAP_SHARED</code></p>
<blockquote>
<p><code>__P000</code> 的意思是 P ( private)，0 ( No Exec)，0 ( No Write)，0 ( No Read)；</p>
</blockquote>
<blockquote>
<p><code>__P001</code> 的意思是 P ( private)，0 ( No Exec)，0 ( No Write)，0 ( Read)；</p>
</blockquote>
<blockquote>
<p><code>__S111</code> 的意思是 S ( Shared)，1 (Exec)，1 ( Write)，1 ( Read)；</p>
</blockquote>
<h2 id="rixi"><a href="#rixi" class="headerlink" title="rixi"></a>rixi</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_has_rixi                    1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>arch/mips/xburst2/soc-x2000/include/cpu-feature-overrides.h</p>
</blockquote>
<p>使能该功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br></pre></td></tr></table></figure>
<p>相应宏定义：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_JZRISC_PEP) &amp;&amp; defined(CONFIG_CPU_MIPS32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_PRESENT_SHIFT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_PRESENT       (1 &lt;&lt; _PAGE_PRESENT_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_READ_SHIFT    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_READ      (1 &lt;&lt; _PAGE_READ_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_WRITE_SHIFT   2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_WRITE     (1 &lt;&lt; _PAGE_WRITE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_ACCESSED_SHIFT    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_ACCESSED      (1 &lt;&lt; _PAGE_ACCESSED_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_MODIFIED_SHIFT    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_MODIFIED      (1 &lt;&lt; _PAGE_MODIFIED_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_FILE      (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_NO_EXEC       (1 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_GLOBAL        (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_VALID_SHIFT   7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_VALID     (1 &lt;&lt; _PAGE_VALID_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_SILENT_READ   (1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_DIRTY_SHIFT   8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_DIRTY     (1 &lt;&lt; _PAGE_DIRTY_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PAGE_SILENT_WRITE  (1 &lt;&lt; 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CACHE_SHIFT        (9)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CACHE_MASK     (7 &lt;&lt; _CACHE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PFN_SHIFT      (PAGE_SHIFT - 12 + _CACHE_SHIFT + 3)</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>file: arch/mips/include/asm/pgtable-bits.h</p>
</blockquote>
<h3 id="page-cachable-default"><a href="#page-cachable-default" class="headerlink" title="_page_cachable_default"></a>_page_cachable_default</h3><blockquote>
<p>定义MMU的类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __cpuinit <span class="title">coherency_setup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mips_cca &lt; <span class="number">0</span> || mips_cca &gt; <span class="number">7</span>)</span><br><span class="line">        mips_cca = read_c0_config() &amp; CONF_CM_CMASK;</span><br><span class="line">    _page_cachable_default = mips_cca &lt;&lt; _CACHE_SHIFT;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/mm/c-r4k.c</p>
</blockquote>
<p>c0_config: Config寄存器主要描述CPU资源信息和配置，<code>CONF_CM_CMASK</code>(#define CONF_CM_CMASK 7)Config[7:9]为MT，表示MMU的类型</p>
<blockquote>
<p>Config[7:9]: MT MMU类型</p>
</blockquote>
<blockquote>
<p>0: None； 1: MIPS32/64标准的TLB； 2：BAT类型； 3： MIPS32标准的FMT固定映射</p>
</blockquote>
<h3 id="cpu-has-rixi-1-和-cpu-has-rixi-0-区别"><a href="#cpu-has-rixi-1-和-cpu-has-rixi-0-区别" class="headerlink" title="cpu_has_rixi = 1 和 cpu_has_rixi = 0 区别"></a>cpu_has_rixi = 1 和 cpu_has_rixi = 0 区别</h3><ul>
<li><p>cpu_has_rixi = 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">protection_map[<span class="number">0</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br></pre></td></tr></table></figure>
</li>
<li><p>cpu_has_rixi = 0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CACHE_CACHABLE_NONCOHERENT (3&lt;&lt;_CACHE_SHIFT)  <span class="comment">/* R4[0246]00      */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_NONE   __pgprot(_PAGE_PRESENT | _CACHE_CACHABLE_NONCOHERENT)</span></span><br><span class="line"></span><br><span class="line">protection_map[<span class="number">0</span>] = PAGE_NONE;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过对<code>protection_map[0]</code>定义的对比，在使能rixi后，其属性增加了 <code>_PAGE_NO_EXEC</code>和<code>_PAGE_NO_READ</code><br>也就是rixi在内存的访问权限上增加了<code>_PAGE_WRITE</code>, <code>_PAGE_READ</code>,<code>_PAGE_NO_READ</code>, <code>_PAGE_NO_EXEC</code>的属性控制</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.360doc.com/content/15/0310/16/18252487_454073748.shtml" target="_blank" rel="noopener">内核初始化</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/post/28384.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[15299.717341] BUG: spinlock lockup suspected on CPU#1, rixitest/4186</span><br><span class="line">[15299.723758]  lock: 0x8c77d644, .magic: dead4ead, .owner: rixitest/4161, .owner_cpu: 0</span><br><span class="line">[15299.731858] CPU: 1 PID: 4186 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c #3</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>以<code>spin_lock</code>进行死锁机制的检测流程说明：</p>
<h3 id="raw-lock"><a href="#raw-lock" class="headerlink" title="raw_lock"></a>raw_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line">    <span class="keyword">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> magic, owner_cpu;</span><br><span class="line">	<span class="keyword">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<p>死锁的检测内核需要配置<code>CONFIG_DEBUG_SPINLOCK</code>,它主要使用的数据有<code>magic</code>, <code>owner_cpu</code>,<code>*owner</code>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">type</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">magic</td>
<td style="text-align:center">幻数,表示锁以及初始化</td>
</tr>
<tr>
<td style="text-align:center">owner_cpu</td>
<td style="text-align:center">raw_smp_processor_id(),<code>锁</code>所在的当前CPU号</td>
</tr>
<tr>
<td style="text-align:center">*ower</td>
<td style="text-align:center">current,<code>锁</code>所在的当前进程</td>
</tr>
</tbody>
</table>
<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPINLOCK_MAGIC		0xdead4ead</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPINLOCK_OWNER_INIT	((void *)-1L)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SPIN_DEBUG_INIT(lockname)		\</span></span><br><span class="line">	.magic = SPINLOCK_MAGIC,		\</span><br><span class="line">	.owner_cpu = <span class="number">-1</span>,			\</span><br><span class="line">	.owner = SPINLOCK_OWNER_INIT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"># define SPIN_DEBUG_INIT(lockname)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>初始化时<code>owner_cpu=-1</code>表示该锁不属于任何CPU，并且不属于任何进程(<code>owner=(void *)-1L</code>)</p>
<h3 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h3><blockquote>
<p>在什么时候指明该锁属于哪一个CPU，哪一个进程。</p>
</blockquote>
<ol>
<li>上锁时指定：<code>spin_lock</code></li>
<li>解锁时恢复：<code>spin_unlock</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spin_lock</span><br><span class="line">	|</span><br><span class="line">_raw_spin_lock</span><br><span class="line">	|</span><br><span class="line">__raw_spin_lock --&gt; &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</span><br><span class="line">		LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/spinlock.h</p>
</blockquote>
<h4 id="do-raw-spin-trylock"><a href="#do-raw-spin-trylock" class="headerlink" title="do_raw_spin_trylock"></a>do_raw_spin_trylock</h4><p>定义：CONFIG_LOCK_STAT</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">debug_spin_lock_before(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	SPIN_BUG_ON(lock-&gt;magic != SPINLOCK_MAGIC, lock, <span class="string">"bad magic"</span>);</span><br><span class="line">	<span class="comment">//进程重入</span></span><br><span class="line">	SPIN_BUG_ON(lock-&gt;owner == current, lock, <span class="string">"recursion"</span>);</span><br><span class="line">	<span class="comment">//CPU重入</span></span><br><span class="line">	SPIN_BUG_ON(lock-&gt;owner_cpu == raw_smp_processor_id(),</span><br><span class="line">							lock, <span class="string">"cpu recursion"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">debug_spin_lock_after</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lock-&gt;owner_cpu = raw_smp_processor_id();</span><br><span class="line">	lock-&gt;owner = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义：CONFIG_LOCK_STAT</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_CONTENDED(_lock, try, lock)			\</span></span><br><span class="line"><span class="keyword">do</span> &#123;								\</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">try</span>(_lock)) &#123;					\</span><br><span class="line">		lock_contended(&amp;(_lock)-&gt;dep_map, _RET_IP_);	\</span><br><span class="line">		lock(_lock);					\</span><br><span class="line">	&#125;							\</span><br><span class="line">	lock_acquired(&amp;(_lock)-&gt;dep_map, _RET_IP_);			\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_raw_spin_trylock</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = arch_spin_trylock(&amp;lock-&gt;raw_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		debug_spin_lock_after(lock);  <span class="comment">//上锁成功后进行重新赋值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must not happen on UP:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SPIN_BUG_ON(!ret, lock, <span class="string">"trylock failure on UP"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: lib/spinlock_debug.c</p>
</blockquote>
<h4 id="do-raw-spin-lock"><a href="#do-raw-spin-lock" class="headerlink" title="do_raw_spin_lock"></a>do_raw_spin_lock</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_CONTENDED(_lock, try, lock) \</span></span><br><span class="line">	lock(_lock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_raw_spin_lock</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	debug_spin_lock_before(lock);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!arch_spin_trylock(&amp;lock-&gt;raw_lock)))</span><br><span class="line">		__spin_lock_debug(lock);</span><br><span class="line">	debug_spin_lock_after(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: lib/spinlock_debug.c</p>
</blockquote>
<p><code>arch_spin_trylock</code>主要实现不同架构的实际<code>加锁</code>的功能函数。如果上锁失败将进入<code>_spin_lock_debug</code>函数，打印上锁失败的原因。在<code>do_raw_spin_lock</code>函数中除路上锁的关键函数，其他函数均为debug函数，这里主要说明debug函数的原理和死锁出现后的debug info的具体含义。</p>
<h2 id="Debug-Info"><a href="#Debug-Info" class="headerlink" title="Debug Info"></a>Debug Info</h2><p>如果上锁失败，将不断尝试上锁直到超时，内核认为出现死锁，主要的引起原因有：<code>该锁没有被释放</code>（排除CPU硬件错误）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __spin_lock_debug(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	u64 i;</span><br><span class="line">	u64 loops = loops_per_jiffy * HZ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arch_spin_trylock(&amp;lock-&gt;raw_lock))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		__delay(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* lockup suspected: */</span></span><br><span class="line">	spin_dump(lock, <span class="string">"lockup suspected"</span>);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> loops_per_jiffy = (<span class="number">1</span>&lt;&lt;<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: /init/main.c</p>
</blockquote>
<p><code>loops_per_jiffy</code>:定义超时时间, (4096)_delay(1)为4096s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[15299.717341] BUG: spinlock lockup suspected on CPU#1, rixitest/4186</span><br><span class="line">[15299.723758]  lock: 0x8c77d644, .magic: dead4ead, .owner: rixitest/4161, .owner_cpu: 0</span><br><span class="line">[15299.731858] CPU: 1 PID: 4186 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c #3</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spin_dump</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	printk(KERN_EMERG <span class="string">"BUG: spinlock %s on CPU#%d, %s/%d\n"</span>,</span><br><span class="line">		msg, raw_smp_processor_id(),</span><br><span class="line">		current-&gt;comm, task_pid_nr(current));</span><br><span class="line">	printk(KERN_EMERG <span class="string">" lock: %pS, .magic: %08x, .owner: %s/%d, "</span></span><br><span class="line">			<span class="string">".owner_cpu: %d\n"</span>,</span><br><span class="line">		lock, lock-&gt;magic,</span><br><span class="line">		owner ? owner-&gt;comm : <span class="string">"&lt;none&gt;"</span>,</span><br><span class="line">		owner ? task_pid_nr(owner) : <span class="number">-1</span>,</span><br><span class="line">		lock-&gt;owner_cpu);</span><br><span class="line">	dump_stack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>lockup suspected on CPU#1</code>: 说明当前检测到死锁的CPU为核1<br><code>.owner_cpu: 0</code>:说明之前上锁的CPU为核0</p>
</blockquote>
<blockquote>
<p>以上log说明有一把锁，在核0上锁后，没有释放之前核1有一次去上锁，从而导致死锁</p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="信号异常造成的死锁"><a href="#信号异常造成的死锁" class="headerlink" title="信号异常造成的死锁"></a>信号异常造成的死锁</h3><blockquote>
<p>两核互锁</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[   50.920653] BUG: spinlock lockup suspected on CPU#0, rixitest/835</span><br><span class="line">[   50.933282]  lock: 0x8c57c9e4, .magic: dead4ead, .owner: rixitest/507, .owner_cpu: 1</span><br><span class="line">[   50.941294] CPU: 0 PID: 835 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c-dirty</span><br><span class="line"></span><br><span class="line">[   50.949568] Stack : 8211374a 0000004b 80510000 80510000 00000343 80050000 8c888d40</span><br><span class="line"></span><br><span class="line">	8049e028 00000000 00000343 82112ee0 8004eee8 8cff7ee8 82120000 803e79ac</span><br><span class="line">	80510000 8003b454 8c57c9e4 00000000 8049fb4c 8cff7d74 8cff7d74 8c888d40</span><br><span class="line">	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">	00000000 00000000 00000000 00000000 00000000 00000000 00000000 8cff7d08</span><br><span class="line">	...</span><br><span class="line">[   50.986508] Call Trace:</span><br><span class="line">[   50.989051] [&lt;80021cf4&gt;] show_stack+0x48/0x70</span><br><span class="line">[   50.993564] [&lt;8021c804&gt;] do_raw_spin_lock+0x12c/0x184 //spin_lock_irq(&amp;sighand-&gt;siglock)</span><br><span class="line">[   50.998793] [&lt;8004ecc0&gt;] get_signal_to_deliver+0xb8/0x690</span><br><span class="line">[   51.004378] [&lt;8001fb08&gt;] do_signal+0x30/0x1fc</span><br><span class="line">[   51.008887] [&lt;80020c84&gt;] do_notify_resume+0x34/0x90</span><br><span class="line">[   51.013940] [&lt;8001b8a4&gt;] work_notifysig+0x10/0x18</span><br><span class="line">[   51.018802]</span><br><span class="line">[   64.332523] SMP[0] action:1 will reenter, mailbox:1, timeout:16777216</span><br><span class="line">[   64.339172] CPU: 1 PID: 507 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c-dirty</span><br><span class="line"></span><br><span class="line">[   64.347425] Stack : 8211374a 0000004b 80510000 80510000 000001fb 01000000 8c54b9c0</span><br><span class="line"></span><br><span class="line">	8049e028 00000001 000001fb 82112ee0 00000000 8c551ee8 82120000 803e79ac</span><br><span class="line">	00000000 8003b454 00000006 00000000 8049fb4c 8c551c14 8c551c14 8c54b9c0</span><br><span class="line">	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">	00000000 00000000 00000000 00000000 00000000 00000000 00000000 8c551ba8</span><br><span class="line">	...</span><br><span class="line">[   64.384270] Call Trace:</span><br><span class="line">[   64.386796] [&lt;80021cf4&gt;] show_stack+0x48/0x70</span><br><span class="line">[   64.391295] [&lt;80011eb4&gt;] xburst2_send_ipi_single+0xb4/0x114</span><br><span class="line">[   64.397051] [&lt;8006d800&gt;] try_to_wake_up+0x298/0x31c</span><br><span class="line">[   64.402093] [&lt;8004c7fc&gt;] signal_wake_up_state+0x44/0x68</span><br><span class="line">[   64.407489] [&lt;80138e44&gt;] zap_process+0x80/0xbc    //spin_lock_irq(&amp;tsk-&gt;sighand-&gt;siglock);</span><br><span class="line">[   64.412077] [&lt;8013926c&gt;] do_coredump+0x160/0xc24</span><br><span class="line">[   64.416843] [&lt;8004f24c&gt;] get_signal_to_deliver+0x644/0x690</span><br><span class="line">[   64.422504] [&lt;8001fb08&gt;] do_signal+0x30/0x1fc</span><br><span class="line">[   64.427002] [&lt;80020c84&gt;] do_notify_resume+0x34/0x90</span><br><span class="line">[   64.432040] [&lt;8001b8a4&gt;] work_notifysig+0x10/0x18</span><br><span class="line">[   64.436889]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>死锁的产生和发送IPI的先后顺序：先死锁后发送IPI</p>
</blockquote>
<ol>
<li>最开始的两个打印可以得到，CPU0进行上锁时，发现该锁被CPU1所持有，所以造成两核互锁</li>
<li>CPU1上完<code>spin_lock_irq(siglock)</code>锁后，发送IPI（sched调度），此时信号处理进程被调度到CPU0，并且也进行<code>spin_lock_irq(siglock)</code>上锁，由于CPU1上完锁后等待IPI的完成，但是此时CPU1已经<strong><em>关闭中断的IE位，其中包括IPI中断，因此IPI无法完成</em></strong>，CPU1的锁无法释放，同时CPU0又在上同一把锁<code>siglock</code>,从而造成死锁</li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
        <category>同步</category>
      </categories>
      <tags>
        <tag>spinlock</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核DMA机制</title>
    <url>/post/59370.html</url>
    <content><![CDATA[<blockquote>
<ul>
<li>DMA的映射机制</li>
<li>DMA的数据处理</li>
<li>DMA物理通道和逻辑通道</li>
<li>DMA地址空间的排布</li>
<li>一致性和流式DMA的定义和区别</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://my.oschina.net/u/174242/blog/70359" target="_blank" rel="noopener">Linux 内核DMA机制</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/DMA-API-HOWTO.txt" target="_blank" rel="noopener">内核文档</a></li>
<li><a href="https://www.linuxjournal.com/article/7104" target="_blank" rel="noopener">Kernel Korner - Using DMA</a></li>
<li><a href="https://static.lwn.net/images/pdf/LDD3/ch15.pdf" target="_blank" rel="noopener">LDD3-ch15</a></li>
<li><a href="http://linuxperf.com/?p=67" target="_blank" rel="noopener">DMAR 与 IOMMU</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>dma</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核调试方法---Debug</title>
    <url>/post/53462.html</url>
    <content><![CDATA[<p>常用的Linux调试方法：</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">工具</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">debugfs文件系统</td>
<td style="text-align:center">提供了 procfs, sysfs, debugfs以及 relayfs 来与用户空间进行数据交互, 尤其是 debugfs, 这是内核开发者们实现的专门用来调试的文件系统接口. 其他的工具或者接口, 多数都依赖于 debugfs</td>
</tr>
<tr>
<td style="text-align:center">printk</td>
<td style="text-align:center">强大的输出系统, 没有什么逻辑上的bug是用PRINT解决不了的</td>
</tr>
<tr>
<td style="text-align:center">ftrace以及其前端工具trace-cmd等</td>
<td style="text-align:center">内核提供了 ftrace 工具来实现检查点, 事件等的检测, 这一框架依赖于 debugfs, 他在 debugfs 中的 tracing 子系统中为用户提供了丰富的操作接口, 我们可以通过该系统对内核实现检测和分析. 功能虽然强大, 但是其操作并不是很简单, 因此使用者们为实现了 trace-cmd 等前端工具, 简化了 ftrace 的使用.</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -D a.out &gt; a.dump</span><br></pre></td></tr></table></figure>
<h3 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h3><ul>
<li>-d:将代码段反汇编</li>
<li>-D:表示对全部文件进行反汇编</li>
<li>-S:将代码段反汇编的同时，将<code>反汇编代码和源代码交替显示</code>，编译时需要给出-g，即需要调试信息。</li>
<li>-C:将C++符号名逆向解析。</li>
<li>-l:反汇编代码中插入源代码的文件名和行号。</li>
<li>-j section:仅反汇编指定的section。可以有多个-j参数来选择多个section。</li>
</ul>
<blockquote>
<p>$mips-linux-gnu-objdump -d vmlinux &gt; a.s</p>
</blockquote>
<h2 id="addr2line"><a href="#addr2line" class="headerlink" title="addr2line"></a>addr2line</h2><p>一个可以将指令的地址和可执行映像转换成文件名、函数名和源代码行数的工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$mips-linux-gnu-addr2line -e out/target/product/xxxxx/symbols/system/lib/libdvm.so 23452</span><br><span class="line">/work/android-4.3-fpga/dalvik/vm/mterp/out/InterpAsm-mips.S:1335</span><br></pre></td></tr></table></figure>
<blockquote>
<p>23452 –&gt; 异常PC</p>
</blockquote>
<blockquote>
<p>mips-linux-gnu-addr2line -e vmlinux 0x802354c0</p>
</blockquote>
<h2 id="汇编定位"><a href="#汇编定位" class="headerlink" title="汇编定位"></a>汇编定位</h2><blockquote>
<p>在函数中添加空指令，确认该代码段反汇编后的具体位置.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asm __volatile__(&quot;ssnop\n\t&quot;);</span><br><span class="line">asm __volatile__(&quot;ssnop\n\t&quot;);</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt;= MAXJSAMPLE; i++)</span><br><span class="line">	table[i] = (JSAMPLE) i;</span><br><span class="line"></span><br><span class="line">asm __volatile__(&quot;ssnop\n\t&quot;);</span><br><span class="line">asm __volatile__(&quot;ssnop\n\t&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="ftrace"><a href="#ftrace" class="headerlink" title="ftrace"></a>ftrace</h2><p>ftrace 是内建于 Linux 内核的跟踪工具，从 2.6.27 开始加入主流内核。使用 ftrace 可以调试或者分析内核中发生的事情。ftrace 提供了不同的跟踪器，以用于不同的场合，比如跟踪内核函数调用、对上下文切换进行跟踪、查看中断被关闭的时长、跟踪内核态中的延迟以及性能问题等</p>
<blockquote>
<p><a href="https://elixir.bootlin.com/linux/v4.16-rc5/source/Documentation/trace" target="_blank" rel="noopener">Documentation/trace/ftrace.txt</a></p>
</blockquote>
<h3 id="kernel配置"><a href="#kernel配置" class="headerlink" title="kernel配置"></a>kernel配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol: FTRACE [=y]</span><br><span class="line">Type  : boolean</span><br><span class="line">Prompt: Tracers</span><br><span class="line">  Location:</span><br><span class="line">      -&gt; Kernel hacking</span><br><span class="line">	    Defined at kernel/trace/Kconfig:135</span><br><span class="line">		  Depends on: TRACING_SUPPORT [=y]</span><br><span class="line"></span><br><span class="line">--- Tracers</span><br><span class="line">-*-   Kernel Function Tracer</span><br><span class="line">[*]     Kernel Function Graph Tracer</span><br><span class="line">[*]   Interrupts-off Latency Tracer</span><br><span class="line">[*]   Preemption-off Latency Tracer</span><br><span class="line">[*]   Scheduling Latency Tracer</span><br><span class="line">-*-   Create a snapshot trace buffer</span><br><span class="line">-*-     Allow snapshot to swap per CPU</span><br><span class="line">Branch Profiling (No branch profiling)  ---&gt;</span><br><span class="line">[*]   Trace max stack</span><br><span class="line">[*]   Support for tracing block IO actions</span><br><span class="line">[*]   enable/disable function tracing dynamically</span><br><span class="line">[ ]   Kernel function profiler</span><br><span class="line">[ ]   Perform a startup test on ftrace</span><br><span class="line">&lt; &gt;   Ring buffer benchmark stress tester</span><br><span class="line">[ ]   Ring buffer startup self test</span><br></pre></td></tr></table></figure>
<h3 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mount -t debugfs none /mnt/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd /mnt/tracing/</span><br><span class="line"># ls</span><br><span class="line">README                      set_event</span><br><span class="line">available_events            set_ftrace_filter</span><br><span class="line">available_filter_functions  set_ftrace_notrace</span><br><span class="line">available_tracers           set_ftrace_pid</span><br><span class="line">buffer_size_kb              set_graph_function</span><br><span class="line">buffer_total_size_kb        snapshot</span><br><span class="line">current_tracer              stack_max_size</span><br><span class="line">dyn_ftrace_total_info       stack_trace</span><br><span class="line">enabled_functions           stack_trace_filter</span><br><span class="line">events                      trace</span><br><span class="line">free_buffer                 trace_clock</span><br><span class="line">instances                   trace_marker</span><br><span class="line">max_graph_depth             trace_options</span><br><span class="line">options                     trace_pipe</span><br><span class="line">per_cpu                     tracing_cpumask</span><br><span class="line">printk_formats              tracing_max_latency</span><br><span class="line">saved_cmdlines              tracing_on</span><br><span class="line">saved_tgids                 tracing_thresh</span><br></pre></td></tr></table></figure>
<h3 id="available-tracers"><a href="#available-tracers" class="headerlink" title="available_tracers"></a>available_tracers</h3><p>记录了当前编译进内核的跟踪器的列表</p>
<blockquote>
<p>available_tracers     - list of configured tracers for current_tracer</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat available_tracers</span></span><br><span class="line">blk function_graph wakeup_rt wakeup preemptirqsoff preemptoff irqsoff function nop</span><br></pre></td></tr></table></figure>
<h3 id="current-tracer"><a href="#current-tracer" class="headerlink" title="current_tracer"></a>current_tracer</h3><p>用于设置或显示当前使用的跟踪器；<br>使用<code>echo</code>将跟踪器名字写入该文件可以切换到不同的跟踪器。系统启动后，其缺省值为<code>nop</code> ，即不做任何跟踪操作。在执行完一段跟踪任务后，可以通过向该文件写入<code>nop</code>来重置跟踪器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> wakeup &gt; current_tracer</span></span><br></pre></td></tr></table></figure>
<h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>文件提供了查看获取到的跟踪信息的接口。</p>
<p>通过 cat 等命令查看该文件以查看跟踪到的内核活动记录，也可以将其内容保存为记录文件以备后续查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat trace</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> tracer: wakeup</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wakeup latency trace v1.1.5 on 3.10.14-00042-ge40985e</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> latency: 624 us, <span class="comment">#174/174, CPU#0 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:2)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    -----------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    | task: ksdioirqd/mmc1-155 (uid:0 nice:0 policy:1 rt_prio:1)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    -----------------</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                  _------=&gt; CPU<span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                 / _-----=&gt; irqs-off</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                | / _----=&gt; need-resched</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                || / _---=&gt; hardirq/softirq</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                ||| / _--=&gt; preempt-depth</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                |||| /     delay</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  cmd     pid   ||||| time  |   <span class="built_in">caller</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \   /      |||||  \    |   /</span></span><br><span class="line">&lt;idle&gt;-0       0dNh4    4us+:      0:120:R   + [000]   155: 98:R ksdioirqd/mmc1</span><br><span class="line">&lt;idle&gt;-0       0dNh4   12us+: 0</span><br><span class="line">&lt;idle&gt;-0       0dNh4   17us+: task_woken_rt &lt;-ttwu_do_wakeup</span><br><span class="line">&lt;idle&gt;-0       0dNh4   21us+: _raw_spin_unlock &lt;-try_to_wake_up</span><br><span class="line">&lt;idle&gt;-0       0dNh4   24us+: sub_preempt_count &lt;-_raw_spin_unlock</span><br><span class="line">&lt;idle&gt;-0       0dNh3   28us+: _raw_spin_unlock_irqrestore &lt;-try_to_wake_up</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>内核中断</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 0 &gt; tracing_on</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> &gt; trace</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> nop &gt; current_tracer</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> irq &gt; set_event</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 1 &gt; tracing_on</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat trace_pipe</span></span><br><span class="line">		sh-100   [000] d.h3  1333.894909: irq_handler_entry: irq=58 name=uart1</span><br><span class="line">		sh-100   [000] d.h3  1333.894931: irq_handler_exit: irq=58 ret=handled</span><br><span class="line">	&lt;idle&gt;-0     [000] d.h2  1333.902444: irq_handler_entry: irq=34 name=jz-timerirq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat trace</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tracer: nop</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> entries-in-buffer/entries-written: 5510/5510   <span class="comment">#P:1</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                              _-----=&gt; irqs-off</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                             / _----=&gt; need-resched</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                            | / _---=&gt; hardirq/softirq</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                            || / _--=&gt; preempt-depth</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                            ||| /     delay</span></span><br><span class="line"><span class="meta">#</span><span class="bash">           TASK-PID   CPU<span class="comment">#  ||||    TIMESTAMP  FUNCTION</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">              | |       |   ||||       |         |</span></span><br><span class="line">              sh-100   [000] d.h3  1342.498892: irq_handler_exit: irq=58 ret=handled</span><br><span class="line">		&lt;idle&gt;-0     [000] d.h2  1342.673707: irq_handler_entry: irq=34 name=jz-timerirq</span><br><span class="line">		&lt;idle&gt;-0     [000] d.h2  1342.673717: irq_handler_exit: irq=34 ret=handled</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/gatieme/article/details/68948080" target="_blank" rel="noopener">Linux内核调试的方式以及工具集锦</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>高端内存</title>
    <url>/post/19487.html</url>
    <content><![CDATA[<p>Linux高端内存是针对物理内存来说的，虚拟内存没有高端这个概念。Linux系统将虚拟内存分为两个部分，即<code>用户地址空间</code>和<code>内核地址空间</code>，对于32位系统来说，虚拟地址空间为4GB，其中用户空间范围为0-3GB，内核空间范围为3-4GB。Linux将3GB开始的内核虚拟地址空间的<code>896M</code>地址直接映射到物理地址空间的0-896M，这部分是永久性映射，剩下的<code>128M</code>则可根据需要进行动态映射，也称临时性映射。如果没有动态映射，那么1GB的内核虚拟地址空间最多只能访问1GB的物理内存，那么如果物理内存大于1GB，就会有一部分物理内存无法被内核访问到，显然不是我们想要的。因此，对于32位系统来说，高端物理内存是内核虚拟地址空间后128M可动态映射使内核得以访问的物理内存，用户空间虚拟地址也是映射到这部分物理内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          ________________ _____    ________________</span><br><span class="line">         |Other KernelData|___  |  |                |</span><br><span class="line">         |----------------|   | |__|                |</span><br><span class="line">         |     Kernel     |\  |____|   Real Other   |</span><br><span class="line">3 GB ---&gt;|----------------| \      |   Kernel Data  |</span><br><span class="line">         |                |\ \     |                |</span><br><span class="line">         |              __|_\_\____|__   Real       |</span><br><span class="line">         |      Tasks     |  \ \   |     Tasks      |</span><br><span class="line">         |              __|___\_\__|__   Space      |</span><br><span class="line">         |                |    \ \ |                |</span><br><span class="line">         |                |     \ \|----------------|</span><br><span class="line">         |                |      \ |Real KernelSpace|</span><br><span class="line">         |________________|       \|________________|</span><br><span class="line"></span><br><span class="line">         Logical Addresses          Physical Addresses</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="启动参数”mem-”"><a href="#启动参数”mem-”" class="headerlink" title="启动参数”mem=”"></a>启动参数”mem=”</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mem=255M@0x0 mem=256M@0x30000000</span><br></pre></td></tr></table></figure>
<p>内核解析：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">early_param(&quot;mem&quot;, early_parse_mem);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>file:arch/mips/kernel/setup.c</p>
</blockquote>
<p>mem参数由early_parse_mem函数处理。每一个<code>mem=size@addr</code>格式的参数，表示从<code>addr地址（物理地址）</code>开始的size大小的内存区域。如果没有”@addr”则默认起始地址为<code>0</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://ilinuxkernel.com/?p=1013" target="_blank" rel="noopener">Linux内核高端内存</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核--中断</title>
    <url>/post/21246.html</url>
    <content><![CDATA[<p>中断有两种：</p>
<ol>
<li>由CPU外部产生。（被动）</li>
<li>由CPU本身在执行程序的时候产生。（主动）</li>
</ol>
<p>中断服务程序一般都是在中断请求关闭的条件下执行的，以避免嵌套而使中断控制复杂化。但是，中断是一个随机事件，它随时会到来，如果关中断的时间太长，CPU就不能及时响应其他的中断请求，从而造成中断的丢失。因此为了保证所有的中断都被响应，并且相对公平的执行，引入了中断下半部，主要有<code>tasklet</code>，<code>工作队列</code>，<code>软中断</code>和<code>线程化irq</code></p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">条件</th>
<th style="text-align:center">tasklet</th>
<th style="text-align:center">workqueue</th>
<th style="text-align:center">softirq</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">运行上下文</td>
<td style="text-align:center">软中断</td>
<td style="text-align:center">进程（内核态）</td>
<td style="text-align:center">软中断</td>
</tr>
<tr>
<td style="text-align:center">是否sleep</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">是否关中断</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">是否可重新调度</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">是否可带参数</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">谁被触发，谁执行</td>
<td style="text-align:center">是</td>
<td style="text-align:center">默认是（进程调度）</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">可同时多CPU执行</td>
<td style="text-align:center">同一个Tasklet在任意时刻, 只能被一个CPU执行</td>
<td style="text-align:center">有进程调度决定</td>
<td style="text-align:center">同一个softirq_action, 可同时被多个CPU执行</td>
</tr>
<tr>
<td style="text-align:center">是否可延时执行</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">数据结构</td>
<td style="text-align:center">softirq_action(中断服务), irq_cpustat_t(触发状态)</td>
<td style="text-align:center">tasklet_struct, tasklet_head</td>
<td style="text-align:center">work_struct, workqueue_struct</td>
</tr>
<tr>
<td style="text-align:center">初始化</td>
<td style="text-align:center">open_softirq</td>
<td style="text-align:center">tasklet_init, DECLARE_TASKLET</td>
<td style="text-align:center">INIT_DELAYED_WORK</td>
</tr>
<tr>
<td style="text-align:center">改变运行状态</td>
<td style="text-align:center"></td>
<td style="text-align:center">tasklet_trylock, tasklet_unlock</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">使能/停止</td>
<td style="text-align:center"></td>
<td style="text-align:center">tasklet_enable, tasklet_disable</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">触发</td>
<td style="text-align:center">raise_softirq, raise_softirq_irqoff</td>
<td style="text-align:center">tasklet_schedule, tasklet_hi_schedule</td>
<td style="text-align:center">schedule_work, queue_work, schedule_delayed_work</td>
</tr>
<tr>
<td style="text-align:center">执行</td>
<td style="text-align:center">do_softirq</td>
<td style="text-align:center">tasklet_action, tasklet_hi_action</td>
<td style="text-align:center">resouer_thread被CPU调度执行</td>
</tr>
<tr>
<td style="text-align:center">创建线程</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">alloc_workqueue</td>
</tr>
<tr>
<td style="text-align:center">结束</td>
<td style="text-align:center"></td>
<td style="text-align:center">tasklet_kill</td>
<td style="text-align:center">destroy_weoker, destroy_weokequeue</td>
</tr>
</tbody>
</table>
<h2 id="上半部"><a href="#上半部" class="headerlink" title="上半部"></a>上半部</h2><blockquote>
<ol>
<li>实时性要求高</li>
<li>不能被中断</li>
</ol>
</blockquote>
<p>  上半部的功能是响应中断。当中断发生时，它就把设备驱动程序中中断处理例程的下半部挂到设备的下半部执行队列中去，然后继续等待新的中断到来</p>
<h2 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h2><p>下半部所负责的工作一般是查看设备以获得产生中断的事件信息，并根据这些信息（一般通过读设备上的寄存器得来）进行相应的处理。</p>
<h2 id="上半部与下半部的区分？"><a href="#上半部与下半部的区分？" class="headerlink" title="上半部与下半部的区分？"></a>上半部与下半部的区分？</h2><blockquote>
<p>下半部和上半部最大的区别是可中断，而上半部却不可中断</p>
</blockquote>
<p>对于一个中断，如何划分上下两部分呢？哪些处理放在上半部，哪些处理放在下半部？</p>
<ol>
<li>如果一个任务对时间十分敏感，将其放在上半部</li>
<li>如果一个任务和硬件有关，将其放在上半部</li>
<li>如果一个任务要保证不被其他中断打断，将其放在上半部</li>
<li>其他所有任务，考虑放在下半部</li>
</ol>
<h2 id="下半部的实现方式"><a href="#下半部的实现方式" class="headerlink" title="下半部的实现方式"></a>下半部的实现方式</h2><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>linux中，执行软中断有专门的内核线程，每个处理器对应一个线程，名称<code>ksoftirqd/n</code> (n对应处理器号)</p>
<h3 id="Tasklet"><a href="#Tasklet" class="headerlink" title="Tasklet"></a>Tasklet</h3><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><h3 id="线程化irq"><a href="#线程化irq" class="headerlink" title="线程化irq"></a>线程化irq</h3><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>什么时候选择哪种方式更好？</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/myarrow/article/details/9287169" target="_blank" rel="noopener">中断处理“下半部”机制</a></li>
<li><a href="https://www.cnblogs.com/wang_yb/archive/2013/04/23/3037268.html" target="_blank" rel="noopener">《Linux内核设计与实现》读书笔记（八）- 中断下半部的处理</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>jiffies &amp;&amp; HZ</title>
    <url>/post/33522.html</url>
    <content><![CDATA[<h2 id="jiffies"><a href="#jiffies" class="headerlink" title="jiffies"></a>jiffies</h2><p>全局变量<code>jiffies</code>用来记录自系统启动以来产生的节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的(jiffies是记录着从电脑开机到现在总共的时钟中断次数),一秒内时钟中断的次数等于Hz，所以jiffies一秒内增加的值也就是Hz。系统运行时间以秒为单位，等于i<code>jiffies/Hz</code>。</p>
<p><strong>注意</strong>: jiffies类型为<code>无符号长整型(unsigned long)</code>，其他任何类型存放它都不正确。</p>
<ul>
<li>将以秒为单位的时间转化为jiffies： seconds * Hz (jiffies)</li>
<li>将jiffies转化为以秒为单位的时间： jiffies / Hz (s)</li>
</ul>
<h2 id="HZ"><a href="#HZ" class="headerlink" title="HZ"></a>HZ</h2><p>LINUX系统时钟频率是一个常数HZ来决定的， 通常<code>HZ＝100</code>，那么他的精度度就是10ms（毫秒）。也就是说每10ms一次中断。</p>
<a id="more"></a>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="时间比较"><a href="#时间比较" class="headerlink" title="时间比较"></a>时间比较</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time_after(a,b)</span><br><span class="line">time_before(a,b)</span><br><span class="line">time_after_eq(a,b)</span><br><span class="line">time_before_eq(a,b)</span><br><span class="line">time_in_range(a,b,c)</span><br></pre></td></tr></table></figure>
<h3 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h3><p>jiffies和msecs以及usecs的转换：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int jiffies_to_msecs(const unsigned long);</span><br><span class="line">unsigned int jiffies_to_usecs(const unsigned long);</span><br><span class="line">unsigned long msecs_to_jiffies(const unsigned int m);</span><br><span class="line">unsigned long usecs_to_jiffies(const unsigned int u);</span><br></pre></td></tr></table></figure></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>watchdog_timeo = 2 * HZ;</li>
</ol>
<p>将2s转换为jiffies, 设定2s延时。</p>
<ol start="2">
<li>mod_timer(&amp;host-&gt;timer, jiffies + 10 * HZ);</li>
</ol>
<p>设定10s的定时时间。</p>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>LTP测试</title>
    <url>/post/39613.html</url>
    <content><![CDATA[<p>LTP套件是由 Linux Test Project 所开发的一套系统测试套件。它基于系统资源的利用率统计开发了一个测试的组合,为系统提供足够的压力。</p>
<p>通过压力测试来判断系统的稳定性和可靠性。</p>
<p>压力测试是一种破坏性的测试,即系统在非正常的、超负荷的条件下的运行情况 。用来评估在超越最大负载的情况下系统将如何运行,是系统在正常的情况下对某种负载强度的承受能力的考验</p>
<p>LTP测试套件对Linux操作系统进行超长时间的测试,重点在于Linux用户环境相关的工作负荷。而并不是致力于证明缺陷。<br><a id="more"></a></p>
<h2 id="LTP测试"><a href="#LTP测试" class="headerlink" title="LTP测试"></a>LTP测试</h2><p>测试分为两个阶段：<code>初始测试</code>，<code>压力测试</code></p>
<h3 id="初始测试"><a href="#初始测试" class="headerlink" title="初始测试"></a>初始测试</h3><blockquote>
<p>是开始测试的必要条件。初始测试包括LTP测试套件在硬件和操作系统上成功运转,这些硬件和操作系统将用于可靠性运转</p>
</blockquote>
<p>测试脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runalltests.sh(或runltp)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>runltp默认执行的内容与runalltests相同</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd usr; ./runltp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详细使用见：<a href="/doc/LTP使用说明.doc">LTP使用说明</a></p>
</blockquote>
<h2 id="测试单元"><a href="#测试单元" class="headerlink" title="测试单元"></a>测试单元</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr; ./runltp -f crashme</span><br></pre></td></tr></table></figure>
<h3 id="crashme"><a href="#crashme" class="headerlink" title="crashme"></a>crashme</h3><p>对系统的极端测试</p>
<table>
<thead>
<tr>
<th style="text-align:center">测试项</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">f00f</td>
<td style="text-align:center">x86测试</td>
</tr>
<tr>
<td style="text-align:center">crash01</td>
<td style="text-align:center">生成随机指令进行执行， 申请一块空间写随机值后，将PC跳转至此进行执行，并判断执行结果, 由于指令随机生成可能导致相同卡死，就看相同是否足够强壮，（同时也可能存成内存的泄露）</td>
</tr>
<tr>
<td style="text-align:center">crash02</td>
<td style="text-align:center">随机进行系统调用（0～127）， 并且系统调用的所有参数全是随机值， 由于随机的系统调用可以进行内存分配，而不会释放，也可能存在内存泄露</td>
</tr>
<tr>
<td style="text-align:center">mem01</td>
<td style="text-align:center">根据系统中可以内存的大小，随机或线性申请内存，别填充释放</td>
</tr>
<tr>
<td style="text-align:center">fork12</td>
<td style="text-align:center">尽可能的fork子进程，目的是耗尽系统的pid号，主要冲突是pid_max和内存容量</td>
</tr>
</tbody>
</table>
<h2 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h2><h3 id="max-map-count"><a href="#max-map-count" class="headerlink" title="max_map_count"></a>max_map_count</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat /proc/sys/vm/max_map_count</span><br><span class="line">65530</span><br></pre></td></tr></table></figure>
<blockquote>
<p>限制一个进程所拥有的最大内存区域(64MB)</p>
</blockquote>
<h3 id="min-free-kbytes"><a href="#min-free-kbytes" class="headerlink" title="min_free_kbytes"></a>min_free_kbytes</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat /proc/sys/vm/min_free_kbytes</span><br><span class="line">1961</span><br></pre></td></tr></table></figure>
<blockquote>
<p>表示系统所保留空闲内存的最低限</p>
</blockquote>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><blockquote>
<p>验证产品在系统高使用率时的健壮性。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/trochiluses/article/details/10061513" target="_blank" rel="noopener">LTP–linux稳定性测试,性能测试和压力测试</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-rel/" target="_blank" rel="noopener">测试 Linux 的可靠性</a></li>
<li><a href="http://ltp.sourceforge.net/documentation/technical_papers/ltp-ols-2008-paper.pdf" target="_blank" rel="noopener">Building a Robust Linux kernel piggybacking The Linux Test Project
</a></li>
<li><a href="https://www.cnblogs.com/muahao/p/6532527.html" target="_blank" rel="noopener">[kernel]—-理解kswapd的低水位min_free_kbytes</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>ltp</tag>
      </tags>
  </entry>
  <entry>
    <title>MIPS架构下的中断处理</title>
    <url>/post/61535.html</url>
    <content><![CDATA[<p>内核版本: 3.10.14</p>
<p>linux内核出入文件:arch/mips/kernel/traps.c</p>
<h2 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set_except_vector(0, using_rollback_handler() ? rollback_handle_int: handle_int)</span><br><span class="line">	-&gt; handle_int</span><br><span class="line">		-&gt; plat_irq_dispatch</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="trap-init"><a href="#trap-init" class="headerlink" title="trap_init"></a>trap_init</h2><p>在Linux内核启动时注册，main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	set_except_vector(<span class="number">0</span>, using_rollback_handler() ? rollback_handle_int</span><br><span class="line">	                          : handle_int);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/kernel/traps.c</p>
</blockquote>
<h2 id="handle-int"><a href="#handle-int" class="headerlink" title="handle_int"></a>handle_int</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NESTED(handle_int, PT_SIZE, sp)</span><br><span class="line">	SAVE_ALL</span><br><span class="line">	CLI</span><br><span class="line">	TRACE_IRQS_OFF</span><br><span class="line"></span><br><span class="line">	LONG_L  s0, TI_REGS($<span class="number">28</span>)</span><br><span class="line">	LONG_S  sp, TI_REGS($<span class="number">28</span>)</span><br><span class="line">	PTR_LA  ra, ret_from_irq</span><br><span class="line">	PTR_LA  v0, plat_irq_dispatch</span><br><span class="line">	jr  v0</span><br><span class="line">END(handle_int)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/kernel/genex.S</p>
</blockquote>
<h2 id="plat-irq-dispatch"><a href="#plat-irq-dispatch" class="headerlink" title="plat_irq_dispatch"></a>plat_irq_dispatch</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">plat_irq_dispatch</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r = (read_c0_status() &amp; read_c0_cause()) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	do_IRQ(MIPS_CPU_IRQ_BASE + __ffs(r &amp; <span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/xburst2/soc-x2000/common/irq.c</p>
</blockquote>
<h2 id="ret-from-irq"><a href="#ret-from-irq" class="headerlink" title="ret_from_irq"></a>ret_from_irq</h2><h2 id="代码跳转-反汇编"><a href="#代码跳转-反汇编" class="headerlink" title="代码跳转(反汇编)"></a>代码跳转(反汇编)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80014780 &lt;handle_int&gt;:</span><br><span class="line">80014780:   401a6000    mfc0    k0,c0_status</span><br><span class="line">80014784:   335a0001    andi    k0,k0,0x1</span><br><span class="line">80014788:   17400002    bnez    k0,80014794 &lt;handle_int+0x14&gt;</span><br><span class="line">8001478c:   00000000    nop</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">80014898:   27ff43e0    addiu   ra,ra,17376</span><br><span class="line">8001489c:   3c028001    lui v0,0x8001</span><br><span class="line">800148a0:   24421404    addiu   v0,v0,5124</span><br><span class="line">800148a4:   00400008    jr  v0       #jr -&gt; 0x80011404</span><br><span class="line">800148a8:   00000000    nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">80011404 &lt;plat_irq_dispatch&gt;:</span><br><span class="line">80011404:   40076000    mfc0    a3,c0_status</span><br><span class="line">80011408:   40066800    mfc0    a2,c0_cause</span><br><span class="line">8001140c:   00e61024    and v0,a3,a2</span><br><span class="line">80011410:   00021202    srl v0,v0,0x8</span><br></pre></td></tr></table></figure>
<h3 id="jr-v0"><a href="#jr-v0" class="headerlink" title="jr v0"></a>jr v0</h3><p>handle_int中jr跳转的函数地址v0的计算:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lui v0 0x8001</span><br><span class="line">addiu v0,v0,5124 #0x80011404</span><br></pre></td></tr></table></figure>
<h3 id="lui-amp-addiu"><a href="#lui-amp-addiu" class="headerlink" title="lui &amp; addiu"></a>lui &amp; addiu</h3><p>具体的指令码,可参考MIPS手册.<br>这两个指令码的低十六位为立即数的十六进制数.</p>
<h2 id="handle-int函数的组合"><a href="#handle-int函数的组合" class="headerlink" title="handle_int函数的组合"></a>handle_int函数的组合</h2>]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>setup_per_cpu_areas</title>
    <url>/post/23122.html</url>
    <content><![CDATA[<blockquote>
<p>为了对内核的内存管理<code>（mm）</code>进行初始化而调用的函数之一。只在<code>SMP</code>系统中调用，<code>UP</code>（单核）中不执行任何操作。<br>为SMP的每个处理器生成per-cpu数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">	\-&gt;setup_per_cpu_areas</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: init/main.c</p>
</blockquote>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/yin262/article/details/46787879" target="_blank" rel="noopener">start_kernel——setup_per_cpu_areas</a></li>
<li><a href="http://blog.csdn.net/xylovezf/article/details/6828929" target="_blank" rel="noopener">对Linux内核中percpu data进行分析</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mmu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核中的read_mostly</title>
    <url>/post/59553.html</url>
    <content><![CDATA[<blockquote>
<p>Linux内核版本: linux4.4.166</p>
</blockquote>
<h2 id="read-mostly"><a href="#read-mostly" class="headerlink" title="read_mostly"></a>read_mostly</h2><p><code>__read_mostly</code>原语将定义的变量为存放在<code>.data..read_mostly</code>段中.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define __read_mostly __attribute__((__section__(&quot;.data..read_mostly&quot;)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/arm/include/asm/cache.h</p>
</blockquote>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_DATA_SECTION(cacheline, pagealigned, inittask)       \</span></span><br><span class="line">    . = ALIGN(PAGE_SIZE);                       \</span><br><span class="line">    .data : AT(ADDR(.data) - LOAD_OFFSET) &#123;             \</span><br><span class="line">        INIT_TASK_DATA(inittask)                \</span><br><span class="line">        NOSAVE_DATA                     \</span><br><span class="line">        PAGE_ALIGNED_DATA(pagealigned)              \</span><br><span class="line">        CACHELINE_ALIGNED_DATA(cacheline)           \</span><br><span class="line">        READ_MOSTLY_DATA(cacheline)             \</span><br><span class="line">        DATA_DATA                       \</span><br><span class="line">        CONSTRUCTORS                        \</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_MOSTLY_DATA(align)                     \</span></span><br><span class="line">    . = ALIGN(align);                       \</span><br><span class="line">    *(.data..read_mostly)                       \</span><br><span class="line">    . = ALIGN(align);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/asm-generic/vmlinux.lds.h</p>
</blockquote>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>因为<code>__read_mostly</code>修饰的变量均放在<code>.data..read_mostly</code>段中，因此，我们可以将经常需要被读取的数据定义为<code>__read_mostly</code>类型， 这样Linux内核被加载时,该数据将自动被存放到Cache中,以提高整个系统的执行效率。</p>
<p>如果所在平台没有Cache，或者虽然有Cache，但是并不提供存放数据的接口，(也就是并不允许人工放置数据在Cache中), 那么定义为<code>__read_mostly</code>类型的数据将不能存放在Linux内核中，甚至也不能够被加载到系统内存去执行。</p>
<p>如果数据不能存放在linux内核，甚至也不能够被加载到系统内存去执行，后果非常严重，将造成Linux 内核启动失败。</p>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>OOM</title>
    <url>/post/53957.html</url>
    <content><![CDATA[<p>内核出现OOM的log分析：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[  128.496873] min_free_kbytes invoked oom-killer: gfp_mask=0x200da, order=0, oom_score_adj=0</span><br><span class="line">[  128.505497] min_free_kbytes cpuset=/ mems_allowed=0</span><br><span class="line">[  128.510968] CPU: 0 PID: 118 Comm: min_free_kbytes Not tainted 3.10.14-00062-g277665d-dirty #322</span><br><span class="line">[  128.523967] Stack : 00000000 00000000 00000000 00000000 80624582 00000053 805b0000 805ad500</span><br><span class="line">		8c3933a0 805ad407 8053d15c 00000076 80623d20 805ad500 00000000 00000000</span><br><span class="line">		805ad500 8046cffc 805c0000 8003b3bc 80b3324c 00000000 8053eecc 890019ac</span><br><span class="line">		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">		00000000 00000000 00000000 00000000 00000000 00000000 00000000 89001938</span><br><span class="line">		...</span><br><span class="line">[  128.607831] Call Trace:</span><br><span class="line">[  128.612474] [&lt;800209e0&gt;] show_stack+0x48/0x70</span><br><span class="line">[  128.621191] [&lt;8046daf0&gt;] dump_header.isra.4+0x88/0x260</span><br><span class="line">[  128.628626] [&lt;800bd78c&gt;] oom_kill_process+0xd0/0x478</span><br><span class="line">[  128.635875] [&lt;800be070&gt;] out_of_memory+0x318/0x390</span><br><span class="line">[  128.642951] [&lt;800c1ef4&gt;] __alloc_pages_nodemask+0x8b8/0x900</span><br><span class="line">[  128.650833] [&lt;800d9104&gt;] handle_pte_fault+0xae4/0xc5c</span><br><span class="line">[  128.660245] [&lt;800d9358&gt;] handle_mm_fault+0xdc/0x11c</span><br><span class="line">[  128.667406] [&lt;800298d8&gt;] do_page_fault+0x158/0x480</span><br><span class="line">[  128.674477] [&lt;8001a784&gt;] resume_userspace_check+0x0/0x10</span><br><span class="line">[  128.684178]</span><br><span class="line">[  128.687833] Mem-Info:</span><br><span class="line">[  128.692287] Normal per-cpu:</span><br><span class="line">[  128.699351] CPU    0: hi:   90, btch:  15 usd:  32</span><br><span class="line">[  128.706406] HighMem per-cpu:</span><br><span class="line">[  128.711486] CPU    0: hi:   90, btch:  15 usd:  15</span><br><span class="line">[  128.718564] active_anon:120239 inactive_anon:11 isolated_anon:0</span><br><span class="line">[  128.718564]  active_file:5 inactive_file:2 isolated_file:0</span><br><span class="line">[  128.718564]  unevictable:0 dirty:0 writeback:0 unstable:0</span><br><span class="line">[  128.718564]  free:4617 slab_reclaimable:150 slab_unreclaimable:600</span><br><span class="line">[  128.718564]  mapped:1 shmem:15 pagetables:150 bounce:0</span><br><span class="line">[  128.718564]  free_cma:0</span><br><span class="line">[  128.754330] Normal free:18244kB min:10084kB low:12604kB high:15124kB active_anon:219220kB inactive_anon:0kB active_file</span><br><span class="line">:20kB inactive_file:8kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:262144kB managed:241940kB mlocked:0k</span><br><span class="line">B dirty:0kB writeback:0kB mapped:4kB shmem:0kB slab_reclaimable:600kB slab_unreclaimable:2400kB kernel_stack:320kB pagetab</span><br><span class="line">les:600kB unstable:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:426 all_unreclaimable? yes</span><br><span class="line">[  128.798925] lowmem_reserve[]: 0 2048 2048</span><br><span class="line">[  128.807365] HighMem free:224kB min:256kB low:2984kB high:5716kB active_anon:261736kB inactive_anon:44kB active_file:0kB</span><br><span class="line">inactive_file:0kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:262144kB managed:262144kB mlocked:0kB dir</span><br><span class="line">ty:0kB writeback:0kB mapped:0kB shmem:60kB slab_reclaimable:0kB slab_unreclaimable:0kB kernel_stack:0kB pagetables:0kB uns</span><br><span class="line">table:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:31 all_unreclaimable? yes</span><br><span class="line">[  128.850710] lowmem_reserve[]: 0 0 0</span><br><span class="line">[  128.858541] Normal: 1*4kB (R) 0*8kB 0*16kB 0*32kB 1*64kB (R) 0*128kB 1*256kB (R) 1*512kB (R) 1*1024kB (R) 0*2048kB 0*40</span><br><span class="line">96kB 2*8192kB (R) 0*16384kB 0*32768kB 0*65536kB = 18244kB</span><br><span class="line">[  128.896190] HighMem: 0*4kB 0*8kB 0*16kB 1*32kB (R) 1*64kB (R) 1*128kB (R) 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB 0*</span><br><span class="line">8192kB 0*16384kB 0*32768kB 0*65536kB = 224kB</span><br><span class="line">[  128.928406] 22 total pagecache pages</span><br><span class="line">[  128.988524] 262144 pages RAM</span><br><span class="line">[  128.993703] 131072 pages HighMem</span><br><span class="line">[  129.001226] 136074 pages reserved</span><br><span class="line">[  129.006754] 30 pages shared</span><br><span class="line">[  129.011751] 121318 pages non-shared</span><br><span class="line">[  129.017458] [ pid ]   uid  tgid total_vm      rss nr_ptes swapents oom_score_adj name</span><br><span class="line">[  129.027697] [   61]     0    61      883       18       3        0             0 syslogd</span><br><span class="line">[  129.040259] [   64]     0    64      883       18       3        0             0 klogd</span><br><span class="line">[  129.050561] [   86]  1000    86      753       38       4        0             0 dbus-daemon</span><br><span class="line">[  129.061408] [   96]     0    96     1327       70       4        0         -1000 sshd</span><br><span class="line">[  129.071623] [  103]     0   103      899       23       5        0             0 sh</span><br><span class="line">[  129.081664] [  104]     0   104      883       17       3        0             0 telnetd</span><br><span class="line">[  129.094214] [  108]     0   108      753       36       4        0             0 min_free_kbytes</span><br><span class="line">[  129.105410] [  118]     0   118   120817   120018     121        0             0 min_free_kbytes</span><br><span class="line">[  129.116617] Out of memory: Kill process 118 (min_free_kbytes) score 922 or sacrifice child</span><br><span class="line">[  129.129353] Killed process 118 (min_free_kbytes) total-vm:483268kB, anon-rss:480072kB, file-rss:0kB</span><br></pre></td></tr></table></figure>
<h2 id="相关变量说明"><a href="#相关变量说明" class="headerlink" title="相关变量说明"></a>相关变量说明</h2><h3 id="file-rss"><a href="#file-rss" class="headerlink" title="file-rss"></a>file-rss</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[  129.129353] Killed process 118 (min_free_kbytes) total-vm:483268kB, anon-rss:480072kB, file-rss:0kB</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>rss</code>:”Resident Set Size”, 实际驻留”在内存中”的内存数. 不包括已经交换出去的代码. 举一个例子: 如果你有一个程序使用了100K内存, 操作系统交换出40K内存, 那么RSS为60K. RSS还包括了与其它进程共享的内存区域. 这些区域通常用于libc库等.</p>
</blockquote>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.163.com/digoal@126/blog/static/1638770402016514102751241/" target="_blank" rel="noopener">Linux中进程内存RSS与cgroup内存的RSS统计 - 差异</a></li>
<li><a href="http://blog.chinaunix.net/uid-29043620-id-5754325.html" target="_blank" rel="noopener">进程实际内存占用: 私有驻留内存数(Private RSS)介绍</a></li>
<li><a href="https://e-mailky.github.io/2017-01-14-oom" target="_blank" rel="noopener">Out of Memory(OOM)处理流程</a></li>
<li><a href="https://lwn.net/Articles/317814/" target="_blank" rel="noopener">Taming the OOM killer</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>oom</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核同步机制【rwlock】</title>
    <url>/post/42371.html</url>
    <content><![CDATA[<blockquote>
<p>读写锁实际是一种<code>特殊的自旋锁</code>，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。</p>
</blockquote>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="rwlock-t"><a href="#rwlock-t" class="headerlink" title="rwlock_t"></a>rwlock_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">arch_rwlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> magic, owner_cpu;</span><br><span class="line">	<span class="keyword">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">rwlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/rwlock_types.h</p>
</blockquote>
<h3 id="arch-rwlock-t"><a href="#arch-rwlock-t" class="headerlink" title="arch_rwlock_t"></a>arch_rwlock_t</h3><h4 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> lock;</span><br><span class="line">&#125; <span class="keyword">arch_rwlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/include/asm/spinlock_types.h</p>
</blockquote>
<h2 id="通用接口API"><a href="#通用接口API" class="headerlink" title="通用接口API"></a>通用接口API</h2><ul>
<li>rwlock_init</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ARCH_RW_LOCK_UNLOCKED     &#123; 0 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __RW_LOCK_UNLOCKED(lockname) \</span></span><br><span class="line">    (<span class="keyword">rwlock_t</span>)  &#123;   .raw_lock = __ARCH_RW_LOCK_UNLOCKED,    \</span><br><span class="line">	RW_DEP_MAP_INIT(lockname) &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># define rwlock_init(lock)                  \</span><br><span class="line">    <span class="keyword">do</span> &#123; *(lock) = __RW_LOCK_UNLOCKED(lock); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>初始化<code>rwlock_t-&gt;raw_lock-&gt;lock=0</code></p>
<ul>
<li>R/W lock</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define write_lock(lock)    _raw_write_lock(lock)</span><br><span class="line">#define read_lock(lock)     _raw_read_lock(lock)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/rwlock.h</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>读写锁包括读取锁和写入锁，多个读线程可以同时访问共享数据；写线程必须等待所有读线程都释放锁以后，才能取得锁；同样的，读线程必须等待写线程释放锁后，才能取得锁；</p>
<p>也就是说读写锁要确保的是如下互斥关系：可以同时读，但是读-写，写-写都是互斥的；</p>
<ul>
<li>读锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read_lock</span><br><span class="line">  |-&gt;_raw_read_lock</span><br><span class="line">	|-&gt;__raw_read_lock</span><br><span class="line">	  |-&gt;preempt_disable();</span><br><span class="line">	  |-&gt;rwlock_acquire_read(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</span><br><span class="line">	  |-&gt;LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock);</span><br></pre></td></tr></table></figure>
<p>在读锁上锁时与spinlock的流程基本相同，都会关闭内核抢占，因此读写锁中也不能睡眠</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> do_raw_read_trylock(rwlock)    arch_read_trylock(&amp;(rwlock)-&gt;raw_lock)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> do_raw_read_lock(rwlock)   do &#123;__acquire(lock); arch_read_lock(&amp;(rwlock)-&gt;raw_lock); &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/rwlock.h</p>
</blockquote>
<h3 id="MIPS-1"><a href="#MIPS-1" class="headerlink" title="MIPS"></a>MIPS</h3><p>不同架构的实现：</p>
<h3 id="arch-read-lock"><a href="#arch-read-lock" class="headerlink" title="arch_read_lock"></a>arch_read_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_read_lock</span><span class="params">(<span class="keyword">arch_rwlock_t</span> *rw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        __asm__ __volatile__(</span><br><span class="line">        <span class="string">"1: ll  %1, %2  # arch_read_lock    \n"</span></span><br><span class="line">        <span class="string">"   bltz    %1, 1b              \n"</span></span><br><span class="line">        <span class="string">"    addu   %1, 1               \n"</span></span><br><span class="line">        <span class="string">"2: sc  %1, %0              \n"</span></span><br><span class="line">        : <span class="string">"=m"</span> (rw-&gt;lock), <span class="string">"=&amp;r"</span> (tmp)</span><br><span class="line">        : <span class="string">"m"</span> (rw-&gt;lock)</span><br><span class="line">        : <span class="string">"memory"</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(!tmp));</span><br><span class="line"></span><br><span class="line">    smp_llsc_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>bltz $s,offset &lt;==&gt; if($s&lt; 0) jump(offset « 2); 小于0，跳转</p>
</blockquote>
<p>内嵌汇编源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c2020000    ll  v0,0(s0)</span><br><span class="line">0440fffe    bltz    v0,8021c8f8 &lt;do_raw_read_lock+0x38&gt;</span><br><span class="line">00000000    nop</span><br><span class="line">24420001    addiu   v0,v0,1</span><br><span class="line">e2020000    sc  v0,0(s0)</span><br><span class="line">1040fffa    beqz    v0,8021c8f8 &lt;do_raw_read_lock+0x38&gt;</span><br></pre></td></tr></table></figure></p>
<p>上读锁是通过原子操作对<code>rwlock_t-&gt;raw_lock-&gt;lock += 1</code></p>
<h3 id="arch-read-unlock"><a href="#arch-read-unlock" class="headerlink" title="arch_read_unlock"></a>arch_read_unlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_read_unlock</span><span class="params">(<span class="keyword">arch_rwlock_t</span> *rw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    smp_mb__before_llsc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        __asm__ __volatile__(</span><br><span class="line">        <span class="string">"1: ll  %1, %2  # arch_read_unlock  \n"</span></span><br><span class="line">        <span class="string">"   sub %1, 1               \n"</span></span><br><span class="line">        <span class="string">"   sc  %1, %0              \n"</span></span><br><span class="line">        : <span class="string">"=m"</span> (rw-&gt;lock), <span class="string">"=&amp;r"</span> (tmp)</span><br><span class="line">        : <span class="string">"m"</span> (rw-&gt;lock)</span><br><span class="line">        : <span class="string">"memory"</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(!tmp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读锁是通过原子操作对<code>rwlock_t-&gt;raw_lock-&gt;lock -= 1</code></p>
<h3 id="arch-write-lock"><a href="#arch-write-lock" class="headerlink" title="arch_write_lock"></a>arch_write_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_write_lock</span><span class="params">(<span class="keyword">arch_rwlock_t</span> *rw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        __asm__ __volatile__(</span><br><span class="line">        <span class="string">"1: ll  %1, %2  # arch_write_lock   \n"</span></span><br><span class="line">        <span class="string">"   bnez    %1, 1b              \n"</span></span><br><span class="line">        <span class="string">"    lui    %1, 0x8000          \n"</span></span><br><span class="line">        <span class="string">"2: sc  %1, %0              \n"</span></span><br><span class="line">        : <span class="string">"=m"</span> (rw-&gt;lock), <span class="string">"=&amp;r"</span> (tmp)</span><br><span class="line">        : <span class="string">"m"</span> (rw-&gt;lock)</span><br><span class="line">        : <span class="string">"memory"</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(!tmp));</span><br><span class="line"></span><br><span class="line">    smp_llsc_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lui $t,imm &lt;==&gt; $t=(imm « 16)<br>将立即数左移16位，低16位补零</p>
</blockquote>
<p>内嵌汇编反汇编源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c2020000    ll  v0,0(s0)</span><br><span class="line">1440fffe    bnez    v0,8021ca08 &lt;do_raw_write_lock+0x70&gt;</span><br><span class="line">00000000    nop</span><br><span class="line">3c028000    lui v0,0x8000</span><br><span class="line">e2020000    sc  v0,0(s0)</span><br><span class="line">1040fffa    beqz    v0,8021ca08 &lt;do_raw_write_lock+0x70&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="arch-write-unlock"><a href="#arch-write-unlock" class="headerlink" title="arch_write_unlock"></a>arch_write_unlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_write_unlock</span><span class="params">(<span class="keyword">arch_rwlock_t</span> *rw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    smp_mb();</span><br><span class="line"></span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">    <span class="string">"               # arch_write_unlock \n"</span></span><br><span class="line">    <span class="string">"   sw  $0, %0                  \n"</span></span><br><span class="line">    : <span class="string">"=m"</span> (rw-&gt;lock)</span><br><span class="line">    : <span class="string">"m"</span> (rw-&gt;lock)</span><br><span class="line">    : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li>读锁怎么实现可以存在多个读者进行处理？？</li>
</ol>
<ol start="2">
<li>读写锁与SMP多核之间的线程处理关系？？</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-rwlock_writing/" target="_blank" rel="noopener">Linux下写者优先的读写锁的设计</a></li>
<li><a href="http://guojing.me/linux-kernel-architecture/posts/read-and-write-spin-lock/" target="_blank" rel="noopener">读/写自旋锁</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
        <category>同步</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>rwlock</tag>
      </tags>
  </entry>
  <entry>
    <title>任务调度</title>
    <url>/post/65317.html</url>
    <content><![CDATA[<div class="note info">
            <p>调度器 </p>
          </div>
<p>多任务操作系统分为非抢占式多任务和抢占式多任务。与大多数现代操作系统一样，Linux采用的是抢占式多任务模式。这表示对CPU的占用时间由操作系统决定的，具体为操作系统中的调度器。调度器决定了什么时候停止一个进程以便让其他进程有机会运行，同时挑选出一个其他的进程开始运行</p>
<ol>
<li>schedule</li>
<li>抢占</li>
</ol>
<a id="more"></a>
<h2 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h2><blockquote>
<p>调度什么时候发生？schedule()函数什么时候被调用</p>
</blockquote>
<p>调度方式：</p>
<ul>
<li><p>主动式调度（自愿调度）<br>在内核中进程直接调用<code>schelule()</code>, 当进程需要等待资源而暂时停止运行时，会把进程状态置为挂起（睡眠），并主动请求调度，让出CPU。</p>
</li>
<li><p>被动式调度（抢占调度）<br>内核抢占和用户抢占</p>
</li>
</ul>
<ol>
<li><p>用户抢占<br>当内核即将返回用户空间时, 内核会检查<code>need_resched</code>是否设置, 如果设置, 则调用schedule(), 此时,发生用户抢占.</p>
</li>
<li><p>内核抢占<br>内核抢占就是指一个在内核态运行的进程, 可能在执行内核函数期间被另一个进程取代.</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/gatieme/article/details/51872618" target="_blank" rel="noopener">Linux用户抢占和内核抢占详解(概念, 实现和触发时机)–Linux进程的管理与调度(二十）)</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内存的VM参数</title>
    <url>/post/18938.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@buildroot ~]# sysctl -a | grep &quot;vm&quot;</span><br><span class="line">sysctl: error reading key &apos;net.ipv4.route.flush&apos;: Permission denied</span><br><span class="line">vm.admin_reserve_kbytes = 8192</span><br><span class="line">vm.block_dump = 0</span><br><span class="line">vm.dirty_background_bytes = 0</span><br><span class="line">vm.dirty_background_ratio = 10</span><br><span class="line">vm.dirty_bytes = 0</span><br><span class="line">vm.dirty_expire_centisecs = 3000</span><br><span class="line">vm.dirty_ratio = 20</span><br><span class="line">vm.dirty_writeback_centisecs = 500</span><br><span class="line">vm.drop_caches = 0</span><br><span class="line">vm.extra_free_kbytes = 0</span><br><span class="line">vm.highmem_is_dirtyable = 0</span><br><span class="line">vm.laptop_mode = 0</span><br><span class="line">vm.legacy_va_layout = 0</span><br><span class="line">vm.lowmem_reserve_ratio = 32      32</span><br><span class="line">vm.max_map_count = 65530</span><br><span class="line">vm.min_free_kbytes = 1970</span><br><span class="line">vm.min_free_order_shift = 1</span><br><span class="line">vm.mmap_min_addr = 4096</span><br><span class="line">vm.nr_pdflush_threads = 0</span><br><span class="line">vm.oom_dump_tasks = 1</span><br><span class="line">vm.oom_kill_allocating_task = 0</span><br><span class="line">vm.overcommit_memory = 0</span><br><span class="line">vm.overcommit_ratio = 50</span><br><span class="line">vm.page-cluster = 3</span><br><span class="line">vm.panic_on_oom = 0</span><br><span class="line">vm.percpu_pagelist_fraction = 0</span><br><span class="line">vm.scan_unevictable_pages = 0</span><br><span class="line">vm.stat_interval = 1</span><br><span class="line">vm.swappiness = 60</span><br><span class="line">vm.user_reserve_kbytes = 15712</span><br><span class="line">vm.vfs_cache_pressure = 100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>proc文件系统：<code>ls /proc/sys/vm/</code></p>
</blockquote>
<a id="more"></a>
<h2 id="overcommit-memory"><a href="#overcommit-memory" class="headerlink" title="overcommit_memory"></a>overcommit_memory</h2><blockquote>
<p>内核分配内存的策略，有0，1，2三种</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">overcommit_memory</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">表示内核允许分配所有的物理内存，而不管当前的内存状态如何</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">表示内核允许分配超过所有物理内存和交换空间总和的内存</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title>等待队列</title>
    <url>/post/36894.html</url>
    <content><![CDATA[<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>由循环链表实现，其元素包括指向进程描述符的指针。每个等待队列都有一个等待队列头(wait queue head),等待队列头是一个类型为wait_queue_head_t的数据结构</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3>]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>process</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核中驱动注册的先后顺序</title>
    <url>/post/47803.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile基础语法</title>
    <url>/post/21058.html</url>
    <content><![CDATA[<p>Makefile语法</p>
<a id="more"></a>
<h2 id><a href="#" class="headerlink" title="= := ?= +="></a>= := ?= +=</h2><ol>
<li><code>=</code> 是最基本的赋值</li>
<li><code>:=</code> 是覆盖之前的值</li>
<li><code>?=</code> 是如果没有被赋值过就赋予等号后面的值</li>
<li><code>+=</code> 是添加等号后面的值</li>
</ol>
<h3 id="-1"><a href="#-1" class="headerlink" title="="></a><code>=</code></h3><p>make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = foo</span><br><span class="line">y = $(x) bar</span><br><span class="line">x = xyz</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    echo &quot;==: $y&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果==: xyz bar</p>
</blockquote>
<h3 id="-2"><a href="#-2" class="headerlink" title=":="></a><code>:=</code></h3><p>表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := $(x) bar</span><br><span class="line">x := xyz</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    echo &quot;==: $y&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果==: foo bar</p>
</blockquote>
]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>H264 ES PS TS流之间的联系</title>
    <url>/post/51817.html</url>
    <content><![CDATA[<blockquote>
<p><code>ES流(Elementary Stream)</code>: 也叫基本码流,包含视频、音频或数据的连续码流.</p>
</blockquote>
<blockquote>
<p><code>PES流(Packet Elementary Stream)</code>: 也叫打包的基本码流, 是将基本的码流ES流根据需要分成长度不等的数据包, 并加上包头就形成了打包的基本码流PES流.</p>
</blockquote>
<blockquote>
<p><code>TS流(Transport Stream)</code>: 也叫传输流, 是由固定长度为<code>188字节</code>的包组成, 含有独立时基的一个或多个program, 一个program又可以包含多个视频、音频、和文字信息的ES流;</p>
</blockquote>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><p>ES是只包含一种<code>内容的数据流</code>，如只含<code>视频</code>或只含<code>音频</code>等，打包之后的PES也是只含一种性质的ES,如只含视频ES的PES,只含音频ES的PES等。每个ES都由若干个<code>存取单元（AU）</code>组成，每个视频AU或音频AU都是<code>由头部和编码数据</code>两部分组成，<code>个AU相当于编码的1幅视频图像或1个音频帧</code>，也可以说，每个AU实际上是编码数据流的显示单元，即相当于解码的1幅视频图像或1个音频帧的取样。</p>
<h3 id="PES"><a href="#PES" class="headerlink" title="PES"></a>PES</h3><p>PES–Packetized  Elementary Streams  (分组的ES)，ES形成的分组称为<code>PES分组</code>，是用来<code>传递ES的一种数据结构</code>。PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。PES包由<code>包头和payload</code>组成。</p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>PS–Program Stream(节目流)PS流由PS包组成，而一个PS包又由若干个PES包组成（到这里，ES经过了两层的封装）。PS包的包头中包含了<code>同步信息</code>与<code>时钟恢复信息</code>。一个PS包最多可包含具有<code>同一时钟基准</code>的16个视频PES包和32个音频PES包。</p>
<h3 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h3><p>TS–Transport Stream（传输流）由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES也经过了两层的封装）。<code>PES包的包头信息依然存在于TS包中</code>。</p>
<h3 id="PS和TS区别："><a href="#PS和TS区别：" class="headerlink" title="PS和TS区别："></a>PS和TS区别：</h3><p>TS流与PS流的区别在于<code>TS流的包结构是固定长度的</code>,而<code>PS流的包结构是可变长度的</code>。PS包由于长度是变化的,一旦丢失某一PS包的同步信息,接收机就会进入失步状态,从而导致严重的信息丢失事件。而TS码流由于采用了固定长度的包结构,当传输误码破坏了某一TS包的同步信息时,接收机可在固定的位置检测它后面包中的同步信息,从而恢复同步,避免了信息丢失。因此<code>在信道环境较为恶劣、传输误码较高时一般采用TS码流</code>,而<code>在信环境较好、传输误码较低时一般采用PS码流</code>。</p>
<h3 id="PTS、DTS"><a href="#PTS、DTS" class="headerlink" title="PTS、DTS"></a>PTS、DTS</h3><p>PTS–PresentationTime Stamp（显示时间标记）表示显示单元出现在系统目标解码器（H.264、MJPEG等）的时间。</p>
<p>DTS–Decoding Time Stamp（解码时间标记）表示将存取单元全部字节从解码缓存器移走的时间。</p>
<p>PTS/DTS是打在<code>PES包</code>的包头里面的，这两个参数是解决音视频同步显示，防止解码器输入缓存上溢或下溢的关键。每一个I（关键帧）、P（预测帧）、B（双向预测 帧）帧的包头都有一个PTS和DTS，但PTS与DTS对于B帧不一样，无需标出B帧的DTS，对于I帧和P帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，所以一定要分别标明PTS和DTS。</p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>h264</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC内嵌汇编(mips)</title>
    <url>/post/55412.html</url>
    <content><![CDATA[<blockquote>
<p>以MIPS架构的汇编为主进行说明</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">	&quot;1: ll  %1, %2  # arch_read_lock    \n&quot;</span><br><span class="line">	&quot;   bltz    %1, 1b              \n&quot;</span><br><span class="line">	&quot;    addu   %1, 1               \n&quot;</span><br><span class="line">	&quot;2: sc  %1, %0              \n&quot;</span><br><span class="line">	: &quot;=m&quot; (rw-&gt;lock), &quot;=&amp;r&quot; (tmp)</span><br><span class="line">	: &quot;m&quot; (rw-&gt;lock)</span><br><span class="line">	: &quot;memory&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>基本形式： <code>__asm__ __volatile__(&quot;ssnop\n\t&quot;);</code><blockquote>
<p><code>ssnop</code>: 空指令</p>
</blockquote>
</li>
</ul>
<p>汇编扩展以<code>__asm__</code>开头表示后面部分为汇编,<code>__volatile__</code>严禁将此处的汇编语句和其他语句进行重组优化，就是希望gcc不要修改我们这个部分。<br><a id="more"></a></p>
<h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>主要由四部分构成,之间以<code>:</code>分隔：</p>
<ol>
<li><code>instruction指令</code>:每条指令之后最好使用<code>&quot;\n\t&quot;</code>结尾,这样在gcc产生汇编格式比较好.</li>
<li><code>output operand输出</code>:每个输出部分使用,分隔.”=”作为修饰符,”m”表示<code>存放位置/约束符</code>,()里面表示对应C程序值.</li>
<li><code>input operand输入</code>:这个部分和输出是一样的.</li>
<li><code>clobber(装备)</code>:这个部分是告诉gcc在这条指令里面我们会修改什么值.</li>
</ol>
<h3 id="约束符"><a href="#约束符" class="headerlink" title="约束符"></a>约束符</h3><p>束符影响的内容包括:</p>
<blockquote>
<p>whether an operand may be in a register<br>which kinds of register<br>whether the operand can be a memory reference<br>which kinds of address<br>whether the operand may be an immediate constant<br>which possible values it may have</p>
</blockquote>
<p>约束符包括:</p>
<ul>
<li>p 内存地址</li>
<li>m 内存变量</li>
<li>o 内存变量,但是寻址方式必须是偏移量的,就是基址寻址或者是基址变址寻址.</li>
<li>V 内存变量,但是寻址方式是非偏移量的.</li>
<li>r general寄存器操作数</li>
<li>i 立即操作数,内容在编译器可以确定.</li>
<li>n 立即操作数.有些系统不支持字(双字节)以外的立即操作数,这些操作数以n非i来表示.</li>
<li>E/F 浮点常数</li>
<li>g 内存操作数,整数常数,非genernal寄存器操作数</li>
<li>X 任何操作数</li>
<li>0,1,2…9 和编号指定操作数匹配的操作数束符影响的内容包括</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符包括:</p>
<ul>
<li><code>=</code> 操作数是write only的</li>
<li><code>+</code> 操作数是可读可写的</li>
<li><code>&amp;</code> 常用于输出限定符,表示某个寄存器不会被输入所使用.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">&quot;   .set    mips3               \n&quot;</span><br><span class="line">&quot;   ll  %0, %1      # atomic_sub    \n&quot;</span><br><span class="line">&quot;   subu    %0, %2              \n&quot;</span><br><span class="line">&quot;   sc  %0, %1              \n&quot;</span><br><span class="line">&quot;   .set    mips0               \n&quot;</span><br><span class="line">: &quot;=&amp;r&quot; (temp), &quot;+m&quot; (v-&gt;counter)</span><br><span class="line">: &quot;Ir&quot; (i));</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="读取CP0-25号硬件计数寄存器的值"><a href="#读取CP0-25号硬件计数寄存器的值" class="headerlink" title="读取CP0 25号硬件计数寄存器的值"></a>读取CP0 25号硬件计数寄存器的值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int get_counter()</span><br><span class="line">&#123;</span><br><span class="line">	int rst;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(	/* mfc0 为取cp0 寄存器值的指令 */</span><br><span class="line">	&quot;mfc0	%0, $25\n\t&quot;	/* %0 表示列表开始的第一个寄存器 */</span><br><span class="line">	: &quot;=r&quot; (rst)		/* 告诉gcc 让rst对应一个通用寄存器 */</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	return rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“=r” 中，’=’ 为修饰符，表示该操作对象只写，一般用于修饰输出参数列表中。’r’ 表示任意一个通用寄存器</p>
</blockquote>
<h3 id="设置CP0-24号硬件计数寄存器的值"><a href="#设置CP0-24号硬件计数寄存器的值" class="headerlink" title="设置CP0 24号硬件计数寄存器的值"></a>设置CP0 24号硬件计数寄存器的值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int op = 0x80f;</span><br><span class="line"></span><br><span class="line">__asm__ __volatile__(</span><br><span class="line">&quot;mtc0 %0, $24\n\t&quot;</span><br><span class="line">:				/* 没有输出，列表为空 */</span><br><span class="line">:&quot;r&quot;(op)		/* 输入参数，告诉gcc 让op对应一个通用寄存器 */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="重设后，读取CP0-24号寄存器的值"><a href="#重设后，读取CP0-24号寄存器的值" class="headerlink" title="重设后，读取CP0 24号寄存器的值"></a>重设后，读取CP0 24号寄存器的值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int rst;</span><br><span class="line">unsigned int op = 0x80f;</span><br><span class="line"></span><br><span class="line">__asm__ __volatile__(</span><br><span class="line">&quot;mtc0	%1, $24\n\t&quot;	/* %1 表示 op 对应的寄存器 */</span><br><span class="line">&quot;mfc0	%0, $25\n\t&quot;	/* %0 表示 rst 对应的寄存器 */</span><br><span class="line">: &quot;=r&quot; (rst)</span><br><span class="line">: &quot;r&quot; (op)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输入输出参数列表，按先后顺序，从0开始编号, %0, %1。</p>
</blockquote>
<h3 id="解读开头汇编代码"><a href="#解读开头汇编代码" class="headerlink" title="解读开头汇编代码"></a>解读开头汇编代码</h3><p>读写锁中读锁上锁的汇编实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">	&quot;1: ll  %1, %2  # arch_read_lock    \n&quot;</span><br><span class="line">	&quot;   bltz    %1, 1b              \n&quot;</span><br><span class="line">	&quot;    addu   %1, 1               \n&quot;</span><br><span class="line">	&quot;2: sc  %1, %0              \n&quot;</span><br><span class="line">	: &quot;=m&quot; (rw-&gt;lock), &quot;=&amp;r&quot; (tmp)</span><br><span class="line">	: &quot;m&quot; (rw-&gt;lock)</span><br><span class="line">	: &quot;memory&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&quot;=m&quot; (rw-&gt;lock)</code>: 只写内存操作<br><code>&quot;=&amp;r&quot; (tmp)</code> : 只写的输出变量，使用一个通用寄存器<br><code>&quot;memory&quot;</code>: 告诉gcc编译，该指令会修改内存中的值</p>
</blockquote>
<ol>
<li>通过原子操作<code>ll</code>,将<code>rw-&gt;lock</code>读到<code>tmp</code></li>
<li>加一：<code>tmp = tmp + 1</code></li>
<li>通过原子操作<code>sc</code>,将<code>tmp</code>写入<code>rw-&gt;lock</code></li>
</ol>
<h2 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h2><p>内存屏障：保证前后指令的执行顺序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> barrier() __asm__ __volatile__(<span class="meta-string">""</span>: : :<span class="meta-string">"memory"</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/compiler-gcc.h</p>
</blockquote>
<p><code>&quot;memory&quot;</code>作为clobber部分另外一个作用是可以让在这条指令之后的指令,告诉gcc应该刷新内存状态.内存的状态可能发生修改,如果需要操作的话,需要重新把内存内容载入寄存器</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/comcat/article/details/1557963" target="_blank" rel="noopener">MIPS GCC 嵌入式汇编</a></li>
<li><a href="https://dirtysalt.github.io/html/gcc-asm.html" target="_blank" rel="noopener">GCC内嵌汇编</a></li>
</ol>
]]></content>
      <categories>
        <category>MIPS</category>
      </categories>
      <tags>
        <tag>mips</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache</title>
    <url>/post/50757.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+  +----+   +----+  +----+</span><br><span class="line">|CPU0|  |CPU1|   |CPU2|  |CPU3|</span><br><span class="line">+----+  +----+   +----+  +----+</span><br><span class="line">  +-+     +-+     +-+      +-+</span><br><span class="line">    |     |         |      |</span><br><span class="line">+---v-----v--+   +--v------v--+</span><br><span class="line">|   L1 Cache |   |  L2 Cache  |</span><br><span class="line">+------+-----+   +------+-----+</span><br><span class="line">       |                |</span><br><span class="line">+------v----------------v-----+</span><br><span class="line">|         L2 Cache            |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Cache-初始化"><a href="#Cache-初始化" class="headerlink" title="Cache 初始化"></a>Cache 初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel_start</span><br><span class="line">	\-&gt;setup_arch</span><br><span class="line">		\-&gt;cpu_cache_init</span><br><span class="line">			\-&gt;r4k_cache_init</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_dcache_size()           (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_dcache_ways()           8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_dcache_line_size()      32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_icache_size()           (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_icache_ways()           8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_icache_line_size()      32</span></span><br></pre></td></tr></table></figure>
<h2 id="cpuinfo-mips"><a href="#cpuinfo-mips" class="headerlink" title="cpuinfo_mips"></a>cpuinfo_mips</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpuinfo_mips</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>        udelay_val;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *Capability and feature descriptor structure for MIPS CPU</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>        processor_id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>        fpu_id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>        msa_id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>        cputype;</span><br><span class="line">	...</span><br><span class="line">&#125; __attribute__((aligned(SMP_CACHE_BYTES)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpuinfo_mips</span> <span class="title">cpu_data</span>[];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> current_cpu_data cpu_data[smp_processor_id()]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_current_cpu_data cpu_data[raw_smp_processor_id()]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/include/asm/cpu-info.h</p>
</blockquote>
<ul>
<li>初始化：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpuinfo_mips</span> <span class="title">cpu_data</span>[<span class="title">NR_CPUS</span>] __<span class="title">read_mostly</span>;</span></span><br><span class="line">EXPORT_SYMBOL(cpu_data);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>file:  arch/mips/kernel/setup.c</p>
</blockquote>
]]></content>
      <categories>
        <category>MIPS</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cache</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title>mips指令集</title>
    <url>/post/25760.html</url>
    <content><![CDATA[<p>注意使用<code>jr.hb</code>、<code>jal.hb</code>等硬件屏障指令。(hardware barrier)</p>
]]></content>
      <categories>
        <category>MIPS</category>
      </categories>
      <tags>
        <tag>指令</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title>eMMC中的HPI</title>
    <url>/post/14442.html</url>
    <content><![CDATA[<p>在某些情景下，不同类型的数据对于Host来讲可能会有不同的优先级。比如在写指定的数据的时候，由于写数据会消耗掉很多的时间，当用于想要立即进行另外一个操作的时候，就必须项办法抑制住当前的写操作来实现分页操作的需求。</p>
<blockquote>
<p>HPI(High Priority Interrupt)高优先级中断，该机制可以中断一些还没有完成的优先级比较低的操作，来满足对高优先级操作的需求。</p>
</blockquote>
<a id="more"></a>
<p>HPI命令可以从一下两个命令中的任何一个来发送：</p>
<p>1.CMD12 - 基于STOP_TRANSMISSION命令，当HPI标志位置一的时候生效</p>
<p>2.CMD13 - 基于SEND_STATUS命令，当HPI标志位置一的时候生效</p>
<p>当HPI生效的时候，以上两个命令的参数必须设定为:</p>
<table>
<thead>
<tr>
<th style="text-align:center">RCA</th>
<th style="text-align:center">填充位</th>
<th style="text-align:center">HPI</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[31:16]</td>
<td style="text-align:center">[15:1]</td>
<td style="text-align:center">[0]</td>
</tr>
</tbody>
</table>
<blockquote>
<p>填充位不影响参数配置</p>
</blockquote>
<p>当在执行WRITE_MULTIPLE_BLOCK命令时(CMD 25)，设备会更新CORRECTLY_PRG_SECTORS_NUM(EXT_CSD[245:242])，这个值会根据目前成功写入的扇区(512B)数量来更新。当HPI生效之后，Host可以根据这个值来重新继续写入数据而不必从头开始写。</p>
<p>如果HPI中断了在Packed write command中的CMD25，CORRECTLY_PRG_SECTORS_NUM返回的是所有写命令积累起来的当前成功写入扇区的总数量，Host应当通过这个值计算出具体的中断的命令和扇区偏移地址。</p>
<p>在使用HPI功能之前，要先把在EXT_CSD里面[161]字节的HPI_MGMT，把HPI_EN置1</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/polley88/article/details/50457946" target="_blank" rel="noopener">eMMC当中HPI的作用以及使用方法</a></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>emmc的HS200特性</title>
    <url>/post/34668.html</url>
    <content><![CDATA[<p>emmc设备支持的时钟模式:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Speed Mode</th>
<th style="text-align:center">clock (MHz)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Default Speed</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td style="text-align:center">Hight Speed SDR</td>
<td style="text-align:center">52</td>
</tr>
<tr>
<td style="text-align:center">Hight Speed DDR</td>
<td style="text-align:center">52</td>
</tr>
<tr>
<td style="text-align:center">HS200</td>
<td style="text-align:center">200</td>
</tr>
<tr>
<td style="text-align:center">HS400</td>
<td style="text-align:center">200</td>
</tr>
</tbody>
</table>
<blockquote>
<p>SDR : 单边沿采样<br>DDR : 双边沿采样</p>
</blockquote>
<a id="more"></a>
<h2 id="Hardware-System"><a href="#Hardware-System" class="headerlink" title="Hardware System"></a>Hardware System</h2><p><img src="/images/emmc/emmc_hw.png" alt="emmc hardware"></p>
<blockquote>
<p>DS（Data Strobe）：This signal is generated by the device and used for data output and CRC status<br>response output in <code>HS400</code> mode.</p>
</blockquote>
<p><img src="/images/emmc/emmc_gpio.png" alt="emmc gpio"></p>
<p><strong>注:</strong> 在电路的设计中需要将<code>RST_n</code>的pin脚可以控制，否则在第一次写数据是容易出现超时错误，因此可以通过mmc驱动控制软件控制，也可以通过硬件的系统reset时控制</p>
<h3 id="Boot的状态转换"><a href="#Boot的状态转换" class="headerlink" title="Boot的状态转换"></a>Boot的状态转换</h3><p><img src="/images/emmc/emmc_boot.png" alt="emmc boot"></p>
<blockquote>
<ol>
<li>GO_PRE_IDLE_STATE command (CMD0 with argument of 0xF0F0F0F0) is the software reset command and puts the device into <code>Pre-idle</code> State.</li>
<li>Hardware reset may be used by host resetting a device , moving the device to <code>Pre-idle</code> state and disabling power-on period write protect on blocks that had been set as power-on write protect before the reset was asserted.</li>
</ol>
</blockquote>
<p><code>BOOT_PARTITION_ENABLE</code>配置：</p>
<p>Extended CSD register进行设置，<code>BOOT_PARTITION_ENABLE</code>默认配置为<code>0</code>，（0x0 : Device not boot enabled (default)）</p>
<h2 id="Bus-Speed-Mode"><a href="#Bus-Speed-Mode" class="headerlink" title="Bus Speed Mode"></a>Bus Speed Mode</h2><p><img src="/images/emmc/emmc_bus_speed_mode.png" alt="emmc bus speed"></p>
<h3 id="HS200-Bus-Speed-Mode"><a href="#HS200-Bus-Speed-Mode" class="headerlink" title="HS200 Bus Speed Mode"></a><code>HS200</code> Bus Speed Mode</h3><p>The HS200 mode offers the following features:</p>
<ul>
<li><code>SDR</code> Data sampling method</li>
<li>CLK frequency up to <code>200MHz</code> Data rate – up to 200MB/s</li>
<li><code>4 or 8-bits bus</code> width supported</li>
<li>Single ended signaling with <code>4 Drive Strengths</code></li>
<li>Signaling levels of <code>1.8V</code> and <code>1.2V</code></li>
<li><code>Tuning concept</code> for Read Operations</li>
</ul>
<h4 id="HS200-System-Block-Diagram"><a href="#HS200-System-Block-Diagram" class="headerlink" title="HS200 System Block Diagram"></a>HS200 System Block Diagram</h4><p><img src="/images/emmc/emmc_hs200_block.png" alt="emmc hs200 block"></p>
<blockquote>
<p>After power-on or software reset(CMD0), the interface timing of the device is set as the default “Backward Compatible Timing “. <code>Device shall select HS200 Timing mode if required and perform the Tuning process if needed</code>.</p>
</blockquote>
<h4 id="HS200-Adjustable-Sampling-Host"><a href="#HS200-Adjustable-Sampling-Host" class="headerlink" title="HS200 Adjustable Sampling Host"></a><strong>HS200 Adjustable Sampling Host</strong></h4><blockquote>
<p>The Host may use <code>adjustable sampling</code> to determine the correct sampling point. A predefined tuning block stored in Device may be used by the Host as an aid for finding the optimal data sampling point. The Host can use <code>CMD21 tuning command</code> to read the tuning block.</p>
</blockquote>
<ol>
<li><p>HS200为什么需要tuning， 其作用，好处？</p>
</li>
<li><p>何时发生tuning，tuning的原理？</p>
</li>
</ol>
<h3 id="HS400-Bus-Speed-Mode"><a href="#HS400-Bus-Speed-Mode" class="headerlink" title="HS400 Bus Speed Mode"></a><code>HS400</code> Bus Speed Mode</h3><p>The HS400 mode has the following features:</p>
<ul>
<li><code>DDR</code> Data sampling method</li>
<li>CLK frequency up to <code>200MHz</code>, Data rate is up to 400MB/s</li>
<li><code>Only 8-bit bus</code> width supported</li>
<li>Signaling levels of <code>1.8V</code> and <code>1.2V</code></li>
<li>Support up to <code>5 Drive Strengths</code></li>
<li><code>Data strobe signal</code> is toggled only for Data out and CRC response</li>
</ul>
<blockquote>
<p>e•MMC device in HS400 mode while enabling <code>Enhanced Strobe</code> without the need for tuning procedure.</p>
</blockquote>
<h4 id="HS400-System-Block-Diagram"><a href="#HS400-System-Block-Diagram" class="headerlink" title="HS400 System Block Diagram"></a>HS400 System Block Diagram</h4><p><img src="/images/emmc/emmc_hs400_block.png" alt="emmc hs400 block"></p>
<blockquote>
<p>For read operations, Data Strobe is generated by device output circuit. Host receives the data which is <code>aligned to the edge of Data Strobe</code>.</p>
</blockquote>
<ol>
<li><p><code>DS</code>信号初始状态啥样、何时、什么情况下发生跳变?</p>
<ul>
<li>DS的初始信号为<code>O/PP</code>， 上拉高电平<br>*</li>
</ul>
</li>
<li><p>HOST端接受数据为啥要与<code>DS</code>的边沿对齐?</p>
</li>
<li><p>为啥只支持<code>8bit</code>？</p>
</li>
<li><p>为啥不需要和HS200 mode一样使用tuning?</p>
</li>
<li><p><code>DS</code>和<code>tuning</code>?</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>SD卡的硬件电路及相关属性</title>
    <url>/post/47964.html</url>
    <content><![CDATA[<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><h2 id="电路连接"><a href="#电路连接" class="headerlink" title="电路连接"></a>电路连接</h2><h2 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h2><h2 id="总线信号的变化"><a href="#总线信号的变化" class="headerlink" title="总线信号的变化"></a>总线信号的变化</h2><h2 id="CMD线的数据传输"><a href="#CMD线的数据传输" class="headerlink" title="CMD线的数据传输"></a>CMD线的数据传输</h2>]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>sd</tag>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title>MMC子系统</title>
    <url>/post/24681.html</url>
    <content><![CDATA[<h2 id="MMC子系统"><a href="#MMC子系统" class="headerlink" title="MMC子系统"></a>MMC子系统</h2><p>系统框架：</p>
<p><img src="/images/mmc_framework.png" alt="mmc子系统"></p>
<a id="more"></a>
<p>Linux MMC子系统主要分成三个部分：</p>
<ul>
<li>MMC核心层：完成不同协议和规范的实现，为host层和设备驱动层提供接口函数。MMC核心层由三个部分组成：MMC，SD和SDIO，分别为三类设备驱动提供接口函数；</li>
<li>Host 驱动层：针对不同主机端的SDHC、MMC控制器的驱动；</li>
<li>Client 驱动层：针对不同客户端的设备驱动程序。如SD卡、T-flash卡、SDIO接口的GPS和wi-fi等设备驱动。</li>
</ul>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── card</span><br><span class="line">├── core</span><br><span class="line">└── host</span><br></pre></td></tr></table></figure>
<p>MMC子系统代码主要在drivers/mmc目录下，共有三个目录：</p>
<ul>
<li>Card：与块设备调用相关驱动，如MMC/SD卡设备驱动，SDIOUART；</li>
<li>Core：整个MMC的核心层，这部分完成不同协议和规范的实现，为host层和设备驱动层提供接口函数。</li>
<li>Host：针对不同主机端的SDHC、MMC控制器的驱动，这部分需要由驱动工程师来完成；</li>
</ul>
<h2 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h2><p>在linux系统中，系统启动时将加载相关配置的驱动模块，而各模块的加载将通过各自之间相应的结构关系进行先后顺序进行<a href="/posts/linux_kernel_initcall.md">设备注册</a>，下面是mmc子系统的注册流程</p>
<blockquote>
<p>core —&gt; host —&gt; card</p>
</blockquote>
<ol>
<li>core层的注册主要创建两条虚拟总线mmc_bus和sdio_bus，为host层</li>
<li>host注册主要为相关控制器的初始化及配置参数</li>
<li>card层主要用于与block设备进行绑定，为数据读写准备</li>
</ol>
<h2 id="MMC控制器驱动的软件框架"><a href="#MMC控制器驱动的软件框架" class="headerlink" title="MMC控制器驱动的软件框架"></a>MMC控制器驱动的软件框架</h2><p>在这里主要以符合sdhci标准的mmc控制器为例，结合sdhci驱动说明mmc的工作流程。</p>
<p>驱动的总体框架：</p>
<p><img src="/images/mmc_software_struct.png" alt="mmc驱动软件框架"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>mmc子系统是将msc（mobile storage controller）控制器及其该控制器适配的相关外设中的细节屏蔽掉而抽象出来的一种框架。<br>主要将控制器和卡抽象成为不同的结构mmc_host和mmc_card.</p>
<h3 id="mmc-host"><a href="#mmc-host" class="headerlink" title="mmc_host"></a>mmc_host</h3><p>  该结构体主要为msc控制器所抽象化的一个对象，用于对当前控制器的描述。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>		<span class="title">class_dev</span>;</span></span><br><span class="line"><span class="keyword">int</span>			index;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_host_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_ios</span>		<span class="title">ios</span>;</span>		<span class="comment">/* current io bus settings */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span>		*<span class="title">card</span>;</span>		<span class="comment">/* device attached to this host */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_bus_ops</span> *<span class="title">bus_ops</span>;</span>	<span class="comment">/* current bus driver */</span></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>		<span class="keyword">private</span>[<span class="number">0</span>] ____cacheline_aligned;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上为该结构体的主要成员（由于成员变量过多省略部分）</p>
<ol>
<li>struct mmc_host_ops *ops</li>
</ol>
<p>该接口主要为控制器的操作函数，用于控制器各种行为的控制，由于不同的控制器的设计和使用流程不同，mmc子系统将控制器的实际操作抽象出来，为驱动开发人员，根据实际要求进行功能实现。<br>主要功能：<br>  1）request<br>    为mmc子系统中的request请求进行数据处理，其中包含对cmd命令的发送和data数据的传输（PIO，DMA）<br>  2）set_ios<br>    主要设置控制器的各种参数，包括时钟，电压，总线宽度及驱动类型（驱动类型跟卡自身的属性相关）等。<br>  3）get_sd<br>    主要由于对卡的探测，实现热插拔功能（一般可能过gpio中断实现）</p>
<ol start="2">
<li>struct mmc_bus_ops</li>
</ol>
<p>主要为mmc子系统中的一条虚拟总线的操作接口函数，该接口的实现由mmc子系统自己完成。</p>
<ol start="3">
<li>struct mmc_ios        ios</li>
</ol>
<p>主要为当前总线的设置参数，该总线指控制器和卡实际相接的数据线（cmd，lck，data），主要参数包含set_ios所设置的时钟，电压，总线宽度及驱动类型（驱动类型跟卡自身的属性相关）等参数。</p>
<h3 id="mmc-card"><a href="#mmc-card" class="headerlink" title="mmc_card"></a>mmc_card</h3><p>  主要是与msc控制相连的相关卡的抽象对象，其中主要描述了卡自身的一些属性</p>
<h2 id="初始化控制器"><a href="#初始化控制器" class="headerlink" title="初始化控制器"></a>初始化控制器</h2><h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><p>在mmc驱动的核心是数据的读写，根据sd协议数据的读写流程基本一致。</p>
<blockquote>
<p>cmd + data<br>cmd_line   先发送读写命令<br>data_line  进行数据传输</p>
</blockquote>
<h3 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h3><p>数据读命令:CMD17和CMD18（single block和multiple block）<br><img src="/images/mmc_single_read.png" alt="数据读"><br><strong>注</strong>:多个block和多根数据线读，流程基本一致，主要是在数据传输时，将读的数据分配给了4根数据线。</p>
<h3 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h3><p>数据读命令:CMD24和CMD25（single block和multiple block）<br><img src="/images/mmc_single_write.png" alt="数据写"></p>
<p>注：</p>
<ul>
<li>S: start 起始位[0]</li>
<li>E: end   结束位[1]</li>
</ul>
<table>
<thead>
<tr>
<th>status</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>“010”</td>
<td>数据被接受写入卡中</td>
</tr>
<tr>
<td>“101”</td>
<td>由于CRC错误，数据不被卡接受</td>
</tr>
<tr>
<td>“110”</td>
<td>由于写错误，数据不被卡接受</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在写的过程中由于控制器需要等到卡将数据全部写完，才视一次传输完成。而在卡写的过程中，<br>只有数据完全写入后，标志数据传输完成的busy位才会返回。同时返回的还有此次写数据后的状态status(CRC校验值)。<br>如果CRC的校验值大于”010”,将代表数据传输失败（如果status为“101”， 表示写数据出现CRC错误）</p>
</blockquote>
<h2 id="mmc中的request处理"><a href="#mmc中的request处理" class="headerlink" title="mmc中的request处理"></a>mmc中的request处理</h2><p>在mmc子系统中将msc控制器和卡初始化完成后，进入数据传输阶段。在此阶段主要维护一个属于当前控制器的一个线程kthread_run(mmc_queue_thread, mq, “mmcqd/%d%s”,host-&gt;index, subname ? subname : “”)，mmc_queue_thread线程在一个while(1)循环中现实对block层的request请求队列的数据处理。</p>
<h3 id="维护mmc-queue-thread线程状态"><a href="#维护mmc-queue-thread线程状态" class="headerlink" title="维护mmc_queue_thread线程状态"></a>维护mmc_queue_thread线程状态</h3><ol>
<li>进入该线程将其设置为set_current_state(TASK_INTERRUPTIBLE)</li>
<li>处理request请求数据，set_current_state(TASK_RUNNING)</li>
<li>数据处理完毕后，如果没有需要处理的数据，调用schedule()</li>
</ol>
<h3 id="Block层的request请求队列"><a href="#Block层的request请求队列" class="headerlink" title="Block层的request请求队列"></a>Block层的request请求队列</h3><p>请求队列的组成方式：<br><img src="/images/block_request_queue.png" alt="request请求队列"><br>具体的实现方式在block设备驱动继续。</p>
<h3 id="request请求队列的处理"><a href="#request请求队列的处理" class="headerlink" title="request请求队列的处理"></a>request请求队列的处理</h3><ol>
<li>通过blk_fetch_request(q)从request请求队列中取出一个request请求。</li>
<li>如果request请求队列中有需要处理的数据，调用issue_fn(mq, req)的回调函数进行数据处理。</li>
</ol>
<h3 id="一个request请求的处理流程"><a href="#一个request请求的处理流程" class="headerlink" title="一个request请求的处理流程"></a>一个request请求的处理流程</h3><p>这里以multiple block的读写为例进行说明：</p>
<h4 id="写数据的处理"><a href="#写数据的处理" class="headerlink" title="写数据的处理"></a>写数据的处理</h4><p>在一个写操作中的request基本可以分为三类:</p>
<ul>
<li>a. 使用写命令CMD25写1024block的数据写操作</li>
<li>b. 先进行数据同步操作，接着使用cmd13获取卡的状态,判断没有错误后,再使用CMD25写1024block数据</li>
<li>c. 先进行数据同步操作，再单独发送cmd13命令检测卡的状态</li>
</ul>
<blockquote>
<p>注: 一次request请求所传输的数据量有block层设置.在注册card层初始化mmc_queue时,根据block的设置进行配置.<br>mmc_blk_probe-&gt;mmc_blk_alloc-&gt;mmc_blk_alloc_req-&gt;mmc_init_queue-&gt;blk_queue_max_hw_sectors-&gt;blk_limits_max_hw_sectors-&gt;BLK_DEF_MAX_SECTORS=1024</p>
</blockquote>
<h4 id="读数据的处理"><a href="#读数据的处理" class="headerlink" title="读数据的处理"></a>读数据的处理</h4><p>在进行读操作时的request,分为两类:</p>
<ul>
<li>a. 携带数据和读命令的request， 及CMD18 + data（512block）</li>
<li>b. 进行数据同步的request</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="附：相关简写"><a href="#附：相关简写" class="headerlink" title="附：相关简写"></a>附：相关简写</h2><ol>
<li>mmc<br>mmc（Multi-Media Card）主要指mmc子系统</li>
<li>sd<br>sd（Secure Digital）拥有两层含义：一种指sd卡，另一种指sd卡协议</li>
<li>emmc<br>emmc（Embedded Multi Media Card)）同样一种指emmc卡，另一种指emmc协议，该卡的主要存储介质为nand flash，因此也称e-nand<br>3.sdio<br>sdio（Secure Digital Input and Output Card）一种在sd标准上定义的外设接口。不过其有自己的特有协议标准。主要由于sdio接口的wifi，蓝牙等</li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>emmc</tag>
        <tag>sd</tag>
        <tag>mmc</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层网络模型</title>
    <url>/post/51171.html</url>
    <content><![CDATA[<p>一张非常强大的OSI七层模型图解:</p>
<a id="more"></a>
<p><img src="/images/net/OSI_network_model.gif" alt="OSI七层网络模型"></p>
<table>
<thead>
<tr>
<th style="text-align:center">Later</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">DHCP · DNS · FTP · Gopher · HTTP · IMAP4 · IRC · NNTP · XMPP · POP3 · SIP · SMTP · SNMP · SSH · TELNET · RPC · RTCP · RTP ·RTSP · SDP · SOAP · GTP · STUN · NTP · SSDP</td>
</tr>
<tr>
<td style="text-align:center">表示层</td>
<td style="text-align:center">HTTP/HTML · FTP · Telnet · ASN.1（具有表示层功能）</td>
</tr>
<tr>
<td style="text-align:center">会话层</td>
<td style="text-align:center">ADSP·ASP·H.245·ISO-SP·iSNS·NetBIOS·PAP·RPC·RTCP·SMPP·SCP·SSH·ZIP·SDP（具有会话层功能）</td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">TCP · UDP · TLS · DCCP · SCTP ·RSVP · PPTP</td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">IP (IPv4 · IPv6) · ICMP · ICMPv6 · IGMP ·IS-IS · IPsec · BGP · RIP · OSPF ·ARP · RARP</td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">Wi-Fi(IEEE 802.11) · WiMAX(IEEE 802.16) ·ATM · DTM · 令牌环 · 以太网路 · FDDI · 帧中继 · GPRS · EVDO · HSPA · HDLC · PPP · L2TP · ISDN ·STP</td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">以太网路卡 · 调制解调器 · 电力线通信(PLC) · SONET/SDH（光同步数字传输网） · G.709（光传输网络）· 光导纤维 · 同轴电缆 · 双绞线</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title>sd卡测速</title>
    <url>/post/11560.html</url>
    <content><![CDATA[<p>测试sd卡的读写速度</p>
<a id="more"></a>
<h2 id="mmc驱动测速"><a href="#mmc驱动测速" class="headerlink" title="mmc驱动测速"></a>mmc驱动测速</h2><p>结合mmc子系统提供的测试列表进行速度测试和其他相关测试。</p>
<h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt;DeviceDriver</span><br><span class="line">    -&gt; MMC/SD/SDIO card support (MMC [=y])</span><br><span class="line">    [*]MMC host test driver</span><br></pre></td></tr></table></figure>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>编译并启动新编译的linux内核，进入文件系统。</p>
<ul>
<li>进入mmcblk解除绑定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd sys/bus/mmc/drivers/mmcblk</span><br><span class="line">echo mmc0:e624 &gt; unbind</span><br></pre></td></tr></table></figure>
<ul>
<li>绑定测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd sys/bus/mmc/drivers/mmc_test</span><br><span class="line">echo mmc0:e624 &gt; bind</span><br><span class="line">[  17.243808] mmc_test mmc0:e624: Card claimed for testing.</span><br></pre></td></tr></table></figure>
<h3 id="挂载debugfs"><a href="#挂载debugfs" class="headerlink" title="挂载debugfs"></a>挂载debugfs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mount -t debugfs none /mnt</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>进入测试目录mmc0:e624</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /mnt/mmc0/mmc0:e624</span><br></pre></td></tr></table></figure>
<ul>
<li>查看测试列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cat testlist</span><br><span class="line">	1:      Basic write (no data verification)</span><br><span class="line">	2:      Basic read (no data verification)</span><br><span class="line">	3:      Basic write (with data verification)</span><br><span class="line">	4:      Basic read (with data verification)</span><br><span class="line">	5:      Multi-block write</span><br><span class="line">	6:      Multi-block read</span><br><span class="line">	7:      Power of two block writes</span><br><span class="line">	8:      Power of two block reads</span><br><span class="line">	9:      Weird sized block writes</span><br><span class="line">	10:     Weird sized block reads</span><br><span class="line">	11:     Badly aligned write</span><br><span class="line">	12:     Badly aligned read</span><br><span class="line">	13:     Badly aligned multi-block write</span><br><span class="line">	14:     Badly aligned multi-block read</span><br><span class="line">	15:     Correct xfer_size at write (start failure)</span><br><span class="line">	16:     Correct xfer_size at read (start failure)</span><br><span class="line">	17:     Correct xfer_size at write (midway failure)</span><br><span class="line">	18:     Correct xfer_size at read (midway failure)</span><br><span class="line">	19:     Highmem write</span><br><span class="line">	20:     Highmem read</span><br><span class="line">	21:     Multi-block highmem write</span><br><span class="line">	22:     Multi-block highmem read</span><br><span class="line">	23:     Best-case read performance</span><br><span class="line">	24:     Best-case write performance</span><br><span class="line">	25:     Best-case read performance into scattered pages</span><br><span class="line">	26:     Best-case write performance from scattered pages</span><br><span class="line">	27:     Single read performance by transfer size</span><br><span class="line">	28:     Single write performance by transfer size</span><br><span class="line">	29:     Single trim performance by transfer size</span><br><span class="line">	30:     Consecutive read performance by transfer size</span><br><span class="line">	31:     Consecutive write performance by transfer size</span><br><span class="line">	32:     Consecutive trim performance by transfer size</span><br><span class="line">	33:     Random read performance by transfer size</span><br><span class="line">	34:     Random write performance by transfer size</span><br><span class="line">	35:     Large sequential read into scattered pages</span><br><span class="line">	36:     Large sequential write from scattered pages</span><br><span class="line">	37:     Write performance with blocking req 4k to 4MB</span><br><span class="line">	38:     Write performance with non-blocking req 4k to 4MB</span><br><span class="line">	39:     Read performance with blocking req 4k to 4MB</span><br><span class="line">	40:     Read performance with non-blocking req 4k to 4MB</span><br><span class="line">	41:     Write performance blocking req 1 to 512 sg elems</span><br><span class="line">	42:     Write performance non-blocking req 1 to 512 sg elems</span><br><span class="line">	43:     Read performance blocking req 1 to 512 sg elems</span><br><span class="line">	44:     Read performance non-blocking req 1 to 512 sg elems</span><br><span class="line">	45:     eMMC hardware reset</span><br></pre></td></tr></table></figure>
<ul>
<li>执行测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 34 &gt; test</span><br></pre></td></tr></table></figure>
<h2 id="测试命令-dd"><a href="#测试命令-dd" class="headerlink" title="测试命令  dd"></a>测试命令  dd</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/dev/null</span><br></pre></td></tr></table></figure>
<ul>
<li>输入或输出</li>
</ul>
<blockquote>
<p>dd if=[STDIN] of=[STDOUT]</p>
</blockquote>
<ul>
<li>强迫输入或输出的Size为多少Bytes</li>
</ul>
<blockquote>
<p>bs: dd -ibs=[BYTE] -obs=[SIZE]</p>
</blockquote>
<ul>
<li>强迫一次只做多少个 Bytes</li>
</ul>
<blockquote>
<p>bs=BYTES</p>
</blockquote>
<ul>
<li>跳过一段以后才输出</li>
</ul>
<blockquote>
<p>seek=BLOCKS</p>
</blockquote>
<ul>
<li>跳过一段以后才输入</li>
</ul>
<blockquote>
<p>skip=BLOCKS</p>
</blockquote>
<h3 id="写测试"><a href="#写测试" class="headerlink" title="写测试"></a>写测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/mnt/sd/test.txt bs=512 count=100</span><br></pre></td></tr></table></figure>
<p>写数据量：512*100 / 1024 = 50Kb</p>
<h3 id="读测试"><a href="#读测试" class="headerlink" title="读测试"></a>读测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=/mnt/sd/test.txt of=/dev/null bs=512 count=100</span><br></pre></td></tr></table></figure>
<p>读数据量：512*100 / 1024 = 50Kb</p>
<h2 id="PC测试"><a href="#PC测试" class="headerlink" title="PC测试"></a>PC测试</h2><p>在pc上使用以上命令，将读写的目标改为（/dev/sdb）即可得到当前的读写速度</p>
<h2 id="开发板测试"><a href="#开发板测试" class="headerlink" title="开发板测试"></a>开发板测试</h2><p>由于在开发板中的文件系统使用busybox编译生成，其中的dd命令无法直接得到读写速度，因此需要结合time命令</p>
<h3 id="写测试-1"><a href="#写测试-1" class="headerlink" title="写测试"></a>写测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time dd if=/dev/zero of=/mnt/sd/test.txt bs=512 count=100</span><br></pre></td></tr></table></figure>
<p>写数据量：512*100 / 1024 = 50Kb</p>
<h3 id="读测试-1"><a href="#读测试-1" class="headerlink" title="读测试"></a>读测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time dd if=/mnt/sd/test.txt of=/dev/null bs=512 count=100</span><br></pre></td></tr></table></figure>
<p>读数据量：512*100 / 1024 = 50Kb</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>在对sd进行测速时，使用以上命令进行读写操作，文件系统会将该数据块进行一定大小（128个block为一个单元，即一个request请求）的分割，并将其传入sd驱动。在mmc驱动中配置msc控制器的block count大小时，其值为VFS层传入的128blk。</li>
</ol>
<p>也就是说一个大于128个block数据块的读写，在mmc驱动中使用若干个request请求进行读写操作完成。</p>
<ol start="2">
<li>写测试增加conv=fsync参数</li>
</ol>
<p>该参数可通过dd -h查看，作用将写的数据完全写入到sd完成返回，但是使用后根据写操作所得到的时间计算的写速度将降低<br>主要原因是，使用fsync后文件系统会将写的数据块根据bs的大小进行分割，也就是将其分割成count个bs。如果bs为512时，一次request请求的block count为512，加大了request请求次数，同时将增加sd驱动中的中断次数和读及等状态的次数，继而增大了写操作的时间，最后计算的写速度将降低。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读写速率和以下情况有关：</p>
<ol>
<li>外部通信时钟；</li>
<li>DDR时钟，</li>
<li>代码运行速率，和CPU时钟、L2CACHE时钟有关</li>
<li>当前系统负荷</li>
<li>内部的总线时钟，比如MMC控制器所在的APB总线等</li>
<li>MMC控制器的DMA工作时钟</li>
<li>读写代码的流程</li>
<li>MSC的通信数据线的位数</li>
<li>读写的位置是否连续。</li>
</ol>
<p>其中瓶颈是在（1）SD的通信速率（7）代码的流程（8）SD卡通信所占用的数据线（9）读写的位置是否连续</p>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>sd</tag>
        <tag>mmc</tag>
        <tag>dd</tag>
      </tags>
  </entry>
  <entry>
    <title>网络调试--tcpdump</title>
    <url>/post/18035.html</url>
    <content><![CDATA[<p>网络调试的手段工具：<code>tcpdump</code>、<code>wireshark</code></p>
<a id="more"></a>
<h2 id="抓包–tcpdump"><a href="#抓包–tcpdump" class="headerlink" title="抓包–tcpdump"></a>抓包–tcpdump</h2><p>下载：<a href="http://www.tcpdump.org" target="_blank" rel="noopener">http://www.tcpdump.org</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i wlan0 -p  -w file.pcap</span><br></pre></td></tr></table></figure>
<p>常用参数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">arg</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-p</td>
<td style="text-align:left">将网卡设置为非混杂模式</td>
</tr>
<tr>
<td style="text-align:center">-n</td>
<td style="text-align:left">对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。</td>
</tr>
<tr>
<td style="text-align:center">-nn</td>
<td style="text-align:left">除了-n的作用外，还把端口显示为数值，否则显示端口服务名。</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:left">指定要抓取的包数量</td>
</tr>
<tr>
<td style="text-align:center">-v</td>
<td style="text-align:left">当分析和打印的时候，产生详细的输出</td>
</tr>
<tr>
<td style="text-align:center">-vv</td>
<td style="text-align:left">产生比-v更详细的输出</td>
</tr>
<tr>
<td style="text-align:center">-w</td>
<td style="text-align:left">将抓包数据输出到文件中而不是标准输出。可以同时配合<code>-G time</code>选项使得输出文件每time秒就自动切换到另一个文件</td>
</tr>
</tbody>
</table>
<h3 id="Install-for-arm"><a href="#Install-for-arm" class="headerlink" title="Install for arm"></a>Install for arm</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> host</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> libpcap error: configure: error: Neither flex nor lex was found.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sudo apt install flex bison</span></span><br><span class="line"></span><br><span class="line">PWD=$(pwd)</span><br><span class="line"></span><br><span class="line">TCPDUMP="tcpdump-4.9.2"</span><br><span class="line">LIBPCAP="libpcap-1.9.0"</span><br><span class="line"></span><br><span class="line">export CC=arm-linux-gnueabihf-gcc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://www.tcpdump.org</span></span><br><span class="line"></span><br><span class="line">for software in $&#123;TCPDUMP&#125; $&#123;LIBPCAP&#125;</span><br><span class="line">do</span><br><span class="line">	echo "Download $software ..."</span><br><span class="line">	echo "wget http://www.tcpdump.org/release/$&#123;software&#125;.tar.gz"</span><br><span class="line">	wget http://www.tcpdump.org/release/$&#123;software&#125;.tar.gz</span><br><span class="line">	echo "tar xvf $&#123;software&#125;.tar.gz"</span><br><span class="line">	tar xvf $&#123;software&#125;.tar.gz</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">cd $&#123;LIBPCAP&#125;</span><br><span class="line">./configure --host=arm-linux --with-pcap=linux --prefix=$&#123;PWD&#125;/out</span><br><span class="line">make; make install</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">cd $&#123;TCPDUMP&#125;</span><br><span class="line">./configure --host=arm-linux --with-system-libpcap=$&#123;PWD&#125;/../$&#123;LIBPCAP&#125;/out/lib --prefix=$&#123;PWD&#125;/out</span><br><span class="line">make; make install</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">cp $&#123;PWD&#125;/$&#123;TCPDUMP&#125;/out/sbin/tcpdump .</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p><code>-n</code>：直接打印，<code>-w</code>：保存文件</p>
</blockquote>
<ul>
<li><p>抓取wlan0中的所有数据包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tcpdump -i wlan0 -v -n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>抓取wlan0中的udp包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tcpdump -i wlan0 -v -n udp</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>抓取wlan中的5个udp包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tcpdump -i wlan0 -v -n udp -c 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定端口号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i wlan0 tcp port 7236 -w rrrr.pcap</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="分析–wireshark"><a href="#分析–wireshark" class="headerlink" title="分析–wireshark"></a>分析–wireshark</h2><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># netstat -n</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 192.168.100.3:40964     192.168.100.2:7236      ESTABLISHED</span><br><span class="line">udp        0      0 239.0.0.11:15550        192.168.100.2:*         ESTABLISHED</span><br><span class="line">udp        0      0 239.0.0.11:15551        192.168.100.2:1         ESTABLISHED</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】网络库libevent、libev、libuv对比</title>
    <url>/post/12060.html</url>
    <content><![CDATA[<p>地址：<a href="https://blog.csdn.net/lijinqi1987/article/details/71214974" target="_blank" rel="noopener">https://blog.csdn.net/lijinqi1987/article/details/71214974</a></p>
<blockquote>
<p>三者都是*异步事件库（Asynchronous event library）。</p>
</blockquote>
<a id="more"></a>
<h2 id="异步事件库"><a href="#异步事件库" class="headerlink" title="异步事件库"></a>异步事件库</h2><ol>
<li>异步事件通知</li>
<li>可移植</li>
</ol>
<p>异步事件库本质上是提供异步事件通知（Asynchronous Event Notification，AEN）的。可移植（Portable）、可扩展（Scalable）这些特性只是为了使库更通用、易用，并非必须。</p>
<h3 id="异步事件通知"><a href="#异步事件通知" class="headerlink" title="异步事件通知"></a>异步事件通知</h3><p>异步事件通知机制就是根据发生的事件，调用相应的回调函数进行处理。</p>
<ol>
<li>事件（Event）：事件是异步事件通知机制的核心，比如fd事件、超时事件、信号事件、<br>定时器事件。有时候也称事件为事件处理器（Event Handler），这个名称更形象，因为Handler本身表示了包含处理所需数据（或数据的地址）和处理的方法（回调函数），更像是面向对象思想中的称谓。<ul>
<li>数据（Data）：提供给回调函数的输入数据，可以是实际的数据，也可以指针，为了提供统一的API，一般为 void * 指针。</li>
<li>回调函数（Callback Function）：事件发生时调用的方法。注意回调只是一种机制，跟异步没有太大关系，同步也可以采用回调机制（API）。</li>
</ul>
</li>
<li>事件循环（Event Loop）：等待并分发事件。事件循环用于管理事件。</li>
</ol>
<p>对于应用程序来说，这些只是异步事件库提供的API，封装了异步事件库跟操作系统的交互，异步事件库会选择一种操作系统提供的机制来实现某一种事件，比如利用Unix/Linux平台的epoll机制实现网络IO事件，在同时存在多种机制可以利用时，异步事件库会采用最优机制。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件种类"><a href="#事件种类" class="headerlink" title="事件种类"></a>事件种类</h3><table>
<thead>
<tr>
<th style="text-align:left">type</th>
<th style="text-align:left">libevent</th>
<th style="text-align:left">libev</th>
<th style="text-align:left">libuv</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IO</td>
<td style="text-align:left">fd</td>
<td style="text-align:left">io</td>
<td style="text-align:left">fs_event</td>
</tr>
<tr>
<td style="text-align:left">计时器（mono clock）</td>
<td style="text-align:left">timer</td>
<td style="text-align:left">timer</td>
<td style="text-align:left">timter</td>
</tr>
<tr>
<td style="text-align:left">计时器（wall clock）</td>
<td style="text-align:left">–</td>
<td style="text-align:left">periodic</td>
<td style="text-align:left">–</td>
</tr>
<tr>
<td style="text-align:left">信号</td>
<td style="text-align:left">signal</td>
<td style="text-align:left">signal</td>
<td style="text-align:left">signal</td>
</tr>
<tr>
<td style="text-align:left">进程控制</td>
<td style="text-align:left">–</td>
<td style="text-align:left">child</td>
<td style="text-align:left">process</td>
</tr>
<tr>
<td style="text-align:left">文件stat</td>
<td style="text-align:left">–</td>
<td style="text-align:left">stat</td>
<td style="text-align:left">fs_poll</td>
</tr>
<tr>
<td style="text-align:left">每次循环都会执行的Idle事件</td>
<td style="text-align:left">–</td>
<td style="text-align:left">idle</td>
<td style="text-align:left">idle</td>
</tr>
<tr>
<td style="text-align:left">循环block之前执行</td>
<td style="text-align:left">–</td>
<td style="text-align:left">prepare</td>
<td style="text-align:left">prepare</td>
</tr>
<tr>
<td style="text-align:left">循环blcck之后执行</td>
<td style="text-align:left">–</td>
<td style="text-align:left">check</td>
<td style="text-align:left">check</td>
</tr>
<tr>
<td style="text-align:left">嵌套loop</td>
<td style="text-align:left">–</td>
<td style="text-align:left">embed</td>
<td style="text-align:left">–</td>
</tr>
<tr>
<td style="text-align:left">fork</td>
<td style="text-align:left">–</td>
<td style="text-align:left">fork</td>
<td style="text-align:left">–</td>
</tr>
<tr>
<td style="text-align:left">loop销毁之前的清理工作</td>
<td style="text-align:left">–</td>
<td style="text-align:left">cleanup</td>
<td style="text-align:left">–</td>
</tr>
<tr>
<td style="text-align:left">操作另一个线程中的loop</td>
<td style="text-align:left">–</td>
<td style="text-align:left">async</td>
<td style="text-align:left">async</td>
</tr>
<tr>
<td style="text-align:left">双向通信</td>
<td style="text-align:left">–</td>
<td style="text-align:left">–</td>
<td style="text-align:left">stream ( tcp, pipe, tty )</td>
</tr>
</tbody>
</table>
<p>这个对比对于libev和libuv更有意义，对于libevent，很多都是跟其设计思想有关的。<br>libev中的embed很少用，libuv没有也没关系；cleanup完全可以用libuv中的async_exit来替代；libuv没有fork事件。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在libevent中，激活的事件是组织在优先级队列中的，各类事件默认的优先级是相同的，可以通过设置事件的优先级使其优先被处理。</p>
<p>libev也通过优先级队列来管理激活的时间，也可以设置事件的优先级。</p>
<p>libuv没有优先级的概念，而是按照固定的顺序访问各类事件。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="略有不同"><a href="#略有不同" class="headerlink" title="略有不同"></a>略有不同</h4><p>对于事件循环，libev和libuv是相同的，即管理事件（等待并分发事件）。</p>
<p>但是在libevent里还有一个概念是event_base，是用于管理事件的，而lievent中的loop只是一个执行过程（仅仅是函数），并非一个实体（数据和函数）。</p>
<blockquote>
<p>Before you can use any interesting Libevent function, you need to allocate one or more event_base structures. Each event_base structure holds a set of events and can poll to determine which events are active.</p>
</blockquote>
<blockquote>
<p>If an event_base is set up to use locking, it is safe to access it between multiple threads. Its loop can only be run in a single thread, however. If you want to have multiple threads polling for IO, you need to have an event_base for each thread.</p>
</blockquote>
<blockquote>
<p>Tip</p>
</blockquote>
<blockquote>
<p>[A future version of Libevent may have support for event_bases that run events across multiple threads.]</p>
</blockquote>
<p>根据官网的介绍（不考虑其中提到的特殊版本），并对照源码中event_base_loop的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">event_base_loop(struct event_base *base, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Grab the lock.  We will release it inside evsel.dispatch, and again</span></span><br><span class="line"><span class="comment">	* as we invoke user callbacks. */</span></span><br><span class="line">	EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (base-&gt;running_loop) &#123;</span><br><span class="line">	event_warnx(<span class="string">"%s: reentrant invocation.  Only one event_base_loop"</span></span><br><span class="line">	    <span class="string">" can run on each event_base at once."</span>, __func__);</span><br><span class="line">	EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	done:</span><br><span class="line">	clear_time_cache(base);</span><br><span class="line">	base-&gt;running_loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在loop执行过程中，传入的base已被加锁，是不能用于其他执行过程的。</p>
<p>所以基本上libev和libuv里的loop相当于libevent中的loop函数和event_base的结合。</p>
<p>下文中提到的loop仅指libev和libuv中的loop。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>libevent、libev、libuv里的event_base和loop都不是线程安全的，也就是说一个event_base或loop实例只能在用户的一个线程内访问（一般是主线程），注册到event_base或loop的event都是串行访问的，即每个执行过程中，会按照优先级顺序访问已经激活的事件，执行其回调函数。所以在仅使用一个event_base或loop的情况下，回调函数的执行不存在并行关系。</p>
<p>如果应用程序除了主loop外，没有自己启动任何线程，那么不用担心回调里的“临界区”。</p>
<p>如果使用了多个event_base或loop（一般每个线程一个event_base或loop），需要考虑共享数据的同步问题。</p>
<h2 id="可移植"><a href="#可移植" class="headerlink" title="可移植"></a>可移植</h2><h3 id="支持的操作系统"><a href="#支持的操作系统" class="headerlink" title="支持的操作系统"></a>支持的操作系统</h3><p>三个库都支持Linux, *BSD, Mac OS X, Solaris, Windows</p>
<table>
<thead>
<tr>
<th style="text-align:left">type</th>
<th style="text-align:left">libevent</th>
<th style="text-align:left">libev</th>
<th style="text-align:left">libuv</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">dev/poll (Solaris)</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
</tr>
<tr>
<td style="text-align:left">event ports</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
</tr>
<tr>
<td style="text-align:left">kqueue (*BSD)</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
</tr>
<tr>
<td style="text-align:left">POSIX select</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
</tr>
<tr>
<td style="text-align:left">Windows select</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
</tr>
<tr>
<td style="text-align:left">Windows IOCP</td>
<td style="text-align:left">y</td>
<td style="text-align:left">N</td>
<td style="text-align:left">y</td>
</tr>
<tr>
<td style="text-align:left">poll</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
</tr>
<tr>
<td style="text-align:left">epoll</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
<td style="text-align:left">y</td>
</tr>
</tbody>
</table>
<p>对于Unix/Linux平台，没有什么大不同，优先选择epoll，对于windows，libevent、libev都使用select检测和分发事件（不I/O），libuv在windows下使用IOCP。libevent有一个socket handle, 在windows上使用IOCP进行读写。libev没有类似的。但是libevent的IOCP支持也不是很好（性能不高）。所以如果是在windows平台下，使用原生的IOCP进行I/O，或者使用libuv。</p>
<h2 id="异步架构程序设计原则"><a href="#异步架构程序设计原则" class="headerlink" title="异步架构程序设计原则"></a>异步架构程序设计原则</h2><ol>
<li>回调函数不可以执行过长时间，因为一个loop中可能包含其他事件，尤其是会影响一些准确度要求比较高的timer。</li>
<li>尽量采用库中所缓存的时间，有时候需要根据时间差来执行timeout之类的操作。当然能够利用库中的timer最好。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>lib</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket Buffer</title>
    <url>/post/21941.html</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP调用connect的作用</title>
    <url>/post/33300.html</url>
    <content><![CDATA[<blockquote>
<p>问： UDP中可以使用<code>connect</code>系统调用吗?</p>
</blockquote>
<blockquote>
<p>答： 可以</p>
</blockquote>
<blockquote>
<p>问： 为什么使用？</p>
</blockquote>
<blockquote>
<p>答： 提高效率</p>
</blockquote>
<a id="more"></a>
<h2 id="UDP中connect操作与TCP中connect操作有着本质区别？"><a href="#UDP中connect操作与TCP中connect操作有着本质区别？" class="headerlink" title="UDP中connect操作与TCP中connect操作有着本质区别？"></a>UDP中connect操作与TCP中connect操作有着本质区别？</h2><blockquote>
<ol>
<li>TCP中调用connect会引起三次握手,client与server建立连结</li>
<li>UDP中调用connect内核仅仅把对端<code>ip&amp;port</code>记录下来.</li>
</ol>
</blockquote>
<h2 id="UDP中可以多次调用connect-TCP只能调用一次onnect"><a href="#UDP中可以多次调用connect-TCP只能调用一次onnect" class="headerlink" title="UDP中可以多次调用connect,TCP只能调用一次onnect"></a>UDP中可以<code>多次</code>调用connect,TCP只能调用<code>一次</code>onnect</h2><blockquote>
<p>UDP多次调用connect有两种用途:</p>
<blockquote>
<ol>
<li>指定一个新的ip&amp;port连结.</li>
<li>断开和之前的ip&amp;port的连结.</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remoteAddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(remoteAddr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(remoteAddr.sin_zero));</span><br><span class="line">remoteAddr.sin_family = AF_INET;  <span class="comment">/* 建立新的连接 */</span></span><br><span class="line"><span class="comment">//remoteAddr.sin_family = AF_INET;  /* 断开旧的连接 */</span></span><br><span class="line">inet_pton(AF_INET,player-&gt;rtpUdp.rip, &amp;remoteAddr.sin_addr);</span><br><span class="line">remoteAddr.sin_port = htons(player-&gt;rtpUdp.rport);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ret = <span class="built_in">connect</span>(player-&gt;rtpUdp.fd,(struct sockaddr *)&amp;remoteAddr,remoteAddrLen);</span><br><span class="line">&#125; <span class="keyword">while</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br></pre></td></tr></table></figure>
<h2 id="UDP中使用connect可以提高效率原因"><a href="#UDP中使用connect可以提高效率原因" class="headerlink" title="UDP中使用connect可以提高效率原因"></a>UDP中使用connect可以提高效率原因</h2><ul>
<li><p>普通的UDP发送两个报文内核处理如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1:建立连结 -&gt; #2:发送报文 -&gt; #3:断开连结 -&gt; #4:建立连结 -&gt; #5:发送报文 -&gt; #6:断开连结</span><br></pre></td></tr></table></figure>
</li>
<li><p>采用connect方式的UDP发送两个报文内核处理如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1:建立连结 -&gt; #2:发送报文 -&gt; #3:发送另外一个报文</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>每次发送报文内核都由可能要做路由查询</p>
</blockquote>
<h2 id="UDP中使用connect的好处："><a href="#UDP中使用connect的好处：" class="headerlink" title="UDP中使用connect的好处："></a>UDP中使用connect的好处：</h2><ol>
<li>会提升效率</li>
<li>高并发服务中会增加系统稳定性.<blockquote>
<p>原因: ???</p>
<p>假设client A 通过非connect的UDP与server B,C通信.B,C提供相同服务.为了负载均衡,我们让A与B,C交替通信.A 与 B通信IPa:PORTa —- IPb:PORTb；</p>
<p>A 与 C通信IPa:PORTa’— IPc:PORTc</p>
<p>假设PORTa 与 PORTa’相同了(在大并发情况下会发生这种情况),那么就有可能出现A等待B的报文,却收到了C的报文.导致收报错误.解决方法内就是采用connect的UDP通信方式.在A中创建两个udp,然后分别connect到B,C.</p>
</blockquote>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/u013920085/article/details/44834815" target="_blank" rel="noopener">UDP 调用 connect</a></li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>一行代码的作用</title>
    <url>/post/c6279e60.html</url>
    <content><![CDATA[<h2 id="网页自由编辑"><a href="#网页自由编辑" class="headerlink" title="网页自由编辑"></a>网页自由编辑</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.body.contentEditable=`true`</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>在任意需要编辑的网页中点击<code>F12</code></li>
<li>在调试面板选中<code>Console</code>，然后输入上面的这行代码，回车。</li>
<li>现在当前整个网页可以随便编辑了</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>进程退出的exitcode</title>
    <url>/post/7653.html</url>
    <content><![CDATA[<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p>内核打印</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="出错位置"><a href="#出错位置" class="headerlink" title="出错位置"></a>出错位置</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">panic(<span class="string">"Attempted to kill init! exitcode=0x%08x\n"</span>,</span><br><span class="line">    father-&gt;signal-&gt;group_exit_code ?:</span><br><span class="line">        father-&gt;exit_code);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel/exit.c</p>
</blockquote>
<h3 id="exit-cede赋值"><a href="#exit-cede赋值" class="headerlink" title="exit_cede赋值"></a>exit_cede赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">long</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	 tsk-&gt;exit_code = code;</span><br><span class="line">	...</span><br><span class="line">	exit_notify(tsk, group_dead);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数调用关系:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit_notify</span><br><span class="line">	|-&gt; forget_original_parent(tsk);</span><br><span class="line">				|-&gt; find_new_reaper(father);</span><br><span class="line">							|-&gt; &quot;Attempted to kill init! exitcode=0x%08x\n&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="错误来源"><a href="#错误来源" class="headerlink" title="错误来源"></a>错误来源</h2><p>在Android系统中,linux内核启动过程中,进入<code>用户空间</code>后,init进程执行过程中出现该错误</p>
<p><strong>由于在用户空间引起的内核错误,因此只能通过系统调用产生</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(<span class="built_in">exit</span>, <span class="keyword">int</span>, error_code)</span><br><span class="line">&#123;</span><br><span class="line">    do_exit((error_code&amp;<span class="number">0xff</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入内核是do_exit取了用户空间传入的错误码的<code>低8位</code></p>
<h2 id="进程退出的错误码"><a href="#进程退出的错误码" class="headerlink" title="进程退出的错误码"></a>进程退出的错误码</h2><p>在系统中的进程在正常和非正常退出时，都有一个表示当前进程退出状态的标识，即<code>退出码</code></p>
<h3 id="查看进程退出码"><a href="#查看进程退出码" class="headerlink" title="查看进程退出码"></a>查看进程退出码</h3><p>退出码代表的是一个进程退出的状态码, 可以使用wait函数进行查看。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status)，</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>status表明了进程终止时的状态。当子进程使用_exit()后，父进程如果在用wait()等待子进程，那么wait()将会返回status状态，注意只有status的低8位（0~255）会返回给父进程</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    pid = fork( );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid=%d\n"</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error : "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is son, his count is: %d (%p). and his pid is: %d\n"</span>,</span><br><span class="line">                ++count, &amp;count, getpid());</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = wait(&amp;status);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is father, his count is: %d (%p), his pid is: %d, son exit status: %d[%08x]\n"</span>,</span><br><span class="line">                count, &amp;count, getpid(), status, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常退出结果：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$./a.out</span><br><span class="line">pid=4018</span><br><span class="line">pid=0</span><br><span class="line">This is son, his count is: 2 (0x7fff19658714). and his pid is: 4018</span><br><span class="line">This is father, his count is: 1 (0x7fff19658714), his pid is: 4017, son exit status: 0[00000000]</span><br></pre></td></tr></table></figure></p>
<p>在子进程sleep时将其kill掉的结果：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$./a.out &amp;</span><br><span class="line">[1] 4066</span><br><span class="line">00:11 [xxx@machine]~/work/MyCode/systemcall/test</span><br><span class="line">=====&gt;$pid=4067</span><br><span class="line">pid=0</span><br><span class="line">This is son, his count is: 2 (0x7ffe19987d04). and his pid is: 4067</span><br><span class="line"></span><br><span class="line">00:11 [xxx@machine]~/work/MyCode/systemcall/test</span><br><span class="line">=====&gt;$kill 4067</span><br><span class="line">This is father, his count is: 1 (0x7ffe19987d04), his pid is: 4066, son exit status: 15[0000000f]</span><br></pre></td></tr></table></figure></p>
<p>在进程正常退出时，子进程的状态码是<code>0</code>，而kill掉后变为了<code>15</code>.</p>
<blockquote>
<p>注：此时如果在linux终端下使用<code>echo $?</code>,获取的仅仅该进程的main函数的返回值。</p>
</blockquote>
<h3 id="退出码的含义"><a href="#退出码的含义" class="headerlink" title="退出码的含义"></a>退出码的含义</h3><p>根据前面分析，在进程调用_exit退出时,是通过exit系统调用实现的，而这里的<code>0</code>和<code>15</code>,就是系统调用exit的参数<code>error_code</code></p>
<p><strong>进程的退出状态不等于退出码，程退出时候的状态码是8位，高4位存储退出码，低4位存储导致进程退出的信号标志位</strong></p>
<blockquote>
<p>网上有人说16位，分别是高八位和低八位，还需确认</p>
</blockquote>
<p>根据这段话的描述，之前测试中子进程的退出状态<code>0</code>和<code>15</code>中，退出码均为<code>0</code>,而退出时的singal不同，正常退出时为0，kill掉后变为15</p>
<h3 id="制造段错误"><a href="#制造段错误" class="headerlink" title="制造段错误"></a>制造段错误</h3><p>在测试case中的子进程中，制造一个段错误，根据此时的分析子进程退出的状态码中的signal应该代表段错误<br>子进程中添加：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">*a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>测试结果：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$./a.out</span><br><span class="line">pid=4500</span><br><span class="line">pid=0</span><br><span class="line">This is son, his count is: 2 (0x7fff54e86d1c). and his pid is: 4500</span><br><span class="line">This is father, his count is: 1 (0x7fff54e86d1c), his pid is: 4499, son exit status: 139[0000008b]</span><br></pre></td></tr></table></figure></p>
<p>此时子进程的<code>退出码=8</code>，而<code>signal=b</code></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>linux内核中x86的信号列表：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSEGV     11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTERM     15</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>arch/x86/include/uapi/asm/signal.h</p>
</blockquote>
<table>
<thead>
<tr>
<th>信号</th>
<th>行为</th>
<th>产生原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGTERM</td>
<td>请求中断</td>
<td>kill() 可以发 SIGTERM 过去；kill 命令默认也使用 SIGTERM 信号</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>无效内存引用</td>
<td>段错误</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>进程在退出时都会将自己当前的状态告诉内核，而此时的<code>状态码</code>包含两种含义：</p>
<ul>
<li>高4位代表当前进程的退出码</li>
<li>低4位代表使当前进程退出所使用的信号</li>
</ul>
<p><strong>在本文最开始提到的错误也是由于<code>SIGSEGV</code>无效内存引用引起的。</strong></p>
<p>mips架构下的信号列表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTERM     15  <span class="comment">/* Termination (ANSI).  */</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>arch/mips/include/uapi/asm/signal.h</p>
</blockquote>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><a href="http://blog.csdn.net/eqiang8271/article/details/8225468" target="_blank" rel="noopener"> linux子进程退出状态值解析：waitpid() status意义解析</a></li>
</ol>
]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>exit_code</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】python练习项目</title>
    <url>/post/9636.html</url>
    <content><![CDATA[<p>转载再次，自己实现练习python<br>本书链接 <a href="http://aosabook.org/blog/" target="_blank" rel="noopener">http://aosabook.org/blog/</a><br>目录页：<a href="http://aosabook.org/blog/" target="_blank" rel="noopener">http://aosabook.org/blog/</a><br>以下是章节目录，每一章都让你热血澎湃，看完介绍你就向往下读。</p>
<ol>
<li>A Template Engine （<a href="http://aosabook.org/en/500L/a-template-engine.html）" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-template-engine.html）</a><br>MVC模型中的view层如何解析html中的静态变量和简单的语句，如下：</li>
</ol>
<p></p><p>Welcome, {name}!</p><p></p>
<p></p><p>Products:</p><p></p>
<p><ul><br>{products}<br></ul><br><a id="more"></a></p>
<p>web中的view层不只是html代码，还有支持其他的代码。比如 {products}是一个变量。 同时view层还支持{if} , {for}, {foreach}等等。django，velocity等是如何解析他们的？<br>大牛用不到500行代码告诉你，是如何实现的？ （不是替换，替换需要每次请求都需要解析）</p>
<ol start="2">
<li><p>Web Spreadsheet （<a href="http://aosabook.org/en/500L/web-spreadsheet.html）" target="_blank" rel="noopener">http://aosabook.org/en/500L/web-spreadsheet.html）</a><br>web的电子表格如何实现的？ 好像比较简单，但是介绍了 web storage 和 web worker，还是很值得一看的</p>
</li>
<li><p>A Web Crawler <a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html</a><br>不多说，几百行代码实现高效的网络爬虫， 高效！</p>
</li>
<li><p>Static Analysis <a href="http://aosabook.org/en/500L/static-analysis.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/static-analysis.html</a><br>成熟的IDE都有代码检查和代码提示，怎么做的？ 看这章</p>
</li>
<li><p>Clustering by Consensus <a href="http://aosabook.org/en/500L/clustering-by-consensus.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/clustering-by-consensus.html</a><br>分布式系统 paxos原理与实现。不知道paxos说明你没接触过分布式体统，接触过分布式还不懂，说明你只会用分布式系统</p>
</li>
<li><p>A Simple Object Modle <a href="http://aosabook.org/en/500L/a-simple-object-model.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-simple-object-model.html</a><br>Python是面向对象语言，对象，继承，多态，怎么用代码实现的，不到500行代码，实际不到400 行， 666.。。</p>
</li>
<li><p>An Archaeology-Inspired Database <a href="http://aosabook.org/en/500L/an-archaeology-inspired-database.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/an-archaeology-inspired-database.html</a><br>如何用python实现一个数据库，支持 query，index, transaction， 2，3百行代码和对每个函数的讲解。看完你就知道知道数据库原理，太值了</p>
</li>
<li><p>Dog Bed Database <a href="http://aosabook.org/en/500L/dbdb-dog-bed-database.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/dbdb-dog-bed-database.html</a><br>类似上一章，不过这次实现的是key-value的非关系型数据库，详细的讲解和2，3百行代码</p>
</li>
<li><p>A 3D Modeller <a href="http://aosabook.org/en/500L/a-3d-modeller.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-3d-modeller.html</a><br>用python实现一个3D设计，显示到屏幕，可以交互。不是很懂，但不明觉厉</p>
</li>
<li><p>A Python Interpreter Written in Python <a href="http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html</a><br>手把手教你如何实现python解析器。</p>
</li>
<li><p>A Pedometer in the Real World <a href="http://aosabook.org/en/500L/a-pedometer-in-the-real-world.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-pedometer-in-the-real-world.html</a><br>你用过手机应用记录你每天走的步数，然后发送到朋友圈吗？ （没有？ 没关系。）这章告诉你如何实现步数记录，怎么算走一步。手机中有加速记，很容易获得你某一时刻在x,y,z三个方向的加速度，用这些参数，如何计算你走了多少步？ 知道吗？ 不知道，看这章，讲解加实现</p>
</li>
<li><p>A Continuous Intergration System <a href="http://aosabook.org/en/500L/a-continuous-integration-system.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-continuous-integration-system.html</a><br>CI System是一个专门用来测试新代码的系统，根据代码提交记录，拿到新的代码，测试，生成报告。这不是关键，关键是 如果test失败，它还会 恢复，然后从失败的那个点在跑，相当于把出错环境重现了。。。</p>
</li>
</ol>
<p>13 A Rejection Sampler <a href="http://aosabook.org/en/500L/a-rejection-sampler.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-rejection-sampler.html</a><br>不是很懂，和机器学习相关，如何 计算你赢得象棋比赛的概率，天气对飞机的影响等类似的问题</p>
<p>14 A visual programming toolkit <a href="http://aosabook.org/en/500L/blockcode-a-visual-programming-toolkit.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/blockcode-a-visual-programming-toolkit.html</a><br>不太明白</p>
<ol start="15">
<li>A Flow Shop Scheduler <a href="http://aosabook.org/en/500L/a-flow-shop-scheduler.html" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-flow-shop-scheduler.html</a><br>flowshop调度问题，好像很出名的样子，最优化问题，如何从局部最优解找全局最优解</li>
</ol>
<p>16 Optical Character Recognition<br>几百行代码使用人工神经网络实现识别手写字母。。。</p>
<p>github源码：500lines/README.md at master · aosabook/500lines · GitHub</p>
<p>作者：小小搬运工<br>链接：<a href="http://www.zhihu.com/question/29372574/answer/88624507" target="_blank" rel="noopener">http://www.zhihu.com/question/29372574/answer/88624507</a><br>来源：知乎<br>著作权归作者所有，转载请联系作者获得授权。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据处理</title>
    <url>/post/60233.html</url>
    <content><![CDATA[<p><a href="https://supergis.gitbooks.io/git_notebook/content/doc/opendatasource.html" target="_blank" rel="noopener">https://supergis.gitbooks.io/git_notebook/content/doc/opendatasource.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器和Cache</title>
    <url>/post/12702.html</url>
    <content><![CDATA[<p>在平时的工作中经常进行<code>寄存器</code>和<code>Cache</code>的相关操作，这里主要说明其二者的具体操作和实现的不同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>*)(<span class="number">0xb3450000</span> + <span class="number">0x20</span>) = <span class="number">0x5a5a5a5a</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>写寄存器时经过Cache吗？，为什么？怎么实现的？</li>
<li>如果经常Cache，是CPU进行同步，还是软件进行同步？</li>
</ol>
</blockquote>
<a id="more"></a>
<p><img src="/images/cpu_memory_struct.png" alt="cpu_memory_struct"></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote>
<p>寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的<code>高速存贮部件</code>，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</p>
</blockquote>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><blockquote>
<p>即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。</p>
</blockquote>
<h2 id="二者联系？"><a href="#二者联系？" class="headerlink" title="二者联系？"></a>二者联系？</h2>]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>SMP--对称多处理器</title>
    <url>/post/14018.html</url>
    <content><![CDATA[<p>SMP的结构中，在CPU运行时都是“对称”的，没有主次之分。所有的CPU通过同一条总线共享同一个内存以及外设。为了减少内存访问的冲突，SMP结构中的各干CPU通常都有自己的高速缓存。</p>
<p>程序的运行：</p>
<blockquote>
<p>各个CPU动态的从系统的<code>就绪队列</code>中调度进程加以执行，一个进程在不同的时间可以在不同的CPU上运行，中断请求则动态的分配给其中的一个CPU，由这个CPU提供中断服务。除一般的内存共享外，处理器间的通信手段还有进程间通信和处理器间的中断请求。</p>
</blockquote>
<p>SMP中的主要问题：</p>
<ul>
<li>同步</li>
<li>cache一致性</li>
<li>中断</li>
</ul>
<a id="more"></a>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><blockquote>
<p>进程间的同步实际是对临界资源的互斥操作</p>
</blockquote>
<p>在单处理器结构中，只要能保证在对临界资源的操作中途不发生进程调度，并且不会发生中断，或者即使发生中断也与操作的对象无关，就保证了操作的互斥性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spin_lock</span><br><span class="line">atomic</span><br></pre></td></tr></table></figure></p>
<p>一般而言，只要能保证对临界资源操作的“原子性”，互斥性就保证了，在单处理器结构中，能够在单条指令完成的操作就认为是“原子操作”。在CPU的设计中为保证原子操作，设计一些原子指令，“测试并设置”， “测试并清除”。</p>
<p>在SMP结构中，对指令间的执行顺序的依赖会存在很大的风险。必须使用锁使其在一个CPU上执行完毕，不能中断，否则可能导致指令顺序错乱。</p>
<h2 id="Cache一致性"><a href="#Cache一致性" class="headerlink" title="Cache一致性"></a>Cache一致性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+  +----+   +----+  +----+</span><br><span class="line">|CPU0|  |CPU1|   |CPU2|  |CPU3|</span><br><span class="line">+----+  +----+   +----+  +----+</span><br><span class="line">  +-+     +-+     +-+      +-+</span><br><span class="line">    |     |         |      |</span><br><span class="line">+---v-----v--+   +--v------v--+</span><br><span class="line">|   L1 Cache |   |  L2 Cache  |</span><br><span class="line">+------+-----+   +------+-----+</span><br><span class="line">       |                |</span><br><span class="line">+------v----------------v-----+</span><br><span class="line">|         L2 Cache            |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Cache-line"><a href="#Cache-line" class="headerlink" title="Cache line"></a>Cache line</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>[Linux内核源代码情景分析]</li>
<li><a href="http://blog.sina.com.cn/s/blog_70dd16910101axyw.html" target="_blank" rel="noopener">基于多核处理器的RTOS多核扩展分析与研究 一</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>cpu</tag>
        <tag>smp</tag>
      </tags>
  </entry>
  <entry>
    <title>shell常用代码</title>
    <url>/post/3776.html</url>
    <content><![CDATA[<div class="note info">
            <p>shell常用代码： </p>
          </div>
<a id="more"></a>
<h2 id="递归便利整个目录及子目录"><a href="#递归便利整个目录及子目录" class="headerlink" title="递归便利整个目录及子目录"></a>递归便利整个目录及子目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function getdir()&#123;</span><br><span class="line">    echo $1</span><br><span class="line">    for file in $1/*</span><br><span class="line">    do</span><br><span class="line">        if test -f $file</span><br><span class="line">        then</span><br><span class="line">            echo $file</span><br><span class="line">            arr=($&#123;arr[*]&#125; $file)</span><br><span class="line">        else</span><br><span class="line">            getdir $file</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line">getdir ./src</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$&#123;arr[@]&#125;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="打开多个窗口并登录ssh执行命令"><a href="#打开多个窗口并登录ssh执行命令" class="headerlink" title="打开多个窗口并登录ssh执行命令"></a>打开多个窗口并登录ssh执行命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">run_cmd_shell=$(tempfile)</span><br><span class="line">cat &gt; $run_cmd_shell &lt;&lt; EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">ssh root@192.168.101.55 'pwd; ls; sleep 10'</span><br><span class="line">EOF</span><br><span class="line">echo "Run cmd shell: $run_cmd_shell"</span><br><span class="line"></span><br><span class="line">for win in &#123;1..5&#125;</span><br><span class="line">do</span><br><span class="line">    gnome-terminal -t "win-$win" --window -e \</span><br><span class="line">        "bash $&#123;run_cmd_shell&#125;"</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="判断是否使用sudo"><a href="#判断是否使用sudo" class="headerlink" title="判断是否使用sudo"></a>判断是否使用sudo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root or not</span></span><br><span class="line">if [[ $EUID -ne 0 ]]; then</span><br><span class="line">  SUDO='sudo -H'</span><br><span class="line">else</span><br><span class="line">  SUDO=''</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">SUD0 apt update -y</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>EUID</code>: 在shell启动时被初始化的当前用户的有效ID,如果是root用户<code>EUID=0</code></p>
<blockquote>
<p>shell命令<code>id -u</code>作用相同</p>
</blockquote>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(( EUID != 0 )) &amp;&amp; exec sudo -E -- "$0" "$@"</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ $&#123;UID&#125; -ne 0 ] &amp;&amp; echo "Please run with sudo" &amp;&amp; exit -1</span><br></pre></td></tr></table></figure>
<h2 id="变量的默认值"><a href="#变量的默认值" class="headerlink" title="${:-}变量的默认值"></a>${:-}变量的默认值</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NUM_THREADS=$&#123;NUM_THREADS:-4&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果NUM_THREADS变量没有被定义，NUM_THREADS值将是<code>：-</code>后得默认值；如果NUM_THREADS变量被定义，NUM_THREADS值将定义值</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$bash -v aa.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">NUM_THREADS=$&#123;NUM_THREADS:-4&#125;</span><br><span class="line">echo "num-thread=$NUM_THREADS"</span><br><span class="line">num-thread=4</span><br><span class="line"></span><br><span class="line">=====&gt;$bash -v aa.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">NUM_THREADS=8</span><br><span class="line">NUM_THREADS=$&#123;NUM_THREADS:-4&#125;</span><br><span class="line">echo "num-thread=$NUM_THREADS"</span><br><span class="line">num-thread=8</span><br></pre></td></tr></table></figure>
<h2 id="将逗号分隔的字符串转成换行"><a href="#将逗号分隔的字符串转成换行" class="headerlink" title="将逗号分隔的字符串转成换行"></a>将逗号分隔的字符串转成换行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OLD_IFS="$IFS"</span><br><span class="line">IFS=","</span><br><span class="line">arr=(`cat 1.txt`)</span><br><span class="line">IFS="$OLD_IFS"</span><br><span class="line">for s in $&#123;arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">    echo $s | tr -d '"'</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cpu_tmp=0</span><br><span class="line">cpu=""</span><br><span class="line">pmon=""</span><br><span class="line">cycles=0</span><br><span class="line">data_dir="test_rpt.$$"</span><br><span class="line"></span><br><span class="line">while read LINE</span><br><span class="line">do</span><br><span class="line">	if echo $LINE|grep 'cpu_tmp'</span><br><span class="line">	then</span><br><span class="line">		cpu_tmp=$&#123;LINE#*:&#125;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if echo $LINE|grep 'cycles'</span><br><span class="line">	then</span><br><span class="line">		cycles=$&#123;LINE#*:&#125;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">done &lt; run.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">多线程：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> init fifo file</span></span><br><span class="line">THREAD1DIR=3 &amp;&amp; FIFONR=4 &amp;&amp; FIFONAME="$$.ff" &amp;&amp; mkfifo $FIFONAME &amp;&amp; str="exec $FIFONR&lt;&gt; $FIFONAME" &amp;&amp; eval $str &amp;&amp; rm $FIFONAME -f</span><br><span class="line">i=0</span><br><span class="line">while [ $i -lt $THREAD1DIR ]; do</span><br><span class="line">	i=$((i+1))</span><br><span class="line">	echo</span><br><span class="line">done &gt;&amp; $FIFONR</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">for</span> (( i=0; i&lt;<span class="variable">$THREAD1DIR</span>; i++ )); <span class="keyword">do</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> start <span class="built_in">test</span> 1st level dir</span></span><br><span class="line">all=`find . -maxdepth 1 -name "?????\.*"`</span><br><span class="line">for i in $all</span><br><span class="line">do</span><br><span class="line">	if [ -d $i ]</span><br><span class="line">	then</span><br><span class="line">		read</span><br><span class="line">		( echo $i" 1runing" &amp;&amp; cd $i/ &amp;&amp; ./$i'.run'.sh $cycles &amp;&amp; cd - &amp;&amp; echo &gt;&amp; $FIFONR ) &amp;</span><br><span class="line">	fi</span><br><span class="line">done &lt;&amp; $FIFONR</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rm fifo file</span></span><br><span class="line">wait &amp;&amp; str="exec $FIFONR&gt;&amp;-" &amp;&amp; eval $str</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">get <span class="built_in">log</span></span></span><br><span class="line">[ -d $data_dir ] &amp;&amp; rm -rf $data_dir || mkdir $data_dir &amp;&amp; cp run.cfg $data_dir -f</span><br><span class="line"></span><br><span class="line">for i in $all</span><br><span class="line">do</span><br><span class="line">	if [ -d $i ]</span><br><span class="line">	then</span><br><span class="line">		des_dir=$data_dir'/'$i'/'</span><br><span class="line">		mkdir $des_dir</span><br><span class="line">		src_dir='./'$i'/'</span><br><span class="line">		file_path=`find $src_dir/ -name *_*.log`</span><br><span class="line">		echo $file_path</span><br><span class="line">		mv $file_path $des_dir</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line">chmod 777 './'$data_dir -R</span><br><span class="line">rm *.ff -f</span><br></pre></td></tr></table></figure>
<h2 id="修改文件名后缀"><a href="#修改文件名后缀" class="headerlink" title="修改文件名后缀"></a>修改文件名后缀</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for file in `find . -name "*.f90"`</span><br><span class="line">do</span><br><span class="line">	newfile=$&#123;file%.*&#125;.f77</span><br><span class="line"><span class="meta">	#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"<span class="variable">$newfile</span>"</span></span></span><br><span class="line">	mv $file $newfile</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/longxibendi/article/details/6387732" target="_blank" rel="noopener">Linux批量更改文件后缀名</a></p>
</blockquote>
<h2 id="检查网段IP占用情况"><a href="#检查网段IP占用情况" class="headerlink" title="检查网段IP占用情况"></a>检查网段IP占用情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">up=0</span><br><span class="line">down=0</span><br><span class="line"></span><br><span class="line">for siteip in $(seq 1 255)</span><br><span class="line">do</span><br><span class="line"><span class="meta">	#</span><span class="bash">site=<span class="string">"192.168.2.<span class="variable">$&#123;siteip&#125;</span>"</span></span></span><br><span class="line">	site="172.16.189.$&#123;siteip&#125;"</span><br><span class="line">	ping -c1 -W1 $&#123;site&#125; &amp;&gt; /dev/null</span><br><span class="line">	if [ "$?" == "0" ]; then</span><br><span class="line">		up=$[$up+1]</span><br><span class="line">		echo "$site is UP, cnt=$up"</span><br><span class="line">	else</span><br><span class="line">		down=$[$down+1]</span><br><span class="line">		echo "$site is DOWN, cnt=$down"</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 除法</span></span><br><span class="line">alive=`awk 'BEGIN&#123;printf "%.2f\n",('$up'/'$(($up + $down))')&#125;'`</span><br><span class="line"></span><br><span class="line">echo "up:$up, down:$down, alive:$alive"</span><br></pre></td></tr></table></figure>
<h2 id="提取本地IP"><a href="#提取本地IP" class="headerlink" title="提取本地IP"></a>提取本地IP</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip=`ifconfig | grep "inet " | grep -v "127.0.0.1"| awk '&#123;print $2&#125;'`</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-v</code>: 排除</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>[shell中各种括号的作用()、(())、[]、<a href="http://blog.csdn.net/taiyang1987912/article/details/39551385" target="_blank" rel="noopener">[]]、{}</a></li>
<li><a href="https://www.cnblogs.com/barrychiao/archive/2012/10/22/2733210.html" target="_blank" rel="noopener">shell变量详解</a></li>
</ol>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>SMP多核启动</title>
    <url>/post/49009.html</url>
    <content><![CDATA[<p>smp的多核启动：</p>
<blockquote>
<p>MIPS框架下的启动流程</p>
</blockquote>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*send_ipi_single)(<span class="keyword">int</span> cpu, <span class="keyword">unsigned</span> <span class="keyword">int</span> action);</span><br><span class="line">    <span class="keyword">void</span> (*send_ipi_mask)(<span class="keyword">const</span> struct cpumask *mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> action);</span><br><span class="line">    <span class="keyword">void</span> (*init_secondary)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">void</span> (*smp_finish)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">void</span> (*cpus_done)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">void</span> (*boot_secondary)(<span class="keyword">int</span> cpu, struct task_struct *idle);</span><br><span class="line">    <span class="keyword">void</span> (*smp_setup)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">void</span> (*prepare_cpus)(<span class="keyword">unsigned</span> <span class="keyword">int</span> max_cpus);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line">    <span class="keyword">int</span> (*cpu_disable)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">void</span> (*cpu_die)(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="smp-init"><a href="#smp-init" class="headerlink" title="smp init"></a>smp init</h3><p><img src="/images/smp/smp-init.png" alt="smp_init"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smp_prepare_cpus  --&gt; (.prepare_cpus)</span><br><span class="line">	|</span><br><span class="line">1. 初始化mailbox并申请mailbox中断</span><br><span class="line">2. 制造每个核启动时的初始化代码</span><br><span class="line">3. 将初始化代码写入reset entry</span><br><span class="line">4. 刷cache</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将CCU中的相应CPU进行reset后， 相应的CPU PC将跳入reset entry执行代码</p>
</blockquote>
<h3 id="init-secondary"><a href="#init-secondary" class="headerlink" title="init_secondary"></a>init_secondary</h3><p>在boot_secondary中，将per CPU进行reset后，系统所有CPU依次启动</p>
<p><img src="/images/smp/smp-init-secondary.png" alt="smp_init"></p>
<h2 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h2><p>系统上电后，boot CPU启动，执行<code>start_kernel</code>（init/main.c），并分别调用<code>boot_cpu_init</code>和<code>setup_arch</code>两个接口，进行possible CPU相关的初始化。</p>
<p><img src="/images/smp/smp-booting.png" alt="smp-booting"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Activate the first processor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">boot_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line">	<span class="comment">/* Mark the boot cpu "present", "online" etc for SMP and UP case */</span></span><br><span class="line">	set_cpu_online(cpu, <span class="literal">true</span>);</span><br><span class="line">	set_cpu_active(cpu, <span class="literal">true</span>);</span><br><span class="line">	set_cpu_present(cpu, <span class="literal">true</span>);</span><br><span class="line">	set_cpu_possible(cpu, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>set_cpu_xxx接口，可以将指定的CPU设置为（或者清除）指定的状态。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following particular system cpumasks and operations manage</span><br><span class="line"> * possible, present, active and online cpus.</span><br><span class="line"> *</span><br><span class="line"> *     cpu_possible_mask- has bit &apos;cpu&apos; set iff cpu is populatable</span><br><span class="line"> *     cpu_present_mask - has bit &apos;cpu&apos; set iff cpu is populated</span><br><span class="line"> *     cpu_online_mask  - has bit &apos;cpu&apos; set iff cpu available to scheduler</span><br><span class="line"> *     cpu_active_mask  - has bit &apos;cpu&apos; set iff cpu available to migration</span><br><span class="line"> *</span><br><span class="line"> *  If !CONFIG_HOTPLUG_CPU, present == possible, and active == online.</span><br><span class="line"> *</span><br><span class="line"> *  The cpu_possible_mask is fixed at boot time, as the set of CPU id&apos;s</span><br><span class="line"> *  that it is possible might ever be plugged in at anytime during the</span><br><span class="line"> *  life of that system boot.  The cpu_present_mask is dynamic(*),</span><br><span class="line"> *  representing which CPUs are currently plugged in.  And</span><br><span class="line"> *  cpu_online_mask is the dynamic subset of cpu_present_mask,</span><br><span class="line"> *  indicating those CPUs available for scheduling.</span><br><span class="line"> *</span><br><span class="line"> *  If HOTPLUG is enabled, then cpu_possible_mask is forced to have</span><br><span class="line"> *  all NR_CPUS bits set, otherwise it is just the set of CPUs that</span><br><span class="line"> *  ACPI reports present at boot.</span><br><span class="line"> *</span><br><span class="line"> *  If HOTPLUG is enabled, then cpu_present_mask varies dynamically,</span><br><span class="line"> *  depending on what ACPI reports as currently plugged in, otherwise</span><br><span class="line"> *  cpu_present_mask is just a copy of cpu_possible_mask.</span><br><span class="line"> *</span><br><span class="line"> *  (*) Well, cpu_present_mask is dynamic in the hotplug case.  If not</span><br><span class="line"> *      hotplug, it&apos;s a copy of cpu_possible_mask, hence fixed at boot.</span><br><span class="line"> *</span><br><span class="line"> * Subtleties:</span><br><span class="line"> * 1) UP arch&apos;s (NR_CPUS == 1, CONFIG_SMP not defined) hardcode</span><br><span class="line"> *    assumption that their single CPU is online.  The UP</span><br><span class="line"> *    cpu_&#123;online,possible,present&#125;_masks are placebos.  Changing them</span><br><span class="line"> *    will have no useful affect on the following num_*_cpus()</span><br><span class="line"> *    and cpu_*() macros in the UP case.  This ugliness is a UP</span><br><span class="line"> *    optimization - don&apos;t waste any instructions or memory references</span><br><span class="line"> *    asking if you&apos;re online or how many CPUs there are if there is</span><br><span class="line"> *    only one CPU.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">online</td>
<td style="text-align:center">可以被调度的</td>
</tr>
<tr>
<td style="text-align:center">active</td>
<td style="text-align:center">可以被迁移的</td>
</tr>
<tr>
<td style="text-align:center">present</td>
<td style="text-align:center">内核已接管的</td>
</tr>
<tr>
<td style="text-align:center">possible</td>
<td style="text-align:center">系统存在的CPU，但没有被内核接管</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">setup_arch</span><span class="params">(<span class="keyword">char</span> **cmdline_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EARLY_PRINTK</span></span><br><span class="line">	setup_early_printk();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	cpu_probe();</span><br><span class="line">	prom_init();</span><br><span class="line"></span><br><span class="line">	cpu_report();</span><br><span class="line">	check_bugs_early();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_VT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_VGA_CONSOLE)</span></span><br><span class="line">	conswitchp = &amp;vga_con;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_DUMMY_CONSOLE)</span></span><br><span class="line">	conswitchp = &amp;dummy_con;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	arch_mem_init(cmdline_p);</span><br><span class="line"></span><br><span class="line">	resource_init();</span><br><span class="line">	plat_smp_setup();</span><br><span class="line"></span><br><span class="line">	cpu_cache_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/kernel/setup.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">prom_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	prom_init_cmdline((<span class="keyword">int</span>)fw_arg0, (<span class="keyword">char</span> **)fw_arg1);</span><br><span class="line">	mips_machtype = MACH_XBURST;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	register_smp_ops(&amp;xburst2_smp_ops);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/xburst2/core/prom.c</p>
</blockquote>
<p>将<code>struct plat_smp_ops</code>结构体注册SMP框架</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* preload SMP state for boot cpu */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smp_prepare_boot_cpu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_cpu_possible(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">	set_cpu_online(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">	cpu_set(<span class="number">0</span>, cpu_callin_map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/kernel/smp.c</p>
</blockquote>
<h2 id="开关核"><a href="#开关核" class="headerlink" title="开关核"></a>开关核</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /sys/devices/system/cpu/cpu1/online //关</span><br><span class="line">echo 1 &gt; /sys/devices/system/cpu/cpu1/online //开</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> __ref <span class="title">store_online</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">				  struct device_attribute *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	cpu_hotplug_driver_lock();</span><br><span class="line">	<span class="keyword">switch</span> (buf[<span class="number">0</span>]) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">		ret = cpu_down(cpuid);</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">		from_nid = cpu_to_node(cpuid);</span><br><span class="line">		ret = cpu_up(cpuid);</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	cpu_hotplug_driver_unlock();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(online, <span class="number">0644</span>, show_online, store_online)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: drivers/base/cpu.c</p>
</blockquote>
<h3 id="echo-0-gt-online"><a href="#echo-0-gt-online" class="headerlink" title="echo 0 &gt; online"></a>echo 0 &gt; online</h3><p>实现接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __cpu_disable(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mp_ops-&gt;cpu_disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __cpu_die(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">    mp_ops-&gt;cpu_die(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">play_dead</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/include/asm/smp.h</p>
</blockquote>
<p>调用关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpu_down</span><br><span class="line">	\-&gt;_cpu_down(cpu, 0)</span><br><span class="line">		\-&gt;take_cpu_down</span><br><span class="line">			\-&gt;__cpu_disable()</span><br><span class="line">				\-&gt;mp_ops-&gt;cpu_disable()</span><br><span class="line">        \-&gt;__cpu_die(cpu)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: /kernel/cpu.c</p>
</blockquote>
<p>将被关闭的CPU的中断迁移走后，使其处理完成最后的（飞行状态）任务，进入idle模式，在idle模式判断自己是否需要关闭，如果需要将执行到<code>play_dead</code>将自己杀掉（关闭中断）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_idle_loop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cpu_is_offline(smp_processor_id()))</span><br><span class="line">            arch_cpu_idle_dead();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: kernel/cpu/idle.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_cpu_idle_dead</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* What the heck is this check doing ? */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpu_isset(smp_processor_id(), cpu_callin_map))</span><br><span class="line">		play_dead();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/kernel/process.c</p>
</blockquote>
<h3 id="echo-1-gt-online"><a href="#echo-1-gt-online" class="headerlink" title="echo 1 &gt; online"></a>echo 1 &gt; online</h3><p>调用被开核的<code>boot_secondary</code>,重新走一次启动时的第二阶段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpu_up</span><br><span class="line">	\-&gt;_cpu_up</span><br><span class="line">		\-&gt;__cpu_up</span><br><span class="line">			\-&gt;mp_ops-&gt;boot_secondary(cpu, tidle)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: /kernel/cpu.c</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://free-electrons.com/pub/conferences/2014/elc/clement-smp-bring-up-on-arm-soc/clement-smp-bring-up-on-arm-soc.pdf" target="_blank" rel="noopener"> clement-smp-bring-up-on-arm-soc.pdf</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>smp</tag>
      </tags>
  </entry>
  <entry>
    <title>IPI通信（SMP）</title>
    <url>/post/60164.html</url>
    <content><![CDATA[<blockquote>
<p>IPI(Interrupt-Procecesorr Interrupt): 处理中间的中断</p>
</blockquote>
<p>主要应用是一个处理器让另一个处理器做特定的事情（function和sched）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">              +---------------------------+-+</span><br><span class="line">system boot   | request_percpu_irq（）      +</span><br><span class="line">              | mailbox irq handle          +</span><br><span class="line">              +--+-----------------------+--+</span><br><span class="line">                 |                       |</span><br><span class="line">                 |                       |</span><br><span class="line">              +--v--+                +---v-+</span><br><span class="line">              | CPU0|                &gt; CPU1|</span><br><span class="line">              +--+--+                +----++</span><br><span class="line">                 |                        |</span><br><span class="line">            +----+----+             +-----+-----+</span><br><span class="line">            |mailbox0 |          +--&gt;mailbox1   |</span><br><span class="line">            +---------+          |  +-----------+</span><br><span class="line">                                 |</span><br><span class="line">                 +---------------+        |</span><br><span class="line">system run    A send IPI CPU1             |</span><br><span class="line">              write mailbox1              |</span><br><span class="line">                 |                        |</span><br><span class="line">                 |                  +-----v-----------------+---+</span><br><span class="line">          +------+----+             | 1. 读取mailbox中的action  +</span><br><span class="line">          |  Task A   |             | 2. 通过action判断IPI类型  +</span><br><span class="line">          |           |             | 3. 进行function和sched处理+</span><br><span class="line">          +-----------+             |                           +</span><br><span class="line">                                    +---------------------------+</span><br></pre></td></tr></table></figure>
<p>在多核处理器中，每一个CPU核有一个<code>mailbox</code>(相当于邮箱)，如果需要进行IPI通信时，其主要通过IPI的中断实现。假设CPU0需要给CPU1发送一个<code>action</code>(<code>action</code>I的类型：<code>SMP_CALL_FUNCTION</code>,<code>SMP_RESCHEDULE_YOURSELF</code>等)时, 只需要CPU0向CPU1的<code>mailbox</code>中写于<code>action</code>的id（相当于信），此时CPU1将产生一个IPI中断（表明收到信），<code>mailbox</code>的中断处理程序将读取<code>mailbox</code>（相当于看信）中的<code>action</code>，判断<code>action</code>的类型进行相应的处理。</p>
<a id="more"></a>
<p>MIPS架构下的IPI通信</p>
<blockquote>
<ol>
<li>关闭中断后还会发送IPI</li>
</ol>
</blockquote>
<h2 id="MIPS接口"><a href="#MIPS接口" class="headerlink" title="MIPS接口"></a>MIPS接口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*send_ipi_single)(<span class="keyword">int</span> cpu, <span class="keyword">unsigned</span> <span class="keyword">int</span> action);</span><br><span class="line">	<span class="keyword">void</span> (*send_ipi_mask)(<span class="keyword">const</span> struct cpumask *mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> action);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>IPI通信就是多个处理器之间的<code>交流</code>。<br><code>send_ipi_single</code>： 一对一聊天<br><code>send_ipi_mask</code> : 群发，mask表示群发的成员（CPU）</p>
</blockquote>
<h2 id="action类型"><a href="#action类型" class="headerlink" title="action类型"></a>action类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMP_RESCHEDULE_YOURSELF 0x1 <span class="comment">/* XXX braindead */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMP_CALL_FUNCTION   0x2</span></span><br><span class="line"><span class="comment">/* Octeon - Tell another core to flush its icache */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMP_ICACHE_FLUSH    0x4</span></span><br><span class="line"><span class="comment">/* Used by kexec crashdump to save all cpu's state */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMP_DUMP        0x8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMP_IPI_TIMER       0xC</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/include/asm/smp.h</p>
</blockquote>
<ol>
<li>不同的action(活动)何时将产生？</li>
<li>各自都有什么作用？</li>
</ol>
<h3 id="SMP-RESCHEDULE-YOURSELF"><a href="#SMP-RESCHEDULE-YOURSELF" class="headerlink" title="SMP_RESCHEDULE_YOURSELF"></a>SMP_RESCHEDULE_YOURSELF</h3><blockquote>
<p><code>SMP_RESCHEDULE_YOURSELF</code>将直接调用<code>scheduler_ipi</code>.将任务插入目标CPU的运行队列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this function sends a 'reschedule' IPI to another CPU.</span></span><br><span class="line"><span class="comment"> * it goes straight through and wastes no time serializing</span></span><br><span class="line"><span class="comment"> * anything. Worst case is that we lose a reschedule ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">smp_send_reschedule</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">	mp_ops-&gt;send_ipi_single(cpu, SMP_RESCHEDULE_YOURSELF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/include/asm/smp.h</p>
</blockquote>
<h3 id="SMP-CALL-FUNCTION"><a href="#SMP-CALL-FUNCTION" class="headerlink" title="SMP_CALL_FUNCTION"></a>SMP_CALL_FUNCTION</h3><blockquote>
<p><code>SMP_CALL_FUNCTION</code>:将特定的函数在目标CPU上运行</p>
</blockquote>
<ul>
<li>内核回调接口：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_send_call_function_single_ipi</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">	mp_ops-&gt;send_ipi_mask(&amp;cpumask_of_cpu(cpu), SMP_CALL_FUNCTION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_send_call_function_ipi_mask</span><span class="params">(<span class="keyword">const</span> struct cpumask *mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">	mp_ops-&gt;send_ipi_mask(mask, SMP_CALL_FUNCTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>file: arch/mips/include/asm/smp.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * smp_call_function_single - Run a function on a specific CPU</span></span><br><span class="line"><span class="comment"> * @func: The function to run. This must be fast and non-blocking.</span></span><br><span class="line"><span class="comment"> * @info: An arbitrary pointer to pass to the function.</span></span><br><span class="line"><span class="comment"> * @wait: If true, wait until function has completed on other CPUs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, else a negative status code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">smp_call_function_single</span><br><span class="line">	\-&gt;generic_exec_single</span><br><span class="line">		\-&gt;arch_send_call_function_single_ipi</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * smp_call_function_many(): Run a function on a set of other CPUs.</span></span><br><span class="line"><span class="comment"> * @mask: The set of cpus to run on (only runs on online subset).</span></span><br><span class="line"><span class="comment"> * @func: The function to run. This must be fast and non-blocking.</span></span><br><span class="line"><span class="comment"> * @info: An arbitrary pointer to pass to the function.</span></span><br><span class="line"><span class="comment"> * @wait: If true, wait (atomically) until function has completed</span></span><br><span class="line"><span class="comment"> *        on other CPUs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @wait is true, then returns once @func has returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You must not call this function with disabled interrupts or from a</span></span><br><span class="line"><span class="comment"> * hardware interrupt handler or from a bottom half handler. Preemption</span></span><br><span class="line"><span class="comment"> * must be disabled when calling this function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">smp_call_function_many</span><br><span class="line">	\-&gt;arch_send_call_function_ipi_mask</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: kernel/smp.c</p>
</blockquote>
<h2 id="刷新TLB"><a href="#刷新TLB" class="headerlink" title="刷新TLB"></a>刷新TLB</h2><p>多核进行TLB的同步？</p>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>smp</tag>
        <tag>ipi</tag>
      </tags>
  </entry>
  <entry>
    <title>Smoke Testing（冒烟测试）</title>
    <url>/post/27818.html</url>
    <content><![CDATA[<p>最近接到测试组的测试报告，写的<code>冒烟测试</code>。由于第一次遇到，便百度搜索一番，在这里进行简单记录。</p>
<a id="more"></a>
<blockquote>
<p>Smoke Testing 的概念最早源于制造业，用于测试管道。测试时，用鼓风机往管道里灌烟，看管壁外面是否有烟冒出来，以便检验管道是否有缝隙。这一测试显然比较初级，更深层一点的测试至少要进行渗油测试、带压测试等等。Smoke Testing 只是一种初级、直观的测试。</p>
</blockquote>
<p>Smoke Testing 在软件测试中的意义，应该说取的是其原始概念中的目的而非手段。通过 Smoke Testing，在软件代码正式编译并交付测试之前，<code>先尽量消除其“表面的”错误，减少后期测试的负担</code>。因此可以说，Smoke Testing 是预测试。</p>
<p><strong>冒烟测试的执行对象一般是程序的开发者，可以建议在开发人员的 自测报告中加入冒烟测试的情况反馈，因为只有通过冒烟测试才能进行更深入的系统测试，如果连冒烟测试都没有通过的版本，交给测试人员，很有可能因为环境、部署等问题回退。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/u012460084/article/details/45868993" target="_blank" rel="noopener">详细介绍一下 Smoke Testing（冒烟测试）</a></li>
<li><a href="https://blog.csdn.net/zhusongziye/article/details/78670034" target="_blank" rel="noopener">冒烟测试浅谈</a></li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>常用网站</title>
    <url>/post/20962.html</url>
    <content><![CDATA[<p>平时工作学习的常用网站.</p>
<a id="more"></a>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li><p>python</p>
<p>  –<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/" target="_blank" rel="noopener">廖雪峰Python教程</a></p>
</li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li><p>嵌入式linux学习</p>
<p>  –<a href="http://www.wowotech.net/" target="_blank" rel="noopener">蜗窝科技</a></p>
</li>
</ul>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul>
<li><p>电子书</p>
<p>–<a href="http://www.kindlepush.com/main" target="_blank" rel="noopener">kindle推</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>C程序函数调用关系</title>
    <url>/post/1655.html</url>
    <content><![CDATA[<p>阅读源码</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cflow graphviz</span><br><span class="line">sudo apt-get install gawk</span><br><span class="line"></span><br><span class="line">wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/tree2dotx</span><br><span class="line">wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/callgraph</span><br><span class="line">sudo cp tree2dotx callgraph /usr/local/bin</span><br><span class="line">sudo chmod +x /usr/local/bin/&#123;tree2dotx,callgraph&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">callgraph -f main</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://tinylab.org/callgraph-draw-the-calltree-of-c-functions/" target="_blank" rel="noopener">源码分析：静态分析 C 程序函数调用关系图</a></li>
<li><a href="https://www.linuxidc.com/Linux/2015-01/111501.htm" target="_blank" rel="noopener">看开源代码利器—用Graphviz + CodeViz生成C/C++函数调用图(call graph)</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>callgraph</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下常用工具</title>
    <url>/post/36295.html</url>
    <content><![CDATA[<p>Linux下常用工具：</p>
<a id="more"></a>
<h2 id="yuv-rgba-player"><a href="#yuv-rgba-player" class="headerlink" title="yuv rgba player"></a>yuv rgba player</h2><ul>
<li><a href="https://github.com/IENT/YUView" target="_blank" rel="noopener">https://github.com/IENT/YUView</a></li>
</ul>
<blockquote>
<p>ubuntu 18.04</p>
</blockquote>
<h2 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h2><ul>
<li><a href="http://community.wps.cn/download/" target="_blank" rel="noopener">http://community.wps.cn/download/</a></li>
</ul>
<p>字体：<a href="http://wps-community.org/download.html?vl=fonts#download" target="_blank" rel="noopener">http://wps-community.org/download.html?vl=fonts#download</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb</span><br><span class="line">sudo apt -f install</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wps-office 依赖于 libpng12-0；然而：未安装软件包 libpng12-0。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://ftp.cn.debian.org/debian/pool/main/libp/libpng/libpng12-0_1.2.49-1+deb7u2_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i libpng12-0_1.2.49-1+deb7u2_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i wps-office-fonts_1.0_all.deb</span><br></pre></td></tr></table></figure>
<h3 id="缺失字体"><a href="#缺失字体" class="headerlink" title="缺失字体"></a>缺失字体</h3><ul>
<li><a href="https://pan.baidu.com/s/1eS6xIzo" target="_blank" rel="noopener">https://pan.baidu.com/s/1eS6xIzo</a></li>
</ul>
<p>wps_symbol_fonts.zip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip wps_symbol_fonts.zip</span><br><span class="line">sudo cp mtextra.ttf  symbol.ttf  WEBDINGS.TTF  wingding.ttf  WINGDNG2.ttf  WINGDNG3.ttf  /usr/share/fonts</span><br></pre></td></tr></table></figure>
<h2 id="Teamviewer"><a href="#Teamviewer" class="headerlink" title="Teamviewer"></a>Teamviewer</h2><ul>
<li><a href="https://www.teamviewer.com/zhcn/download/linux/" target="_blank" rel="noopener">下载</a></li>
<li>安装：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i teamviewer_13.1.3026_amd64.deb</span><br><span class="line">sudo apt-get remove teamviewer</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果安装失败，可以更新ubuntu的源，参考：<a href="https://blog.csdn.net/u011292539/article/details/79249027/" target="_blank" rel="noopener">Ubuntu 16.04 安装 TeamViewer 13</a></p>
<h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable teamviewerd.service</span><br></pre></td></tr></table></figure>
<h3 id="ubuntu18-04系统重启后，TeamViewer无法连接"><a href="#ubuntu18-04系统重启后，TeamViewer无法连接" class="headerlink" title="ubuntu18.04系统重启后，TeamViewer无法连接"></a>ubuntu18.04系统重启后，TeamViewer无法连接</h3><p>修改<code>/etc/gdm3/custom.conf</code>文件：</p>
<p>将如下行取消注释<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WaylandEnable=false</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使通过TeamViewer进行的远程桌面会话请求由GNOME桌面的xorg处理，来代替Wayland显示管理器。</p>
</blockquote>
<ul>
<li><a href="https://community.teamviewer.com/t5/Linux/Teamviewer-13-not-connecting-in-Ubuntu-18-04-Login-Screen/td-p/35342" target="_blank" rel="noopener">https://community.teamviewer.com/t5/Linux/Teamviewer-13-not-connecting-in-Ubuntu-18-04-Login-Screen/td-p/35342</a></li>
</ul>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br></pre></td></tr></table></figure>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul>
<li><code>dash-to-panel</code>： 任务栏合并，类似window</li>
<li><code>workspace-grid</code>： 多工作区</li>
</ul>
<h2 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h2><p>Evolution</p>
<h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  kolourpaint4</span><br></pre></td></tr></table></figure>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>VirtualBox</p>
<h2 id="音视频文件分析工具-–-MediaInfo"><a href="#音视频文件分析工具-–-MediaInfo" class="headerlink" title="音视频文件分析工具 – MediaInfo"></a>音视频文件分析工具 – MediaInfo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mediainfo mediainfo-gui</span><br></pre></td></tr></table></figure>
<h2 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h2><p>stardict(星际译王)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install stardict</span><br></pre></td></tr></table></figure>
<p>词典的词库网站下载词库：<a href="http://download.huzheng.org/" target="_blank" rel="noopener">下载</a></p>
<ul>
<li><a href="https://blog.csdn.net/suyingshipp/article/details/7736297" target="_blank" rel="noopener">linux下StarDict和词典的安装</a></li>
</ul>
<h3 id="有道词典—命令行"><a href="#有道词典—命令行" class="headerlink" title="有道词典—命令行"></a>有道词典—命令行</h3><ul>
<li><a href="https://github.com/TimothyYe/ydict" target="_blank" rel="noopener">https://github.com/TimothyYe/ydict</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ydict</span><br></pre></td></tr></table></figure>
<h2 id="画图–结构图流程图"><a href="#画图–结构图流程图" class="headerlink" title="画图–结构图流程图"></a>画图–结构图流程图</h2><ol>
<li><p><del>亿图：<a href="http://www.edrawsoft.cn/download-edrawmax.php" target="_blank" rel="noopener">http://www.edrawsoft.cn/download-edrawmax.php</a> —— 收费</del></p>
</li>
<li><p><strong>draw.io</strong>: <a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a> —— 在线开源免费的画流程图，思维导图，界面设计等</p>
<ul>
<li>桌面版： <a href="https://github.com/jgraph/drawio-desktop" target="_blank" rel="noopener">https://github.com/jgraph/drawio-desktop</a></li>
</ul>
</li>
<li>dia 流程图<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install dia</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="vooya"><a href="#vooya" class="headerlink" title="vooya"></a>vooya</h2><p>vooya – Raw YUV/RGB Video Player</p>
<ul>
<li><a href="http://www.offminor.de/downloads.html" target="_blank" rel="noopener">http://www.offminor.de/downloads.html</a></li>
</ul>
<h2 id="gedit汉字乱码"><a href="#gedit汉字乱码" class="headerlink" title="gedit汉字乱码"></a>gedit汉字乱码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;[&apos;GB18030&apos;, &apos;GB2312&apos;, &apos;GBK&apos;, &apos;UTF-8&apos;, &apos;BIG5&apos;, &apos;CURRENT&apos;, &apos;UTF-16&apos;]&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ubntu 18.04</p>
</blockquote>
<h2 id="Albert"><a href="#Albert" class="headerlink" title="Albert"></a>Albert</h2><p>全局搜索软件</p>
<h2 id="数据库-sqlitebrowser"><a href="#数据库-sqlitebrowser" class="headerlink" title="数据库:sqlitebrowser"></a>数据库:sqlitebrowser</h2><ul>
<li>官网地址：<a href="http://sqlitebrowser.org/" target="_blank" rel="noopener">http://sqlitebrowser.org/</a></li>
<li>开源地址：<a href="https://github.com/sqlitebrowser/sqlitebrowser" target="_blank" rel="noopener">https://github.com/sqlitebrowser/sqlitebrowser</a></li>
</ul>
<p>DB Browser for SQLite (DB4S) 是一款面向开发者的高质量的，可视化的开源的工具，他可以创建，设计，以及修改SQlite数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sqlitebrowser</span><br></pre></td></tr></table></figure>
<h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h2><blockquote>
<p>python编辑器</p>
</blockquote>
<ul>
<li><a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">http://www.jetbrains.com/pycharm/</a></li>
</ul>
<h2 id="7yuv"><a href="#7yuv" class="headerlink" title="7yuv"></a>7yuv</h2><p>查看yuv格式的文件</p>
<ul>
<li>官网：<a href="http://datahammer.de/" target="_blank" rel="noopener">http://datahammer.de</a></li>
</ul>
<h2 id="Nitroshare"><a href="#Nitroshare" class="headerlink" title="Nitroshare"></a>Nitroshare</h2><blockquote>
<p>跨平台局域网传输软件</p>
</blockquote>
<ul>
<li><a href="https://nitroshare.net/" target="_blank" rel="noopener">https://nitroshare.net/</a></li>
</ul>
<h2 id="Alt-Tab不跨工作区"><a href="#Alt-Tab不跨工作区" class="headerlink" title="Alt+Tab不跨工作区"></a>Alt+Tab不跨工作区</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.shell.app-switcher current-workspace-only true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/post/22648.html</url>
    <content><![CDATA[<p>在这里主要记录makedown的使用语法，以备后续写作时的不时之需。</p>
<a id="more"></a>
<h2 id="Atom-插件"><a href="#Atom-插件" class="headerlink" title="Atom 插件"></a>Atom 插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apm install tool-bar markdown-writer tool-bar-markdown-writer markdown-scroll-sync</span><br></pre></td></tr></table></figure>
<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><ul>
<li><p>分段： <code>两个回车</code></p>
</li>
<li><p>换行 <code>两个空格 + 回车</code></p>
</li>
<li><p>标题 <code># ~ ######</code> 井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题</p>
</li>
<li><p>引用 <code>&gt;</code></p>
</li>
<li><p>列表 <code>* ， + ， - ， 1.</code>选其中之一，注意后面有个空格</p>
</li>
<li><p>代码区块 <code>四个空格</code> 开头</p>
</li>
<li><p>链接 <code>[文字](链接地址)</code></p>
</li>
<li><p>图片 <code>![图片说明](图片地址)</code> ，图片地址可以是本地路劲，也可以是网络地址</p>
</li>
<li><p>强调 <code>**文字**</code> ， <code>__文字__</code></p>
</li>
<li><p>删除线：<code>~~xxxx~~</code></p>
</li>
<li><p>代码: 三个点</p>
</li>
<li><p>待办事宜 <code>- [ ] 表示未完成</code>和<code>- [x] 表示已完成</code></p>
<blockquote>
<ul>
<li>[ ] 表示未完成</li>
<li>[x] 表示已完成</li>
</ul>
</blockquote>
</li>
<li><p>段落缩进 <code>&amp;ensp;&amp;ensp;</code>（两个空格）</p>
</li>
</ul>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><table>
<thead>
<tr>
<th style="text-align:center">操作模块</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">start`</td>
<td style="text-align:center">开始</td>
</tr>
<tr>
<td style="text-align:center">end</td>
<td style="text-align:center">结束</td>
</tr>
<tr>
<td style="text-align:center">opration</td>
<td style="text-align:center">普通操作块</td>
</tr>
<tr>
<td style="text-align:center">condition</td>
<td style="text-align:center">判断块</td>
</tr>
<tr>
<td style="text-align:center">subroutine</td>
<td style="text-align:center">子任务块</td>
</tr>
<tr>
<td style="text-align:center">inputoutput</td>
<td style="text-align:center">输入输出块</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&apos;&apos; flow</span><br><span class="line">//定义部分</span><br><span class="line">st=&gt;start: Start:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond=&gt;condition: Yes or No?:&gt;http://www.google.com</span><br><span class="line">io=&gt;inputoutput: catch something...</span><br><span class="line"></span><br><span class="line">//判断和位置控制</span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op1</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>st 是变量名， start 是指操作模块名，冒号后面就是内容了。需要注意的是，<code>冒号后要加空格</code>才能识别</p>
</blockquote>
<div id="flowchart-0" class="flow-chart"></div>

<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&apos;&apos;sequence</span><br><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>
<div id="sequence-0"></div>


<h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><blockquote>
<p><a href="https://mermaid-js.github.io/mermaid" target="_blank" rel="noopener">https://mermaid-js.github.io/mermaid</a></p>
</blockquote>
<pre class="mermaid">graph TD

A[Hard] -->|Text| B(Round)
B --> C{Decision}
C -->|One| D[Result 1]
C -->|Two| E[Result 2]</pre>


<h2 id="Atom和Makedown预览"><a href="#Atom和Makedown预览" class="headerlink" title="Atom和Makedown预览"></a>Atom和Makedown预览</h2><ol>
<li>命令：ctrl + shift + p</li>
<li>输入 markdown preview toggle(可以偷懒只输入<strong>mdpt</strong>，跟Sublime Text一样支持模糊匹配)</li>
</ol>
<h2 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h2><p>官网：<a href="https://typora.io" target="_blank" rel="noopener">https://typora.io</a></p>
<blockquote>
<p>Debian/Ubuntu</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># or use</span><br><span class="line"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"># add Typora&apos;s repository</span><br><span class="line">sudo add-apt-repository &apos;deb https://typora.io/linux ./&apos;</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"># install typora</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Windows: <a href="http://winddoing.github.io/software">http://winddoing.github.io/software</a></p>
</blockquote>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><h4 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h4><p>使用“[toc]”会自动根据使用的一二三级标题生成目录</p>
<h4 id="插入分页符"><a href="#插入分页符" class="headerlink" title="插入分页符"></a>插入分页符</h4><p>导出pdf时希望分页可以添加这个html实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">//定义部分
st=>start: Start:>http://www.google.com[blank]
e=>end:>http://www.google.com
op1=>operation: My Operation
sub1=>subroutine: My Subroutine
cond=>condition: Yes or No?:>http://www.google.com
io=>inputoutput: catch something...

//判断和位置控制
st->op1->cond
cond(yes)->io->e
cond(no)->sub1(right)->op1</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Alice->Bob: Hello Bob, how are you?
Note right of Bob: Bob thinks
Bob-->Alice: I am good thanks!</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>整理文件分类</title>
    <url>/post/39420.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls *.md | xargs sed  -i &apos;/categories:/&#123;s/单片机/嵌入式/; &#125;&apos;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>nbench</title>
    <url>/post/18855.html</url>
    <content><![CDATA[<p> nbench是一个简单的用于测试处理器，存储器性能的基准测试程序。即著名的BYTE Magazine杂志的BYTEmark benchmark program。nbench在系统中运行并将结果和一台运行Linux的AMD K6-233电脑比较，得到的比值作为性能指数。由于是完全开源的，爱好者可以在各种平台和操作系统上运行nbench，并进行优化和测试，是一个简单有效的性能测试工具。nbench的结果主要分为MEM、INT和FP，其中MEM指数主要体现处理器总线、CACHE和存储器性能，INT当然是整数处理性能，FP则体现双精度浮点性能</p>
<a id="more"></a>
<h2 id="下载-amp-编译"><a href="#下载-amp-编译" class="headerlink" title="下载&amp;编译"></a>下载&amp;编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git clone https://github.com/Winddoing/nbench.git</span><br><span class="line">$git checkout arch-mips-test</span><br><span class="line">$make</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行<code>./nbench</code></p>
<h3 id="mips"><a href="#mips" class="headerlink" title="mips"></a>mips</h3>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nbench</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN的基础使用</title>
    <url>/post/56583.html</url>
    <content><![CDATA[<p>svn的基础使用命令：</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install subversion</span><br></pre></td></tr></table></figure>
<h2 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h2><h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn checkout svn_path local_path</span><br></pre></td></tr></table></figure>
<h3 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h3><blockquote>
<p>将新的文件添加到代码仓库中,如果一个文件不在版本则需要使用add添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn add files</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li><code>--no-ignore</code>: disregard default and svn:ignore and svn:global-ignores property ignores(忽略默认值和 svn:ignore 属性)</li>
<li><code>--force</code>: 强制添加</li>
</ul>
<h4 id="递归添加"><a href="#递归添加" class="headerlink" title="递归添加"></a>递归添加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn add . --no-ignore --force</span><br></pre></td></tr></table></figure>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn update</span><br></pre></td></tr></table></figure>
<h3 id="修改提交"><a href="#修改提交" class="headerlink" title="修改提交"></a>修改提交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn commit -m path-to-commit，其中path-to-commit可以为空</span><br></pre></td></tr></table></figure>
<h3 id="查看log"><a href="#查看log" class="headerlink" title="查看log"></a>查看log</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn log</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-v : 显示修改目录</p>
</blockquote>
<h3 id="回退到某一个（r123）log"><a href="#回退到某一个（r123）log" class="headerlink" title="回退到某一个（r123）log"></a>回退到某一个（r123）log</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn up -r r123</span><br></pre></td></tr></table></figure>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn copy -m &quot;create branch&quot; http://svn_server/xxx_repository http://svn_server/xxx_repository/br_feature001</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分支名： br_feature001</p>
</blockquote>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn switch http://svn_server/xxx_repository/br_feature001</span><br></pre></td></tr></table></figure>
<h4 id="更新SVN地址"><a href="#更新SVN地址" class="headerlink" title="更新SVN地址"></a>更新SVN地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn switch --relocate http://192.168.1.1/repos[old addr]  http://192.168.1.11/repos[new addr]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch –relocate FROM TO [PATH…]</p>
</blockquote>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn rm http://svn_server/xxx_repository/br_feature001</span><br></pre></td></tr></table></figure>
<h3 id="恢复本地修改"><a href="#恢复本地修改" class="headerlink" title="恢复本地修改"></a>恢复本地修改</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">revert PATH...</span><br></pre></td></tr></table></figure>
<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><ol>
<li>将代码更新到与目前版本库里一致（<code>svn up</code>），如果存在冲突解决冲突</li>
<li>使用(<code>svn st</code>)查看所有文件状态，判断使用有新添加的文件，如果有新添加的文件，使用(<code>svn add</code>)将新文件添加到版本库<ul>
<li><strong>在确定提交前，使用（<code>svn st</code>）查看是否有多余的修改，如果有将其退回（svn revert）</strong></li>
</ul>
</li>
<li>提交代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn commit -m &quot;备注修改的目的&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="补丁-patch"><a href="#补丁-patch" class="headerlink" title="补丁-patch"></a>补丁-patch</h2><h3 id="制作补丁"><a href="#制作补丁" class="headerlink" title="制作补丁"></a>制作补丁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn diff &gt; patch.diff</span><br></pre></td></tr></table></figure>
<h3 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patch &lt; to-file.patch</span><br></pre></td></tr></table></figure>
<h3 id="取消补丁"><a href="#取消补丁" class="headerlink" title="取消补丁"></a>取消补丁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patch -RE  &lt; to-file.patch</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-R</code>: 取消打过的补丁<br><code>-E</code>: 选项说明如果发现了空文件，那么就删除它</p>
</blockquote>
<h2 id="示例–创建分支提交"><a href="#示例–创建分支提交" class="headerlink" title="示例–创建分支提交"></a>示例–创建分支提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn up</span><br><span class="line"></span><br><span class="line">svn copy http://172.16.180.100/svn/Hi3798MV200 http://172.16.180.100/svn/Hi3798MV200/Hi3798MV200_M -m &quot;single S multi R code branch&quot;</span><br><span class="line"></span><br><span class="line">svn</span><br></pre></td></tr></table></figure>
<h2 id="图形界面使用"><a href="#图形界面使用" class="headerlink" title="图形界面使用"></a>图形界面使用</h2><h3 id="RapidSVN"><a href="#RapidSVN" class="headerlink" title="RapidSVN"></a>RapidSVN</h3>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>tftp</title>
    <url>/post/3037.html</url>
    <content><![CDATA[<p>tftp:</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="软件包："><a href="#软件包：" class="headerlink" title="软件包："></a>软件包：</h3><p><code>tftpd（服务端）</code>，<code>tftp（客户端）</code>，<code>xinetd</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tftpd tftp xinetd</span><br></pre></td></tr></table></figure>
<h3 id="建立配置文件："><a href="#建立配置文件：" class="headerlink" title="建立配置文件："></a>建立配置文件：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/xinetd.d/tftp</span><br><span class="line"></span><br><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line">    protocol        = udp</span><br><span class="line">    port            = 69</span><br><span class="line">    socket_type     = dgram</span><br><span class="line">    wait            = yes</span><br><span class="line">    user            = nobody</span><br><span class="line">    server          = /usr/sbin/in.tftpd</span><br><span class="line">    server_args     = /home/xxx/tftprootfs</span><br><span class="line">    disable         = no</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/xinetd restart</span><br></pre></td></tr></table></figure>
<h2 id="window工具–tftpd服务"><a href="#window工具–tftpd服务" class="headerlink" title="window工具–tftpd服务"></a>window工具–tftpd服务</h2><p>下载：<a href="https://pan.baidu.com/s/1vhF6tD7zwLhDLQDmSY5Hsw" target="_blank" rel="noopener">tftpd32</a></p>
<h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$tftp localhost</span><br><span class="line">tftp&gt; get aaa</span><br><span class="line">Received 8 bytes in 0.0 seconds</span><br></pre></td></tr></table></figure>
<h2 id="开发板使用"><a href="#开发板使用" class="headerlink" title="开发板使用"></a>开发板使用</h2><p>下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tftp –gr 源文件名  服务器地址</span><br></pre></td></tr></table></figure>
<p>上传：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tftp –pr 目标文件名 服务器地址</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tftp</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux</title>
    <url>/post/40876.html</url>
    <content><![CDATA[<p>tmux是一个优秀的终端复用软件，split窗口。可以在一个terminal下打开多个终端。<br>即使非正常掉线，也能保证当前的任务运行，这一点对于远程SSH访问特别有用，网络不好的情况下仍然能保证工作现场不丢失。SSH重新连接以后，就可以直接回到原来的工作环境，不但提高了工作效率，还降低了风险，增加了安全性。</p>
<p>tmux完全使用键盘控制窗口，实现窗口的切换功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p><a href="https://raw.githubusercontent.com/Winddoing/vim_work_config/master/.tmux.conf" target="_blank" rel="noopener">my tmux.conf</a></p>
</blockquote>
<p>tmux的系统级配置文件为<code>/etc/tmux.conf</code>，用户级配置文件为<code>~/.tmux.conf</code>。配置文件实际上就是tmux的命令集合，也就是说每行配置均可在进入命令行模式后输入生效。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM绘图--dot、uml</title>
    <url>/post/44070.html</url>
    <content><![CDATA[<p>在整理软件逻辑和设计思路时，通过VIM进行画图记录。</p>
<ul>
<li><code>DOT</code> + graphviz: 结构图和流程图</li>
<li><code>plantuml</code>: UML图</li>
<li><code>DrawIt</code>: 简易图（ASCII）</li>
</ul>
<a id="more"></a>
<h2 id="DOT-graphviz"><a href="#DOT-graphviz" class="headerlink" title="DOT + graphviz"></a>DOT + graphviz</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi aaa.dot</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用DOT语法，绘画</p>
</blockquote>
<h3 id="DOT语法"><a href="#DOT语法" class="headerlink" title="DOT语法"></a>DOT语法</h3><p><code>graph</code>（无向图）或者<code>digraph</code>（无向图）表示图，然后<code>{}</code>中的内容是对图的描述，注释风格和C类似（“<code>//</code>”用于单行注释，<code>/**/</code>用于多行注释）。如一个无向图：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//usr/bin/dot</span><br><span class="line">graph graph1 &#123;</span><br><span class="line">    label = &quot;this is a graph&quot;;</span><br><span class="line">    aa; bb;</span><br><span class="line">    a -- b;</span><br><span class="line"></span><br><span class="line">    &#123;p, q&#125; -- &#123;x, y&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;c, d&#125; -- o;</span><br><span class="line"></span><br><span class="line">    o -- end [style = dotted, color = red];</span><br><span class="line"></span><br><span class="line">    subgraph subgraph1 &#123;</span><br><span class="line">        label = &quot;This is subgraph&quot;;</span><br><span class="line">        bgcolor = greenyellow;</span><br><span class="line">        cc; dd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ccc -- ddd [label = &quot;test&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li><a href="https://blog.csdn.net/jy692405180/article/details/52077979" target="_blank" rel="noopener">Dot脚本语言语法整理</a></li>
<li><a href="https://blog.csdn.net/stormdpzh/article/details/14648827" target="_blank" rel="noopener">DOT + graphviz 轻松画图神器</a></li>
</ul>
</blockquote>
<h2 id="Plantuml"><a href="#Plantuml" class="headerlink" title="Plantuml"></a>Plantuml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi aaa.uml</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><a href="https://yq.aliyun.com/articles/25405" target="_blank" rel="noopener">类图</a></li>
<li><a href="https://blog.csdn.net/zh_weir/article/details/72675013" target="_blank" rel="noopener">时序图</a></li>
<li><a href="https://blog.csdn.net/zhangjikuan/article/details/53484558" target="_blank" rel="noopener">流程图</a></li>
</ul>
</blockquote>
<h2 id="DrawIt"><a href="#DrawIt" class="headerlink" title="DrawIt"></a>DrawIt</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">|                |</span><br><span class="line">+-------+--------+</span><br><span class="line">|       |        |</span><br><span class="line">|       +--------+</span><br><span class="line">|       |        |</span><br><span class="line">+-------+--------+</span><br></pre></td></tr></table></figure>
<ul>
<li><p>绘图–操作</p>
<blockquote>
<p>:DIstart   – 启动（默认虚线—-）<br>:DIstop    – 停止<br>:DIdbl     – 双实线(════)<br>:DInrml    – 单虚线(—-)<br>:DIsngl    – 单实现(────)</p>
</blockquote>
</li>
<li><p>划线：</p>
<blockquote>
<p>方向键（直线）；Page up、Page Down（斜线）</p>
</blockquote>
</li>
<li><p>箭头：</p>
<blockquote>
<p>&lt;、&gt;、^、v</p>
</blockquote>
</li>
<li><p>擦除：</p>
<blockquote>
<p>空格切换</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>dot</tag>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows常用工具</title>
    <url>/post/14436.html</url>
    <content><![CDATA[<p>Windows下的常用工具，提高使用效率</p>
<p>简单记录，方便以后重装系统后安装使用。</p>
<a id="more"></a>
<h2 id="快速搜素–Listary"><a href="#快速搜素–Listary" class="headerlink" title="快速搜素–Listary"></a>快速搜素–Listary</h2><p>官网：<a href="http://www.listary.com/" target="_blank" rel="noopener">http://www.listary.com/</a><br>下载：<a href="http://www.listary.com/download/Listary.exe?version=5.00.2843" target="_blank" rel="noopener">here</a></p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>快速启动： <code>Ctrl+Ctrl</code></p>
<h2 id="读取Ext4分区–ext2explore"><a href="#读取Ext4分区–ext2explore" class="headerlink" title="读取Ext4分区–ext2explore"></a>读取Ext4分区–ext2explore</h2><p>在Windows和Linux的双系统中，方便在Windows系统下获取Linux中的数据。</p>
<ul>
<li><a href="https://netix.dl.sourceforge.net/project/ext2read/Ext2read%20Version%202.2%20%28Latest%29/ext2explore-2.2.71.zip" target="_blank" rel="noopener"><code>ext2explore</code></a>只能读取文件，无法写入，使用时需要管理员权限运行。（Window10可以使用）</li>
<li><a href="https://excellmedia.dl.sourceforge.net/project/ext2fsd/Ext2fsd/0.69/Ext2Fsd-0.69.exe" target="_blank" rel="noopener"><code>Ext2fsd</code></a>据说最好用(Windows10无法使用)</li>
<li><a href="https://www.paragon-software.com/home/linuxfs-windows/" target="_blank" rel="noopener">Paragon ExtFS for Windows</a>需要注册对个人免费。</li>
</ul>
<p>使用：<a href="https://roov.org/2014/06/windows-ext/" target="_blank" rel="noopener">在 Windows 下访问 Ext 分区</a></p>
<h2 id="系统镜像下载"><a href="#系统镜像下载" class="headerlink" title="系统镜像下载"></a>系统镜像下载</h2><p>网站：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></p>
<h2 id="Windows-10-下清理-WinSxS"><a href="#Windows-10-下清理-WinSxS" class="headerlink" title="Windows 10 下清理 WinSxS"></a>Windows 10 下清理 WinSxS</h2><p>图形界面操作<a href="http://www.chuyu.me/zh-Hans/index.html" target="_blank" rel="noopener">http://www.chuyu.me/zh-Hans/index.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dism.exe /online /Cleanup-Image /StartComponentCleanup /ResetBase</span><br></pre></td></tr></table></figure>
<h2 id="磁盘文件目录大小可视化布局"><a href="#磁盘文件目录大小可视化布局" class="headerlink" title="磁盘文件目录大小可视化布局"></a>磁盘文件目录大小可视化布局</h2><p><a href="http://www.uderzo.it/main_products/space_sniffer/" target="_blank" rel="noopener">SpaceSniffer</a></p>
<blockquote>
<p>SpaceSniffer_1.1.4.0.1399531007</p>
</blockquote>
<h2 id="同步软件–FreeFileSync"><a href="#同步软件–FreeFileSync" class="headerlink" title="同步软件–FreeFileSync"></a>同步软件–FreeFileSync</h2><p><a href="https://freefilesync.org/download.php" target="_blank" rel="noopener">FreeFileSync</a></p>
<blockquote>
<p>硬盘和U盘的同步</p>
</blockquote>
<h2 id="esEye-–-Elecard-StreamEye-Tools"><a href="#esEye-–-Elecard-StreamEye-Tools" class="headerlink" title="esEye – Elecard StreamEye Tools"></a>esEye – Elecard StreamEye Tools</h2><p>esEye 分析264的码流结构</p>
<h2 id="edid-manager"><a href="#edid-manager" class="headerlink" title="edid_manager"></a>edid_manager</h2><p><a href="https://pan.baidu.com/s/1BPgXadM9Mnwwio1PU4jiPQ" target="_blank" rel="noopener">edid_managerv1x0</a></p>
<blockquote>
<p>EDID查询</p>
</blockquote>
<h2 id="dxdiag"><a href="#dxdiag" class="headerlink" title="dxdiag"></a>dxdiag</h2><blockquote>
<p>按键盘<code>win+r</code>调出运行命令，输入<code>dxdiag</code>,如<a href="https://winddoing.github.io/src/DxDiag.txt">DxDiag</a></p>
</blockquote>
<p>Dxdiag可以显示计算机上DirectX相关的文件，检查正在运行的文件、输入设备、视频驱动程序版本、以及当前的系统信息。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>getch、getche、getchar的区别和缓冲区的概念</title>
    <url>/post/26893.html</url>
    <content><![CDATA[<h3 id="输入输出缓冲区的概念（C-用的多一些）"><a href="#输入输出缓冲区的概念（C-用的多一些）" class="headerlink" title="输入输出缓冲区的概念（C++用的多一些）"></a>输入输出缓冲区的概念（C++用的多一些）</h3><ul>
<li><p>转载于：<a href="http://blog.csdn.net/cxyol/article/details/628324" target="_blank" rel="noopener">http://blog.csdn.net/cxyol/article/details/628324</a></p>
</li>
<li><p>我想以一个例子说明，比如我想把一篇文章以字符序列的方式输出到计算机显示器屏幕上，那么我的程序内存作为数据源而显示器驱动程序作为数据目标，如果数据源直接对数据目标发送数据的话。数据目标获得第一个字符，便将它显示。然后从端口读取下一个字符，可是这时就不能保证数据源向端口发送的恰好是第二个字符（也许是第三个，而第二个已经在数据目标显示时发送过了）。这样的话就不能保证输出的数据能完整的被数据目标所接受并处理。</p>
</li>
<li><p>为了解决这个问题，我们需要在数据源与数据目标中间放置一个保存完整数据内容的区域，那就是 “缓冲区”。这样的话， 数据源可以不考虑数据目标正在处理哪部分数据，只要把数据输出到缓冲区就可以了，数据目标也可以不考虑数据源的发送频率，只是从缓冲区中依次取出下一个数据。从而保证了数据发送的完整性，同时也提高了程序的效率。</p>
<a id="more"></a></li>
<li>当然getch(),getche()没有用到缓冲区。</li>
</ul>
<h3 id="几个函数的区别"><a href="#几个函数的区别" class="headerlink" title="几个函数的区别"></a>几个函数的区别</h3><h3 id="getch"><a href="#getch" class="headerlink" title="getch()"></a>getch()</h3><ul>
<li><p>首先不要忘了，要用getch()必须引入头文件conio.h，以前学C语言的时候，我们总喜欢用在程序的末尾加上它，利用它来实现程序运行完了暂停不退出的效果。如果不加这句话，在TC2.0的环境中我们用Ctrl+F9编译并运行后，程序一运行完了就退回到TC环境中，我们根本来不及看到结果，这时要看结果，我们就要按Alt+F5回到DOS环境中去看结果，这很麻烦。而如果在程序的结尾加上一行getch();语句，我们就可以省掉会DOS看结果这个步骤，因为程序运行完了并不退出，而是在程序最后把屏幕停住了，按任意键才退回到TC环境中去。</p>
</li>
<li><p>那我们来看看getch()到底起的什么作用，getch()实际是一个输入命令，<em>作用</em>是从键盘接收一个字符，而且并不把这个字符显示出来，就是说，你按了一个键后它并不在屏幕上显示你按的什么，而继续运行后面的代码，所以我们在C++中可以用它来实现“按任意键继续”的效果，即程序中遇到getch();这行语句，它就会把程序暂停下来，等你按任意键，它接收了这个字符键后再继续执行后面的代码。</p>
</li>
<li><p>你也许会问，为什么我们在C++中就没有在程序的末尾加上getch()，解释是，软件总是不断更新的，不好的地方当然要进行改正，getch()加在程序末尾，它又不赋值给任何变量，所以它在这个地方完全是垃圾代码，与程序无关。C++中考虑到这一点，于是在每次程序运行完了并不退出，而是自动把屏幕停下来，并显示“press any key…”叫你按任意键退出，这就好比C++在它的环境中运行程序，在程序的末尾自动加上了一行getch();语句，并且在这行语句前还添加了一行输出语句cout&lt;&lt;”press any key…”;来提示你程序结束了，按任意键继续。</p>
</li>
<li><p>实际上我们编译好的程序在程序结束了本身是不会停下来的，我们可以在编译产生的Debug目录中找到这个编译好的应用程序（扩展名exe），在文件夹中双击运行它，你会发现屏幕闪了一下MS-DOS窗口就关闭了，因为程序运行完就自动退出了，回到了windows环境，当然，如果我们在DOS环境中运行这个程序，我们就可以直接在看到DOS屏幕上看到程序运行结果，因为程序运行完后并不清屏。但是，visual stdio.net2003有返回到了tc那样的情况，你必需要有个getch()才行。</p>
</li>
</ul>
<h3 id="getche"><a href="#getche" class="headerlink" title="getche()"></a>getche()</h3><ul>
<li><p>getche()和getch()很相似，它也需要引入头文件conio.h，那它们之间的区别又在哪里呢？<strong>不同之处就在于getch()无返回显示，getche()有返回显示。</strong>就这么一点看看下面的例子：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
void main()
{
    char ch;
    for(int i=0;i&lt;5;i++)
    {
        ch=getch();
        printf(&quot;%c&quot;,ch);
    }
}
</code></pre></li>
</ul>
<ul>
<li><p>首先这是个连续5次的循环来实现5次停顿，等待我们输入，我们编译并运行这个程序，假设我们分别输入abcde，屏幕上显示的结果是abcde，这个abcde并不是在ch=getch();中输出的，我们把printf(“%c”,ch);这行语句去掉，就会发现我们按5次任意键程序就结束了，但屏幕上什么都没有显示。</p>
</li>
<li><p>然后我们在把代码中的getch()换成getche()看看有什么不同，我们还是分别输入abcde，这时屏幕上显示的结果是aabbccddee，我们把printf(“%c”,ch);这行语句再去掉看看，显示的结果就是abcde了，说明程序在执行ch=getche();这条语句的时候就把我们输入的键返回显示在屏幕上，<strong>有无回显就是它们的唯一区别。</strong></p>
</li>
<li><p>有人会说，既然是C的函数库中的，那么就应该淘汰了，我们还研究它，还用它干嘛？但是我发现还是有用着它的地方，否则我也不会在这里说这么多来耽误大家的时间。我就举个例子吧，程序如下：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
void main()
{
    char ch=&apos;*&apos;;
    while(ch==&apos;*&apos;)
    {
        printf(&quot;\n按 * 继续循环，按其他键退出！&quot;);
        ch=getch();
    }
    printf(&quot;\n退出程序！&quot;);
}
</code></pre></li>
<li><p>我们可以在这个循环体中添加我们想要的功能，程序中按*继续循环，其他任意键退出，而且利用getch()无回显的特性，我们不管按什么，都不会在屏幕上留下痕迹，使我们的界面达到美观效果，如果还有更好的办法实现这个功能。例子：</p>
<pre><code>void main()
{
    char c, ch;
    c=getch();     /*从键盘上读入一个字符不回显送给字符变量c*/
    putchar(c);    /*输出该字符*/
    ch=getche();   /*从键盘上带回显的读入一个字符送给字符变量ch*/
    putchar(ch);
    printf(&quot;/n/n&quot;);
}
</code></pre><p><em>值得注意的是前面两个函数都是从键盘读入数据！</em></p>
</li>
</ul>
<h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h3><ul>
<li><p>还有getchar是很值得研究的：getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符，也就是说，如果stdin有数据的话不用输入它就可以直接读取了。而getch()和getche()是conio.h中的库函数，它的<strong>作用</strong>是从键盘接收字符。getchar带有显示。</p>
</li>
<li><p>与前面两个函数的区别在于：</p>
</li>
</ul>
<blockquote>
<p>getchar()函数等待输入直到按回车才结束（前提是缓冲区没有数据），回车前的所有输入字符都会逐个显示在屏幕上。但只有第一个字符作为函数的返回值。</p>
</blockquote>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
void main()
{
    char c;
    c=getchar();   /*从键盘读入字符直到回车结束*/
           //getchar()在这里它只返回你输入字符串的第一个字符，并把返回值赋值给c
    putchar(c);    /*显示输入的第一个字符*/
    printf(&quot;\n\n&quot;);
}
</code></pre><ul>
<li><p>例四：呵呵，这个程序你运行一下，相信你又会有疑问了。这个就是从缓冲区中读取了例子。第一次getchar()时，确实需要人工的输入，但是如果你输了多个字符，以后的getchar()再执行时就会直接从缓冲区中读取了。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
void main()
{
    char c;
    while ((c=getchar())!=&apos;\n&apos;)    /*每个getchar()依次读入一个字符*/
        printf(&quot;%c&quot;,c);        /*按照原样输出*/
    printf(&quot;\n\n&quot;);
}
</code></pre></li>
<li><p>程序运行时，首先停下来，等你输入一串字符串，<strong>输入完毕后，它把你输入的整个字符串都输出来了</strong>，咦，你不是说getchar()只返回第一个字符么，这里怎么？</p>
</li>
<li><p>因为我们输入的字符串并不是取了第一个字符就把剩下的字符串丢掉了，它还在我们的内存中，就好比，开闸放水，我们把水放到闸里去以后，开一次闸就放掉一点，开一次就放掉一点，直到放光了为止，这里开闸动作就相当于调用一次getchar()。我们输入的字符串也是这么一回事，首先我们输入的字符串是放在内存的缓冲区中的，我们调用一次getchar()就把缓冲区中里出口最近的一个字符输出，也就是最前面的一个字符输出，输出后，就把它释放掉了，但后面还有字符串，所以我们就用循环把最前面的一个字符一个个的在内存中释放掉，直到不满足循环条件退出为止。</p>
</li>
<li><p>例子中循环条件里的’\n’实际上就是你输入字符串后的回车符，所以意思就是说，直到遇到回车符才结束循环，而getchar()函数就是等待输入（或缓冲区中的数据）直到按回车才结束，所以实现了整个字符串的输出。当然，我们也可以把循环条件改一下，比如while ((c=getchar())!=’a’)，什么意思呢，意思就是遇到字符’a’就停止循环，当然意思是如果你输入“12345a213123\n”那么只会输出到a，结果是12345a。</p>
</li>
<li><p>再次<strong>注意</strong>：用getchar()它是从“流”中间去读取，所以第一个getchar()接受的是刚刚中断的流队列中即将出列的第一个字符（不限于回车符，上面举过例子了），如果流队列不为空，执行getchar()就继续放水，直到把回车符也放空为止，空了之后再在执行getchar()就停下等待你的输入了；我们用getch()为什么每次都是等待用户的输入呢？因为getch()是从键盘接收，即时的接收，并不是从stdin流中去读取数据。</p>
</li>
<li><p>补充：按键盘上的回车产生了2个字符:回车符(‘\r’)和换行符(‘\n’)。回车符’\r’(CR:carriage return:倒车）使光标回到这行的首部，换行符(‘\n’)(new line)然后再换行。</p>
</li>
<li><p><strong>所以当输入字符’w’,并按下回车键以后。首先得到回车符。那个getchar函数结束了。 但是还存在一个换行符。所以如果用getchar()来做判断的时候。最好再写一次getchar()清除缓冲区的’/n’.</strong></p>
</li>
</ul>
<h3 id="如何清空输入缓冲区的内容？"><a href="#如何清空输入缓冲区的内容？" class="headerlink" title="如何清空输入缓冲区的内容？"></a>如何清空输入缓冲区的内容？</h3><ul>
<li><p>如果我想让getchar()每次都能够等待用户输入的话就要清空缓冲区，下面就介绍方法（不同平台）</p>
</li>
<li><p>C标准规定 fflush()函数是用来刷新输出（stdout）缓存的。对于输入（stdin），它是没有定义的。但是有些编译器也定义了 fflush( stdin )的实现，比如微软的VC。其它编译器是否也定义了 fflush( stdin )的实现应当查找它的手册。GCC编译器没有定义它的实现，所以不能使用 fflush( stdin )来刷新输入缓存。</p>
</li>
<li><p>对于没有定义 fflush( stdin )的编译器，可以使用 fgets()函数来代替它（比用 getchar()、scanf()等函数通用性好）。可以这样忽略输入流中留下的回车等其它输入，从而使下一次的输入总保持一个“干净”的状态。（这个是任何平台下都可以的）</p>
<pre><code>// ...
char sbuf[1024];
// ...
fgets( sbuf, 1024, stdin );
// ...
</code></pre></li>
<li><p>在windows 的vc下面就可以这样了</p>
<pre><code>for(int i=0;i&lt;10;++i)
{
       char ch=getchar();
       fflush(stdin); //每次都会有等待状态了
}
</code></pre></li>
</ul>
<h3 id="运用实例"><a href="#运用实例" class="headerlink" title="运用实例"></a>运用实例</h3><pre><code>//从键盘输入一些字符，逐个把它们送到磁盘上去，直到输入一个&quot;#&quot;为止

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main()
{
    FILE *fp;
    char ch,filename[10];
    scanf(&quot;%s&quot;,filename);
    if((fp=fopen(filename,&apos;w&apos;))==NULL)
    {
        printf(&quot;cannnot open file\n&quot;);
        exit(0);   /* 终止程序 */
    }
    ch=getchar();   /* 此语句用来接收在执行scanf语句时最后输入的回车符 */
    ch=getchar( );   /* 接收输入的第一个字符 */
    while(ch!=&apos;#&apos;)
    {
        fputc(ch,fp);
        putchar(ch);
        ch=getchar();
    }
    putchar(10);  /*向屏幕输出一个换行符 */
    fclose(fp);
}
</code></pre><ul>
<li>运行情况如下：</li>
</ul>
<blockquote>
<p>file1.c↙             (输入磁盘文件名)<br>computer and c#↙     (输入一个字符串)<br>computer and c        (输出一个字符串)</p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>输入输出</tag>
        <tag>getch</tag>
      </tags>
  </entry>
  <entry>
    <title>redhat更新yum源进行软件在线安装</title>
    <url>/post/44387.html</url>
    <content><![CDATA[<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><ul>
<li><p>YUM是Redhat Linux在线安装更新及软件的工具，但是这是RHEL5的收费功能，如果没有购买Redhat的服务时不能使用RHEL5的更新源的，会提示注册。由于CentOS是从Redhat演化而来的免费Linux版本，因此可以利用CentOS的yum更新源来实现RHEL5的YUM功能。</p>
</li>
<li><p>配置方法如下：检查yum是否安装，默认情况下都是安装好的，总共4各包</p>
<pre><code>[root@localhost /]# rpm -qa |grep yum
yum-3.2.22-20.el5
yum-security-1.1.16-13.el5
yum-metadata-parser-1.1.2-3.el5
yum-updatesd-0.9-2.el5
yum-rhn-plugin-0.5.4-13.el5
</code></pre><a id="more"></a>
<h3 id="更新yum源"><a href="#更新yum源" class="headerlink" title="更新yum源"></a>更新yum源</h3></li>
<li><p>修改/etc/yum.conf文件，用下面代码全部覆盖。定义yum更新源，这里使用的是上海交大的CentOS更新源</p>
<pre><code>[main]

cachedir=/var/cache/yum

keepcache=1

debuglevel=2

logfile=/var/log/yum.log

pkgpolicy=newest

distroverpkg=redhat-release

tolerant=1

exactarch=1

obsoletes=1

gpgcheck=1

plugins=1

[base]
name=CentOS-5-Base
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever5&amp;arch=$basearch&amp;repo=os
#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
baseurl=http://ftp.sjtu.edu.cn/centos/5/os/$basearch/
gpgcheck=0
gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
#released updates
[update]
name=CentOS-5-Updates
#mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=updates
baseurl=http://ftp.sjtu.edu.cn/centos/5/updates/$basearch/
gpgcheck=0
gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
#packages used/produced in the build but not released
[addons]
name=CentOS-5-Addons
#mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=addons
baseurl=http://ftp.sjtu.edu.cn/centos/5/addons/$basearch/
gpgcheck=0
gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
#additional packages that may be useful
[extras]
name=CentOS-5-Extras
#mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=extras
baseurl=http://ftp.sjtu.edu.cn/centos/5/extras/$basearch/
gpgcheck=0
gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
#additional packages that extend functionality of existing packages
[centosplus]
name=CentOS-5-Plus
#mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=centosplus
baseurl=http://ftp.sjtu.edu.cn/centos/5/centosplus/$basearch/
gpgcheck=0
enabled=0
gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
#contrib - packages by Centos Users
[contrib]
name=CentOS-5-Contrib
#mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=contrib
baseurl=http://ftp.sjtu.edu.cn/centos/5/contrib/$basearch/
gpgcheck=0
enabled=0
gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
# vi dag.repo
[dag]
name=Dag RPM Repository for RHEL5
baseurl=http://ftp.riken.jp/Linux/dag/redhat/el5/en/$basearch/dag/
enabled=1
gpgcheck=0
gpgkey=http://ftp.riken.jp/Linux/dag/packages/RPM-GPG-KEY.dag.txt]
</code></pre></li>
<li><p>修改yum.conf配置文件中[main]部分的参数详细说明如下：</p>
</li>
</ul>
<pre><code>[main] //main开头的块用于对客户端进行配置，在main后也可以指定yum源（不推荐这样做），与/etc/yum.repo.d中指定yum源相同

cachedir=/var/cache/yum
#cachedir：yum更新软件时的缓存目录，默认设置为/var/cache/yum
keepcache=[1 or 0]

#设置 keepcache=1，yum 在成功安装软件包之后保留缓存的头文件 (headers) 和软件包。默认值为 keepcache=0 不保存

debuglevel=2
#debuglevel：Debug信息输出等级，范围为0-10，缺省为2
logfile=/var/log/yum.log
#logfile：存放系统更新软件的日志的目录。用户可以到/var/log/yum.log文件去查询自己在过去的日子里都做了哪些更新。
pkgpolicy=newest
#包的策略。一共有两个选项，newest和last，这个作用是如果你设置了多个repository，而同一软件在不同的repository中同时存在，yum应该安装哪一个，如果是newest，则yum会安装最新的那个版本。如果是last，则yum会将服务器id以字母表排序，并选择最后的那个服务器上的软件安装。一般都是选newest。
distroverpkg=redhat-release
#指定一个软件包，yum会根据这个包判断你的发行版本，默认是redhat-release，也可以是安装的任何针对自己发行版的rpm包。
tolerant=1
#如果值为1，则yum会忽略任何的有关包的错误。举例来说，当执行yum来安装baz时，如果baz包已经安装在系统中了，则yum会继续重复安装baz，而不会报错。默认值为1。
exactarch=1
#设置为1，则yum只会安装和系统架构匹配的软件包，例如，yum不会将i686的软件包安装在适合i386的系统中。默认为1
retries=20
#网络连接发生错误后的重试次数，如果设为0，则会无限重试。默认值为6
obsoletes=1
#此选项在进行发行版跨版本升级的时候会用到。
gpgcheck=1
#有1和0两个选择，分别代表是否是否进行gpg校验。这个选项如果设置在[main]部分，则对每个repository都有效。默认值为0.
plugins = 1 //是否启用插件，默认1为允许，0表示不允许
</code></pre><ul>
<li><p>修改完yum.conf文件，使用下列命令进行配置。</p>
<pre><code>yum clean all    清楚缓存
yum makecache    更新生成缓存
</code></pre></li>
</ul>
<h3 id="使用yum安装软件"><a href="#使用yum安装软件" class="headerlink" title="使用yum安装软件"></a>使用yum安装软件</h3><h3 id="1-用YUM安装删除软件"><a href="#1-用YUM安装删除软件" class="headerlink" title="1. 用YUM安装删除软件"></a>1. 用YUM安装删除软件</h3><ul>
<li><p>注：Yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
</li>
<li><p>在系统中添加删除软件是常事，yum同样可以胜任这一任务，只要软件是rpm安装的。安装的命令是，yum install xxx，yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断。删除的命令是，yum remove xxx，同安装一样，yum也会查询数据库，给出解决依赖关系的提示。</p>
</li>
</ul>
<ul>
<li><p>用YUM安装软件包命令：</p>
<pre><code>yum install xxx
</code></pre></li>
<li><p>用YUM删除软件包命令：</p>
<p>  yum remove xxx</p>
</li>
</ul>
<h3 id="2-用YUM查询软件信息"><a href="#2-用YUM查询软件信息" class="headerlink" title="2. 用YUM查询软件信息"></a>2. 用YUM查询软件信息</h3><ul>
<li>我们常会碰到这样的情况，想要安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字。这时yum的查询功能就起作用了。<br>你可以用 yum  search keyword这样的命令来进行搜索，比如我们要则安装一个Instant Messenger,但又不知到底有哪些，这时不妨用yum search messenger这样的指令进行搜索，yum会搜索所有可用rpm的描述，列出所有描述中和messeger有关的rpm包，于是我们可能得到gaim,kopete等等，并从中选择。有时我们还会碰到安装了一个包，但又不知道其用途，我们可以用yum info packagename这个指令来获取信息。</li>
</ul>
<p>　　使用YUM查找软件包命令：</p>
<pre><code>yum search
</code></pre><p>　　列出所有可安装的软件包命令：</p>
<pre><code>yum list
</code></pre><p>　　列出所有可更新的软件包命令：</p>
<pre><code>yum list updates
</code></pre><p>　　列出所有已安装的软件包命令：</p>
<pre><code>yum list installed
</code></pre><p>　　列出所有已安装但不在 Yum Repository 内的软件包命令：</p>
<pre><code>yum list extras
</code></pre><p>　　列出所指定的软件包命令：</p>
<pre><code>yum list
</code></pre><h3 id="Ubuntu中的高级包管理方法apt-get"><a href="#Ubuntu中的高级包管理方法apt-get" class="headerlink" title="Ubuntu中的高级包管理方法apt-get"></a>Ubuntu中的高级包管理方法apt-get</h3><ul>
<li>apt-get的一大好处是极大地减小了所谓依赖关系恶梦的发生几率(dependency hell)，即使是陷入了dependency hell,apt-get也提供了很好的援助手段。通常 apt-get 都和网上的压缩包一起出没，从互联网上下载或是安装。</li>
</ul>
<h3 id="apt方式安装："><a href="#apt方式安装：" class="headerlink" title="apt方式安装："></a>apt方式安装：</h3><ol>
<li>打开一个终端，su -成root用户；</li>
<li>apt-cache search soft 注：soft是您要找的软件的名称或相关信息</li>
<li>假如2中找到了软件soft.version，则用apt-get install soft.version命令安装软件 注：只要您能够上网，只需要用apt-cache search查找软件，用apt-get install软件</li>
</ol>
<ul>
<li><p>常用的APT命令参数</p>
<pre><code>apt-cache search package 搜索包
apt-cache show package 获取包的相关信息，如说明、大小、版本等
sudo apt-get install package 安装包
sudo apt-get install package - - reinstall 重新安装包
sudo apt-get -f install 修复安装&quot;-f = --fix-missing&quot;
sudo apt-get remove package 删除包
sudo apt-get remove package - - purge 删除包，包括删除配置文件等
sudo apt-get update 更新源sudo apt-get upgrade 更新已安装的包
sudo apt-get dist-upgrade 升级系统
sudo apt-get dselect-upgrade 使用 dselect 升级
apt-cache depends package 了解使用依赖
apt-cache rdepends package 是查看该包被哪些包依赖
sudo apt-get build-dep package 安装相关的编译环境
apt-get source package 下载该包的源代码
sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包
sudo apt-get check 检查是否有损坏的依赖
</code></pre></li>
</ul>
<h2 id="其他软件安装技巧"><a href="#其他软件安装技巧" class="headerlink" title="其他软件安装技巧"></a>其他软件安装技巧</h2><h3 id="1-linux下安装软件，如何知道软件安装位置"><a href="#1-linux下安装软件，如何知道软件安装位置" class="headerlink" title="1. linux下安装软件，如何知道软件安装位置"></a>1. linux下安装软件，如何知道软件安装位置</h3><blockquote>
<p>注：一般的软件的默认安装目录在/usr/local或者/opt里，可以到那里去找找.</p>
</blockquote>
<ul>
<li><p>指令名称：whereis</p>
</li>
<li><p>功能介绍：在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。</p>
</li>
<li><p>语法格式：whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…]</p>
</li>
<li><p>常用参数说明：</p>
</li>
</ul>
<p>　-b 　只查找二进制文件。<br>　-B &lt;目录&gt; 　只在设置的目录下查找二进制文件。<br>　-f 　不显示文件名前的路径名称。<br>　-m 　只查找说明文件。<br>　-M &lt;目录&gt; 　只在设置的目录下查找说明文件。<br>　-s 　只查找原始代码文件。<br>　-S &lt;目录&gt; 　只在设置的目录下查找原始代码文件。<br>　-u 　查找不包含指定类型的文件。</p>
<ul>
<li>应用：#whereis  软件名   –&gt;查看软件安装路径</li>
<li>#which  软件名     –&gt;软件软件的运行路径</li>
</ul>
<h3 id="2-通过rpm包管理器安装的软件："><a href="#2-通过rpm包管理器安装的软件：" class="headerlink" title="2. 通过rpm包管理器安装的软件："></a>2. 通过rpm包管理器安装的软件：</h3><ul>
<li>rpm包</li>
</ul>
<ul>
<li><p>可以用命令：</p>
<pre><code>#rpm –ql 包名           如 rpm -ql gcc 来查看gcc的文件都安装到哪里去了
#rpm -qa | grep 包名   来查看有没有安装这个包 ，
#rpm -qa              查看全部已经安装的包名
</code></pre></li>
</ul>
<ul>
<li>deb包</li>
</ul>
<ul>
<li><p>可以用命令：</p>
<pre><code>#dpkg -L 包名 查看如 dpkg -L gcc 来查看gcc的文件。
#dpkg -l | grep 包名  来查看有没有安装某个包 ，
# dpkg -l            是查看全部包的
</code></pre></li>
</ul>
<h2 id="其他更多软件安装方法技巧"><a href="#其他更多软件安装方法技巧" class="headerlink" title="其他更多软件安装方法技巧"></a>其他更多软件安装方法技巧</h2><blockquote>
<p>参考[<a href="http://blog.chinaunix.net/uid-28769209-id-4257451.html]:http://blog.chinaunix.net/uid-28769209-id-4257451.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-28769209-id-4257451.html]:http://blog.chinaunix.net/uid-28769209-id-4257451.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>yum</tag>
        <tag>redhat</tag>
      </tags>
  </entry>
  <entry>
    <title>Cgroup</title>
    <url>/post/10807.html</url>
    <content><![CDATA[<p>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制。</p>
<p>CGroup 是将任意进程进行分组化管理的 Linux 内核功能。CGroup 本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O 或内存的分配控制等具体的资源管理功能是通过这个功能来实现的。这些具体的资源管理功能称为 CGroup 子系统或控制器。CGroup 子系统有控制内存的 Memory 控制器、控制进程调度的 CPU 控制器等。运行中的内核可以使用的 Cgroup 子系统由<code>/proc/cgroup</code> 来确认，根据系统对资源的需求，这个根进程组将被进一步细分为子进程组，子进程组内的进程是根进程组内进程的子集。而这些子进程组很有可能继续被进一步细分，最终，系统内所有的进程组形成一颗具有层次等级（hierarchy）关系的进程组树。</p>
<p><img src="/images/cgroup/cgroup_tree.jpeg" alt="cgroup tree"></p>
<a id="more"></a>
<h2 id="Cgroup虚拟文件系统"><a href="#Cgroup虚拟文件系统" class="headerlink" title="Cgroup虚拟文件系统"></a>Cgroup虚拟文件系统</h2><blockquote>
<p>CGroup 提供了一个 CGroup 虚拟文件系统，作为进行分组管理和各子系统设置的用户接口。要使用 CGroup，必须挂载 CGroup 文件系统。这时通过挂载选项指定使用哪个子系统。</p>
</blockquote>
<p><img src="/images/cgroup/cgroup_struct.jpeg" alt="cgroup stru"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@buildroot /]# mount -t cgroup cgroup /mnt/</span><br><span class="line">[root@buildroot /]# ls /mnt/</span><br><span class="line">blkio.reset_stats                cpuset.mem_exclusive</span><br><span class="line">cgroup.clone_children            cpuset.mem_hardwall</span><br><span class="line">cgroup.event_control             cpuset.memory_migrate</span><br><span class="line">cgroup.procs                     cpuset.memory_pressure</span><br><span class="line">cgroup.sane_behavior             cpuset.memory_pressure_enabled</span><br><span class="line">cpu.cfs_period_us                cpuset.memory_spread_page</span><br><span class="line">cpu.cfs_quota_us                 cpuset.memory_spread_slab</span><br><span class="line">cpu.rt_period_us                 cpuset.mems</span><br><span class="line">cpu.rt_runtime_us                cpuset.sched_load_balance</span><br><span class="line">cpu.shares                       cpuset.sched_relax_domain_level</span><br><span class="line">cpu.stat                         devices.allow</span><br><span class="line">cpuacct.stat                     devices.deny</span><br><span class="line">cpuacct.usage                    devices.list</span><br><span class="line">cpuacct.usage_percpu             notify_on_release</span><br><span class="line">cpuset.cpu_exclusive             release_agent</span><br><span class="line">cpuset.cpus                      tasks</span><br></pre></td></tr></table></figure>
<p>各个子系统的挂载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t cgroup -o cpu cgroup /mnt/</span><br><span class="line">mount -t cgroup -o cpu,cpuset cgroup /mnt/</span><br><span class="line">mount -t cgroup -o cpu,cpuset,devices cgroup /mnt/</span><br></pre></td></tr></table></figure></p>
<p>CGroup 支持的文件种类:</p>
<table>
<thead>
<tr>
<th style="text-align:center">文件</th>
<th style="text-align:center">R/W</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">release_agent</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">删除分组时执行的命令，这个文件只存在于根分组</td>
</tr>
<tr>
<td style="text-align:center">notify_on_release</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">设置是否执行 release_agent。为 1 时执行</td>
</tr>
<tr>
<td style="text-align:center">tasks</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">属于分组的线程 TID 列表(进程ID)</td>
</tr>
<tr>
<td style="text-align:center">cgroup.procs</td>
<td style="text-align:center">R</td>
<td style="text-align:center">属于分组的进程 PID 列表。仅包括多线程进程的线程 leader 的 TID，这点与 tasks 不同</td>
</tr>
<tr>
<td style="text-align:center">cgroup.event_control</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">监视状态变化和分组删除事件的配置文件</td>
</tr>
</tbody>
</table>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>子系统（subsystem）<br>一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@buildroot ~]# cat /proc/cgroups</span><br><span class="line">#subsys_name      hierarchy       num_cgroups     enabled</span><br><span class="line">cpuset    1       1       1</span><br><span class="line">cpu       1       1       1</span><br><span class="line">cpuacct   1       1       1</span><br><span class="line">devices   1       1       1</span><br><span class="line">freezer   1       1       1</span><br><span class="line">blkio     1       1       1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Version: Linux-3.10.14</p>
</blockquote>
<p>1.<code>cpuset</code>: 为cgroup中的任务分配独立CPU（SMP多核）和内存节点<br>2.<code>cpu</code>： 提供调度程序对CPU的cgroup任务访问<br>3.<code>cpuacct</code>： 自动生成cgroup中任务所使用的CPU报告<br>4.<code>devices</code>: 允许或拒绝cgroup中的任务访问设备<br>5.<code>freezer</code>：挂起或者恢复cgroup中的任务<br>6.<code>blkio</code>： 块设备输入输出的限制<br>7.<code>perf_event</code>：  增加了对每group的监测跟踪的能力，即可以监测属于某个特定的group的所有线程以及运行在特定CPU上的线程，此功能对于监测整个group非常有用，<a href="https://lwn.net/Articles/421574/" target="_blank" rel="noopener">https://lwn.net/Articles/421574/</a></p>
<ul>
<li>层级（hierarchy）<br>控制族群可以组织成 hierarchical 的形式，既一颗控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@buildroot ~]# cat /proc/cgroups</span><br><span class="line">#subsys_name      hierarchy       num_cgroups     enabled</span><br><span class="line">cpuset    0       1       1</span><br><span class="line">cpu       0       1       1</span><br><span class="line">cpuacct   0       1       1</span><br><span class="line">devices   0       1       1</span><br><span class="line">freezer   0       1       1</span><br><span class="line">blkio     0       1       1</span><br><span class="line">[root@buildroot ~]# mount -t cgroup -o cpu cgroup /mnt/cpu/</span><br><span class="line">[root@buildroot ~]# mount -t cgroup -o cpuset cgroup /mnt/cpuset/</span><br><span class="line">[root@buildroot ~]# mount -t cgroup -o devices cgroup /mnt/blkio/</span><br><span class="line">[root@buildroot ~]# mount -t cgroup -o blkio cgroup /mnt/blkio/</span><br><span class="line">[root@buildroot ~]# cat /proc/cgroups</span><br><span class="line">#subsys_name      hierarchy       num_cgroups     enabled</span><br><span class="line">cpuset    0       1       1</span><br><span class="line">cpu       4       1       1</span><br><span class="line">cpuacct   0       1       1</span><br><span class="line">devices   0       1       1</span><br><span class="line">freezer   0       1       1</span><br><span class="line">blkio     0       1       1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>一个子系统最多只能附加到一个层级</p>
</blockquote>
<ul>
<li>控制族群（control group）</li>
</ul>
<p>控制族群就是一组按照某种标准划分的进程。Cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制.<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@buildroot cpu]# mkdir aaa</span><br><span class="line">[root@buildroot cpu]# mkdir bbb</span><br><span class="line">[root@buildroot cpu]# ls</span><br><span class="line">aaa/                   cgroup.sane_behavior   cpu.shares</span><br><span class="line">bbb/                   cpu.cfs_period_us      cpu.stat</span><br><span class="line">cgroup.clone_children  cpu.cfs_quota_us       notify_on_release</span><br><span class="line">cgroup.event_control   cpu.rt_period_us       release_agent</span><br><span class="line">cgroup.procs           cpu.rt_runtime_us      tasks</span><br><span class="line">[root@buildroot cpu]# ls aaa/ bbb/</span><br><span class="line">aaa/:</span><br><span class="line">cgroup.clone_children  cpu.cfs_quota_us       cpu.stat</span><br><span class="line">cgroup.event_control   cpu.rt_period_us       notify_on_release</span><br><span class="line">cgroup.procs           cpu.rt_runtime_us      tasks</span><br><span class="line">cpu.cfs_period_us      cpu.shares</span><br><span class="line"></span><br><span class="line">bbb/:</span><br><span class="line">cgroup.clone_children  cpu.cfs_quota_us       cpu.stat</span><br><span class="line">cgroup.event_control   cpu.rt_period_us       notify_on_release</span><br><span class="line">cgroup.procs           cpu.rt_runtime_us      tasks</span><br><span class="line">cpu.cfs_period_us      cpu.shares</span><br></pre></td></tr></table></figure></p>
<ul>
<li>任务（task）<br>在 cgroups 中，任务就是系统的一个进程<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@buildroot cpu]# cat tasks</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li>每次在系统中创建新层级时，该系统中的所有任务都是那个层级的默认 cgroup（我们称之为 <code>root cgroup</code>，此cgroup在创建层级时自动创建，后面在该层级中创建的cgroup都是此cgroup的后代）的初始成员;</li>
</ul>
<p><code>root cgroup:</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@buildroot mnt]# cat tasks</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><code>subsys cgroup:</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@buildroot mnt]# mkdir aaa</span><br><span class="line">[root@buildroot mnt]# cd aaa/</span><br><span class="line">[root@buildroot aaa]# cat tasks</span><br></pre></td></tr></table></figure></p>
<ul>
<li>一子系统最多只能附加到一个层级;</li>
<li>一个层级可以附加多个子系统;</li>
<li>一个任务可以是多个cgroup的成员，但是这些cgroup必须在不同的层级;</li>
<li>系统中的进程（任务）创建子进程（任务）时，该子任务自动成为其父进程所在 cgroup的成员。然后可根据需要将该子任务移动到不同的 cgroup 中，但开始时它总是继承其父任务的cgroup。</li>
</ul>
<h2 id="限制cpu的资源"><a href="#限制cpu的资源" class="headerlink" title="限制cpu的资源"></a>限制cpu的资源</h2><p>CPU资源的控制，主要是对CPU计算的控制，可以最大化的利用CPU资源。而<code>进程</code>是对CPU资源的利用实体。</p>
<h3 id="实时进程控制-–-系统整体"><a href="#实时进程控制-–-系统整体" class="headerlink" title="实时进程控制 – 系统整体"></a>实时进程控制 – 系统整体</h3><blockquote>
<p>控制实时进程的CPU资源占用</p>
</blockquote>
<ul>
<li><p>获取当前系统的设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sysctl -n kernel.sched_rt_period_us   <span class="comment"># 实时进程调度的单位CPU时间 1 秒</span></span></span><br><span class="line">1000000</span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl -n kernel.sched_rt_runtime_us  <span class="comment"># 实时进程在 1 秒中实际占用的CPU时间, 0.95秒</span></span></span><br><span class="line">950000</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置实时进程占用CPU时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sysctl -w kernel.sched_rt_runtime_us=970000 <span class="comment"># 设置实时进程每1秒中只占0.97秒的CPU时间</span></span></span><br><span class="line">kernel.sched_rt_runtime_us = 970000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>sysctl -w : 临时修改指定参数的值</p>
</blockquote>
<h3 id="实时进程控制-–-系统部分"><a href="#实时进程控制-–-系统部分" class="headerlink" title="实时进程控制 – 系统部分"></a>实时进程控制 – 系统部分</h3><blockquote>
<p>通过cgroup对一组进程中的实时进程的CPU资源进行控制.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mount -t cgroup cgroup -o cpu /mnt/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">cgroup.clone_children  cpu.cfs_quota_us       notify_on_release</span><br><span class="line">cgroup.event_control   cpu.rt_period_us       release_agent</span><br><span class="line">cgroup.procs           cpu.rt_runtime_us      tasks</span><br><span class="line">cgroup.sane_behavior   cpu.shares</span><br><span class="line">cpu.cfs_period_us      cpu.stat</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat cpu.rt_period_us cpu.rt_runtime_us</span></span><br><span class="line">1000000</span><br><span class="line">950000</span><br></pre></td></tr></table></figure>
<p>通过虚拟文件系统mount出CPU子系统，为CPU子系统的根节点，其可以控制整个系统的进程<code>tasks</code>,因此如果想对部分实时进程进行控制，需要创建子cgroup，并将需要控制的进程搬到新的cgroup中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir rt_ctl</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> rt_ctl/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> PID &gt; tasks</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 1000000 &gt; cpu.rt_period_us</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 920000 &gt; cpu.rt_runtime_us</span></span><br></pre></td></tr></table></figure>
<p>通过配置<code>cpu.rt_period_us</code>和<code>cpu.rt_runtime_us</code>就可以对<code>rt_ctl cgroup</code> 中的进程组中的实时进程进行CPU使用时间的控制.</p>
<p>在子cgroup中，对相关子系统进行修改时，该子系统的相关属性小于父cgroup属性的相应值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 960000 &gt; cpu.rt_runtime_us</span></span><br><span class="line">sh: write error: Invalid arguments</span><br></pre></td></tr></table></figure>
<h2 id="限制进程的内存资源"><a href="#限制进程的内存资源" class="headerlink" title="限制进程的内存资源"></a>限制进程的内存资源</h2><p>内核配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Location:</span><br><span class="line">  -&gt; General setup</span><br><span class="line">    -&gt; Control Group support (CGROUPS [=y])</span><br><span class="line">      -&gt; Resource counters (RESOURCE_COUNTERS [=y])</span><br><span class="line">        -&gt; Memory Resource Controller for Control Groups (MEMCG [=y])</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mount -t cgroup -o memory cgroup /mnt/</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /mnt/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">cgroup.clone_children               memory.kmem.usage_in_bytes</span><br><span class="line">cgroup.event_control                memory.limit_in_bytes</span><br><span class="line">cgroup.procs                        memory.max_usage_in_bytes</span><br><span class="line">cgroup.sane_behavior                memory.move_charge_at_immigrate</span><br><span class="line">memory.failcnt                      memory.oom_control</span><br><span class="line">memory.force_empty                  memory.pressure_level</span><br><span class="line">memory.kmem.failcnt                 memory.soft_limit_in_bytes</span><br><span class="line">memory.kmem.limit_in_bytes          memory.stat</span><br><span class="line">memory.kmem.max_usage_in_bytes      memory.swappiness</span><br><span class="line">memory.kmem.slabinfo                memory.usage_in_bytes</span><br><span class="line">memory.kmem.tcp.failcnt             memory.use_hierarchy</span><br><span class="line">memory.kmem.tcp.limit_in_bytes      notify_on_release</span><br><span class="line">memory.kmem.tcp.max_usage_in_bytes  release_agent</span><br><span class="line">memory.kmem.tcp.usage_in_bytes      tasks</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>memsw</code>:表示虚拟内存，不带<code>memsw</code>的仅包括物理内存</p>
</blockquote>
<ul>
<li><p><code>limit_in_bytes</code> 是用来限制内存使用 ,memory.memsw.limit_in_bytes 必须大于或等于 memory.limit_in_byte。要解除内存限制，对应的值设为 -1</p>
<blockquote>
<p>这种方式限制进程内存占用会有个风险。当进程试图占用的内存超过限制时，会触发 oom ，导致进程直接被杀，从而造成可用性问题。即使关闭控制组的 oom killer，在内存不足时，进程虽然不会被杀，但是会长时间进入 D 状态（等待系统调用的不可中断休眠），并被放到 OOM-waitqueue 等待队列中， 仍然导致服务不可用。因此，用 memory.limit_in_bytes 或 memory.memsw.limit_in_bytes 限制进程内存占用仅应当作为一个保险，避免在进程异常时耗尽系统资源</p>
</blockquote>
</li>
<li><p><code>memory.oom_control</code>：内存超限之后的OOM行为控制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat memory.oom_control</span></span><br><span class="line">oom_kill_disable 0</span><br><span class="line">under_oom 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>关闭oom killer： <code>oom_kill_disable为1</code></p>
</blockquote>
<ul>
<li><p><code>memory.soft_limit_in_bytes</code>: memory.limit_in_bytes 的不同是，这个限制并不会阻止进程使用超过限额的内存，只是在系统内存足够时，会优先回收超过限额的内存，使之向限定值靠拢。</p>
</li>
<li><p><code>memory.usage_in_bytes</code>: 当前使用量</p>
</li>
<li><code>memory.max_usage_in_bytes</code>: 最高使用量</li>
<li><code>memory.failcnt</code>: 发生的缺页次数（申请内存失败的次数)</li>
<li><code>memory.stat</code>: 就是内存使用情况报告了。包括当前资源总量、使用量、换页次数、活动页数量等等</li>
</ul>
<h2 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h2><p>在多核处理器时，如果想将一个进程指定到特定的CPU上进行执行，可通过<code>cpuset</code>子系统实现。</p>
<blockquote>
<p><code>cpuset</code>:针对 CPU 核心进行隔离，其实就是把要运行的进程绑定到指定的核心上运行，通过让不同的进程占用不同的核心，以达到运算资源隔离的目的。为cgroup中的任务分配独立<code>CPU（在多核系统）</code>和<code>内存节点</code>。</p>
</blockquote>
<ol>
<li>挂载 cgroup 文件系统, 并指定 -o cpuset</li>
<li>指定 A 的物理CPU为 0 (双核CPU的每个核编号分别是 CPU0, CPU1)</li>
<li>指定 B 的物理CPU也为 1</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mount -t cgroup -o cpuset cgroup /mnt/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat cpuset.cpus cpuset.mems</span></span><br><span class="line">0-1</span><br><span class="line">0</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /mnt/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir A B <span class="comment"># 创建子cgroup A 和 B</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat A/cpuset.cpus</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat B/cpuset.cpus</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 0 &gt; A/cpuset.cpus <span class="comment"># 设置A组绑定到CPU0</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 1 &gt; B/cpuset.cpus <span class="comment"># 设置B组绑定到CPU1</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 0 &gt; A/cpuset.mems <span class="comment"># 设置A组绑定内存</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 0 &gt; B/cpuset.mems <span class="comment"># 设置A组绑定内存</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> pid1 &gt; A/tasks <span class="comment">#将B组进程迁入A组</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> pid2 &gt; B/tasks <span class="comment">#将A组进程迁入B组</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># echo $$ &gt; tasks</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">sh: write error: No space left on devices</span></span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>原因</strong>：没有配置<code>cpuset.mems</code></p>
</blockquote>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><blockquote>
<p>ltp-full-20140115/testcases/kernel/controllers/cpuctl/cpuctl_test02.c</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/" target="_blank" rel="noopener">CGroup 介绍、应用实例及原理描述</a></li>
<li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/6/html/resource_management_guide/ch01" target="_blank" rel="noopener">控制族群（CGROUP）</a></li>
<li><a href="http://blog.csdn.net/ljy1988123/article/details/48032577" target="_blank" rel="noopener">Linux内核工程导论——CGroup子系统</a></li>
<li><a href="http://blog.csdn.net/arnoldlu/article/details/52945252" target="_blank" rel="noopener">Linux资源控制-使用cgroup控制CPU和内存</a></li>
<li><a href="https://www.jianshu.com/p/dc3140699e79" target="_blank" rel="noopener">cgroup实践-资源控制</a></li>
<li><a href="https://www.cnblogs.com/acool/p/6852250.html" target="_blank" rel="noopener">cgroup原理简析:vfs文件系统</a></li>
<li><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="noopener">Docker背后的内核知识——cgroups资源限制</a></li>
<li><a href="https://blog.csdn.net/jk198310/article/details/9288877" target="_blank" rel="noopener">Linux cgroup机制分析之框架分析</a></li>
</ol>
]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux应用调试方法---Debug</title>
    <url>/post/43503.html</url>
    <content><![CDATA[<p>常用的Linux应用调试方法：<code>GDB</code></p>
<a id="more"></a>
<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ./a.out</span><br></pre></td></tr></table></figure>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>core dump</p>
<h3 id="查看core设置"><a href="#查看core设置" class="headerlink" title="查看core设置"></a>查看core设置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 30956</span><br><span class="line">max locked memory       (kbytes, -l) 16384</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 30956</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>
<h3 id="开启core-file"><a href="#开启core-file" class="headerlink" title="开启core file"></a>开启core file</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p>ubuntu18.04 64bit</p>
</blockquote>
<ul>
<li>异常程序(段错误)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line"></span><br><span class="line">    *a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译*<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g test.c</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>运行异常程序后,生成core文件</p>
</li>
<li><p>使用gdb查看异常位置</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ./a.out core</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from ./a.out...done.</span><br><span class="line"></span><br><span class="line">warning: exec file is newer than core file.</span><br><span class="line">[New LWP 20661]</span><br><span class="line">Core was generated by `./a.out&apos;.</span><br><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x0000563a00047609 in main (argc=1, argv=0x7ffe99b73178) at tst.c:8</span><br><span class="line">8	    *a = 1;</span><br></pre></td></tr></table></figure>
<h3 id="ARM平台"><a href="#ARM平台" class="headerlink" title="ARM平台"></a>ARM平台</h3><blockquote>
<p>本地编译支持arm平台的gdb</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">PWD=`pwd`</span><br><span class="line"></span><br><span class="line">mkdir tmp</span><br><span class="line">cd tmp</span><br><span class="line"></span><br><span class="line">if [ ! -f gdb-8.2.tar.gz ]; then</span><br><span class="line">    wget http://101.110.118.57/ftp.gnu.org/gnu/gdb/gdb-8.2.tar.gz</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">rm gdb-8.2 -rf</span><br><span class="line">tar zxvf gdb-8.2.tar.gz</span><br><span class="line"></span><br><span class="line">cd gdb-8.2</span><br><span class="line"></span><br><span class="line">./configure --target=arm-linux --prefix=$PWD/_install  --enable-static</span><br><span class="line">make -j2</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd .. #gdb-8.2</span><br><span class="line">cd .. #tmp</span><br></pre></td></tr></table></figure>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>目标平台直接使用gdb调试</p>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb ./a,out</span><br></pre></td></tr></table></figure>
<ul>
<li>动态的改变你程序的执行环境</li>
</ul>
<h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><table>
<thead>
<tr>
<th style="text-align:center">启动方式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$gdb</code></td>
<td style="text-align:left">直接进去交互模式</td>
</tr>
<tr>
<td style="text-align:center"><code>$gdb -tui</code></td>
<td style="text-align:left">启动可以直接将屏幕分成两个部分，上面显示源代码,上下方向键可以查看源代码,想要命令行使用上下键就用<code>Ctrl+n</code>和<code>Ctrl+p</code></td>
</tr>
<tr>
<td style="text-align:center"><code>$gdb app</code></td>
<td style="text-align:left">启动gdb调试指定程序app</td>
</tr>
<tr>
<td style="text-align:center"><code>$gdb &lt;program&gt; &lt;PID&gt;</code></td>
<td style="text-align:left"><program>是程序的可执行文件名，<pid>是要调试程序的PID</pid></program></td>
</tr>
<tr>
<td style="text-align:center"><code>$gdb &lt;PID&gt;</code></td>
<td style="text-align:left"><pid>是要调试程序的PID, 此时无法查看源码，使用<code>file</code>命令指明可执行文件就可以显示源代码</pid></td>
</tr>
</tbody>
</table>
<h3 id="调试交互"><a href="#调试交互" class="headerlink" title="调试交互"></a>调试交互</h3><blockquote>
<p>以下所有命令可以在调试时，使用<code>Tab</code>进行补全</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">别名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>help</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">显示帮助信息</td>
</tr>
<tr>
<td style="text-align:center"><code>file app</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">载入指定的程序,编译app的时候要加入<code>-g</code>调试选项</td>
</tr>
<tr>
<td style="text-align:center"><code>list n1 n2</code></td>
<td style="text-align:center"><code>l</code></td>
<td style="text-align:left">列出指定区域(n1到n2之间)的代码<a href="#list">详见list</a></td>
</tr>
<tr>
<td style="text-align:center"><code>start</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">开始执行程序,在main函数的第一条语句前面停下来</td>
</tr>
<tr>
<td style="text-align:center"><code>run</code></td>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:left">重新运行调试的程序, 它后面可以跟随发给该程序的任何参数，包括标准输入和标准输出说明符(&lt;和&gt; )和shell通配符（*、？、[、]）在内</td>
</tr>
<tr>
<td style="text-align:center"><code>continue</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">继续运行程序直接运行到下一个断点</td>
</tr>
<tr>
<td style="text-align:center"><code>next</code></td>
<td style="text-align:center"><code>n</code></td>
<td style="text-align:left">执行下一步(执行一行代码，如果是函数也会跳过函数)</td>
</tr>
<tr>
<td style="text-align:center"><code>next N</code></td>
<td style="text-align:center"><code>n N</code></td>
<td style="text-align:left">执行N次下一步</td>
</tr>
<tr>
<td style="text-align:center"><code>step</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">单步进入(执行一行代码，如果遇到函数进入函数的内部，再一行一行的执行)</td>
</tr>
<tr>
<td style="text-align:center"><code>finish</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">执行完当前函数返回到调用它的函数</td>
</tr>
<tr>
<td style="text-align:center"><code>until</code></td>
<td style="text-align:center"><code>u</code></td>
<td style="text-align:left">指定程序直到退出当前循环体</td>
</tr>
<tr>
<td style="text-align:center"><code>jump 5</code></td>
<td style="text-align:center"><code>j 5</code></td>
<td style="text-align:left">跳转执行程序到第5行</td>
</tr>
<tr>
<td style="text-align:center"><code>return</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">强制返回当前函数</td>
</tr>
<tr>
<td style="text-align:center"><code>call &lt;expr&gt;</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">强制调用函数, 如果函数的返回类型是void那么就不会打印函数的返回值</td>
</tr>
<tr>
<td style="text-align:center"><code>print &lt;expr&gt;</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">强制调用函数, 如果函数的返回值是void那么call不会打印返回值</td>
</tr>
<tr>
<td style="text-align:center"><code>break 6</code></td>
<td style="text-align:center"><code>b 6</code></td>
<td style="text-align:left">在当前的文件中某一行（假设为6）设定断点</td>
</tr>
<tr>
<td style="text-align:center"><code>break 46 if testsize==100</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">设置条件断点(如果testsize==100就在46行处断点)</td>
</tr>
<tr>
<td style="text-align:center"><code>watch &lt;expr&gt;</code></td>
<td style="text-align:center"></td>
<td style="text-align:left"><expr> 为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序(也是一种断点)</expr></td>
</tr>
<tr>
<td style="text-align:center"><code>watch i != 10</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">检测表达式变化则停住,i != 10这个表达式一旦变化，则停住</td>
</tr>
<tr>
<td style="text-align:center"><code>break func</code></td>
<td style="text-align:center"><code>b func</code></td>
<td style="text-align:left">在当前的文件中为某一函数(假设为func)处设定断点</td>
</tr>
<tr>
<td style="text-align:center"><code>break fileName:N</code></td>
<td style="text-align:center"><code>b fileName:N</code></td>
<td style="text-align:left">给指定文件（fileName）的某个行（N）处设置断点</td>
</tr>
<tr>
<td style="text-align:center"><code>info breakpoints</code></td>
<td style="text-align:center"><code>info break</code></td>
<td style="text-align:left">显示当前gdb断点信息</td>
</tr>
<tr>
<td style="text-align:center"><code>print var</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">print显示变量(var)值<a href="#print">详见print</a></td>
</tr>
<tr>
<td style="text-align:center"><code>set var name=v</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">设置变量的值</td>
</tr>
<tr>
<td style="text-align:center"><code>delete N</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">删除N号断点</td>
</tr>
<tr>
<td style="text-align:center"><code>delete</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">删除所有断点</td>
</tr>
<tr>
<td style="text-align:center"><code>clear N</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">清除行N上面的所有断点</td>
</tr>
<tr>
<td style="text-align:center"><code>clear</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">清除所有断点</td>
</tr>
<tr>
<td style="text-align:center"><code>backtrace</code></td>
<td style="text-align:center"><code>bt</code></td>
<td style="text-align:left">显示当前调用函数堆栈中的函数</td>
</tr>
<tr>
<td style="text-align:center"><code>frame</code></td>
<td style="text-align:center"><code>f</code></td>
<td style="text-align:left">查看栈帧</td>
</tr>
<tr>
<td style="text-align:center"><code>set args no</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">修改发送给程序的参数</td>
</tr>
<tr>
<td style="text-align:center"><code>show args</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">显示缺省的参数列表</td>
</tr>
<tr>
<td style="text-align:center"><code>show language</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">查看当前调试程序的语言环境,默认是c语言</td>
</tr>
<tr>
<td style="text-align:center"><code>info function</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">查看当前函数的程序语言</td>
</tr>
<tr>
<td style="text-align:center"><code>set language c++</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">手动设置当前的程序语言为c++</td>
</tr>
<tr>
<td style="text-align:center"><code>set language</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">查看可以设置的程序语言</td>
</tr>
<tr>
<td style="text-align:center"><code>kill</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">终止一个正在调试的程序</td>
</tr>
<tr>
<td style="text-align:center"><code>whatis var</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">显示一个变量var的类型</td>
</tr>
<tr>
<td style="text-align:center"><code>ptype var</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">以更详细的方式显示变量var的类型, 会打印出var的结构定义</td>
</tr>
<tr>
<td style="text-align:center"><code>info source</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">显示当前的调试源文件</td>
</tr>
<tr>
<td style="text-align:center"><code>info locals</code></td>
<td style="text-align:center"><code>i locals</code></td>
<td style="text-align:left">查看当前程序栈的局部变量</td>
</tr>
<tr>
<td style="text-align:center"><code>info registers</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">查看当前寄存器的值(不包括浮点寄存器)</td>
</tr>
<tr>
<td style="text-align:center"><code>info all-registers</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">查看当前寄存器的值,包括浮点寄存器</td>
</tr>
<tr>
<td style="text-align:center"><code>info frame</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">查看当前程序栈的信息</td>
</tr>
<tr>
<td style="text-align:center"><code>x/10x $sp</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">查看当前程序栈的内容</td>
</tr>
<tr>
<td style="text-align:center"><code>display</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">跟踪查看某个变量,每次停下来都显示它的值</td>
</tr>
<tr>
<td style="text-align:center"><code>[Enter]</code></td>
<td style="text-align:center"></td>
<td style="text-align:left">直接回车，执行上一步命令</td>
</tr>
<tr>
<td style="text-align:center"><code>quit</code></td>
<td style="text-align:center"><code>q</code></td>
<td style="text-align:left">退出gdb环境</td>
</tr>
</tbody>
</table>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>list</code>默认显示当前行和之后的10行，再执行又下滚10行</p>
<p>list后可以使用不同参数：</p>
<ul>
<li><code>&lt;linenum&gt;</code> : 行号</li>
<li><code>&lt;+offset&gt;</code> : 当前行号的正偏移量</li>
<li><code>&lt;-offset&gt;</code> : 当前行号的负偏移量</li>
<li><code>&lt;filename:linenum&gt;</code> : 哪个文件的哪一行</li>
<li><code>&lt;function&gt;</code> : 函数名</li>
<li><code>&lt;filename:function&gt;</code> : 哪个文件中的哪个函数</li>
<li><code>&lt;*address&gt;</code> : 程序运行时的语句在内存中的地址</li>
</ul>
<h4 id="print"><a href="#print" class="headerlink" title="print"></a>print</h4><p><code>print</code>有打印显示变量（数组、结构体）与修改运行时变量的功能</p>
<ul>
<li><code>print /x var</code>: 用16进制显示(var)值<blockquote>
<p>print可以指定显示的格式，这里用’/x’表示16进制的格式</p>
<ul>
<li><code>x</code>: 按十六进制格式显示变量。</li>
<li><code>d</code>: 按十进制格式显示变量。</li>
<li><code>u</code>: 按十六进制格式显示无符号整型。</li>
<li><code>o</code>: 按八进制格式显示变量。</li>
<li><code>t</code>: 按二进制格式显示变量。</li>
<li><code>a</code>: 按十六进制格式显示变量。</li>
<li><code>c</code>: 按字符格式显示变量。</li>
<li><code>f</code>: 按浮点数格式显示变量。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>使用打印功能时：<code>var</code>可以是变量、数组、结构体</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">print</span> aa <span class="comment">//数组</span></span><br><span class="line">$<span class="number">1</span> = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">12</span>, <span class="number">67</span>&#125;</span><br><span class="line">(gdb) <span class="built_in">print</span> tst <span class="comment">//结构体</span></span><br><span class="line">$<span class="number">2</span> = &#123;a = <span class="number">11</span>, b = <span class="number">88</span>, c = <span class="number">44</span>&#125;</span><br><span class="line">(gdb) <span class="built_in">print</span> i <span class="comment">//变量</span></span><br><span class="line">$<span class="number">3</span> = <span class="number">9</span></span><br><span class="line">(gdb) <span class="built_in">print</span> /x i</span><br><span class="line">$<span class="number">4</span> = <span class="number">0x9</span></span><br><span class="line">(gdb) <span class="built_in">print</span> /x tst</span><br><span class="line">$<span class="number">5</span> = &#123;a = <span class="number">0xb</span>, b = <span class="number">0x58</span>, c = <span class="number">0x2c</span>&#125;</span><br><span class="line">(gdb) <span class="built_in">print</span> /x aa</span><br><span class="line">$<span class="number">6</span> = &#123;<span class="number">0x1</span>, <span class="number">0x3</span>, <span class="number">0x5</span>, <span class="number">0x6</span>, <span class="number">0xc</span>, <span class="number">0x21</span>, <span class="number">0x42</span>, <span class="number">0xc</span>, <span class="number">0x43</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印内存地址"><a href="#打印内存地址" class="headerlink" title="打印内存地址"></a>打印内存地址</h4><p><code>x[/n] &lt;address&gt;</code>打印内存地址的值,n表示后面连续n个地址的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/10 0x7ffffffee3c8</span><br><span class="line">0x7ffffffee3c8: 0xfffee5f7      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7ffffffee3d8: 0xfffee60f      0x00007fff      0xfffeec01      0x00007fff</span><br><span class="line">0x7ffffffee3e8: 0xfffeec11      0x00007fff</span><br><span class="line">(gdb) x 0x7ffffffee3c8</span><br><span class="line">0x7ffffffee3c8: 0xfffee5f7</span><br></pre></td></tr></table></figure>
<h2 id="图形化gdb调试"><a href="#图形化gdb调试" class="headerlink" title="图形化gdb调试"></a>图形化gdb调试</h2><h3 id="cgdb"><a href="#cgdb" class="headerlink" title="cgdb"></a>cgdb</h3><p>cgdb是GNU调试器（GDB）的轻量级curses（基于终端）接口。 除了标准的gdb控制台之外，cgdb还提供了一个分屏视图，可以在执行时显示源代码。</p>
<blockquote>
<p>官网： <a href="http://cgdb.github.io" target="_blank" rel="noopener">http://cgdb.github.io</a></p>
</blockquote>
<p><img src="/images/2019/04/cgdb.png" alt="cgdb"></p>
<p>cgdb分为上下两栏，上面类似于vi窗口显示对应的代码，下面gdb窗口进行命令调试操作</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ESC</code></td>
<td style="text-align:center">输入焦点进入VI窗口</td>
</tr>
<tr>
<td style="text-align:center"><code>i</code></td>
<td style="text-align:center">输入焦点进入gdb控制台</td>
</tr>
</tbody>
</table>
<h4 id="VI窗口"><a href="#VI窗口" class="headerlink" title="VI窗口"></a>VI窗口</h4><p>调试快捷键</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能键</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>F5</code></td>
<td style="text-align:left">Send a <code>run</code> command to GDB</td>
</tr>
<tr>
<td style="text-align:center"><code>F6</code></td>
<td style="text-align:left">Send a <code>continue</code> command to GDB</td>
</tr>
<tr>
<td style="text-align:center"><code>F7</code></td>
<td style="text-align:left">Send a <code>finish</code> command to GDB</td>
</tr>
<tr>
<td style="text-align:center"><code>F8</code></td>
<td style="text-align:left">Send a <code>next</code> command to GDB</td>
</tr>
<tr>
<td style="text-align:center"><code>F10</code></td>
<td style="text-align:left">Send a <code>step</code> command to GDB</td>
</tr>
</tbody>
</table>
<h4 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h4><p>进入控制台使用方法与gdb一样</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><h3 id="查看线程CPU占用率"><a href="#查看线程CPU占用率" class="headerlink" title="查看线程CPU占用率"></a>查看线程CPU占用率</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps H -eo user,pid,ppid,%cpu,cmd --sort=%cpu</span><br></pre></td></tr></table></figure>
<h2 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h2><p>gdb的图形化调试，方便</p>
<p><img src="/images/2019/06/vscode_debug.png" alt="vscode_debug"></p>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><table>
<thead>
<tr>
<th style="text-align:center">插件</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c-cpp-project-generator</td>
<td style="text-align:center">直接生成项目文件</td>
</tr>
<tr>
<td style="text-align:center">Chinese (Simplified)</td>
<td style="text-align:center">汉化</td>
</tr>
<tr>
<td style="text-align:center">CMake Tools</td>
<td style="text-align:center">cmake</td>
</tr>
<tr>
<td style="text-align:center">Code Runner</td>
<td style="text-align:center">结合WSL编译调试</td>
</tr>
</tbody>
</table>
<p>同步配置插件<code>Settings Sync</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CODE SETTINGS SYNC UPLOAD SUMMARY</span><br><span class="line">Version: 3.2.9</span><br><span class="line">--------------------</span><br><span class="line">GitHub Token: b7a56c3cf8a3a7739799e990fad4906ba2c4f324</span><br><span class="line">GitHub Gist: 3789cdfdf898124a04973b2e8feb0d74</span><br><span class="line">GitHub Gist Type: Secret</span><br><span class="line"></span><br><span class="line">Restarting Visual Studio Code may be required to apply color and file icon theme.</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><blockquote>
<p>配置文件：task.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;bash &amp;&amp; make&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><blockquote>
<p>配置文件：lanuch.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。</span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(gdb) Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;/home/xxx/work/jpeg/jpeg_vgtp_tuning/build/bin/tunning_vgtp_codec&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-a&quot;, &quot;-f&quot;, &quot;/home/xxx/Pictures/test_yuv/app_JDshopping_1080p_30fps_444_295.yuv&quot;,</span><br><span class="line">                &quot;-r&quot;, &quot;1920x1080&quot;, &quot;-c&quot;, &quot;20&quot;, &quot;-s&quot;, &quot;0&quot;, &quot;-m&quot;, &quot;0&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;stopAtEntry&quot;: true,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>program</code>: 需要调试的程序（必须为完整程序路径，可以使用VSCode的环境变量）</li>
<li><code>args</code>: 启动时传递给程序的命令行参数的JSON数据。例如： [“arg1”, “arg2].</li>
<li><code>stopAtEntry</code>: 是否停在程序入口点（停在main函数开始）</li>
<li><code>cwd</code>: 设置调试器启动的应用程序的工作目录。</li>
<li><code>environment</code>: 针对调试的程序，要添加到环境中的环境变量. 例如: [ { “name”: “squid”, “value”: “clam” } ]。</li>
<li><code>MIMode</code>:指定连接的调试器，只可以为gdb或lldb</li>
<li><code>miDebuggerPath</code>： 指定gdb路径</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="设置断点失效"><a href="#设置断点失效" class="headerlink" title="设置断点失效"></a>设置断点失效</h4><blockquote>
<p>检查编译时，是否添加<code>-g</code>选项</p>
</blockquote>
<h4 id="Win10使用WSL"><a href="#Win10使用WSL" class="headerlink" title="Win10使用WSL"></a>Win10使用WSL</h4><p>安装插件<code>Code Runner</code></p>
<blockquote>
<p>launch.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(gdb) Bash on Windows Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;/mnt/c/Users/Administrator/Desktop/test/bin/main&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: true,</span><br><span class="line">            &quot;cwd&quot;: &quot;/mnt/c/Users/Administrator/Desktop/test&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;pipeTransport&quot;: &#123;</span><br><span class="line">                &quot;debuggerPath&quot;: &quot;/usr/bin/gdb&quot;,</span><br><span class="line">                &quot;pipeProgram&quot;: &quot;$&#123;env:windir&#125;\\system32\\bash.exe&quot;,</span><br><span class="line">                &quot;pipeArgs&quot;: [&quot;-c&quot;],</span><br><span class="line">                &quot;pipeCwd&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">             &quot;sourceFileMap&quot;: &#123;</span><br><span class="line">                &quot;/mnt/c&quot;: &quot;c:\\&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/zcshoucsdn/article/details/60466707" target="_blank" rel="noopener">Visual Studio Code （VSCode） 之 C/C++ 调试配置详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>double free or corruption (fasttop)</title>
    <url>/post/27831.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*** Error in `./rixitest-static-ok&apos;: double free or corruption (fasttop): 0x76e006f0 ***`</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在进行多线程编程的时候，可能出现<code>double free</code> 问题。主要是在多线程函数中有个对<code>new</code>出来的变量进行操作，但是未加锁同步导致的。只要在在对new变量进行读写操作之前，加个锁，就可以避免该问题的产生。</p>
</blockquote>
<p><code>0x76e006f0</code> : 多次<code>free</code>的变量地址，变量（或对象）通过<code>new</code>得到的，地址空间在堆里。</p>
<p>在多线程测试中，由于其中一个线程因为异常而exit(-1)退出时，另外的线程也可能因为异常对象的生命周期结束而执行析构函数去delete同一个变量。<br><a id="more"></a></p>
<h2 id="exit-and-exit"><a href="#exit-and-exit" class="headerlink" title="exit and _exit"></a><code>exit</code> and <code>_exit</code></h2><blockquote>
<p>用于终止一个程序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<p><img src="/images/app/exit_and__exit.png" alt="exit_and__exit"></p>
<p><code>_exit</code>直接进入内核，<code>exit</code>则先执行一些清除处理（在进程退出之前要检查文件状态，将文件缓冲区中的内容写回文件）再进入内核</p>
<p>调用<code>_exit</code>函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流（stdin,stdout,stderr…）.<code>exit</code>函数是在<code>_exit</code>函数之上增加了一个封装，写回文件缓存区中的内容</p>
<h2 id="析构函数何时被调用"><a href="#析构函数何时被调用" class="headerlink" title="析构函数何时被调用"></a>析构函数何时被调用</h2><p>析构函数在下边3种情况时被调用：</p>
<ol>
<li>对象生命周期结束，被销毁时；</li>
<li>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</li>
<li>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</li>
</ol>
<h2 id="固定程序的加载地址"><a href="#固定程序的加载地址" class="headerlink" title="固定程序的加载地址"></a>固定程序的加载地址</h2><p>关闭<code>ASLR</code>，每次执行时，进程的加载地址将被固定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p>
</blockquote>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exception::InstallException</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;mCurrentAction,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct sigaction));</span><br><span class="line">	mCurrentAction.sa_handler = Exception::segv_handler;</span><br><span class="line">	mCurrentAction.sa_flags = SA_RESTART | SA_SIGINFO;</span><br><span class="line">	sigemptyset(&amp;mCurrentAction.sa_mask);</span><br><span class="line"></span><br><span class="line">	sigaction (SIGSEGV, &amp;mCurrentAction, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exception::unInstallException</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sigaction (SIGSEGV, &amp;mOldAction, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exception::segv_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">//Error</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在自定义捕获异常信号时，对异常的处理中不能使用<code>exit()</code>来结束进程。</p>
<p>原因：</p>
<ol>
<li>在异常处理中，系统已经陷入内核态进行<code>do_singal</code>的操作，而测试的异常处理函数中存在<code>exit()</code>，执行exit并等待其完成需要等异常信号的完成，而测试正在进行异常信号的处理，因此将造成死锁现象。</li>
<li>异常处理的多次重入，如果在执行exit时，产生新的相同的异常信号，但是此时由于系统的性能下降（存在多个进程执行，压力测试），使其exit的执行需要一定的CPU周期后才可以完成，这时将进行可能在一次进入异常处理，并再一次执行exit，可能将对相同的资源进行再一次的释放，从而造成<code>double free</code>的错误</li>
</ol>
<h3 id="疑问？？？"><a href="#疑问？？？" class="headerlink" title="疑问？？？"></a>疑问？？？</h3><ol>
<li><p>如果在信号处理中调用exit可以造成死锁，为啥不是必现？</p>
</li>
<li><p>两次重入可能对资源造成二次释放的现象，为啥每次释放的地址相同？</p>
</li>
</ol>
<h2 id="进程号"><a href="#进程号" class="headerlink" title="进程号"></a>进程号</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">pid_t</span> tgid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户空间获取<code>pid</code>和<code>tgid</code>, 分别是<code>syscall(SYS_gettid)</code>和<code>getpid</code></p>
<p>在linux系统中，我们用pid区分每一个进程，linux给每一个进程和轻量级进程都分配一个pid，但是linux程序员希望由一个进程产生的轻量级进程具有相同的pid，这样当我们向进程发送信号时，此信号可以影响进程及进程产生的轻量级进程。<br>为了做到这一点，linux用了线程组（可以理解为轻量级进程组）的概念，在线程组内，每个线程都使用此线程组内第一个线程(thread group leader)的pid，并将此值存入tgid</p>
<h3 id="pid和tgid的关系"><a href="#pid和tgid的关系" class="headerlink" title="pid和tgid的关系"></a>pid和tgid的关系</h3><blockquote>
<p>The four threads will have the same PID but only when viewed from above. What you (as a user) call a PID is not what the kernel (looking from below) calls a PID.</p>
</blockquote>
<blockquote>
<p>In the kernel, each thread has it’s own ID, called a PID (although it would possibly make more sense to call this a TID, or thread ID) and they also have a TGID (thread group ID) which is the PID of the thread that started the whole process.</p>
</blockquote>
<blockquote>
<p>Simplistically, when a new process is created, it appears as a thread where both the PID and TGID are the same (new) number.</p>
</blockquote>
<blockquote>
<p>When a thread starts another thread, that started thread gets its own PID (so the scheduler can schedule it independently) but it inherits the TGID from the original thread.</p>
</blockquote>
<blockquote>
<p>That way, the kernel can happily schedule threads independent of what process they belong to, while processes (thread group IDs) are reported to you.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">              USER VIEW</span><br><span class="line"> &lt;-- PID 43 --&gt; &lt;----------------- PID 42 -----------------&gt;</span><br><span class="line">                     +---------+</span><br><span class="line">                     | process |</span><br><span class="line">                    _| pid=42  |_</span><br><span class="line">                  _/ | tgid=42 | \_ (new thread) _</span><br><span class="line">       _ (fork) _/   +---------+                  \</span><br><span class="line">      /                                        +---------+</span><br><span class="line">+---------+                                    | process |</span><br><span class="line">| process |                                    | pid=44  |</span><br><span class="line">| pid=43  |                                    | tgid=42 |</span><br><span class="line">| tgid=43 |                                    +---------+</span><br><span class="line">+---------+</span><br><span class="line"> &lt;-- PID 43 --&gt; &lt;--------- PID 42 --------&gt; &lt;--- PID 44 ---&gt;</span><br><span class="line">                     KERNEL VIEW</span><br></pre></td></tr></table></figure>
<h2 id="信号handle的重入"><a href="#信号handle的重入" class="headerlink" title="信号handle的重入"></a>信号handle的重入</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exception::InstallException</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;mCurrentAction,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct sigaction));</span><br><span class="line">	mCurrentAction.sa_handler = Exception::segv_handler;</span><br><span class="line">	mCurrentAction.sa_flags = SA_RESTART | SA_SIGINFO;</span><br><span class="line">	sigemptyset(&amp;mCurrentAction.sa_mask);</span><br><span class="line"></span><br><span class="line">	sigaction (SIGSEGV, &amp;mCurrentAction, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exception::unInstallException</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sigaction (SIGSEGV, &amp;mOldAction, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exception::segv_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	Exception::unInstallException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>将异常信号的handle应用程序自定义接受后，由于异常信号的不断产生将不断的进入handle，连续多次的进入会对程序造成什么影响？？?</li>
<li>如果进入异常处理后，最后又交给内核处理，结果会咋样？？？</li>
</ol>
</blockquote>
<p><strong><em>信号的处理handler，必须是可重入的</em></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">可重入函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>_exit()</code></td>
</tr>
</tbody>
</table>
<h3 id="SIG-DFL-and-SIG-IGN"><a href="#SIG-DFL-and-SIG-IGN" class="headerlink" title="SIG_DFL and SIG_IGN"></a>SIG_DFL and SIG_IGN</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">__signalfn_t</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__signalfn_t</span> __user *<span class="keyword">__sighandler_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL ((__force __sighandler_t)0) <span class="comment">/* default signal handling */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN ((__force __sighandler_t)1) <span class="comment">/* ignore signal */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_ERR ((__force __sighandler_t)-1)    <span class="comment">/* error return from signal */</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/uapi/asm-generic/signal-defs.h</p>
</blockquote>
<p>signal函数中的信号处理函数handler，可以是用户指定的一个信号处理函数，也可以是内核特定的函数指针SIG_IGN或SIG_DFL。若信号句柄是SIG_IGN或SIG_DFL，则分别表示对捕获的信号采取忽略操作或者默认操作。</p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Test(<span class="keyword">int</span> i)</span><br><span class="line">		&#123;</span><br><span class="line">			m_i = i;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s: construct %d\n"</span>, __func__, m_i);</span><br><span class="line">		&#125;;</span><br><span class="line">		~Test()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s: destruct %d\n"</span>, __func__,  m_i);</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">t_1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">t_3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	exit(1);*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="function">Test <span class="title">t_2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	err = pthread_create(&amp;thread, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create fail!!!\n"</span>);</span><br><span class="line"></span><br><span class="line">	pthread_join(thread,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*	exit (0);*/</span></span><br><span class="line"><span class="comment">/*	_exit(0);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-return-threadFunc-return"><a href="#main-return-threadFunc-return" class="headerlink" title="main(return), threadFunc(return)"></a>main(return), threadFunc(return)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test: construct 1</span><br><span class="line">Test: construct 2</span><br><span class="line">Test: construct 3</span><br><span class="line">~Test: destruct 3</span><br><span class="line">Hello World</span><br><span class="line">~Test: destruct 2</span><br><span class="line">~Test: destruct 1</span><br></pre></td></tr></table></figure>
<h3 id="main-return-，threadFunc-exit"><a href="#main-return-，threadFunc-exit" class="headerlink" title="main(return)，threadFunc(exit)"></a>main(return)，threadFunc(exit)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test: construct 1</span><br><span class="line">Test: construct 2</span><br><span class="line">Test: construct 3</span><br><span class="line">~Test: destruct 1</span><br></pre></td></tr></table></figure>
<h3 id="main-exit-，threadFunc-return"><a href="#main-exit-，threadFunc-return" class="headerlink" title="main(exit)，threadFunc(return)"></a>main(exit)，threadFunc(return)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test: construct 1</span><br><span class="line">Test: construct 2</span><br><span class="line">Test: construct 3</span><br><span class="line">~Test: destruct 3</span><br><span class="line">Hello World</span><br><span class="line">~Test: destruct 1</span><br></pre></td></tr></table></figure>
<h3 id="main-exit-，threadFunc-return-1"><a href="#main-exit-，threadFunc-return-1" class="headerlink" title="main(_exit)，threadFunc(return)"></a>main(_exit)，threadFunc(return)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test: construct 1</span><br><span class="line">Test: construct 2</span><br><span class="line">Test: construct 3</span><br><span class="line">~Test: destruct 3</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/LittleHann/p/4026781.html" target="_blank" rel="noopener">The Linux Process Principle，NameSpace, PID、TID、PGID、PPID、SID、TID、TTY</a></li>
<li><a href="http://blog.chinaunix.net/uid-21718047-id-3069416.html" target="_blank" rel="noopener">task_struct解析(三) 进程id </a></li>
<li><a href="http://www.cnblogs.com/liulipeng/p/3555395.html" target="_blank" rel="noopener">#define SIG_DFL ((void(*)(int))0)</a></li>
<li><a href="http://blog.csdn.net/tangaowen/article/details/47856705" target="_blank" rel="noopener">深入理解可重入与线程安全</a></li>
<li><a href="http://blog.csdn.net/LG1259156776/article/details/52732879" target="_blank" rel="noopener">【C/C++】对于可重入、线程安全、异步信号安全几个概念的理解</a></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>free</tag>
      </tags>
  </entry>
  <entry>
    <title>HID设备--开发板模拟鼠标</title>
    <url>/post/5098.html</url>
    <content><![CDATA[<p>HID</p>
<a id="more"></a>
<h2 id="HID"><a href="#HID" class="headerlink" title="HID"></a>HID</h2><h2 id="鼠标裸数据"><a href="#鼠标裸数据" class="headerlink" title="鼠标裸数据"></a>鼠标裸数据</h2><h3 id="驱动："><a href="#驱动：" class="headerlink" title="驱动："></a>驱动：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol: HIDRAW [=y]</span><br><span class="line">Type  : boolean</span><br><span class="line">Prompt: /dev/hidraw raw HID device support</span><br><span class="line">  Location:</span><br><span class="line">    -&gt; Device Drivers</span><br><span class="line">      -&gt; HID support</span><br><span class="line">        -&gt; HID bus support (HID [=y])</span><br></pre></td></tr></table></figure>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read(uibc-&gt;hid_fd, buf, sizeof(buf));</span><br></pre></td></tr></table></figure>
<h3 id="鼠标数据格式"><a href="#鼠标数据格式" class="headerlink" title="鼠标数据格式"></a>鼠标数据格式</h3><p>鼠标的通信格式：4个字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BYTE3 BYTE2 BYTE1 BYTE0</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">Byte</th>
<th style="text-align:center">BIT7</th>
<th style="text-align:center">BIT6</th>
<th style="text-align:center">BIT5</th>
<th style="text-align:center">BIT4</th>
<th style="text-align:center">BIT3</th>
<th style="text-align:center">BIT2</th>
<th style="text-align:center">BIT1</th>
<th style="text-align:center">BIT0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1 表示Y坐标的变化量超出－256~255的范围, 0表示没有溢出</td>
<td style="text-align:center">1表示X坐标的变化量超出－256~255的范围，0表示没有溢出</td>
<td style="text-align:center">Y坐标变化的符号位，1表示负数，即鼠标向下移动</td>
<td style="text-align:center">X   坐标变化的符号位，1表示负数，即鼠标向左移动</td>
<td style="text-align:center">恒为1</td>
<td style="text-align:center">1表示中键按下</td>
<td style="text-align:center">1表示右键按下</td>
<td style="text-align:center">1表示左键按下</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">X坐标变化量，</td>
<td style="text-align:center">与byte的</td>
<td style="text-align:center">bit4组成</td>
<td style="text-align:center">9位符号数,</td>
<td style="text-align:center">负数表示向左移，</td>
<td style="text-align:center">正数表右移。</td>
<td style="text-align:center">用补码</td>
<td style="text-align:center">表示变化量</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Y坐标变化量，</td>
<td style="text-align:center">与byte的</td>
<td style="text-align:center">bit5组成</td>
<td style="text-align:center">9位符号数，</td>
<td style="text-align:center">负数表示向下移，</td>
<td style="text-align:center">正数表上移。</td>
<td style="text-align:center">用补码</td>
<td style="text-align:center">表示变化量</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">滚轮变化。</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>鼠标的一次点击，包含<code>按下</code>和<code>抬起</code>两个动作，这两个动作均会上报事件，<code>抬起</code>时上报的全部为<code>0x0</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uibc read device raw data[len: 6]: BIT5~BIT0    //按下左键</span><br><span class="line">                00 00 00 00 00 01</span><br><span class="line">uibc read device raw data[len: 6]: BIT5~BIT0    //抬起左键</span><br><span class="line">                00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<h2 id="开发板模拟鼠标"><a href="#开发板模拟鼠标" class="headerlink" title="开发板模拟鼠标"></a>开发板模拟鼠标</h2><p>以开发板作为device端,由于鼠标为HID设备，在HID驱动中添加鼠标的device</p>
<p>参考文档：<a href="https://elixir.bootlin.com/linux/v3.4.35/source/Documentation/usb/gadget_hid.txt" target="_blank" rel="noopener">Documentation/usb/gadget_hid.txt</a>, 其中主要时驱动的添加和测试</p>
<h3 id="Device驱动"><a href="#Device驱动" class="headerlink" title="Device驱动"></a>Device驱动</h3><ul>
<li>hid.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*hid descriptor for a mouse*/</span><br><span class="line">static struct hidg_func_descriptor vx_device_mouse_data = &#123;</span><br><span class="line">    .subclass = 0,  /*NO SubClass*/</span><br><span class="line">    .protocol = 2,  /*Mouse*/</span><br><span class="line">    .report_length = 6,</span><br><span class="line">    .report_desc_length = 79,</span><br><span class="line">    .report_desc=&#123;</span><br><span class="line">        0x05,0x01,  /*Usage Page (Generic Desktop Controls)*/</span><br><span class="line">        0x09,0x02,  /*Usage (Mouse)*/</span><br><span class="line">        0xa1,0x01,  /*Collction (Application)*/</span><br><span class="line">        0x09,0x01,  /*Usage (pointer)*/</span><br><span class="line">        0xa1,0x00,  /*Collction (Physical)*/</span><br><span class="line">        0x05,0x09,  /*Usage Page (Button)*/</span><br><span class="line">        0x19,0x01,  /*Usage Minimum(1)*/</span><br><span class="line">        0x29,0x05,  /*Usage Maximum(3) */</span><br><span class="line">        0x15,0x00,  /*Logical Minimum(1)*/</span><br><span class="line">        0x25,0x01,  /*Logical Maximum(1)*/</span><br><span class="line">        0x95,0x05,  /*Report Count(5)  */</span><br><span class="line">        0x75,0x01,  /*Report Size(1)*/</span><br><span class="line">        0x81,0x02,  /*Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit)*/</span><br><span class="line">        0x95,0x01,  /*Report Count(1)*/</span><br><span class="line">        0x75,0x03,  /*Report Size(3) */</span><br><span class="line">        0x81,0x01,  /*Input (Cnst,Ary,Abs) */</span><br><span class="line">        0x05,0x01,  /*Usage Page (Generic Desktop Controls)*/</span><br><span class="line">        0x09,0x30,  /*Usage(x)*/</span><br><span class="line">        0x09,0x31,  /*Usage(y)*/</span><br><span class="line">        0x16,0x00,0xF8,  /*Logical Minimum (-2048)*/</span><br><span class="line">        0x26,0xFF,0x07,  /*Logical Maximum (2047)*/</span><br><span class="line">        0x75,0x0C, /*Report Size(12)*/</span><br><span class="line">        0x95,0x02, /*Report Count(2) */</span><br><span class="line">        0x81,0x06, /*Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit)*/</span><br><span class="line">        0x09,0x38,  /*Usage(Wheel)*/</span><br><span class="line">        0x15,0x81,  /*Logical Minimum(-127)*/</span><br><span class="line">        0x25,0x7f,  /*Logical Maximum(127)*/</span><br><span class="line">        0x75,0x08,  /*Report Size(8)*/</span><br><span class="line">        0x95,0x01,  /*Report Count(1)  */</span><br><span class="line">        0x81,0x06,  /*Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit)*/</span><br><span class="line">        0x05,0x0C, /*Usage Page (Consumer Devices) */</span><br><span class="line">        0x0A,0x38,0x02, /*Usage (AC Pan)*/</span><br><span class="line">        0x95,0x01, /*Report Count (1) */</span><br><span class="line">        0x75,0x08, /*Report Size (8)*/</span><br><span class="line">        0x15,0x81, /*Logical Minimum (-127) */</span><br><span class="line">        0x25,0x7F, /*Logical Maximum (127)*/</span><br><span class="line">        0x81,0x06, /*Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) */</span><br><span class="line">        0xc0,   /*End Collection*/</span><br><span class="line">        0xc0    /*End Collection*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct platform_device vx_device_hid_mouse = &#123;</span><br><span class="line">    .name = &quot;hidg&quot;,</span><br><span class="line">    .id            = 1,</span><br><span class="line">    .num_resources = 0,</span><br><span class="line">    .resource    = 0,</span><br><span class="line">    .dev.platform_data = &amp;vx_device_mouse_data,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init hidg_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    status = platform_device_register(&amp;vx_device_hid_mouse);</span><br><span class="line">    if (status &lt; 0) &#123;</span><br><span class="line">        printk(&quot;f:%s, l:%d, platform_driver hid mouse error\n&quot;, __func__, __LINE__);</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">module_init(hidg_init);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel: linux3.4.35, file:drivers/usb/gadget/hid.c</p>
</blockquote>
<ul>
<li>f_hid.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Index: f_hid.c</span><br><span class="line">===================================================================</span><br><span class="line">--- f_hid.c	(revision <span class="number">1771</span>)</span><br><span class="line">+++ f_hid.c	(working copy)</span><br><span class="line">@@ <span class="number">-185</span>,<span class="number">12</span> +<span class="number">185</span>,<span class="number">17</span> @@</span><br><span class="line"> 	wake_up(&amp;hidg-&gt;write_queue);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="keyword">static</span> <span class="keyword">int</span> usb_ep_enable_done = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">f_hidg_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="built_in">buffer</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"> 			    <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">f_hidg</span> *<span class="title">hidg</span>  = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"> 	<span class="keyword">ssize_t</span> status = -ENOMEM;</span><br><span class="line"></span><br><span class="line">+	<span class="keyword">if</span> (!usb_ep_enable_done)</span><br><span class="line">+		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">+</span><br><span class="line"> 	<span class="keyword">if</span> (!access_ok(VERIFY_READ, <span class="built_in">buffer</span>, count))</span><br><span class="line"> 		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-316</span>,<span class="number">6</span> +<span class="number">321</span>,<span class="number">7</span> @@</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">usb_request</span>		*<span class="title">req</span>  = <span class="title">cdev</span>-&gt;<span class="title">req</span>;</span></span><br><span class="line"> 	<span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"> 	__u16 value, length;</span><br><span class="line">+	<span class="keyword">unsigned</span> <span class="keyword">char</span> report[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"> 	value	= __le16_to_cpu(ctrl-&gt;wValue);</span><br><span class="line"> 	length	= __le16_to_cpu(ctrl-&gt;wLength);</span><br><span class="line">@@ <span class="number">-324</span>,<span class="number">15</span> +<span class="number">330</span>,<span class="number">29</span> @@</span><br><span class="line"> 		<span class="string">"Value:0x%x\n"</span>, ctrl-&gt;bRequestType, ctrl-&gt;bRequest, value);</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">switch</span> ((ctrl-&gt;bRequestType &lt;&lt; <span class="number">8</span>) | ctrl-&gt;bRequest) &#123;</span><br><span class="line">-	<span class="keyword">case</span> ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span></span><br><span class="line">-		  | HID_REQ_GET_REPORT):</span><br><span class="line">-		VDBG(cdev, <span class="string">"get_report\n"</span>);</span><br><span class="line">-</span><br><span class="line">-		<span class="comment">/* send an empty report */</span></span><br><span class="line">-		length = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span>, length, hidg-&gt;report_length);</span><br><span class="line">-		<span class="built_in">memset</span>(req-&gt;buf, <span class="number">0x0</span>, length);</span><br><span class="line">+		<span class="keyword">case</span> ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span></span><br><span class="line">+				| HID_REQ_GET_REPORT):</span><br><span class="line">+			VDBG(cdev, <span class="string">"get_report\n"</span>);</span><br><span class="line">+		<span class="keyword">switch</span> (value &gt;&gt; <span class="number">8</span>) &#123;</span><br><span class="line">+		<span class="keyword">case</span> HID_REQ_GET_PROTOCOL:</span><br><span class="line">+			report[<span class="number">0</span>] = <span class="number">0x02</span>;</span><br><span class="line">+			report[<span class="number">1</span>] = <span class="number">0x0a</span>;</span><br><span class="line">+</span><br><span class="line">+			length = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span>, length, <span class="number">2</span>);</span><br><span class="line">+			VDBG(cdev, <span class="string">"HID_REQ_GET_PROTOCOL: REPORT[0x0a, 0x02]\n"</span>);</span><br><span class="line">+			length = <span class="number">2</span>;</span><br><span class="line">+			<span class="built_in">memcpy</span>(req-&gt;buf, report, length);</span><br><span class="line">+			<span class="keyword">goto</span> respond;</span><br><span class="line">+			<span class="keyword">break</span>;</span><br><span class="line">+		<span class="keyword">default</span>:</span><br><span class="line">+			<span class="comment">/* send an empty report */</span></span><br><span class="line">+			length = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span>, length, hidg-&gt;report_length);</span><br><span class="line">+			<span class="built_in">memset</span>(req-&gt;buf, <span class="number">0x0</span>, length);</span><br><span class="line">+</span><br><span class="line">+			<span class="keyword">goto</span> respond;</span><br><span class="line">+			<span class="keyword">break</span>;</span><br><span class="line">+		&#125;</span><br><span class="line"></span><br><span class="line">-		<span class="keyword">goto</span> respond;</span><br><span class="line"> 		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">case</span> ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span></span><br><span class="line">@@ <span class="number">-381</span>,<span class="number">6</span> +<span class="number">401</span>,<span class="number">15</span> @@</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">+	<span class="keyword">case</span> ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span></span><br><span class="line">+			| USB_REQ_GET_INTERFACE):</span><br><span class="line">+		VDBG(cdev, <span class="string">"get_interface | wLenght=%d\n"</span>, ctrl-&gt;wLength);</span><br><span class="line">+		<span class="comment">/* send an empty report */</span></span><br><span class="line">+		length = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span>, length, hidg-&gt;report_length);</span><br><span class="line">+		<span class="built_in">memset</span>(req-&gt;buf, <span class="number">0x0</span>, length);</span><br><span class="line">+		<span class="keyword">goto</span> respond;</span><br><span class="line">+		<span class="keyword">break</span>;</span><br><span class="line">+</span><br><span class="line"> 	<span class="keyword">default</span>:</span><br><span class="line"> 		VDBG(cdev, <span class="string">"Unknown request 0x%x\n"</span>,</span><br><span class="line"> 			 ctrl-&gt;bRequest);</span><br><span class="line">@@ <span class="number">-427</span>,<span class="number">11</span> +<span class="number">456</span>,<span class="number">13</span> @@</span><br><span class="line"> 			ERROR(cdev, <span class="string">"config_ep_by_speed FAILED!\n"</span>);</span><br><span class="line"> 			<span class="keyword">goto</span> fail;</span><br><span class="line"> 		&#125;</span><br><span class="line">+		printk(<span class="string">"%s: usb_ep_enable\n"</span>, __func__);</span><br><span class="line"> 		status = usb_ep_enable(hidg-&gt;in_ep);</span><br><span class="line"> 		<span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> 			ERROR(cdev, <span class="string">"Enable endpoint FAILED!\n"</span>);</span><br><span class="line"> 			<span class="keyword">goto</span> fail;</span><br><span class="line"> 		&#125;</span><br><span class="line">+		usb_ep_enable_done = <span class="number">1</span>;</span><br><span class="line"> 		hidg-&gt;in_ep-&gt;driver_data = hidg;</span><br><span class="line"> 	&#125;</span><br><span class="line"> fail:</span><br><span class="line">@@ <span class="number">-543</span>,<span class="number">7</span> +<span class="number">574</span>,<span class="number">9</span> @@</span><br><span class="line"> 	cdev_del(&amp;hidg-&gt;cdev);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/* disable/free request and end point */</span></span><br><span class="line">+	printk(<span class="string">"%s: usb_ep_disable\n"</span>, __func__);</span><br><span class="line"> 	usb_ep_disable(hidg-&gt;in_ep);</span><br><span class="line">+	usb_ep_enable_done = <span class="number">0</span>;</span><br><span class="line"> 	usb_ep_dequeue(hidg-&gt;in_ep, hidg-&gt;req);</span><br><span class="line"> 	kfree(hidg-&gt;req-&gt;buf);</span><br><span class="line"> 	usb_ep_free_request(hidg-&gt;in_ep, hidg-&gt;req);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel: linux3.4.35, file:drivers/usb/gadget/f_hid.c</p>
</blockquote>
<h3 id="hidg-func-descriptor"><a href="#hidg-func-descriptor" class="headerlink" title="hidg_func_descriptor"></a>hidg_func_descriptor</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct hidg_func_descriptor &#123;</span><br><span class="line">    unsigned char       subclass;</span><br><span class="line">    unsigned char       protocol;</span><br><span class="line">    unsigned short      report_length;</span><br><span class="line">    unsigned short      report_desc_length;</span><br><span class="line">    unsigned char       report_desc[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/usb/g_hid.h</p>
</blockquote>
<p>主要是一个设备如何填充<code>struct hidg_func_descriptor</code>数据结构。</p>
<blockquote>
<p>You can add as many HID functions as you want, only limited by the amount of interrupt endpoints your gadget driver supports.</p>
</blockquote>
<p>添加<code>hidg</code>设备的个数，受USB的endpoint的限制，如果endpoint只有一对，只能添加一个<code>hidg0</code>设备。</p>
<h3 id="获取USB鼠标HID-Descriptor"><a href="#获取USB鼠标HID-Descriptor" class="headerlink" title="获取USB鼠标HID Descriptor"></a>获取USB鼠标HID Descriptor</h3><ul>
<li>工具：<code>USBlyzer</code></li>
<li>官网下载地址：<a href="http://www.usblyzer.com/download.htm" target="_blank" rel="noopener">http://www.usblyzer.com/download.htm</a></li>
<li>下载：<a href="http://bbs.armfly.com/job.php?action=download&amp;aid=9919" target="_blank" rel="noopener">http://bbs.armfly.com/job.php?action=download&amp;aid=9919</a></li>
</ul>
<h4 id="Device-Descriptor"><a href="#Device-Descriptor" class="headerlink" title="Device Descriptor"></a>Device Descriptor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Device Descriptor USB OPTICAL MOUSE</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 12h</span><br><span class="line">1 bDescriptorType 1 01h Device</span><br><span class="line">2 bcdUSB 2 0110h USB Spec 1.1</span><br><span class="line">4 bDeviceClass 1 00h Class info in Ifc Descriptors</span><br><span class="line">`5 bDeviceSubClass 1 00h`</span><br><span class="line">6 bDeviceProtocol 1 00h</span><br><span class="line">7 bMaxPacketSize0 1 08h 8 bytes</span><br><span class="line">8 idVendor 2 0101h</span><br><span class="line">10 idProduct 2 0007h</span><br><span class="line">12 bcdDevice 2 0100h 1.00</span><br><span class="line">14 iManufacturer 1 00h</span><br><span class="line">15 iProduct 1 01h &quot;USB OPTICAL MOUSE &quot;</span><br><span class="line">16 iSerialNumber 1 00h</span><br><span class="line">17 bNumConfigurations 1 01h</span><br></pre></td></tr></table></figure>
<h3 id="Interface-Descriptor"><a href="#Interface-Descriptor" class="headerlink" title="Interface Descriptor"></a>Interface Descriptor</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Interface Descriptor 0/0 HID, 1 Endpoint</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 09h</span><br><span class="line">1 bDescriptorType 1 04h Interface</span><br><span class="line">2 bInterfaceNumber 1 00h</span><br><span class="line">3 bAlternateSetting 1 00h</span><br><span class="line">4 bNumEndpoints 1 01h</span><br><span class="line">5 bInterfaceClass 1 03h HID</span><br><span class="line">6 bInterfaceSubClass 1 01h Boot Interface</span><br><span class="line">`7 bInterfaceProtocol 1 02h Mouse`</span><br><span class="line">8 iInterface 1 00h</span><br></pre></td></tr></table></figure>
<h4 id="HID-Descriptor"><a href="#HID-Descriptor" class="headerlink" title="HID Descriptor"></a>HID Descriptor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HID Descriptor</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 09h</span><br><span class="line">1 bDescriptorType 1 21h HID</span><br><span class="line">2 bcdHID 2 0111h 1.11</span><br><span class="line">4 bCountryCode 1 00h</span><br><span class="line">5 bNumDescriptors 1 01h</span><br><span class="line">6 bDescriptorType 1 22h Report</span><br><span class="line">`7 wDescriptorLength 2 004Fh 79 bytes`</span><br><span class="line"></span><br><span class="line">Endpoint Descriptor 81 1 In, Interrupt, 10 ms</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 07h</span><br><span class="line">1 bDescriptorType 1 05h Endpoint</span><br><span class="line">2 bEndpointAddress 1 81h 1 In</span><br><span class="line">3 bmAttributes 1 03h Interrupt</span><br><span class="line"> 1..0: Transfer Type  ......11  Interrupt</span><br><span class="line"> 7..2: Reserved  000000..</span><br><span class="line">`4 wMaxPacketSize 2 0006h 6 bytes`</span><br><span class="line">6 bInterval 1 0Ah 10 ms</span><br><span class="line"></span><br><span class="line">Interface 0 HID Report Descriptor Mouse</span><br><span class="line">`Item Tag (Value) Raw Data`</span><br><span class="line">Usage Page (Generic Desktop) 05 01</span><br><span class="line">Usage (Mouse) 09 02</span><br><span class="line">Collection (Application) A1 01</span><br><span class="line">    Usage (Pointer) 09 01</span><br><span class="line">    Collection (Physical) A1 00</span><br><span class="line">        Usage Page (Button) 05 09</span><br><span class="line">        Usage Minimum (Button 1) 19 01</span><br><span class="line">        Usage Maximum (Button 5) 29 05</span><br><span class="line">        Logical Minimum (0) 15 00</span><br><span class="line">        Logical Maximum (1) 25 01</span><br><span class="line">        Report Count (5) 95 05</span><br><span class="line">        Report Size (1) 75 01</span><br><span class="line">        Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 81 02</span><br><span class="line">        Report Count (1) 95 01</span><br><span class="line">        Report Size (3) 75 03</span><br><span class="line">        Input (Cnst,Ary,Abs) 81 01</span><br><span class="line">        Usage Page (Generic Desktop) 05 01</span><br><span class="line">        Usage (X) 09 30</span><br><span class="line">        Usage (Y) 09 31</span><br><span class="line">        Logical Minimum (-2048) 16 00 F8</span><br><span class="line">        Logical Maximum (2047) 26 FF 07</span><br><span class="line">        Report Size (12) 75 0C</span><br><span class="line">        Report Count (2) 95 02</span><br><span class="line">        Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06</span><br><span class="line">        Usage (Wheel) 09 38</span><br><span class="line">        Logical Minimum (-127) 15 81</span><br><span class="line">        Logical Maximum (127) 25 7F</span><br><span class="line">        Report Size (8) 75 08</span><br><span class="line">        Report Count (1) 95 01</span><br><span class="line">        Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06</span><br><span class="line">        Usage Page (Consumer Devices) 05 0C</span><br><span class="line">        Usage (AC Pan) 0A 38 02</span><br><span class="line">        Report Count (1) 95 01</span><br><span class="line">        Report Size (8) 75 08</span><br><span class="line">        Logical Minimum (-127) 15 81</span><br><span class="line">        Logical Maximum (127) 25 7F</span><br><span class="line">        Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06</span><br><span class="line">    End Collection C0</span><br><span class="line">End Collection C0</span><br></pre></td></tr></table></figure>
<h3 id="hidg-func-descriptor-与-HID-Descriptor"><a href="#hidg-func-descriptor-与-HID-Descriptor" class="headerlink" title="hidg_func_descriptor 与 HID Descriptor"></a>hidg_func_descriptor 与 HID Descriptor</h3><table>
<thead>
<tr>
<th style="text-align:center">hidg_func_descriptor</th>
<th style="text-align:center">HID Descriptor</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">subclass</td>
<td style="text-align:center">bDeviceSubClass</td>
</tr>
<tr>
<td style="text-align:center">protocol</td>
<td style="text-align:center">bInterfaceProtocol</td>
</tr>
<tr>
<td style="text-align:center">report_length</td>
<td style="text-align:center">wMaxPacketSize</td>
</tr>
<tr>
<td style="text-align:center">report_desc_length</td>
<td style="text-align:center">wDescriptorLength</td>
</tr>
<tr>
<td style="text-align:center">report_desc[]</td>
<td style="text-align:center">Item Tag (Value) Raw Data</td>
</tr>
</tbody>
</table>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><code>Bus Hound</code>是一个超级软件总线协议分析器,用于捕捉来自设备的协议包和输入输出操作</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/hclydao/article/details/9284215" target="_blank" rel="noopener">s3c6410 linux gadget hid驱动</a></li>
<li><a href="https://blog.csdn.net/miaopasi_QAQ/article/details/45479709" target="_blank" rel="noopener">DM816X 实现 USB HID Gadget 鼠标键盘功能</a></li>
<li><a href="https://www.cnblogs.com/ningci/p/6807654.html" target="_blank" rel="noopener">linux 读取 USB HID鼠标坐标和点击 在 LCD上显示</a></li>
<li><a href="https://blog.csdn.net/qq_33750826/article/details/79397984" target="_blank" rel="noopener">Linux之访问/dev/hidraw</a></li>
<li><a href="https://blog.csdn.net/sy373466062/article/details/78223563" target="_blank" rel="noopener">USB与BT HID reports描述符实践与抓包分析</a></li>
<li><a href="https://blog.csdn.net/luckywang1103/article/details/41282551" target="_blank" rel="noopener">usb hid gadget模拟鼠标键盘</a></li>
<li><a href="http://blog.chinaunix.net/uid-23215128-id-2521477.html" target="_blank" rel="noopener">USB/HID设备报告描述符详解</a></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>hid</tag>
      </tags>
  </entry>
  <entry>
    <title>USB HID Report描述符</title>
    <url>/post/40274.html</url>
    <content><![CDATA[<p>在USB的枚举后，即交互完 设备描述符(device descriptor),配置描述符(configure descriptor),接口描述符(interface descriptor)和终端描述符(endpointer desciptor)。如果是HID设备，即class值为3设备交互还会发送一系统的特殊包来描述HID设备的特性。</p>
<p>这一些描述HID的特性称为Report Descriptor,报告描述符，可以理解它们是HID设备的上传的包，或者接收的包的格式。<code>设备能包含多个report</code>(测试出错)</p>
<p>主要参考官网文档：<a href="http://www.usb.org/developers/hidpage#Class_Definitions" target="_blank" rel="noopener">HID Information</a></p>
<a id="more"></a>
<p>对于每种HID动作的编码，HID有一个专用术语usage (用法），USB协议中支持所有编码表称为usage tables.这里有全部编码表<a href="http://www.usb.org/developers/hidpage/Hut1_12v2.pdf" target="_blank" rel="noopener">HID Usage Tables 1.12</a></p>
<h2 id="Report-Descriptor"><a href="#Report-Descriptor" class="headerlink" title="Report Descriptor"></a>Report Descriptor</h2><p>在usb.org网站有HID decriptor tools工具下载 可以用创建和解析report descriptor包格式<br><a href="http://www.usb.org/developers/hidpage/dt2_4.zip" target="_blank" rel="noopener">http://www.usb.org/developers/hidpage/dt2_4.zip</a></p>
<blockquote>
<p>一个完整的report 分为二部分，一部分定长的头，另一部分就是变长的定义, 每个collection由若干个usage组成. 在Collection中，每一个组成部分以称为item,item就是usage.<br><code>A1 01</code> 与 <code>C0</code>之间表示<code>Application Collection</code>的.</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">usage</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">输入数据格式</td>
</tr>
<tr>
<td style="text-align:center">output</td>
<td style="text-align:center">输出数据格式</td>
</tr>
<tr>
<td style="text-align:center">Logical Minimum</td>
<td style="text-align:center">取值范围</td>
</tr>
<tr>
<td style="text-align:center">logical_maximum</td>
<td style="text-align:center">取值范围</td>
</tr>
<tr>
<td style="text-align:center">physical_minimum</td>
<td style="text-align:center">取值范围</td>
</tr>
<tr>
<td style="text-align:center">physical_maximum</td>
<td style="text-align:center">取值范围</td>
</tr>
<tr>
<td style="text-align:center">report size</td>
<td style="text-align:center">report输入字节宽度</td>
</tr>
<tr>
<td style="text-align:center">report count</td>
<td style="text-align:center">report总数</td>
</tr>
</tbody>
</table>
<h2 id="获取描述符"><a href="#获取描述符" class="headerlink" title="获取描述符"></a>获取描述符</h2><ul>
<li>工具： <code>USBlyzer</code> （Bus Hound同样也可以抓取，但是需要自己解析）</li>
</ul>
<h2 id="实例分析（鼠标）"><a href="#实例分析（鼠标）" class="headerlink" title="实例分析（鼠标）"></a>实例分析（鼠标）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HID Descriptor</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 09h</span><br><span class="line">1 bDescriptorType 1 21h HID</span><br><span class="line">2 bcdHID 2 0111h 1.11</span><br><span class="line">4 bCountryCode 1 00h</span><br><span class="line">5 bNumDescriptors 1 01h</span><br><span class="line">6 bDescriptorType 1 22h Report</span><br><span class="line">7 wDescriptorLength 2 002Eh 46 bytes  &lt;-------描述符大小</span><br><span class="line"></span><br><span class="line">Endpoint Descriptor 81 1 In, Interrupt, 10 ms</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 07h</span><br><span class="line">1 bDescriptorType 1 05h Endpoint</span><br><span class="line">2 bEndpointAddress 1 81h 1 In</span><br><span class="line">3 bmAttributes 1 03h Interrupt</span><br><span class="line"> 1..0: Transfer Type  ......11  Interrupt</span><br><span class="line"> 7..2: Reserved  000000..</span><br><span class="line">4 wMaxPacketSize 2 0004h 4 bytes  &lt;-----------包数据宽度</span><br><span class="line">6 bInterval 1 0Ah 10 ms</span><br><span class="line"></span><br><span class="line">Interface 0 HID Report Descriptor Mouse</span><br><span class="line">Item Tag (Value) Raw Data</span><br><span class="line">Usage Page (Generic Desktop) 05 01</span><br><span class="line">Usage (Mouse) 09 02</span><br><span class="line">Collection (Application) A1 01</span><br><span class="line">    Usage (Pointer) 09 01</span><br><span class="line">    Collection (Physical) A1 00</span><br><span class="line">        Usage Page (Button) 05 09</span><br><span class="line">        Usage Minimum (Button 1) 19 01</span><br><span class="line">        Usage Maximum (Button 3) 29 03</span><br><span class="line">        Logical Minimum (0) 15 00</span><br><span class="line">        Logical Maximum (1) 25 01</span><br><span class="line">        Report Count (8) 95 08</span><br><span class="line">        Report Size (1) 75 01</span><br><span class="line">        Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 81 02</span><br><span class="line"></span><br><span class="line">        Usage Page (Generic Desktop) 05 01</span><br><span class="line">        Usage (X) 09 30</span><br><span class="line">        Usage (Y) 09 31</span><br><span class="line">        Usage (Wheel) 09 38</span><br><span class="line">        Logical Minimum (-127) 15 81</span><br><span class="line">        Logical Maximum (127) 25 7F</span><br><span class="line">        Report Size (8) 75 08</span><br><span class="line">        Report Count (3) 95 03</span><br><span class="line">        Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06</span><br><span class="line">    End Collection C0</span><br><span class="line">End Collection C0</span><br></pre></td></tr></table></figure>
<h3 id="获取数据格式–Input"><a href="#获取数据格式–Input" class="headerlink" title="获取数据格式–Input"></a>获取数据格式–Input</h3><p>从Report描述符可以获取信息，鼠标输入的数据可以分两部分：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">设备类型</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">宽度</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Usage Page (Button)</td>
<td style="text-align:center">Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit)</td>
<td style="text-align:center">Report Size (1)</td>
<td style="text-align:center">Report Count (8)</td>
<td style="text-align:center">Logical Minimum (0) ~ Logical Maximum (1)</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Usage Page (Generic Desktop)</td>
<td style="text-align:center">Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit)</td>
<td style="text-align:center">Report Size (8)</td>
<td style="text-align:center">Report Count (3)</td>
<td style="text-align:center">Logical Minimum (-127) ~ Logical Maximum (127)</td>
</tr>
</tbody>
</table>
<p>数据格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------------+--------------------------------+</span><br><span class="line">| Usage (Wheel) |   Usage (Y)   |   Usage (X)   |7|6|5|4|3|2|1||0|</span><br><span class="line">+---------------+---------------+--------------------------+-+--++</span><br><span class="line">                                                           | |  v</span><br><span class="line">                                                           | v  Usage Page (Button)</span><br><span class="line">                                                           v Usage Minimum (Button 1)</span><br><span class="line">                                                           Usage Maximum (Button 3)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一部分：一个字节（Byte），其中每个bit代表一种含义, <code>Usage Page (Button)</code>,<code>Usage Minimum (Button 1)</code>,<code>Usage Maximum (Button 3)</code></li>
<li>第二部分：三个字节（Byte），其中一个字节代表一种含义，<code>Usage (X)</code>,<code>Usage (Y)</code>,<code>Usage (Wheel)</code></li>
</ul>
<h2 id="linux下获取HID"><a href="#linux下获取HID" class="headerlink" title="linux下获取HID"></a>linux下获取HID</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usbhid-dump  | grep -v : | xxd -r -p | hidrd-convert -o spec</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=====&gt;$usbhid-dump -a1:5 -i0</span><br><span class="line">001:005:000:DESCRIPTOR         1564469117.021395</span><br><span class="line"> 05 01 09 02 A1 01 09 01 A1 00 05 09 19 01 29 03</span><br><span class="line"> 15 00 25 01 95 08 75 01 81 02 05 01 09 30 09 31</span><br><span class="line"> 09 38 15 81 25 7F 75 08 95 03 81 06 C0 C0</span><br><span class="line"></span><br><span class="line">=====&gt;$usbhid-dump -a1:5 -i0 | grep -v : | xxd -r -p | hidrd-convert -o spec</span><br><span class="line">Usage Page (Desktop),               ; Generic desktop controls (01h)</span><br><span class="line">Usage (Mouse),                      ; Mouse (02h, application collection)</span><br><span class="line">Collection (Application),</span><br><span class="line">    Usage (Pointer),                ; Pointer (01h, physical collection)</span><br><span class="line">    Collection (Physical),</span><br><span class="line">        Usage Page (Button),        ; Button (09h)</span><br><span class="line">        Usage Minimum (01h),</span><br><span class="line">        Usage Maximum (03h),</span><br><span class="line">        Logical Minimum (0),</span><br><span class="line">        Logical Maximum (1),</span><br><span class="line">        Report Count (8),</span><br><span class="line">        Report Size (1),</span><br><span class="line">        Input (Variable),</span><br><span class="line">        Usage Page (Desktop),       ; Generic desktop controls (01h)</span><br><span class="line">        Usage (X),                  ; X (30h, dynamic value)</span><br><span class="line">        Usage (Y),                  ; Y (31h, dynamic value)</span><br><span class="line">        Usage (Wheel),              ; Wheel (38h, dynamic value)</span><br><span class="line">        Logical Minimum (-127),</span><br><span class="line">        Logical Maximum (127),</span><br><span class="line">        Report Size (8),</span><br><span class="line">        Report Count (3),</span><br><span class="line">        Input (Variable, Relative),</span><br><span class="line">    End Collection,</span><br><span class="line">End Collection</span><br><span class="line">=====&gt;$usbhid-dump -a1:5 -i0 | grep -v : | xxd -r -p | hidrd-convert -o code</span><br><span class="line">0x05, 0x01, /*  Usage Page (Desktop),               */</span><br><span class="line">0x09, 0x02, /*  Usage (Mouse),                      */</span><br><span class="line">0xA1, 0x01, /*  Collection (Application),           */</span><br><span class="line">0x09, 0x01, /*      Usage (Pointer),                */</span><br><span class="line">0xA1, 0x00, /*      Collection (Physical),          */</span><br><span class="line">0x05, 0x09, /*          Usage Page (Button),        */</span><br><span class="line">0x19, 0x01, /*          Usage Minimum (01h),        */</span><br><span class="line">0x29, 0x03, /*          Usage Maximum (03h),        */</span><br><span class="line">0x15, 0x00, /*          Logical Minimum (0),        */</span><br><span class="line">0x25, 0x01, /*          Logical Maximum (1),        */</span><br><span class="line">0x95, 0x08, /*          Report Count (8),           */</span><br><span class="line">0x75, 0x01, /*          Report Size (1),            */</span><br><span class="line">0x81, 0x02, /*          Input (Variable),           */</span><br><span class="line">0x05, 0x01, /*          Usage Page (Desktop),       */</span><br><span class="line">0x09, 0x30, /*          Usage (X),                  */</span><br><span class="line">0x09, 0x31, /*          Usage (Y),                  */</span><br><span class="line">0x09, 0x38, /*          Usage (Wheel),              */</span><br><span class="line">0x15, 0x81, /*          Logical Minimum (-127),     */</span><br><span class="line">0x25, 0x7F, /*          Logical Maximum (127),      */</span><br><span class="line">0x75, 0x08, /*          Report Size (8),            */</span><br><span class="line">0x95, 0x03, /*          Report Count (3),           */</span><br><span class="line">0x81, 0x06, /*          Input (Variable, Relative), */</span><br><span class="line">0xC0,       /*      End Collection,                 */</span><br><span class="line">0xC0        /*  End Collection                      */</span><br></pre></td></tr></table></figure>
<h2 id="hid设备操作接口"><a href="#hid设备操作接口" class="headerlink" title="hid设备操作接口"></a>hid设备操作接口</h2><p>通过<code>open</code>及<code>ioctl</code>操作HID设备节点<code>dev/hidrawN</code></p>
<blockquote>
<p>头文件：<code>#include &lt;linux/hidraw.h&gt;</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HIDRAW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HIDRAW_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidraw_report_descriptor</span> &#123;</span></span><br><span class="line">    __u32 <span class="built_in">size</span>;</span><br><span class="line">    __u8 value[HID_MAX_DESCRIPTOR_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidraw_devinfo</span> &#123;</span></span><br><span class="line">    __u32 bustype;</span><br><span class="line">    __s16 vendor;</span><br><span class="line">    __s16 product;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ioctl interface */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDIOCGRDESCSIZE    _IOR(<span class="meta-string">'H'</span>, 0x01, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDIOCGRDESC        _IOR(<span class="meta-string">'H'</span>, 0x02, struct hidraw_report_descriptor)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDIOCGRAWINFO      _IOR(<span class="meta-string">'H'</span>, 0x03, struct hidraw_devinfo)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDIOCGRAWNAME(len)     _IOC(_IOC_READ, <span class="meta-string">'H'</span>, 0x04, len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDIOCGRAWPHYS(len)     _IOC(_IOC_READ, <span class="meta-string">'H'</span>, 0x05, len)</span></span><br><span class="line"><span class="comment">/* The first byte of SFEATURE and GFEATURE is the report number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDIOCSFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, <span class="meta-string">'H'</span>, 0x06, len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDIOCGFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, <span class="meta-string">'H'</span>, 0x07, len)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDRAW_FIRST_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDRAW_MAX_DEVICES 64</span></span><br><span class="line"><span class="comment">/* number of reports to buffer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIDRAW_BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* kernel-only API declarations */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _HIDRAW_H */</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li><a href="http://www.usb.org/developers/hidpage/HID1_11.pdf" target="_blank" rel="noopener">Device Class Definition for HID 1.11</a></li>
<li><a href="http://www.usb.org/developers/hidpage/Hut1_12v2.pdf" target="_blank" rel="noopener">HID Usage Tables 1.12</a></li>
<li><a href="http://d1.amobbs.com/bbs_upload782111/files_41/ourdev_651088NZ5EKW.pdf" target="_blank" rel="noopener">USB HID to PS2 Scan Code Translation Table.pdf</a></li>
<li><a href="http://www.freebsddiary.org/APC/usb_hid_usages.php" target="_blank" rel="noopener">USB HID usage table</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在设备识别阶段多使用<code>bus hound</code>抓取数据包进行分析，在开发板作device时，host可能会获取部分数据（比如触摸屏，需要得到支持几点的触摸操作，默认单点），此时可能会获取失败。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.chinaunix.net/xmlrpc.php?r=blog/article&amp;uid=20587912&amp;id=2984380" target="_blank" rel="noopener">Linux HID 驱动开发(2) USB HID Report 描述及usage 概念</a></li>
<li><a href="https://my.oschina.net/xuwa/blog/2062" target="_blank" rel="noopener">USB HID报告及报告描述符简介</a></li>
<li><a href="http://blog.chinaunix.net/uid-23159239-id-2535119.html" target="_blank" rel="noopener">浅析linux下usb鼠标和usb键盘usbhid驱动hid_parse_report报告描述符</a></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>hid</tag>
      </tags>
  </entry>
  <entry>
    <title>udev的使用</title>
    <url>/post/3820.html</url>
    <content><![CDATA[<p>udev版本：udev-167</p>
<p>udev 是 Linux2.6 内核里的一个功能，它替代了原来的 <code>devfs</code>，成为当前 Linux 默认的设备管理工具。udev 以<code>守护进程</code>的形式运行，通过侦听内核发出来的 uevent 来管理 /dev目录下的设备文件。不像之前的设备管理工具，udev 在<code>用户空间 (user space)</code> 运行，而不在内核空间 (kernel space) 运行。</p>
<p>udev下载：<a href="http://www.kernel.org/pub/linux/utils/kernel/hotplug/" target="_blank" rel="noopener">http://www.kernel.org/pub/linux/utils/kernel/hotplug/</a><br><a id="more"></a></p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>我们都知道，所有的设备在 Linux 里都是以设备文件的形式存在。在早期的 Linux 版本中，/dev目录包含了所有可能出现的设备的设备文件。很难想象 Linux 用户如何在这些大量的设备文件中找到匹配条件的设备文件。现在 udev 只为那些连接到 Linux 操作系统的设备产生设备文件。并且 udev 能通过定义一个 udev 规则 (rule) 来产生匹配设备属性的设备文件，这些设备属性可以是内核设备名称、总线路径、厂商名称、型号、序列号或者磁盘大小等等。</p>
<ul>
<li><code>动态管理</code>：当设备添加 / 删除时，udev 的守护进程侦听来自内核的 <code>uevent</code>，以此添加或者删除 /dev下的设备文件，所以 udev 只为已经连接的设备产生设备文件，而不会在 /dev下产生大量虚无的设备文件, 同时根据udev的规则可以在添加/删除时，执行脚本。</li>
<li><code>自定义命名规则</code>：通过 Linux 默认的规则文件，udev 在 /dev/ 里为所有的设备定义了内核设备名称，比如 /dev/sda、/dev/hda、/dev/fd等等。由于 udev 是在用户空间 (user space) 运行，Linux 用户可以通过自定义的规则文件，灵活地产生标识性强的设备文件名，比如 /dev/boot_disk、/dev/root_disk、/dev/color_printer等等。</li>
<li><code>设定设备的权限和所有者/组</code>：udev 可以按一定的条件来设置设备文件的权限和设备文件所有者 / 组。在不同的 udev 版本中，实现的方法不同，在“如何配置和使用 udev”中会详解。</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/images/udev/udev_work_flow.jpg" alt="udev工作流程"></p>
<h2 id="配置udev"><a href="#配置udev" class="headerlink" title="配置udev"></a>配置udev</h2><p>udev需要内核<code>sysfs</code>和<code>tmpfs</code>的支持，sysfs为udev提供<code>设备入口</code>和<code>uevent通道</code>，tmpfs为udev设备文件提供存放空间.</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="启动udev的守护进程"><a href="#启动udev的守护进程" class="headerlink" title="启动udev的守护进程"></a>启动udev的守护进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /dev/.udev</span><br><span class="line">udevd --daemon</span><br><span class="line">udevadm trigger</span><br></pre></td></tr></table></figure>
<h3 id="配置文件及规则"><a href="#配置文件及规则" class="headerlink" title="配置文件及规则"></a>配置文件及规则</h3><ul>
<li>目录结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /etc/udev</span><br><span class="line"></span><br><span class="line">├── rules.d</span><br><span class="line">│   ├── 22-xxx.rules</span><br><span class="line">│   └── 99-fuse.rules</span><br><span class="line">└── udev.conf</span><br></pre></td></tr></table></figure>
<p>在规则文件里，除了以“#”开头的行（注释），所有的非空行都被视为一条规则，但是一条规则不能扩展到多行。规则都是由多个 键值对（key-value pairs）组成，并由逗号隔开，键值对可以分为 <code>条件匹配键值对</code>( 以下简称“匹配键 ”) 和 <code>赋值键值对</code>( 以下简称“赋值键 ”)，一条规则可以有多条匹配键和多条赋值键。匹配键是匹配一个设备属性的所有条件，当一个设备的属性匹配了该规则里所有的匹配键，就认为这条规则生效，然后按照赋值键的内容，执行该规则的赋值。下面是一个简单的规则：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KERNEL==&quot;sda&quot;, NAME=&quot;my_root_disk&quot;, MODE=&quot;0660&quot;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>KERNEL</code>是匹配键，<code>NAME</code>和<code>MODE</code>是赋值键。这条规则的意思是：如果有一个设备的内核设备名称为 sda，则该条件生效，执行后面的赋值：在 /dev下产生一个名为 my_root_disk的设备文件，并把设备文件的权限设为 0660。</p>
</blockquote>
<p>添加规则时，多从官方文档（<a href="http://www.reactivated.net/writing_udev_rules.html" target="_blank" rel="noopener">Writing udev rules</a>）获取信息</p>
<h4 id="规则操作符"><a href="#规则操作符" class="headerlink" title="规则操作符"></a>规则操作符</h4><ul>
<li>“==”：比较键、值，若等于，则该条件满足；</li>
<li>“!=”： 比较键、值，若不等于，则该条件满足；</li>
<li>“=”： 对一个键赋值；</li>
<li>“+=”：为一个表示多个条目的键赋值。</li>
<li>“:=”：对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。</li>
</ul>
<h4 id="规则匹配键"><a href="#规则匹配键" class="headerlink" title="规则匹配键"></a>规则匹配键</h4><ul>
<li>ACTION： 事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。</li>
<li>KERNEL： 内核设备名称，例如：sda, cdrom。</li>
<li>DEVPATH：设备的 devpath 路径。</li>
<li>SUBSYSTEM： 设备的子系统名称，例如：sda 的子系统为 block。</li>
<li>BUS： 设备在 devpath 里的总线名称，例如：usb。</li>
<li>DRIVER： 设备在 devpath 里的设备驱动名称，例如：ide-cdrom。</li>
<li>ID： 设备在 devpath 里的识别号。</li>
<li>SYSFS{filename}： 设备的 devpath 路径下，设备的属性文件“filename”里的内容。</li>
</ul>
<h4 id="规则赋值键"><a href="#规则赋值键" class="headerlink" title="规则赋值键"></a>规则赋值键</h4><ul>
<li>NAME：在 /dev下产生的设备文件名。只有第一次对某个设备的 NAME 的赋值行为生效，之后匹配的规则再对该设备的 NAME 赋值行为将被忽略。如果没有任何规则对设备的 NAME 赋值，udev 将使用内核设备名称来产生设备文件。</li>
<li>SYMLINK：为 /dev/下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。</li>
<li>OWNER, GROUP, MODE：为设备设定权限。</li>
<li>ENV{key}：导入一个环境变量。</li>
</ul>
<h4 id="值可调用的替换操作符"><a href="#值可调用的替换操作符" class="headerlink" title="值可调用的替换操作符"></a>值可调用的替换操作符</h4><p>在键值对中的键和操作符都介绍完了，最后是值 (value)。Linux 用户可以随意地定制 udev 规则文件的值。例如：my_root_disk, my_printer。同时也可以引用下面的替换操作符：</p>
<ul>
<li>$kernel, %k：设备的内核设备名称，例如：sda、cdrom。</li>
<li>$number, %n：设备的内核号码，例如：sda3 的内核号码是 3。</li>
<li>$devpath, %p：设备的 devpath路径。</li>
<li>$id, %b：设备在 devpath里的 ID 号。</li>
<li>$sysfs{file}, %s{file}：设备的 sysfs里 file 的内容。其实就是设备的属性值。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="hidraw"><a href="#hidraw" class="headerlink" title="hidraw"></a>hidraw</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ACTION!=&quot;add&quot;, GOTO=&quot;uibc_exit&quot;</span><br><span class="line">KERNEL==&quot;hidraw2&quot;, SUBSYSTEM==&quot;hidraw&quot;, RUN+=&quot;/etc/udev/xxx.sh&quot;</span><br><span class="line">LABEL=&quot;uibc_exit&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: /etc/udev/rules.d/22-xxx.rules</p>
</blockquote>
<h4 id="SD"><a href="#SD" class="headerlink" title="SD"></a>SD</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">action!=&quot;add&quot;,goto=&quot;farsight&quot;</span><br><span class="line">kernel==&quot;mmcblk[0-9]p[0-9]&quot;,run+=&quot;/sbin/mount-sd.sh %k&quot;</span><br><span class="line">label=&quot;farsight&quot;</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>在每条规则中，赋值的字符串必须使用<code>双引号</code>括起来。</li>
<li>设备添加/删除后，触发uevent执行<code>RUN+</code>的脚本时，在该脚本中不能直接使用<code>echo</code>输出打印信息，应该导入终端的串口节点。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;print debug info ...&quot; &gt; /dev/ttyS000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="制定-udev-规则和查询设备信息"><a href="#制定-udev-规则和查询设备信息" class="headerlink" title="制定 udev 规则和查询设备信息"></a>制定 udev 规则和查询设备信息</h2><blockquote>
<p>如何查找设备的信息 ( 属性 ) 来制定 udev 规则：</p>
</blockquote>
<h3 id="查询sysfs文件系统："><a href="#查询sysfs文件系统：" class="headerlink" title="查询sysfs文件系统："></a>查询sysfs文件系统：</h3><p>例如：设备 sda 的 SYSFS{size} 可以通过 cat /sys/block/sda/size得到；SYSFS{model} 信息可以通过 cat /sys/block/sda/device/model得到。</p>
<h3 id="udevadm-info"><a href="#udevadm-info" class="headerlink" title="udevadm info"></a>udevadm info</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udevadm info  --query=all --name=/dev/hidraw2</span><br></pre></td></tr></table></figure>
<p>设备信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># udevadm info  --query=all --name=/dev/hidraw2</span><br><span class="line">P: /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.2/0003:1C4D:0503.0003/hidraw/hidraw2</span><br><span class="line">N: hidraw2</span><br><span class="line">S: usb/by-devid/_/hidraw2</span><br><span class="line">E: UDEV_LOG=3</span><br><span class="line">E: DEVPATH=/devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.2/0003:1C4D:0503.0003/hidraw/hidraw2</span><br><span class="line">E: MAJOR=251</span><br><span class="line">E: MINOR=2</span><br><span class="line">E: DEVNAME=/dev/hidraw2</span><br><span class="line">E: SUBSYSTEM=hidraw</span><br><span class="line">E: DEVLINKS=/dev/usb/by-devid/_/hidraw2</span><br></pre></td></tr></table></figure></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="查看udev是否处理内核的uevent事件"><a href="#查看udev是否处理内核的uevent事件" class="headerlink" title="查看udev是否处理内核的uevent事件"></a>查看udev是否处理内核的uevent事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udevadm  monitor</span><br></pre></td></tr></table></figure>
<p>例如：U盘的插入/拔出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># udevadm monitor</span><br><span class="line">monitor will print the received events for:</span><br><span class="line">UDEV - the event which udev sends out after rule processing</span><br><span class="line">KERNEL - the kernel uevent</span><br><span class="line"></span><br><span class="line">usb 1-1: new high-speed USB device number 4 using ehci-platform</span><br><span class="line">KERNEL[209.826989] add  usb-storage 1-1:1.0: USB Mass Storage device detected</span><br><span class="line">    /devices/platform/soscsi host0: usb-storage 1-1:1.0</span><br><span class="line">c/f9890000.ehci/usb1/1-1 (usb)</span><br><span class="line">KERNEL[209.827627] add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0 (usb)</span><br><span class="line">UDEV  [209.834354] add      /devices/platform/soc/f9890000.ehci/usb1/1-1 (usb)</span><br><span class="line">...</span><br><span class="line">UDEV  [209.841660] add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/scsi_host/host0 (scsi_host)</span><br><span class="line">scsi 0:0:0:0: Direct-Access     General  UDisk            5.00 PQ: 0 ANSI: 2</span><br><span class="line">KERNEL[210.848174] add      /devsd 0:0:0:0: [sda] 15728640 512-byte logical blocks: (8.05 GB/7.50 GiB)</span><br><span class="line">ices/platform/soc/f98900sd 0:0:0:0: [sda] Write Protect is off</span><br><span class="line">00.ehci/usb1/1-1/1-1:1.0sd 0:0:0:0: [sda] No Caching mode page found</span><br><span class="line">/host0/target0:0sd 0:0:0:0: [sda] Assuming drive cache: write through</span><br><span class="line">:0 (scsi)</span><br><span class="line">KERNEL[210.848626] add      /devices/platform/soc/f9890000.ehci/usb1/ sda: sda1 sda2</span><br><span class="line">1-1/1-1:1.0/host0/target0:0:0/0:0:0:0 (scsi)</span><br><span class="line">KERNEL[210.848995]sd 0:0:0:0: [sda] Attached SCSI removable disk</span><br><span class="line"> add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/scsi_disk/0:0:0:0 (scsi_disk)</span><br><span class="line">KERNEL[210.849804] add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/scsi_device/0:0:0:0 (scsi_device)</span><br><span class="line">UDEV  [210.858522] add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/scsi_device/0:0:0:0 (scsi_device)</span><br><span class="line">...</span><br><span class="line">dudisk1110 -&gt; /dev/sda</span><br><span class="line">udisk1110p1 -&gt; /dev/sda1</span><br><span class="line"></span><br><span class="line">usb usb1-port1: disabled by hub (EMI?), re-enabling...</span><br><span class="line">usb 1-1: USB disconnect, device number 4</span><br><span class="line">KERNEL[213.650748] remove   /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/bsg/0:0:0:0 (bsg)</span><br><span class="line">...</span><br><span class="line">UDEV  [213.652991] remove   /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/bsg/0:0:0:0 (bsg)</span><br><span class="line">KERNEL[213.653175] remove   /devices/virtual/bdi/8:0 (bdi)</span><br><span class="line">UDEV  [213.774157] remove   /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0 (usb)</span><br></pre></td></tr></table></figure></p>
<h3 id="重启udev"><a href="#重启udev" class="headerlink" title="重启udev"></a>重启udev</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udevadm trigger --type=devices --action=change</span><br></pre></td></tr></table></figure>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="udev-和-devfs-是什么关系"><a href="#udev-和-devfs-是什么关系" class="headerlink" title="udev 和 devfs 是什么关系"></a>udev 和 devfs 是什么关系</h3><p>udev 完全在用户态 (userspace) 工作，利用设备加入或移除时内核所发送的hotplug 事件 (event) 来工作。关于设备的详细信息是由内核输出 (export) 到位于 /sys 的 sysfs 文件系统的。所有的设备命名策略、权限控制和事件处理都是在用户态下完成的。与此相反，devfs 是作为内核的一部分工作的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.reactivated.net/writing_udev_rules.html" target="_blank" rel="noopener">Writing udev rules</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-udev/index.html?ca=drs-cn-0304" target="_blank" rel="noopener">使用 udev 高效、动态地管理 Linux 设备文件</a></li>
<li><a href="http://blog.chinaunix.net/uid-26514815-id-3453208.html" target="_blank" rel="noopener">udev使用方法（附实例）</a></li>
</ul>
]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>udev</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统性能测试--iozone</title>
    <url>/post/40023.html</url>
    <content><![CDATA[<h2 id="iozone"><a href="#iozone" class="headerlink" title="iozone"></a>iozone</h2><blockquote>
<p>一个文件系统性能评测工具，可以测试Read, write, re-read,re-write, read backwards, read strided, fread, fwrite, random read, pread, mmap, aio_read, aio_write 等不同模式下不同文件系统的读写性能</p>
</blockquote>
<p>官网： <a href="http://www.iozone.org/" target="_blank" rel="noopener">http://www.iozone.org</a></p>
<a id="more"></a>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">全自动模式测试。测试记录块大小从4k到16M，测试文件从64k到512M</td>
</tr>
<tr>
<td style="text-align:center">-A</td>
<td style="text-align:center">使用自动模式虽然测试比较全面，但是比较花时间。-a选项将在文件大于32MB时停止使用低于64k一下记录块，来节省时间。-A通知iozone不要节省时间，进行所有测试。注：在3.61版本以后不建议使用，用-az代替-aA</td>
</tr>
<tr>
<td style="text-align:center">-B</td>
<td style="text-align:center">使用mmap()。这将使用mmap()接口来创建并访问所有测试用的临时文件。一些应用程序倾向于将文件当作内存的一块来看待。这些应用程序对文件执行mmap()调用，然后就可以以读写内存的方式访问那个块来完成文件I/O。</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">计算时间将close()包括进来</td>
</tr>
<tr>
<td style="text-align:center">-C</td>
<td style="text-align:center">显示吞吐量测试中每个客户端的字节数。</td>
</tr>
<tr>
<td style="text-align:center">-D</td>
<td style="text-align:center">对mmap文件使用MSYNC(MS_ASYNC)。告诉操作系统在mmap空间的所有数据需要被异步的写到磁盘上。</td>
</tr>
<tr>
<td style="text-align:center">-e</td>
<td style="text-align:center">测试时间是包含flush(fsync, fflush)</td>
</tr>
<tr>
<td style="text-align:center">-f filename</td>
<td style="text-align:center">指定用来测试临时文件，在测试完成后将被自动删除</td>
</tr>
<tr>
<td style="text-align:center">-F filename filename …</td>
<td style="text-align:center">指定测试中每个临时文件名，文件名的数量应该和指定的进程或线程数相同</td>
</tr>
<tr>
<td style="text-align:center">-g #</td>
<td style="text-align:center">在自动模式下设置文件最大值，可以使用#k #m #g分别表示kb，mb，gb</td>
</tr>
<tr>
<td style="text-align:center">-G</td>
<td style="text-align:center">对mmap文件使用msync(MS_SYNC)。告诉操作系统在mmap空间的所有数据需要被同步的写到磁盘上</td>
</tr>
<tr>
<td style="text-align:center">-h</td>
<td style="text-align:center">显示帮助</td>
</tr>
<tr>
<td style="text-align:center">-i #</td>
<td style="text-align:center">指定运行于哪种模式测试。可以使用-i # -i # -i #进行多个测试</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0=write/rewrite</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">1=read/re-read</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">2=random read/random write</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">3=backwards read</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">4=re-write-record</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">5=stride-read</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">6=fwirte/re-fwrite</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">7=fread/re-fread</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">8=random mix</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">9=pwrite/re-pwrite</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">10=pread/re-pread</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">11=pwritev/re-pwritev</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">12=preadv/re-preadv</td>
</tr>
<tr>
<td style="text-align:center">-I</td>
<td style="text-align:center">对所有文件操作使用DIRECT I/O。通知文件系统所有操作跳过缓存直接在磁盘上操作</td>
</tr>
<tr>
<td style="text-align:center">-j #</td>
<td style="text-align:center">设置访问文件的跨度为(# * 块)。stride read测试将使用这个跨度来读块</td>
</tr>
<tr>
<td style="text-align:center">-J #（毫秒）</td>
<td style="text-align:center">在每个I/O操作之前产生指定毫秒的计算延迟。看-X和-Y获取控制计算延迟的其他参数</td>
</tr>
<tr>
<td style="text-align:center">-l #</td>
<td style="text-align:center">设置程序最小进程数。在测试过程允许用户设置的最小进程或线程数。需要配合-u选项使用。</td>
</tr>
<tr>
<td style="text-align:center">-L #</td>
<td style="text-align:center">设置处理器交换信息的单位量为#（bytes）。可以加速测试。</td>
</tr>
<tr>
<td style="text-align:center">-m</td>
<td style="text-align:center">iozone将在内部使用多个缓存。一些程序反复复写一块缓存，还有就是设置多个缓存块。此参数将允许使用这两种模式。iozone默认行为是重复使用内部一个缓存。此选项将允许在内部使用多个缓存块。</td>
</tr>
<tr>
<td style="text-align:center">-M</td>
<td style="text-align:center">调用uname()，将返回字符串放在输出文件中</td>
</tr>
<tr>
<td style="text-align:center">-n #</td>
<td style="text-align:center">设置自动模式下测试文件的最小值</td>
</tr>
<tr>
<td style="text-align:center">-N</td>
<td style="text-align:center">报告结果以毫秒每操作的方式显示</td>
</tr>
<tr>
<td style="text-align:center">-o</td>
<td style="text-align:center">写方式是同步写到磁盘上</td>
</tr>
<tr>
<td style="text-align:center">-O</td>
<td style="text-align:center">报告结果以操作每秒方式显示</td>
</tr>
<tr>
<td style="text-align:center">-q #</td>
<td style="text-align:center">在自动模式下设置记录块的最大值，可以使用#k(kb)，#m(mb)，#g(gb)。使用-y可以设置最小值</td>
</tr>
<tr>
<td style="text-align:center">-r #</td>
<td style="text-align:center">设置记录块大小为#</td>
</tr>
<tr>
<td style="text-align:center">-R</td>
<td style="text-align:center">使用Excel显示结果</td>
</tr>
<tr>
<td style="text-align:center">-s #</td>
<td style="text-align:center">设置测试文件大小</td>
</tr>
<tr>
<td style="text-align:center">-S #</td>
<td style="text-align:center">设置处理器的缓存大小</td>
</tr>
<tr>
<td style="text-align:center">-t #</td>
<td style="text-align:center">设置测试程序的线程或进程数</td>
</tr>
<tr>
<td style="text-align:center">-T</td>
<td style="text-align:center">使用POSIX的pthreads进行测试</td>
</tr>
<tr>
<td style="text-align:center">-u #</td>
<td style="text-align:center">设置最大进程或线程数，需要配合-l参数使用</td>
</tr>
<tr>
<td style="text-align:center">-U mountpoint</td>
<td style="text-align:center">在测试开始之前，iozone将unmount和remount挂载点。这将保证测试中缓存不包含任何文件</td>
</tr>
<tr>
<td style="text-align:center">-w</td>
<td style="text-align:center">在测试结束后不要删除临时文件。临时文件将在测试过后保存下来</td>
</tr>
<tr>
<td style="text-align:center">-W</td>
<td style="text-align:center">在测试过程中，当读或写文件时锁住文件</td>
</tr>
<tr>
<td style="text-align:center">-y #</td>
<td style="text-align:center">设置记录块最小值</td>
</tr>
<tr>
<td style="text-align:center">-z</td>
<td style="text-align:center">同-a一起使用，进行全部测试</td>
</tr>
<tr>
<td style="text-align:center">-Z</td>
<td style="text-align:center">允许mmap I/O和file I/O混合使用</td>
</tr>
</tbody>
</table>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo iozone -ac -s 8m   -f /home/testfile -y 2k -q 8m</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time Resolution = 0.000001 seconds.</span><br><span class="line">Processor cache size set to 1024 Kbytes.</span><br><span class="line">Processor cache line size set to 32 bytes.</span><br><span class="line">File stride size set to 17 * record size.</span><br><span class="line">                                                     random  random    bkwd   record   stride</span><br><span class="line">       KB  reclen   write rewrite    read    reread    read   write    read  rewrite     read   fwrite frewrite   fread  freread</span><br><span class="line">     8192       2  189862  415349  1181932  1608842 1018766  374677 1329412   398615   665257   405521   367288 1569381  1528607</span><br><span class="line">     8192       4  237746  686099  1981095  2178140 1788563  536369 1336133   765253  1662395   391698   586565 1920739  2217786</span><br><span class="line">     8192       8  312623  871304  1620222  1851298 2215927  607182 2392438   979445  1817225   853513   873808 2615731  2264859</span><br><span class="line">     8192      16  280834  625953  2536184  2567262 2224823 1134478 2546334  1416090  2339815   938923   890545 2510611  2251797</span><br><span class="line">     8192      32  395003 1122984  1941688  1715601 1975400  721755 2480882  1573550  1757908   940543  1122654 2917577  2592443</span><br><span class="line">     8192      64  270175 1053372  2642689  2850293 2632364 1407332 2715153  1819245  2919312  1094161  1165811 1840095  1886259</span><br><span class="line">     8192     128  275769 1149623  2585809  2727871 2409382 1451995 2636606  1789028  2325877  1041968  1090826 2615731  1923858</span><br><span class="line">     8192     256  291167 1144454  2486987  2536184 2369668 1446067 2202151  1263978  2343965  1137144  1136994 2354728  2517417</span><br><span class="line">     8192     512  349935 1193800  2327295  2420755 2422804 1362140 1923427  1698135  2658845  1083329  1143007 1855096  1833907</span><br><span class="line">     8192    1024  333752 1308403  2522962  2538433 2496020 1461568 2443132  1573550  2954201   901409  1139520 1943115  2304969</span><br><span class="line">     8192    2048  276766 1110176  2367709  2430860 2420755 1338162 1757548  1406583  1580571   805492  1024660 2241221  2357313</span><br><span class="line">     8192    4096  592891 1179538  2268747  2339337 2063424 1196419 1890618  1383531  1853795   204928  1006737 1808425  1798486</span><br><span class="line">     8192    8192  328823 1199761  2394606  2408707 2175244 1265747 2327926  1293333  2159657  1222513  1181607 2380009  2428798</span><br></pre></td></tr></table></figure>
<p>结果： 左边第一列是测试文件大小，第二列是记录块大小（单位是kb），以后每列就是测试模式（单位是kb/s）</p>
<h3 id="测试项"><a href="#测试项" class="headerlink" title="测试项"></a>测试项</h3><table>
<thead>
<tr>
<th style="text-align:center">测试项</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Write</td>
<td style="text-align:center">测试向一个新文件写入的性能。当一个新文件被写入时，不仅仅是那些文件中的数据需要被存储，还包括那些用于定位数据存储在存储介质的具体位置的额外信息。这些额外信息被称作“元数据”。它包括目录信息，所分配的空间和一些与该文件有关但又并非该文件所含数据的其他数据。拜这些额外信息所赐，Write的性能通常会比Re-write的性能低。</td>
</tr>
<tr>
<td style="text-align:center">Re-write</td>
<td style="text-align:center">测试向一个已存在的文件写入的性能。当一个已存在的文件被写入时，所需工作量较少，因为此时元数据已经存在。Re-write的性能通常比Write的性能高。</td>
</tr>
<tr>
<td style="text-align:center">Read</td>
<td style="text-align:center">测试读一个已存在的文件的性能。</td>
</tr>
<tr>
<td style="text-align:center">Re-Read</td>
<td style="text-align:center">测试读一个最近读过的文件的性能。Re-Read性能会高些，因为操作系统通常会缓存最近读过的文件数据。这个缓存可以被用于读以提高性能。</td>
</tr>
<tr>
<td style="text-align:center">Random Read</td>
<td style="text-align:center">测试读一个文件中的随机偏移量的性能。许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。</td>
</tr>
<tr>
<td style="text-align:center">Random Write</td>
<td style="text-align:center">测试写一个文件中的随机偏移量的性能。同样，许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。</td>
</tr>
<tr>
<td style="text-align:center">Random Mix</td>
<td style="text-align:center">测试读写一个文件中的随机偏移量的性能。同样，许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。这个测试只有在吞吐量测试模式下才能进行。每个线程/进程运行读或写测试。这种分布式读/写测试是基于round robin 模式的。最好使用多于一个线程/进程执行此测试。</td>
</tr>
<tr>
<td style="text-align:center">Backwards Read</td>
<td style="text-align:center">测试使用倒序读一个文件的性能。这种读文件方法可能看起来很可笑，事实上，有些应用确实这么干。MSC Nastran是一个使用倒序读文件的应用程序的一个例子。它所读的文件都十分大（大小从G级别到T级别）。尽管许多操作系统使用一些特殊实现来优化顺序读文件的速度，很少有操作系统注意到并增强倒序读文件的性能。</td>
</tr>
<tr>
<td style="text-align:center">Record Rewrite</td>
<td style="text-align:center">测试写与覆盖写一个文件中的特定块的性能。这个块可能会发生一些很有趣的事。如果这个块足够小（比CPU数据缓存小），测出来的性能将会非常高。如果比CPU数据缓存大而比TLB小，测出来的是另一个阶段的性能。如果比此二者都大，但比操作系统缓存小，得到的性能又是一个阶段。若大到超过操作系统缓存，又是另一番结果。</td>
</tr>
<tr>
<td style="text-align:center">Strided Read</td>
<td style="text-align:center">测试跳跃读一个文件的性能。举例如下：在0偏移量处读4Kbytes，然后间隔200Kbytes,读4Kbytes，再间隔200Kbytes，如此反复。此时的模式是读4Kbytes，间隔200Kbytes并重复这个模式。这又是一个典型的应用行为，文件中使用了数据结构并且访问这个数据结构的特定区域的应用程序常常这样做。许多操作系统并没注意到这种行为或者针对这种类型的访问做一些优化。同样，这种访问行为也可能导致一些有趣的性能异常。一个例子是在一个数据片化的文件系统里，应用程序的跳跃导致某一个特定的磁盘成为性能瓶颈。</td>
</tr>
<tr>
<td style="text-align:center">Fwrite</td>
<td style="text-align:center">测试调用库函数fwrite()来写文件的性能。这是一个执行缓存与阻塞写操作的库例程。缓存在用户空间之内。如果一个应用程序想要写很小的传输块，fwrite()函数中的缓存与阻塞I/O功能能通过减少实际操作系统调用并在操作系统调用时增加传输块的大小来增强应用程序的性能。这个测试是写一个新文件，所以元数据的写入也是要的。</td>
</tr>
<tr>
<td style="text-align:center">Frewrite</td>
<td style="text-align:center">测试调用库函数fwrite()来写文件的性能。这是一个执行缓存与阻塞写操作的库例程。缓存在用户空间之内。如果一个应用程序想要写很小的传输块，fwrite()函数中的缓存与阻塞I/O功能能通过减少实际操作系统调用并在操作系统调用时增加传输块的大小来增强应用程序的性能。</td>
</tr>
</tbody>
</table>
<h2 id="导出Excel表格"><a href="#导出Excel表格" class="headerlink" title="导出Excel表格"></a>导出Excel表格</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iozone -i 0 -i 1 -s 8m   -f /testfile -y 2k -q 8m -Rab /iozone_test.xls</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在嵌入式开发板上导出表格数据全为0，无法使用</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./iozone -s 100M -ac -S 512k 2&gt;&amp;1 | tee test.log</span><br></pre></td></tr></table></figure>
<h3 id="只测试读写模式，测试文件4g"><a href="#只测试读写模式，测试文件4g" class="headerlink" title="只测试读写模式，测试文件4g"></a>只测试读写模式，测试文件4g</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iozone -Rab -g 4g -i 0 -i 1  output.xls</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>iozone</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/post/27055.html</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> aa&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">union</span> aa b;</span><br><span class="line">        b.i = <span class="number">0</span>; <span class="comment">//初始化内存空间，如果不清最后的b.i为随机值</span></span><br><span class="line">        b.a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        b.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b.i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) | (<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果： 266(256+10)</p>
</blockquote>
<ol>
<li>union 类型的特点是不同类型的数据共享同一段内存，union 结构体的大小为其所含占内存<code>最大成员大小</code>，但在同一时刻只能有一类成员存储于其中</li>
<li>计算机存储的大小端不同，最后的输出结果不一定。</li>
</ol>
<h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><ol>
<li><code>Little endian</code>和<code>Big endian</code>是CPU存放数据的两种不同顺序</li>
<li><code>Big endian</code>第一个字节是最高位字节（按照从低地址到高地址的顺序存放数据的高位字节到低位字节）</li>
<li><code>Little endian</code>第一个字节是最低位字节（按照从低地址到高地址的顺序存放数据的低位字节到高位字节）</li>
</ol>
<ul>
<li><p>共同体所有数据共用同一块地址空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> aa&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">union</span> aa a;</span><br><span class="line">        a.i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( a.j == <span class="number">1</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> * p = (<span class="keyword">char</span>*)&amp;a;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><h3 id="取最大值"><a href="#取最大值" class="headerlink" title="取最大值"></a>取最大值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PAD(v, p)  ((v + (p) - 1) &amp; (~((p) - 1)))</span><br></pre></td></tr></table></figure>
<h3 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define IS_POW2(x)  (((x) &amp; (x - 1)) == 0)</span><br></pre></td></tr></table></figure>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><ol>
<li>数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节</li>
<li>结构体或类的自身对齐值：其成员中自身对齐值<code>最大</code>的那个值</li>
<li>指定对齐值：<code>#pragma pack (value)</code>时的指定对齐值value。</li>
<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std1</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;     <span class="comment">//4</span></span><br><span class="line">	<span class="keyword">char</span> b;   <span class="comment">//1</span></span><br><span class="line">			  <span class="comment">//占空3</span></span><br><span class="line">	<span class="keyword">float</span> c;   <span class="comment">//4</span></span><br><span class="line">	<span class="keyword">char</span> d;   <span class="comment">//1</span></span><br><span class="line">			  <span class="comment">//占空3</span></span><br><span class="line">	<span class="keyword">double</span> e; <span class="comment">//8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sizeof</span>(std1) = <span class="number">24</span></span><br><span class="line"></span><br><span class="line">struct std2&#123;</span><br><span class="line">	<span class="keyword">char</span> c;  <span class="comment">//1</span></span><br><span class="line">			 <span class="comment">//占空1</span></span><br><span class="line">	short s;  <span class="comment">//2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(std2) = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line">        p += <span class="number">6</span>; <span class="comment">/*累加的是p指针类型的宽度(4*6)*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出： 0x18[24]</p>
</blockquote>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ol>
<li>管道</li>
<li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
<li>共享内存</li>
<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</li>
<li>socket</li>
<li>信号（sinal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
</ol>
<blockquote>
<p><a href="https://www.cnblogs.com/LUO77/p/5816326.html" target="_blank" rel="noopener">进程间通信的方式——信号、管道、消息队列、共享内存</a></p>
</blockquote>
<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">revstr</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>    *start = str;</span><br><span class="line">    <span class="keyword">char</span>    *<span class="built_in">end</span> = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>    ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">            ch = *start;</span><br><span class="line">            *start++ = *<span class="built_in">end</span>;</span><br><span class="line">            *<span class="built_in">end</span>-- = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strlen</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> my_strlen(str+<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_string</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = my_strlen(<span class="built_in">string</span>);</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> temp = <span class="built_in">string</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="built_in">string</span>[<span class="number">0</span>] = <span class="built_in">string</span>[len<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">string</span>[len<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">                reverse_string(<span class="built_in">string</span>+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">string</span>[len<span class="number">-1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch[] = <span class="string">"abcdefghijklmno"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0:%s\n"</span>,ch);</span><br><span class="line">        reverse_string(ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1:%s\n"</span>,ch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h2><blockquote>
<p><code>C++</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>*a, <span class="keyword">int</span> &amp;b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        c=*a;</span><br><span class="line">        b=<span class="number">30</span>;</span><br><span class="line">        *a=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">10</span>, b=<span class="number">20</span>, c=<span class="number">30</span>;</span><br><span class="line">        <span class="comment">/*指针与引用*/</span></span><br><span class="line">        change(&amp;a,b,c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,%d,%d\n"</span>,a,b,c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：20,30,30</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">" "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">" "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        test(a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0x7fffc646494c 1<br>0x7fffc646494c 1</p>
</blockquote>
<ol>
<li>指针传递是一种<code>值传递</code>的方式，他<code>传递的只是地址值</code>，值传递的时候中我们可以知道被调函数的形参会被当做一个局部变量来出来，会在栈中去给其分配空间用 来存储主调函数传输过来的值，该值只不过是主调函数中实参值的一个拷贝，所以在被调函数中去修改传输过来的值并不会去影响主调函数中的实参值。</li>
<li>引用作为函数参数进行传递时，实质上<code>传递的是实参本身</code>，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。</li>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。</li>
<li>可以有const指针，但是没有const引用；</li>
<li>指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）</li>
<li>指针和引用的自增(++)运算意义不一样；</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；</li>
</ol>
<h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><h2 id="关键字static"><a href="#关键字static" class="headerlink" title="关键字static"></a>关键字static</h2><ol>
<li>在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变， 内存中的位置：<code>静态存储区</code>（<strong>静态存储区在整个程序运行期间都存在</strong>）</li>
<li>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</li>
<li>在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</li>
</ol>
<h2 id="关键字const"><a href="#关键字const" class="headerlink" title="关键字const"></a>关键字const</h2><blockquote>
<p>左<code>数</code>右<code>指</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;    <span class="comment">//a：只读</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;    <span class="comment">//a：只读</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;   <span class="comment">//"左"，指针a，数据不能变，数据只读</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;  <span class="comment">//"右"，指针a，指针不能变，地址只读</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;    <span class="comment">//数据指针均只读</span></span><br></pre></td></tr></table></figure>
<ol>
<li>关键字const的 作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。</li>
<li>通过给编译器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</li>
<li>合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</li>
</ol>
<h2 id="关键字volatile"><a href="#关键字volatile" class="headerlink" title="关键字volatile"></a>关键字volatile</h2><ol>
<li>并行设备的硬件寄存器（如：状态寄存器），防止编译器的优化</li>
<li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables),(即，变量会在程序外被改变,每次都必须从内存中读取，而不能把他放在cache或寄存器中重复使用)</li>
<li>多线程应用中被几个任务共享的变量</li>
</ol>
<h2 id="float类型和0比较大小"><a href="#float类型和0比较大小" class="headerlink" title="float类型和0比较大小"></a>float类型和0比较大小</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const float EPSINON= 0.00001;</span><br><span class="line">if((x &gt;= -EPSINON) &amp;&amp; (x &lt;= EPSINON))&gt;))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不能直接用float类型的值与0进行“==”或“!=”比较</p>
</blockquote>
<p><strong>标准C语言中:</strong><br>单精度float浮点格式的符号位=1，有效位=23，指数未=8，产生一个32位的表示。<br>双精度double浮点格式的符号位=1，有效位=52，指数位=11，产生一个64位的表示。</p>
<p>转成数值即为:V=(-1)^S <em> 1.M </em> 2^(E-127)</p>
<p>对于16.5转成二进制为00010000.1==&gt;1.00001*2^4,<br>那么在内存的表示为:<br>符号位    指数4+127 = 131      尾数<br>0          10000011         00001 000000000000000000</p>
<p>在转换过程中由于需要往右移位, 可见对于float数整数部分越大,小数部分的精度就越低<br>对float数来说有效数字约为7位(2^23约等于10^7),所以整数部分占的位数越多,小数部分<br>的精度就越低,当整数部分超过9999999后小数部分已经完全无精度了</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h3 id="B-树-B-树"><a href="#B-树-B-树" class="headerlink" title="B-树(B+树)"></a>B-树(B+树)</h3><h3 id="红黑树和AVL树"><a href="#红黑树和AVL树" class="headerlink" title="红黑树和AVL树"></a>红黑树和AVL树</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/x_wukong/p/5712345.html" target="_blank" rel="noopener">传指针和传指针引用的区别/指针和引用的区别（本质）</a></li>
<li><a href="http://blog.chinaunix.net/uid-24611346-id-3193852.html" target="_blank" rel="noopener">C语言中static变量详解 </a></li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hung Task</title>
    <url>/post/16306.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[10505.024599] INFO: task ps:26540 blocked for more than 120 seconds.</span><br><span class="line">[10505.199520] &quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot; disables this message.</span><br><span class="line">[10507.707796] ps              D 804059d4     0 26540    110 0x00100000</span><br><span class="line">[10510.574054] Stack : 00000000 8ba75900 807d2ff0 8008c99c 8052c27c 8057e800 00000003 880022</span><br><span class="line"></span><br><span class="line">	8ba75900 80402e34 880180a0 00000001 880180a4 80580000 804bac00 8ba75900</span><br><span class="line">	804be4ec 880180c4 80ab0000 804059d4 ffffff69 8ba75900 004bb030 880180a0</span><br><span class="line">	00000001 80402dc8 8aa7cb80 00000001 8a531df8 800f6b3c 00000002 00000000</span><br><span class="line">	800f7c84 8a531df8 8bc8bd60 880180c4 8ba75900 8a531d00 8a531df8 00000001</span><br><span class="line">	...</span><br><span class="line">[10530.536867] Call Trace:</span><br><span class="line">[10532.061092] [&lt;80405324&gt;] __schedule+0x5d4/0x814</span><br><span class="line">[10533.833196] [&lt;804059d4&gt;] schedule_preempt_disabled+0x18/0x30</span><br><span class="line">[10535.744720] [&lt;80402dc8&gt;] mutex_lock_nested+0x264/0x468</span><br><span class="line">[10537.733761] [&lt;800f7c84&gt;] lookup_slow+0x44/0xd4</span><br><span class="line">[10539.417797] [&lt;800f9590&gt;] path_lookupat+0x13c/0x804</span><br><span class="line">[10541.347068] [&lt;800f9c8c&gt;] filename_lookup.isra.10+0x34/0xa0</span><br><span class="line">[10543.326101] [&lt;800fbd70&gt;] user_path_at_empty+0x60/0xa0</span><br><span class="line">[10545.166088] [&lt;800fbdc4&gt;] user_path_at+0x14/0x20</span><br><span class="line">[10546.921821] [&lt;800f1fe8&gt;] vfs_fstatat+0x64/0xc4</span><br><span class="line">[10548.672953] [&lt;800f25a4&gt;] SyS_stat64+0x18/0x3c</span><br><span class="line">[10550.256996] [&lt;800250b4&gt;] stack_done+0x20/0x44</span><br><span class="line">[10551.912049]</span><br><span class="line">[10552.654893] 1 lock held by ps/26540:</span><br><span class="line">[10553.986958]  #0:  (&amp;sb-&gt;s_type-&gt;i_mutex_key)&#123;+.+.+.&#125;, at: [&lt;800f7c84&gt;] lookup_slow+0x44/0xd4</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>Detecting hung tasks in Linux</p>
</blockquote>
<blockquote>
<p>Sometimes tasks under Linux are blocked forever (essentially hung). Recent Linux kernels have an infrastructure to detect hung tasks. When this infrastructure is active it will periodically get activated to find out hung tasks and present a stack dump of those hung tasks (and maybe locks held). Additionally we can choose to panic the system when we detect atleast one hung task in the system. I will try to explain how khungtaskd works.</p>
</blockquote>
<blockquote>
<p>The infrastructure is based on a single kernel thread named as “khungtaskd”. So if you do a ps in your system and see that there is entry like [khungtaskd] you know it is there. I have one in my system: “136 root SW [khungtaskd]”</p>
</blockquote>
<blockquote>
<p>The loop of the khungtaskd daemon is a call to the scheduler for waking it up after ever 120 seconds (default value). The core algorithm is like this:</p>
</blockquote>
<blockquote>
<ol>
<li>Iterate over all the tasks in the system which are marked as <code>TASK_UNINTERRUPTIBLE</code> (additionally it does not consider UNINTERRUPTIBLE frozen tasks &amp; UNINTERRUPTIBLE tasks that are newly created and never been scheduled out).</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>If a task has not been switched out by the scheduler atleast once in the last 120 seconds it is considered as a hung task and its stack dump is displayed. If CONFIG_LOCKDEP is defined then it will also show all the locks the hung task is holding.</li>
</ol>
</blockquote>
<blockquote>
<p>One can change the sampling interval of khungtaskd through the sysctl interface <code>/proc/sys/kernel/hung_task_timeout_secs</code>.</p>
</blockquote>
<p>该现象是内核的保护机制造成, D状态即无法中断的休眠进程，是由于在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应.</p>
<p>检测每一个进程控制块；当进程处于TASK_UNINTERRUPTIBLE状态时，调用check_hung_task；<br>内核通过khungtaskd线程在<code>hung_task_timeout_secs</code>时间内唤醒，并检测每一个进程控制块，判断该进程是否挂起(TASK_UNINTERRUPTIBLE),如果存在挂起的任务，将调用<code>check_hung_task</code>。</p>
<h2 id="错误日志输出原因："><a href="#错误日志输出原因：" class="headerlink" title="错误日志输出原因："></a>错误日志输出原因：</h2><p>通过栈的dump信息，可以得到出错的主要原因是由于<code>SyS_stat64</code>系统调用引起。在C语言库里的函数是stat, fstat, lstat. 获取文件的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$man stat64</span><br><span class="line">NAME</span><br><span class="line">       stat, fstat, lstat - get file status</span><br><span class="line">DESCRIPTION</span><br><span class="line">       These  functions  return  information about a file.  No permissions are required on the file itself, but—in the case of stat() and lstat() — execute (search) permission is required on all of the  directories  in  path  that lead to the file.</span><br></pre></td></tr></table></figure>
<h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ul>
<li>IO阻塞</li>
<li>内核模块出错</li>
</ul>
<h2 id="amdgpu"><a href="#amdgpu" class="headerlink" title="amdgpu"></a>amdgpu</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23:02:20 localhost.localdomain kernel: amdgpu 0001:01:00.0: GPU fault detected: 146 0x0080442c</span><br><span class="line">23:02:20 localhost.localdomain kernel: amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101A10</span><br><span class="line">23:02:20 localhost.localdomain kernel: amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0804402C</span><br><span class="line">23:02:20 localhost.localdomain kernel: amdgpu 0001:01:00.0: VM fault (0x2c, vmid 4) at page 1055248, read from &apos;TC1&apos; (0x54433100) (68)</span><br><span class="line">23:02:34 localhost.localdomain kernel: amdgpu 0001:01:00.0: GPU fault detected: 146 0x00183d0c</span><br><span class="line">23:02:34 localhost.localdomain kernel: amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101A03</span><br><span class="line">23:02:34 localhost.localdomain kernel: amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0A03D00C</span><br><span class="line">23:02:34 localhost.localdomain kernel: amdgpu 0001:01:00.0: VM fault (0x0c, vmid 5) at page 1055235, read from &apos;SDM1&apos; (0x53444d31) (61)</span><br><span class="line">23:05:11 localhost.localdomain kernel: INFO: task qemu-system-aar:8361 blocked for more than 120 seconds.</span><br><span class="line">23:05:11 localhost.localdomain kernel:       Tainted: G        W      ------------   4.14.0-115.10.1.el7a.aarch64 #1</span><br><span class="line">23:05:11 localhost.localdomain kernel: &quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot; disables this message.</span><br><span class="line">23:05:11 localhost.localdomain kernel: qemu-system-aar D    0  8361  30794 0x00000200</span><br><span class="line">23:05:11 localhost.localdomain kernel: Call trace:</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000008085eb4&gt;] __switch_to+0x8c/0xa8</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff00000885f9f0&gt;] __schedule+0x340/0x914</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff00000885fff8&gt;] schedule+0x34/0x8c</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005aac1f8&gt;] amd_sched_entity_push_job+0x98/0x148 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005aacfa4&gt;] amdgpu_job_submit+0x88/0xa4 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005a233ac&gt;] amdgpu_vm_bo_update_mapping.constprop.21+0x2b0/0x354 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005a23b38&gt;] amdgpu_vm_clear_freed+0xc8/0x1d0 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005a0efe8&gt;] amdgpu_gem_va_ioctl+0x400/0x478 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000057b63c4&gt;] drm_ioctl_kernel+0x74/0xd8 [drm]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000057b6710&gt;] drm_ioctl+0x2b4/0x3ec [drm]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000059f0054&gt;] amdgpu_drm_ioctl+0x54/0x90 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000082c2ee8&gt;] do_vfs_ioctl+0xcc/0x8f0</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000082c379c&gt;] SyS_ioctl+0x90/0xa4</span><br><span class="line">23:05:11 localhost.localdomain kernel: Exception stack(0xffff0000379cfec0 to 0xffff0000379d0000)</span><br><span class="line">23:05:11 localhost.localdomain kernel: fec0: 0000000000000014 00000000c0286448 0000fffffb7cfbb0 00000000c0286400</span><br><span class="line">23:05:11 localhost.localdomain kernel: fee0: 00000000c0006400 000000000000000e 0000000000000002 0000000000410000</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff00: 000000000000001d 0000000017a53200 0000000000000289 000000002e6d71d2</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff20: 0000000000000018 000000005d731dca 0021ee150a5f677c 0000e05d5e15bff7</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff40: 0000ffffa16802a8 0000ffffa17660e0 0000000000000a00 0000ffff9c81f000</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff60: 0000fffffb7cfbb0 00000000c0286448 0000000000000014 0000000000000040</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff80: 0000000017a53818 000000001ad84f30 00000000000003e8 0000000017a53858</span><br><span class="line">23:05:11 localhost.localdomain kernel: ffa0: 000000001ad84f10 0000fffffb7cfb50 0000ffffa1655c48 0000fffffb7cfb50</span><br><span class="line">23:05:11 localhost.localdomain kernel: ffc0: 0000ffffa17660ec 0000000080000000 0000000000000014 000000000000001d</span><br><span class="line">23:05:11 localhost.localdomain kernel: ffe0: 0000000000000000 0000000000000000 0000000000000000 0000000000000000</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff00000808392c&gt;] __sys_trace_return+0x0/0x4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep &quot;qemu&quot;</span><br><span class="line">root      8361  9.4  6.8 11088576 4540480 pts/2 Dl+ 11:56  67:19 qemu-system-aarch64 -m 8192 -enable-kvm -machine virt-4.0,accel=kvm,gic-version=3 -cpu host -smp 8,sockets=2,cores=4,threads=1 -append console=ttyAMA0,38400 earlycon=pl011,0x09000000 nosmp drm.debug=0x0 rootwait rootdelay=5 androidboot.selinux=permissive -serial mon:stdio -kernel Image -initrd ramdisk.img -drive index=0,if=none,id=system,file=system.img -device virtio-blk-pci,drive=system -drive index=1,if=none,id=cache,file=cache.img -device virtio-blk-pci,drive=cache -drive index=2,if=none,id=userdata,file=userdata.img -device virtio-blk-pci,drive=userdata -netdev user,id=mynet,hostfwd=tcp::5550-:5555 -device virtio-net-pci,netdev=mynet -device virtio-gpu-pci,id=video0,virgl=on,max_outputs=1 -vnc :3 -device virtio-serial-pci -display gtk,gl=on -device qemu-xhci,id=usb -device usb-kbd -device usb-mouse</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进程状态：<code>Dl+</code></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.chinaunix.net/xmlrpc.php?r=blog/article&amp;uid=25564582&amp;id=5204177" target="_blank" rel="noopener">khungtaskd 检测处于TASK_UNINTERRUPTIBLE状态的进程</a></li>
<li><a href="http://blog.csdn.net/luckyapple1028/article/details/51931210" target="_blank" rel="noopener">Linux内核调试技术——进程D状态死锁检测</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>task</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核同步机制【spin lock】</title>
    <url>/post/62201.html</url>
    <content><![CDATA[<ol>
<li>spinlock的使用场景，为什么使用？</li>
<li>在spinlock控制临界区中，为什么不能睡眠？如果睡眠会产生什么结果？</li>
<li>spinlock的实现和数据结构，在x86、ARM64、MIPS中的实现方式，不同吗？存在什么差异？</li>
<li>在发生抢锁时，spinlock和信号量处理的区别？</li>
</ol>
<a id="more"></a>
<p>内核版本：linux 4.4.93</p>
<h2 id="spin-lock特点"><a href="#spin-lock特点" class="headerlink" title="spin lock特点"></a>spin lock特点</h2><ul>
<li><p><code>spin lock</code>是一种死等的锁机制。当前的执行thread会不断的重新尝试直到获取锁进入临界区。</p>
<blockquote>
<p>当发生访问资源冲突的时候，可以有两个选择：一个是死等，一个是挂起当前进程，调度其他进程执行。</p>
</blockquote>
</li>
<li><p>只允许一个thread进入。semaphore可以允许多个thread进入，spin lock不行，一次只能有一个thread获取锁并进入临界区，其他的thread都是在门口不断的尝试。</p>
</li>
<li><p>执行时间短。</p>
<blockquote>
<p>由于spin lock死等这种特性，因此它使用在那些代码不是非常复杂的临界区（当然也不能太简单，否则使用原子操作或者其他适用简单场景的同步机制就OK了），如果临界区执行时间太长，那么不断在临界区门口“死等”的那些thread是多么的浪费CPU啊（当然，现代CPU的设计都会考虑同步原语的实现，例如ARM提供了WFE和SEV这样的类似指令，避免CPU进入busy loop的悲惨境地）</p>
</blockquote>
</li>
<li><p>可以在中断上下文执行。由于不睡眠，因此spin lock可以在中断上下文中适用。</p>
</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>spin lock，其保护的资源可能来自多个CPU CORE上的<code>进程上下文</code>和<code>中断上下文</code>的中的访问</p>
<ul>
<li>进程上下文包括：用户进程通过系统调用访问，内核线程直接访问，来自workqueue中work function的访问（本质上也是内核线程）。</li>
<li>中断上下文包括：HW interrupt context（中断handler）、软中断上下文（soft<br>irq，当然由于各种原因，该softirq被推迟到softirqd的内核线程中执行的时候就不属于这个场景了，属于进程上下文那个分类了）、timer的callback函数（本质上也是softirq）、tasklet（本质上也是softirq）。</li>
</ul>
<p>先看最简单的单CPU上的进程上下文的访问。如果一个全局的资源被多个进程上下文访问，这时候，内核如何交错执行呢？对于那些没有打开preemptive选项的内核，所有的系统调用都是串行化执行的，因此不存在资源争抢的问题。</p>
<p>如果内核线程也访问这个全局资源呢？本质上内核线程也是进程，类似普通进程，只不过普通进程时而在用户态运行、时而通过系统调用陷入内核执行，而内核线程永远都是在内核态运行，但是，结果是一样的，对于non-preemptive的linux kernel，只要在内核态，就不会发生进程调度<br>因此，这种场景下，共享数据根本不需要保护（没有并发，谈何保护呢）。</p>
<blockquote>
<p>单核CPU中， 如果系统默认关闭抢占时，spin lock不起任何作用，因为不存在真正并发的条件，不需要进行同步。如果打开内核抢占，其同步机制主要时通过关闭抢占实现</p>
</blockquote>
<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>当打开premptive选项后，事情变得复杂了，我们考虑下面的场景：</p>
<ul>
<li>进程A在某个系统调用过程中访问了共享资源R</li>
<li>进程B在某个系统调用过程中也访问了共享资源R</li>
</ul>
<p><strong>1.会不会造成冲突呢？</strong></p>
<p>假设在A访问共享资源R的过程中发生了中断，中断唤醒了沉睡中的，优先级更高的B，在中断返回现场的时候，发生进程切换，B启动执行，并通过系统调用访问了R，如果没有锁保护，则会出现两个thread进入临界区，导致程序执行不正确。</p>
<p><strong>2.使用spin lock：</strong></p>
<p>A在进入临界区之前获取了spin lock，同样的，在A访问共享资源R的过程中发生了中断，中断唤醒了沉睡中的，优先级更高的B，B在访问临界区之前仍然会试图获取spin lock，这时候由于A进程持有spin lock而导致B进程进入了永久的spin……怎么破？linux的kernel很简单，在A进程获取spin    lock的时候，禁止本CPU上的抢占（上面的永久spin的场合仅仅在本CPU的进程抢占本CPU的当前进程这样的场景中发生）。</p>
<p>如果是多核CPU，A和B运行在不同的CPU上，那么情况会简单一些：A进程虽然持有spin lock而导致B进程进入spin状态，不过由于运行在不同的CPU上，A进程会持续执行并会很快释放spin lock，解除B进程的spin状态。</p>
<h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><ul>
<li>运行在CPU0上的进程A在某个系统调用过程中访问了共享资源R</li>
<li>运行在CPU1上的进程B在某个系统调用过程中也访问了共享资源R</li>
<li>外设P的中断handler中也会访问共享资源R</li>
</ul>
<p>在这样的场景下，使用spin lock可以保护访问共享资源R的临界区吗？我们假设CPU0上的进程A持有spin lock进入临界区，这时候，外设P发生了中断事件，并且调度到了CPU1上执行，看起来没有什么问题，执行在CPU1上的handler会稍微等待一会CPU0上的进程A，等它立刻临界区就会释放spin lock的.</p>
<p>但是，如果外设P的中断事件被调度到了CPU0上执行会怎么样？CPU0上的进程A在持有spin lock的状态下被中断上下文抢占，而抢占它的CPU0上的handler在进入临界区之前仍然会试图获取spin lock，悲剧发生了，CPU0上的P外设的中断handler永远的进入spin状态，这时候，CPU1上的进程B也不可避免在试图持有spin lock的时候失败而导致进入spin状态。<br>为了解决这样的问题，linux kernel采用了这样的办法：如果涉及到中断上下文的访问，spin lock需要和禁止本CPU上的中断联合使用。</p>
<p>linux kernel中提供了丰富的bottom half的机制，虽然同属中断上下文，不过还是稍有不同。我们可以把上面的场景简单修改一下：外设P不是中断handler中访问共享资源R，而是在的bottom half中访问。使用spin lock+禁止本地中断当然是可以达到保护共享资源的效果，但是使用牛刀来杀鸡似乎有点小题大做，这时候disable bottom half就OK了。</p>
<p>最后，我们讨论一下中断上下文之间的竞争。同一种中断handler之间在uni core和multi core上都不会并行执行，这是linux kernel的特性。如果不同中断handler需要使用spin lock保护共享资源，对于新的内核（不区分fast handler和slow handler），所有handler都是关闭中断的，因此使用spin lock不需要关闭中断的配合。<br>bottom half又分成softirq和tasklet，同一种softirq会在不同的CPU上并发执行，因此如果某个驱动中的sofirq的handler中会访问某个全局变量，对该全局变量是需要使用spin lock保护的，不用配合disable CPU中断或者bottom half。<br>tasklet更简单，因为同一种tasklet不会多个CPU上并发，具体我就不分析了，大家自行思考吧。</p>
<h2 id="通用代码结构"><a href="#通用代码结构" class="headerlink" title="通用代码结构"></a>通用代码结构</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line">    <span class="keyword">arch_spinlock_t</span> raw_lock;</span><br><span class="line">&#125; <span class="keyword">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/spinlock_types.h</p>
</blockquote>
<p>通过<code>arch_spinlock_t</code>结构体定义不同arch下spin lock的实现结构。</p>
<h3 id="接口API"><a href="#接口API" class="headerlink" title="接口API"></a>接口API</h3><table>
<thead>
<tr>
<th style="text-align:center">接口类型</th>
<th style="text-align:center">spinlock定义</th>
<th style="text-align:center">raw_spinlock的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义spin lock并初始化</td>
<td style="text-align:center">DEFINE_SPINLOCK</td>
<td style="text-align:center">DEFINE_RAW_SPINLOCK</td>
</tr>
<tr>
<td style="text-align:center">动态初始化spin lock</td>
<td style="text-align:center">spin_lock_init</td>
<td style="text-align:center">raw_spin_lock_init</td>
</tr>
<tr>
<td style="text-align:center">获取指定的spin lock</td>
<td style="text-align:center">spin_lock</td>
<td style="text-align:center">raw_spin_lock</td>
</tr>
<tr>
<td style="text-align:center">获取指定的spin lock同时disable本CPU中断</td>
<td style="text-align:center">spin_lock_irq</td>
<td style="text-align:center">raw_spin_lock_irq</td>
</tr>
<tr>
<td style="text-align:center">保存本CPU当前的irq状态, disable本CPU中断并获取指定的spin lock</td>
<td style="text-align:center">spin_lock_irqsave</td>
<td style="text-align:center">raw_spin_lock_irqsave</td>
</tr>
<tr>
<td style="text-align:center">获取指定的spin lock同时disable本CPU的bottom half</td>
<td style="text-align:center">spin_lock_bh</td>
<td style="text-align:center">raw_spin_lock_bh</td>
</tr>
<tr>
<td style="text-align:center">释放指定的spin lock</td>
<td style="text-align:center">spin_unlock</td>
<td style="text-align:center">raw_spin_unlock</td>
</tr>
<tr>
<td style="text-align:center">释放指定的spin lock同时enable本CPU中断</td>
<td style="text-align:center">spin_unlock_irq</td>
<td style="text-align:center">raw_spin_unock_irq</td>
</tr>
<tr>
<td style="text-align:center">释放指定的spin lock同时恢复本CPU的中断状态</td>
<td style="text-align:center">spin_unlock_irqstore</td>
<td style="text-align:center">raw_spin_unlock_irqstore</td>
</tr>
<tr>
<td style="text-align:center">获取指定的spin lock同时enable本CPU的bottom half</td>
<td style="text-align:center">spin_unlock_bh</td>
<td style="text-align:center">raw_spin_unlock_bh</td>
</tr>
<tr>
<td style="text-align:center">尝试去获取spin lock，如果失败，不会spin，而是返回非零值</td>
<td style="text-align:center">spin_trylock</td>
<td style="text-align:center">raw_spin_trylock</td>
</tr>
<tr>
<td style="text-align:center">判断spin lock是否是locked, 如果其他的thread已经获取了该lock, 那么返回非零值，否则返回0</td>
<td style="text-align:center">spin_is_locked</td>
<td style="text-align:center">raw_spin_is_locked</td>
</tr>
</tbody>
</table>
<h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>spin lock:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spin_lock()</span><br><span class="line">	\-&gt;raw_spin_lock()</span><br><span class="line">		\-&gt;__raw_spin_lock</span><br><span class="line">			&#123;</span><br><span class="line">				preempt_disable(); //关闭内核抢占</span><br><span class="line">				spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_); //获取锁</span><br><span class="line">				LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);//上锁</span><br><span class="line">			&#125;</span><br><span class="line">			-----------------------------  arch</span><br><span class="line">			-&gt; arch_spin_lock()</span><br><span class="line">			-&gt; arch_spin_trylock()</span><br></pre></td></tr></table></figure></p>
<h2 id="MIPS架构的实现"><a href="#MIPS架构的实现" class="headerlink" title="MIPS架构的实现"></a>MIPS架构的实现</h2><h3 id="arch-spinlock-t"><a href="#arch-spinlock-t" class="headerlink" title="arch_spinlock_t"></a>arch_spinlock_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * bits  0..15 : serving_now</span></span><br><span class="line"><span class="comment">	 * bits 16..31 : ticket</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BIG_ENDIAN</span></span><br><span class="line">		u16 ticket;</span><br><span class="line">		u16 serving_now;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		u16 serving_now;</span><br><span class="line">		u16 ticket;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125; h;</span><br><span class="line">&#125; <span class="keyword">arch_spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/include/asm/spinlock_types.h</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="arch-spin-lock"><a href="#arch-spin-lock" class="headerlink" title="arch_spin_lock"></a>arch_spin_lock</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_spin_lock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_ticket;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> inc = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">     __asm__ __volatile__ (</span><br><span class="line">		<span class="string">"   .set push       # arch_spin_lock    \n"</span></span><br><span class="line"> 		<span class="string">"   .set noreorder                  \n"</span></span><br><span class="line"> 		<span class="string">"                           \n"</span></span><br><span class="line"> 		<span class="string">"1: ll  %[ticket], %[ticket_ptr]        \n"</span></span><br><span class="line"> 		<span class="string">"   addu    %[my_ticket], %[ticket], %[inc]     \n"</span></span><br><span class="line"> 		<span class="string">"   sc  %[my_ticket], %[ticket_ptr]     \n"</span></span><br><span class="line"> 		<span class="string">"   beqz    %[my_ticket], 1b            \n"</span></span><br><span class="line"> 		<span class="string">"    srl    %[my_ticket], %[ticket], 16     \n"</span></span><br><span class="line"> 		<span class="string">"   andi    %[ticket], %[ticket], 0xffff        \n"</span></span><br><span class="line"> 		<span class="string">"   bne %[ticket], %[my_ticket], 4f     \n"</span></span><br><span class="line"> 		<span class="string">"    subu   %[ticket], %[my_ticket], %[ticket]  \n"</span></span><br><span class="line"> 		<span class="string">"2: .insn                       \n"</span></span><br><span class="line"> 		<span class="string">"   .subsection 2                   \n"</span></span><br><span class="line"> 		<span class="string">"4: andi    %[ticket], %[ticket], 0xffff        \n"</span></span><br><span class="line"> 		<span class="string">"   sll %[ticket], 5                \n"</span></span><br><span class="line"> 		<span class="string">"                           \n"</span></span><br><span class="line"> 		<span class="string">"6: bnez    %[ticket], 6b               \n"</span></span><br><span class="line"> 		<span class="string">"    subu   %[ticket], 1                \n"</span></span><br><span class="line"> 		<span class="string">"                           \n"</span></span><br><span class="line"> 		<span class="string">"   lhu %[ticket], %[serving_now_ptr]       \n"</span></span><br><span class="line"> 		<span class="string">"   beq %[ticket], %[my_ticket], 2b     \n"</span></span><br><span class="line"> 		<span class="string">"    subu   %[ticket], %[my_ticket], %[ticket]  \n"</span></span><br><span class="line"> 		<span class="string">"   b   4b                  \n"</span></span><br><span class="line"> 		<span class="string">"    subu   %[ticket], %[ticket], 1         \n"</span></span><br><span class="line"> 		<span class="string">"   .previous                   \n"</span></span><br><span class="line"> 		<span class="string">"   .set pop                    \n"</span></span><br><span class="line"> 		: [ticket_ptr] <span class="string">"+"</span> GCC_OFF_SMALL_ASM() (lock-&gt;lock),</span><br><span class="line"> 		  [serving_now_ptr] <span class="string">"+m"</span> (lock-&gt;h.serving_now),</span><br><span class="line"> 		  [ticket] <span class="string">"=&amp;r"</span> (tmp),</span><br><span class="line"> 		  [my_ticket] <span class="string">"=&amp;r"</span> (my_ticket)</span><br><span class="line"> 		: [inc] <span class="string">"r"</span> (inc));</span><br><span class="line"></span><br><span class="line">    smp_llsc_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/include/asm/spinlock.h</p>
</blockquote>
<p><strong>算法：<a href="/downloads/kernel/spinlock/mcs.pdf">Ticket lock: A fair lock</a></strong></p>
<h4 id="arch-spin-trylock"><a href="#arch-spin-trylock" class="headerlink" title="arch_spin_trylock"></a>arch_spin_trylock</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">arch_spin_trylock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp, tmp2, tmp3;</span><br><span class="line">    <span class="keyword">int</span> inc = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">		<span class="string">"   .set push       # arch_spin_trylock \n"</span></span><br><span class="line">		<span class="string">"   .set noreorder                  \n"</span></span><br><span class="line">		<span class="string">"                           \n"</span></span><br><span class="line">		<span class="string">"1: ll  %[ticket], %[ticket_ptr]        \n"</span></span><br><span class="line">		<span class="string">"   srl %[my_ticket], %[ticket], 16     \n"</span></span><br><span class="line">		<span class="string">"   andi    %[now_serving], %[ticket], 0xffff   \n"</span></span><br><span class="line">		<span class="string">"   bne %[my_ticket], %[now_serving], 3f    \n"</span></span><br><span class="line">		<span class="string">"    addu   %[ticket], %[ticket], %[inc]        \n"</span></span><br><span class="line">		<span class="string">"   sc  %[ticket], %[ticket_ptr]        \n"</span></span><br><span class="line">		<span class="string">"   beqz    %[ticket], 1b               \n"</span></span><br><span class="line">		<span class="string">"    li %[ticket], 1                \n"</span></span><br><span class="line">		<span class="string">"2: .insn                       \n"</span></span><br><span class="line">		<span class="string">"   .subsection 2                   \n"</span></span><br><span class="line">		<span class="string">"3: b   2b                  \n"</span></span><br><span class="line">		<span class="string">"    li %[ticket], 0                \n"</span></span><br><span class="line">		<span class="string">"   .previous                   \n"</span></span><br><span class="line">		<span class="string">"   .set pop                    \n"</span></span><br><span class="line">		: [ticket_ptr] <span class="string">"+"</span> GCC_OFF_SMALL_ASM() (lock-&gt;lock),</span><br><span class="line">		  [ticket] <span class="string">"=&amp;r"</span> (tmp),</span><br><span class="line">		  [my_ticket] <span class="string">"=&amp;r"</span> (tmp2),</span><br><span class="line">		  [now_serving] <span class="string">"=&amp;r"</span> (tmp3)</span><br><span class="line">		: [inc] <span class="string">"r"</span> (inc));</span><br><span class="line"></span><br><span class="line">     smp_llsc_mb();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> tmp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/include/asm/spinlock.h</p>
</blockquote>
<h4 id="反汇编arch-spin-lock"><a href="#反汇编arch-spin-lock" class="headerlink" title="反汇编arch_spin_lock"></a>反汇编arch_spin_lock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;lg_local_lock&gt;:</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   3c030001    lui v1,0x1</span><br><span class="line">   c0440000    ll  a0,0(v0)</span><br><span class="line">   00832821    addu    a1,a0,v1</span><br><span class="line">   e0450000    sc  a1,0(v0)</span><br><span class="line">   10a0fffc    beqz    a1,80071228 &lt;lg_local_lock+0x40&gt;</span><br><span class="line">   00042c02    srl a1,a0,0x10</span><br><span class="line">   14850120    bne a0,a1,800716c4 &lt;lg_double_unlock+0x88&gt;</span><br><span class="line">   00a42023    subu    a0,a1,a0</span><br><span class="line"></span><br><span class="line">   0000000f    sync			//smp_llsc_mb();</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指令：ll和sc</p>
<blockquote>
<p>ll: 指令的功能是从内存中读取一个字，以实现接下来的 RMW（Read-Modify-Write） 操作</p>
</blockquote>
<blockquote>
<p>sc: 指令的功能是向内存中写入一个字，以完成前面的 RMW 操作</p>
</blockquote>
</blockquote>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="为什么要关闭抢占？"><a href="#为什么要关闭抢占？" class="headerlink" title="为什么要关闭抢占？"></a>为什么要关闭抢占？</h3><p>如果不禁止内核抢断(或者不禁止中断)，可能会有以下的情况发生（假设进程B比进程A具有更高的优先级）：</p>
<ul>
<li>进程A获得spinlock lock</li>
<li>进程B运行(抢占进程A)</li>
<li>进程B获取spinlock lock</li>
</ul>
<p>由于进程B比进程A优先级高，所以进程B在进程A之前运行，而进程B需要进程A释放lock之后才能运行，于是，死锁</p>
<h3 id="为什么不能睡眠？"><a href="#为什么不能睡眠？" class="headerlink" title="为什么不能睡眠？"></a>为什么不能睡眠？</h3><p>spinlock中的代码不能有睡眠（schedule()之类的放弃CPU的代码），因为此时内核抢占已经关闭，如果让出CPU正好调度到的另一个进程也需要这个锁，整个系统将形成死锁。</p>
<h3 id="spinlock阶段，来中断？"><a href="#spinlock阶段，来中断？" class="headerlink" title="spinlock阶段，来中断？"></a>spinlock阶段，来中断？</h3><ol>
<li>进程A获取spinlcok锁，访问资源R</li>
<li>中断响应后，在中断处理程序中，也去获取spinlock锁，并访问资源R</li>
</ol>
<p>如果在进程A没有释放spinlock锁时，如果触发中断后，进程A和中断怎么处理？？</p>
<blockquote>
<p>此时不能使用spin_lock,应该使用spin_lock_irq</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.wowotech.net/kernel_synchronization/spinlock.html" target="_blank" rel="noopener">Linux内核同步机制之（四）：spin lock</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-spinlock_mips/index.html" target="_blank" rel="noopener">Linux 的 Spinlock 在 MIPS 多核处理器中的设计与实现</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
        <category>同步</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>spinlock</tag>
      </tags>
  </entry>
  <entry>
    <title>EDID</title>
    <url>/post/47714.html</url>
    <content><![CDATA[<blockquote>
<p>环境： ubuntu 18.04</p>
</blockquote>
<p>EDID: <a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data" target="_blank" rel="noopener">Extended Display Identification Data</a></p>
<p>edid读取工具： get-edid</p>
<p>EDID的大小：<code>VGA/DVI</code>=128Byte; <code>HDMI</code>=256Byte</p>
<a id="more"></a>
<h2 id="get-edid"><a href="#get-edid" class="headerlink" title="get-edid"></a>get-edid</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install read-edid edid-decode</span><br></pre></td></tr></table></figure>
<h2 id="获取EDID原始数据并存储到文件"><a href="#获取EDID原始数据并存储到文件" class="headerlink" title="获取EDID原始数据并存储到文件"></a>获取EDID原始数据并存储到文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo get-edid &gt; edid.bin</span><br></pre></td></tr></table></figure>
<h2 id="解析edid"><a href="#解析edid" class="headerlink" title="解析edid"></a>解析edid</h2><h3 id="在线解析"><a href="#在线解析" class="headerlink" title="在线解析"></a>在线解析</h3><blockquote>
<p>在<a href="http://www.edidreader.com/" target="_blank" rel="noopener">http://www.edidreader.com/</a>网站可以对该数据进行在线解析。把以上128字节复制到该网站的对应数据窗口</p>
</blockquote>
<h3 id="本地解析"><a href="#本地解析" class="headerlink" title="本地解析"></a>本地解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parse-edid &lt; edid.bin</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$parse-edid &lt; edid.bin</span><br><span class="line">Checksum Correct</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">	Identifier &quot;PHL 237E7&quot;</span><br><span class="line">	ModelName &quot;PHL 237E7&quot;</span><br><span class="line">	VendorName &quot;PHL&quot;</span><br><span class="line">	# Monitor Manufactured week 24 of 2016</span><br><span class="line">	# EDID version 1.3</span><br><span class="line">	# Analog Display</span><br><span class="line">	Option &quot;SyncOnGreen&quot; &quot;true&quot;</span><br><span class="line">	DisplaySize 510 290</span><br><span class="line">	Gamma 2.20</span><br><span class="line">	Option &quot;DPMS&quot; &quot;true&quot;</span><br><span class="line">	Horizsync 30-83</span><br><span class="line">	VertRefresh 56-76</span><br><span class="line">	# Maximum pixel clock is 170MHz</span><br><span class="line">	#Not giving standard mode: 1920x1080, 60Hz</span><br><span class="line">	#Not giving standard mode: 1440x900, 60Hz</span><br><span class="line">	#Not giving standard mode: 1440x900, 75Hz</span><br><span class="line">	#Not giving standard mode: 1680x1050, 60Hz</span><br><span class="line">	#Not giving standard mode: 1280x720, 60Hz</span><br><span class="line">	#Not giving standard mode: 1280x1024, 60Hz</span><br><span class="line">	#Not giving standard mode: 1280x960, 60Hz</span><br><span class="line">	Modeline 	&quot;Mode 0&quot; 148.50 1920 2008 2052 2200 1080 1084 1089 1125 +hsync +vsync</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># the integer after -m is the monitor id, starting from zero and incrementing by one.</span><br><span class="line">sudo get-edid -m 0 &gt; edid.bin</span><br><span class="line"></span><br><span class="line"># View the output of this command and verify you have the right monitor.</span><br><span class="line"># You can tell via the vendor, resolutions, serial number, all that jazz.</span><br><span class="line">cat edid.bin | edid-decode</span><br></pre></td></tr></table></figure>
<h3 id="Window：-EDID-Manager"><a href="#Window：-EDID-Manager" class="headerlink" title="Window： EDID Manager"></a>Window： EDID Manager</h3><p>下载：<a href="https://pan.baidu.com/s/11VxNBrbvu4-4daB7R7huEw" target="_blank" rel="noopener">EDID Manager</a></p>
<h3 id="Window：-EDID编辑"><a href="#Window：-EDID编辑" class="headerlink" title="Window： EDID编辑"></a>Window： EDID编辑</h3><p>下载：<a href="https://pan.baidu.com/s/1EynJUGQ-FHp_ByvY5Vhpyw" target="_blank" rel="noopener">Phoenix EDID Designer</a></p>
<h2 id="示例：-Lenovo-1600x900"><a href="#示例：-Lenovo-1600x900" class="headerlink" title="示例： Lenovo 1600x900"></a>示例： Lenovo 1600x900</h2><blockquote>
<p>视频输出接口： <code>VGA</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000: 003f 3f3f 3f3f 3f00 303f 3f65 0101 0101  .??????.0??e....</span><br><span class="line">00000010: 071a 0103 6c2c 1978 2e2c c5a4 5650 3f28  ....l,.x.,..VP?(</span><br><span class="line">00000020: 0f50 543f 3f00 714f 3f3f 3f3f 3fc0 a9cf  .PT??.qO?????...</span><br><span class="line">00000030: 9500 0101 0101 302a 403f 603f 6430 1850  ......0*@?`?d0.P</span><br><span class="line">00000040: 1300 3f3f 1000 001e 0000 003f 0055 3041  ..??.......?.U0A</span><br><span class="line">00000050: 595a 3834 300a 2020 2020 0000 003f 0032  YZ840.    ...?.2</span><br><span class="line">00000060: 4b1e 5315 000a 2020 2020 2020 0000 003f  K.S...      ...?</span><br><span class="line">00000070: 004c 454e 204c 5332 3033 3377 480a 0049  .LEN LS2033wH..I</span><br><span class="line">00000080: 0a                                       .</span><br></pre></td></tr></table></figure>
<blockquote>
<p>EDID： 128-byte EDID successfully retrieved from i2c bus 0</p>
</blockquote>
<h3 id="解析：Edid-Manager"><a href="#解析：Edid-Manager" class="headerlink" title="解析：Edid Manager"></a>解析：Edid Manager</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">			Time: 11:22:16</span><br><span class="line">			Date: 2018年9月13日</span><br><span class="line">			EDID Manager Version: 1.0.0.14</span><br><span class="line">	___________________________________________________________________</span><br><span class="line"></span><br><span class="line">	Block 0 (EDID Base Block), Bytes 0 - 127,  128  BYTES OF EDID CODE:</span><br><span class="line"></span><br><span class="line">		        0   1   2   3   4   5   6   7   8   9</span><br><span class="line">		000  |  00  FF  FF  FF  FF  FF  FF  00  30  AE</span><br><span class="line">		010  |  A9  65  01  01  01  01  07  1A  01  03</span><br><span class="line">		020  |  6C  2C  19  78  2E  2C  C5  A4  56  50</span><br><span class="line">		030  |  A1  28  0F  50  54  AF  EF  00  71  4F</span><br><span class="line">		040  |  81  80  81  8A  A9  C0  A9  CF  95  00</span><br><span class="line">		050  |  01  01  01  01  30  2A  40  C8  60  84</span><br><span class="line">		060  |  64  30  18  50  13  00  B0  F0  10  00</span><br><span class="line">		070  |  00  1E  00  00  00  FF  00  55  30  41</span><br><span class="line">		080  |  59  5A  38  34  30  0A  20  20  20  20</span><br><span class="line">		090  |  00  00  00  FD  00  32  4B  1E  53  15</span><br><span class="line">		100  |  00  0A  20  20  20  20  20  20  00  00</span><br><span class="line">		110  |  00  FC  00  4C  45  4E  20  4C  53  32</span><br><span class="line">		120  |  30  33  33  77  48  0A  00  49</span><br><span class="line"></span><br><span class="line">(8-9)    	ID Manufacture Name : LEN</span><br><span class="line">(10-11)  	ID Product Code     : 65A9</span><br><span class="line">(12-15)  	ID Serial Number    : N/A</span><br><span class="line">(16)     	Week of Manufacture : 7</span><br><span class="line">(17)     	Year of Manufacture : 2016</span><br><span class="line"></span><br><span class="line">(18)     	EDID Version Number : 1</span><br><span class="line">(19)     	EDID Revision Number: 3</span><br><span class="line"></span><br><span class="line">(20)     	Video Input Definition: Analog</span><br><span class="line">			0.700, 0.000 (0.700 V p-p)</span><br><span class="line">			Separate SyncsComposite Syncs</span><br><span class="line"></span><br><span class="line">(21)     	Maximum Horizontal Image Size: 44 cm</span><br><span class="line">(22)     	Maximum Vertical Image Size  : 25 cm</span><br><span class="line">(23)     	Display Gamma                : 2.20</span><br><span class="line">(24)     	Power Management and Supported Feature(s):</span><br><span class="line">			Active Off/Very Low Power, RGB Color, sRGB, Preferred Timing Mode</span><br><span class="line"></span><br><span class="line">(25-34)  	Color Characteristics</span><br><span class="line">			Red Chromaticity   :  Rx = 0.641  Ry = 0.338</span><br><span class="line">			Green Chromaticity :  Gx = 0.315  Gy = 0.625</span><br><span class="line">			Blue Chromaticity  :  Bx = 0.159  By = 0.055</span><br><span class="line">			Default White Point:  Wx = 0.313  Wy = 0.329</span><br><span class="line"></span><br><span class="line">(35)     	Established Timings I</span><br><span class="line"></span><br><span class="line">			720 x 400 @ 70Hz (IBM, VGA)</span><br><span class="line">			640 x 480 @ 60Hz (IBM, VGA)</span><br><span class="line">			640 x 480 @ 72Hz (VESA)</span><br><span class="line">			640 x 480 @ 75Hz (VESA)</span><br><span class="line">			800 x 600 @ 56Hz (VESA)</span><br><span class="line">			800 x 600 @ 60Hz (VESA)</span><br><span class="line"></span><br><span class="line">(36)     	Established Timings II</span><br><span class="line"></span><br><span class="line">			800 x 600 @ 72Hz (VESA)</span><br><span class="line">			800 x 600 @ 75Hz (VESA)</span><br><span class="line">			832 x 624 @ 75Hz (Apple, Mac II)</span><br><span class="line">			1024 x 768 @ 60Hz (VESA)</span><br><span class="line">			1024 x 768 @ 70Hz(VESA)</span><br><span class="line">			1024 x 768 @ 75Hz (VESA)</span><br><span class="line">			1280 x 1024 @ 75Hz (VESA)</span><br><span class="line"></span><br><span class="line">(37)     	Manufacturer&apos;s Timings (Not Used)</span><br><span class="line"></span><br><span class="line">(38-53)  	Standard Timings</span><br><span class="line"></span><br><span class="line">			1152x864 @ 75 Hz (4:3 Aspect Ratio)</span><br><span class="line">			1280x1024 @ 60 Hz (5:4 Aspect Ratio)</span><br><span class="line">			1280x1024 @ 70 Hz (5:4 Aspect Ratio)</span><br><span class="line">			1600x900 @ 60 Hz (16:9 Aspect Ratio)</span><br><span class="line">			1600x900 @ 75 Hz (16:9 Aspect Ratio)</span><br><span class="line">			1440x900 @ 60 Hz (16:10 Aspect Ratio)</span><br><span class="line"></span><br><span class="line">(54-71)  	Detailed Descriptor #1: Preferred Detailed Timing (1600x900 @ 60Hz)</span><br><span class="line"></span><br><span class="line">			Pixel Clock            : 108 MHz</span><br><span class="line">			Horizontal Image Size  : 432 mm</span><br><span class="line">			Vertical Image Size    : 240 mm</span><br><span class="line">			Refresh Mode           : Non-interlaced</span><br><span class="line">			Normal Display, No Stereo</span><br><span class="line"></span><br><span class="line">			Horizontal:</span><br><span class="line">				Active Time     : 1600 Pixels</span><br><span class="line">				Blanking Time   : 200 Pixels</span><br><span class="line">				Sync Offset     : 24 Pixels</span><br><span class="line">				Sync Pulse Width: 80 Pixels</span><br><span class="line">				Border          : 0 Pixels</span><br><span class="line">				Frequency       : 60 kHz</span><br><span class="line"></span><br><span class="line">			Vertical:</span><br><span class="line">				Active Time     : 900 Lines</span><br><span class="line">				Blanking Time   : 100 Lines</span><br><span class="line">				Sync Offset     : 1 Lines</span><br><span class="line">				Sync Pulse Width: 3 Lines</span><br><span class="line">				Border          : 0 Lines</span><br><span class="line"></span><br><span class="line">			Digital Separate, Horizontal Polarity (+), Vertical Polarity (+)</span><br><span class="line"></span><br><span class="line">			Modeline: &quot;1600x900&quot; 108.000 1600 1624 1704 1800 900 901 904 1000 +hsync +vsync</span><br><span class="line"></span><br><span class="line">(72-89)  	Detailed Descriptor #2: Monitor Serial Number</span><br><span class="line"></span><br><span class="line">			Monitor Serial Number: U0AYZ840</span><br><span class="line"></span><br><span class="line">(90-107) 	Detailed Descriptor #3: Monitor Range Limits</span><br><span class="line"></span><br><span class="line">			Horizontal Scan Range: 30kHz-83kHz</span><br><span class="line">			Vertical Scan Range  : 50Hz-75Hz</span><br><span class="line">			Supported Pixel Clock: 210 MHz</span><br><span class="line">			Secondary GTF        : Not Supported</span><br><span class="line"></span><br><span class="line">(108-125)	Detailed Descriptor #4: Monitor Name</span><br><span class="line"></span><br><span class="line">			Monitor Name: LEN LS2033wH</span><br><span class="line"></span><br><span class="line">(126-127)	Extension Flag and Checksum</span><br><span class="line"></span><br><span class="line">			Extension Block(s)  : 0</span><br><span class="line">			Checksum Value      : 73</span><br><span class="line"></span><br><span class="line">	___________________________________________________________________</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Horizontal</code>: 水平方向</li>
<li><code>Vertical</code>： 垂直方向</li>
<li><code>Active Time</code>： 有效区域</li>
<li><code>Blanking Time</code>： 空白区域（包括上部和底部，或者是左边和右边的和）</li>
</ul>
<h3 id="Pixel-Clock"><a href="#Pixel-Clock" class="headerlink" title="Pixel Clock"></a>Pixel Clock</h3><p>Pixel clock：像素时脉(Pixel clock)指的是用来划分进来的影像水平线里的个别画素，Pixel clock会将每一条水平线分成取样的样本，越高频率的Pixel clock，每条扫瞄线会有越多的样本画素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pixclock = 1/dotclock</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dotclock是视频硬件在显示器上绘制像素的速率</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dotclock = Htotal × Vtotal × framerate</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Htotal</code>: 水平方向上的所有像素点，（Active Time + Blanking Time）</li>
<li><code>Vtotal</code>: 垂直方向上的所有像素点，（Active Time + Blanking Time）</li>
<li><code>framerate</code>: 帧数</li>
</ul>
<h4 id="示例中的Pixel-Clock"><a href="#示例中的Pixel-Clock" class="headerlink" title="示例中的Pixel Clock"></a>示例中的Pixel Clock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pixel Clock = 60 x (1600 + 200) x (900 + 100) = 108000000Hz = 108Mhz</span><br></pre></td></tr></table></figure>
<h2 id="扩展EDID-E-EDID"><a href="#扩展EDID-E-EDID" class="headerlink" title="扩展EDID - E-EDID"></a>扩展EDID - E-EDID</h2><blockquote>
<p>大小<code>256Byte</code>， 追加一个128Byte的block， 在Block0中的 <code>Extension Block(s)  : 1</code></p>
</blockquote>
<p><img src="/images/2019/03/edid_cea_version3.png" alt="edid_CEA_version3"></p>
<h3 id="数据块-–-index-4"><a href="#数据块-–-index-4" class="headerlink" title="数据块 – index=4"></a>数据块 – index=4</h3><p>在EDID的扩展块中，第四个字节开始，后的数据块是可变长的部分。</p>
<p><img src="/images/2019/03/edid_cea_data_block.png" alt="edid_CEA_data_block"></p>
<ul>
<li>子数据块头部格式：</li>
</ul>
<p><img src="/images/2019/03/edid_cea_data_block_head.png" alt="EDID_CEA_data_block_head"></p>
<ul>
<li>数据标签</li>
</ul>
<p><img src="/images/2019/03/edid_cea_data_block_head_tag.png" alt="EDID_CEA_data_block_head_tag"></p>
<h4 id="Video-Data-Block"><a href="#Video-Data-Block" class="headerlink" title="Video Data Block"></a>Video Data Block</h4><p>主要存储SVD（Short Video Description）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Video Data Block</span><br><span class="line"></span><br><span class="line">640x480p @ 59.94/60Hz - EDTV (4:3, 1:1)</span><br><span class="line">720x480p @ 59.94/60Hz - EDTV (16:9, 32:27)</span><br><span class="line">1280x720p @ 59.94/60Hz - HDTV (16:9, 1:1) [Native]</span><br></pre></td></tr></table></figure>
<h4 id="Audio-Data-Block"><a href="#Audio-Data-Block" class="headerlink" title="Audio Data Block"></a>Audio Data Block</h4><p>进行短音频描述（short audio description）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Audio Data Block</span><br><span class="line"></span><br><span class="line">Audio Format #1    : LPCM, 2-Channel, 24-Bit, 20-Bit, 16-Bit</span><br><span class="line">Sampling Frequency : 48 kHz, 44.1 kHz, 32 kHz</span><br><span class="line"></span><br><span class="line">Audio Format #2    : AC-3, 2-Channel, 640 k Max bit rate</span><br><span class="line">Sampling Frequency : 96 kHz, 48 kHz, 44.1 kHz, 32 kHz</span><br></pre></td></tr></table></figure>
<h4 id="Speaker-Allocation-Data-Block-–-SADB"><a href="#Speaker-Allocation-Data-Block-–-SADB" class="headerlink" title="Speaker Allocation Data Block – SADB"></a>Speaker Allocation Data Block – SADB</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Speaker Allocation Data Block (SADB)</span><br><span class="line"></span><br><span class="line">Front Left/Front Right Audio Channel (FL/FR)</span><br></pre></td></tr></table></figure>
<h4 id="Vendor-Specific-Data-Block-–-VSDB"><a href="#Vendor-Specific-Data-Block-–-VSDB" class="headerlink" title="Vendor Specific Data Block – VSDB"></a>Vendor Specific Data Block – VSDB</h4><p><img src="/images/2019/03/edid_cea_vasb.png" alt="EDID_CEA_VASB"></p>
<p>供应商指定的特定数据块，其中可以标识出数据接口是HDMI还是DVI接口。</p>
<p>HDMI的源端可以检查是否为合理的HDMI VSDB，然后包含有IEEE Registration Identifier登记识别符号<code>0x000C03</code>，就可以判断为HDMI装置，而不是DVI装置。</p>
<blockquote>
<p>In order to determine if a sink is an HDMI device, an HDMI Source shall check the E-EDID for the<br>presence of an HDMI Vendor Specific Data Block within the first CEA Extension. Any device with<br>an HDMI VSDB of any valid length, containing the IEEE Registration Identifier of <code>0x000C03</code>, shall<br>be treated as an HDMI device.<br>Any device with an E-EDID that does not contain a CEA Extension or does not contain an HDMI<br>VSDB of any valid length shall be treated by the Source as a DVI device (see Appendix C).</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vendor Specific Data Block (VSDB)</span><br><span class="line"></span><br><span class="line">IEEE Registration Identifier: 0x000C03</span><br><span class="line">CEC Physical Address        : 0x0030</span><br><span class="line">Maximum TMDS Clock          : 165MHz</span><br></pre></td></tr></table></figure>
<h2 id="首选最佳分辨率"><a href="#首选最佳分辨率" class="headerlink" title="首选最佳分辨率"></a>首选最佳分辨率</h2><blockquote>
<p>A.2.10.1 First Detailed Timing Descriptor<br>The VESA E-EDID Standard [10] requires that the First Detailed Timing Descriptor be used for the most<br><code>“preferred”</code> video format and subsequent detailed timing descriptors are listed in order of decreasing<br>preference.</p>
</blockquote>
<blockquote>
<p>All DTDs and SVDs shall be listed in order of priority; meaning that the first is the one that the display<br>manufacturer has identified as optimal.</p>
</blockquote>
<blockquote>
<p>The first 18 Byte Descriptor Block shall contain the preferred timing mode. The display manufacturer<br>defines the “Preferred Timing Mode (PTM)” as the video timing mode that will produce the best quality<br>image on the display’s viewing screen.</p>
</blockquote>
<h2 id="解析工具"><a href="#解析工具" class="headerlink" title="解析工具"></a>解析工具</h2><ul>
<li><a href="https://coding.net/u/Winddoing/p/software_tools/git/raw/master/edid_managerv1x0.zip" target="_blank" rel="noopener">edid_manager</a> — 获取即解析EDID</li>
<li><a href="https://coding.net/u/Winddoing/p/software_tools/git/raw/master/setup_EEditZ-0p96.zip" target="_blank" rel="noopener">EEditZ</a> — 编辑即解析EDID</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://read.pudn.com/downloads222/doc/1046129/CEA861D.pdf" target="_blank" rel="noopener">EDID CEA Standard</a> – 规范</li>
<li><a href="https://engineering.purdue.edu/ece477/Archive/2012/Spring/S12-Grp10/Datasheets/CEC_HDMI_Specification.pdf" target="_blank" rel="noopener">High-Definition Multimedia Interface Specification Version 1.3</a> – VSDB</li>
<li><a href="http://read.pudn.com/downloads110/ebook/456020/E-EDID%20Standard.pdf" target="_blank" rel="noopener">E-EDID Standard</a></li>
<li><a href="https://github.com/bulletmark/edid-rw" target="_blank" rel="noopener">修改显示器EDID工具(源码)</a>)</li>
<li><a href="http://hubpages.com/technology/how-to-reflash-a-monitors-corrupted-edid" target="_blank" rel="noopener">http://hubpages.com/technology/how-to-reflash-a-monitors-corrupted-edid //读取和修改显示器的EDID</a></li>
<li><a href="https://blog.csdn.net/ganshuyu/article/details/38844963" target="_blank" rel="noopener">EDID使用说明</a></li>
<li><a href="https://blog.csdn.net/haoxingheng/article/details/51586070" target="_blank" rel="noopener">EDID标准简介</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>edid</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体之RTSP/RTP/RTCP</title>
    <url>/post/34052.html</url>
    <content><![CDATA[<p><img src="/images/media/media_C_S.jpg" alt="media_c_s"></p>
<blockquote>
<p>用一句简单的话总结：RTSP发起/终结流媒体、RTP传输流媒体数据 、RTCP对RTP进行控制，同步。</p>
</blockquote>
<a id="more"></a>
<p><img src="/images/media/media_protocol.png" alt="流媒体协议"></p>
<ul>
<li><p>RTP：实时传输协议（Real-time Transport Protocol）</p>
<ul>
<li>RTP/RTCP是实际传输数据的协议</li>
<li>RTP传输音频/视频数据，如果是PLAY，Server发送到Client端，如果是RECORD，可以由Client发送到Server</li>
<li>整个RTP协议由两个密切相关的部分组成：RTP数据协议和RTP控制协议（即RTCP）</li>
</ul>
</li>
<li><p>RTSP：实时流协议（Real Time Streaming Protocol，RTSP）</p>
<ul>
<li>RTSP的请求主要有DESCRIBE,SETUP,PLAY,PAUSE,TEARDOWN,OPTIONS等，顾名思义可以知道起对话和控制作用</li>
<li>RTSP的对话过程中SETUP可以确定RTP/RTCP使用的端口，PLAY/PAUSE/TEARDOWN可以开始或者停止RTP的发送，等等</li>
</ul>
</li>
<li><p>RTCP：RTP 控制协议（RTP Control Protocol）</p>
<ul>
<li>RTP/RTCP是实际传输数据的协议</li>
<li>RTCP包括Sender Report和Receiver Report，用来进行音频/视频的同步以及其他用途，是一种控制协议</li>
</ul>
</li>
</ul>
<h2 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h2><p>RTP数据协议负责对流媒体数据进行封包并实现媒体流的实时传输，每一个RTP数据报都由<code>头部（Header）</code>和<code>负载（Payload）</code>两个部分组成，其中头部前<strong><em>12个字节</em></strong>的含义是固定的，而负载则可以是<code>音频</code>或者<code>视频</code>数据。RTP数据报的头部格式如图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|X|   CC  |M|     PT      |      sequence number          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         timestamp                             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           synchronization source (SSRC) identifier            |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|            contributing source (CSRC) identifiers             |</span><br><span class="line">|                            ....                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>从RTP数据报的格式不难看出，它包含了传输媒体的<code>类型</code>、<code>格式</code>、<code>序列号</code>、<code>时间戳</code>以及是否有附加数据等信息，这些都为实时的流媒体传输提供了相应的基础。</p>
<h3 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h3><table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">2</td>
<td style="text-align:center">RTP协议的版本号，当前协议版本号为2。</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">1</td>
<td style="text-align:center">填充标志, 如果P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">1</td>
<td style="text-align:center">扩展标志，如果X=1，则在RTP报头后跟有一个扩展报头。</td>
</tr>
<tr>
<td style="text-align:center">CC</td>
<td style="text-align:center">4</td>
<td style="text-align:center">CSRC计数器， 指示CSRC 标识符的个数。</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">1</td>
<td style="text-align:center">标记，不同的有效载荷有不同的含义，对于<code>视频</code>，标记一帧的结束；对于<code>音频</code>，标记会话的开始。</td>
</tr>
<tr>
<td style="text-align:center">PT</td>
<td style="text-align:center">7</td>
<td style="text-align:center">有效载荷类型，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等。</td>
</tr>
<tr>
<td style="text-align:center">sequence number</td>
<td style="text-align:center">16</td>
<td style="text-align:center">用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。</td>
</tr>
<tr>
<td style="text-align:center">timestamp</td>
<td style="text-align:center">32</td>
<td style="text-align:center">时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。</td>
</tr>
<tr>
<td style="text-align:center">SSRC</td>
<td style="text-align:center">32</td>
<td style="text-align:center">用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。</td>
</tr>
<tr>
<td style="text-align:center">CSRC</td>
<td style="text-align:center">32</td>
<td style="text-align:center">每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源。</td>
</tr>
</tbody>
</table>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>RTP协议的目的是提供实时数据（如交互式的音频和视频）的端到端传输服务，因此在<code>RTP中没有连接的概念</code>，它可以<code>建立在底层的面向连接或面向非连接的传输协议之上</code>；RTP也不依赖于特别的网络地址格式，而仅仅只需要底层传输协议支持组帧（Framing）和分段（Segmentation）就足够了；另外RTP本身还不提供任何可靠性机制，这些都要由传输协议或者应用程序自己来保证。在典型的应用场合下，RTP一般是在传输协议之上作为应用程序的一部分加以实现的，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------------------------+</span><br><span class="line">|                     Application Layer                           |</span><br><span class="line">+-----------------------------------------------------------------+</span><br><span class="line">|                           RTP/RTCP                              |</span><br><span class="line">+--------------------------------+--------------------------------+</span><br><span class="line">|              UDP               |              TCP               |</span><br><span class="line">+--------------------------------+--------------------------------+</span><br><span class="line">|                         IPv4/IPv6                               |</span><br><span class="line">+-----------------------------------------------------------------+</span><br><span class="line">|                          LAN/WAN                                |</span><br><span class="line">+-----------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h2><p>作为一个应用层协议，RTSP提供了一个可供扩展的框架，它的意义在于使得<code>实时流媒体数据的受控和点播变得可能</code>。总的说来，RTSP是一个流媒体表示协议，主要用来控制具有实时特性的数据发送，但它本身并不传输数据，而是必须依赖于下层传输协议所提供的某些服务。</p>
<p><strong>RTSP可以对流媒体提供诸如播放、暂停、快进等操作，它负责定义具体的控制消息、操作方法、状态码等，此外还描述了与RTP间的交互操作（RFC2326）。</strong></p>
<p>由RTSP控制的媒体流集合可以用表示描述（Presentation  Description）来定义，所谓表示是指流媒体服务器提供给客户机的一个或者多个媒体流的集合，而表示描述则包含了一个表示中各个媒体流的相关信 息，如数据编码/解码算法、网络地址、媒体流的内容等。虽然RTSP服务器同样也使用标识符来区别每一流连接会话（Session），但RTSP连接并没有被绑定到传输层连接（如TCP等），也就是说在整个 RTSP连接期间，RTSP用户可打开或者关闭多个对RTSP服务器的可靠传输连接以发出RTSP  请求。此外，RTSP连接也可以基于面向无连接的传输协议（如UDP等）。</p>
<blockquote>
<p><a href="https://www.ietf.org/rfc/rfc2326.txt" target="_blank" rel="noopener">Real Time Streaming Protocol (RTSP)</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=======================================================================================================================================</span><br><span class="line">RTSP/Packet Counter:</span><br><span class="line">Topic / Item            Count         Average       Min val       Max val       Rate (ms)     Percent       Burst rate    Burst start</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Total RTSP Packets      18                                                      0.0005        100%          0.0700        5.792</span><br><span class="line"> RTSP Response Packets  0                                                       0.0000        0.00%         -             -</span><br><span class="line">  ???: broken           0                                                       0.0000                      -             -</span><br><span class="line">  5xx: Server Error     0                                                       0.0000                      -             -</span><br><span class="line">  4xx: Client Error     0                                                       0.0000                      -             -</span><br><span class="line">  3xx: Redirection      0                                                       0.0000                      -             -</span><br><span class="line">  2xx: Success          0                                                       0.0000                      -             -</span><br><span class="line">  1xx: Informational    0                                                       0.0000                      -             -</span><br><span class="line"> RTSP Request Packets   9                                                       0.0002        50.00%        0.0400        5.848</span><br><span class="line">  SET_PARAMETER         2                                                       0.0001        22.22%        0.0200        5.859</span><br><span class="line">  SETUP                 1                                                       0.0000        11.11%        0.0100        5.933</span><br><span class="line">  PLAY                  1                                                       0.0000        11.11%        0.0100        5.986</span><br><span class="line">  OPTIONS               2                                                       0.0001        22.22%        0.0200        5.751</span><br><span class="line">  GET_PARAMETER         3                                                       0.0001        33.33%        0.0100        5.848</span><br><span class="line"> Other RTSP Packets     9                                                       0.0002        50.00%        0.0400        5.792</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RTSP是一种基于<code>文本</code>的协议，用<code>CRLF</code>作为一行的结束符。使用基于文本协议的好处在于我们可以随时在使用过程中的增加自定义的参数，也可以随便将协议包抓住很直观的进行分析。</p>
</blockquote>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>RTSP有两类报文：<code>请求报文</code>和<code>响应报文</code></p>
<ul>
<li>请求报文:指从客户端向服务器发送请求报文</li>
<li>响应报文:指从服务器到客户端的回答</li>
</ul>
<p>RTSP报文由三部分组成，即<code>开始行</code>、<code>首部行</code>和<code>实体主体</code>。</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>在请求报文中，开始行就是请求行，RTSP请求报文的结构如图</p>
<p><img src="/images/media/rtsp_request_message.jpg" alt="请求报文"></p>
<p>RTSP请求报文的常用方法及作用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OPTIONS</td>
<td style="text-align:left">获得服务器提供的可用方法</td>
</tr>
<tr>
<td style="text-align:center">DESCRIBE</td>
<td style="text-align:left">得到会话描述信息</td>
</tr>
<tr>
<td style="text-align:center">SETUP</td>
<td style="text-align:left">客户端提醒服务器建立会话，并确定传输模式</td>
</tr>
<tr>
<td style="text-align:center">TEARDOWN</td>
<td style="text-align:left">客户端发起关闭请求</td>
</tr>
<tr>
<td style="text-align:center">PLAY</td>
<td style="text-align:left">客户端发送播放请求</td>
</tr>
<tr>
<td style="text-align:center">SET_PARAMETER</td>
<td style="text-align:left">给URI指定的表示或媒体流设置参数值</td>
</tr>
<tr>
<td style="text-align:center">GET_PARAMETER</td>
<td style="text-align:left">获取URI中指定的表示或流的任何指定参数或参数的值</td>
</tr>
</tbody>
</table>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>响应报文的<code>开始行</code>是<code>状态行</code>，RTSP响应报文的结构如图：</p>
<p><img src="/images/media/rtsp_answer_message.jpg" alt="响应报文"></p>
<h4 id="示例-交互"><a href="#示例-交互" class="headerlink" title="示例-交互"></a>示例-交互</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS * RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 1</span><br><span class="line">Require: org.wfa.wfd1.0</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 1</span><br><span class="line">Public: org.wfa.wfd1.0, GET_PARAMETER, SET_PARAMETER</span><br><span class="line"></span><br><span class="line">OPTIONS * RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 1</span><br><span class="line">Require: org.wfa.wfd1.0</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 1</span><br><span class="line">Public: org.wfa.wfd1.0, SETUP, TEARDOWN, PLAY, PAUSE, GET_PARAMETER, SET_PARAMETER</span><br><span class="line"></span><br><span class="line">GET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 2</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 90</span><br><span class="line"></span><br><span class="line">wfd_video_formats</span><br><span class="line">wfd_audio_codecs</span><br><span class="line">wfd_client_rtp_ports</span><br><span class="line">wfd_rtp_multicast: 239.0.0.11</span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 2</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 259</span><br><span class="line"></span><br><span class="line">wfd_video_formats: 28 00 02 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none, 01 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none</span><br><span class="line">wfd_audio_codecs: LPCM 00000002 00, AAC 00000001 00</span><br><span class="line">wfd_client_rtp_ports: RTP/AVP/UDP;unicast 15550 0 mode=play</span><br><span class="line">SET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 3</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 203</span><br><span class="line"></span><br><span class="line">wfd_video_formats: wfd_audio_codecs: LPCM 00000002 00</span><br><span class="line">wfd_presentation_URL: rtsp://192.168.100.2/wfd1.0/streamid=0 none</span><br><span class="line">wfd_client_rtp_ports: RTP/AVP/UDP;unicast 15550 0 mode=play</span><br><span class="line">wfd_display_edid:</span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 3</span><br><span class="line"></span><br><span class="line">SET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 4</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 27</span><br><span class="line"></span><br><span class="line">wfd_trigger_method: SETUP</span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 4</span><br><span class="line"></span><br><span class="line">SETUP rtsp://192.168.100.2/wfd1.0/streamid=0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 2</span><br><span class="line">Transport: RTP/AVP/UDP;unicast;client_port=15550-15551</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 2</span><br><span class="line">Session: 1649760492;timeout=319201969439387</span><br><span class="line">Transport: RTP/AVP/UDP;unicast;client_port=15550-15551;server_port=22648-22649</span><br><span class="line"></span><br><span class="line">PLAY rtsp://192.168.100.2/wfd1.0/streamid=0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 3</span><br><span class="line">Session: 1649760492</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 3</span><br><span class="line">Session: 1649760492;timeout=319201969439387</span><br><span class="line">Range: npt=now-</span><br><span class="line"></span><br><span class="line">GET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:27 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 5</span><br><span class="line">Session: 1649760492</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:01:08 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 5</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 0</span><br><span class="line"></span><br><span class="line">GET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:47 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 6</span><br><span class="line">Session: 1649760492</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:01:28 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 6</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>
<h2 id="RTCP"><a href="#RTCP" class="headerlink" title="RTCP"></a>RTCP</h2><p>RTCP控制协议需要与RTP数据协议一起配合使用，<strong>当应用程序启动一个RTP会话时将同时占用两个端口，分别供RTP和RTCP使用</strong>。<code>RTP本身并不能为按序传输数据包提供可靠的保证，也不提供流量控制和拥塞控制，这些都由RTCP来负责完成</code>。通常RTCP会采用与RTP相同的分发机制，向会话中的所有成员周期性地发送控制信息，应用程序通过接收这些数据，从中获取会话参与者的相关资料，以及网络状况、分组丢失概率等反馈信息，从而能够对服务质量进行控制或者对网络状况进行诊断。</p>
<h2 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h2><ul>
<li>C++<ul>
<li><a href="http://research.edm.uhasselt.be/jori/page/CS/Jrtplib.html" target="_blank" rel="noopener">JRTPLIB</a>【<a href="https://github.com/j0r1/JRTPLIB.git" target="_blank" rel="noopener">Code</a>】</li>
<li><a href="https://github.com/Ansersion/myRtspClient" target="_blank" rel="noopener">myRtspClient</a></li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/ww506772362/article/details/52609379" target="_blank" rel="noopener">RTSP/RTP 媒体传输和控制协议</a></li>
<li><a href="https://tools.ietf.org/pdf/rfc6184.pdf" target="_blank" rel="noopener">RTP Payload Format for H.264 Video</a>【<a href="https://tools.ietf.org/html/rfc6184" target="_blank" rel="noopener">html</a>】</li>
<li><a href="https://www.iana.org/assignments/rtspv2-parameters/rtspv2-parameters.xhtml" target="_blank" rel="noopener">Real-Time Streaming Protocol (RTSP) 2.0 Parameters</a></li>
<li><a href="http://www.txrjy.com/thread-357928-1-1.html" target="_blank" rel="noopener">RTP/RTSP/RTCP的区别</a></li>
<li><a href="https://yq.aliyun.com/articles/229295" target="_blank" rel="noopener">RTSP协议介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>rtp</tag>
      </tags>
  </entry>
  <entry>
    <title>TS流</title>
    <url>/post/36727.html</url>
    <content><![CDATA[<p>TS流</p>
<a id="more"></a>
<p><img src="/images/media/TS.svg" alt="TS"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="TS头"><a href="#TS头" class="headerlink" title="TS头"></a>TS头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Transport packet header</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_packet_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> sync_byte                    : <span class="number">8</span>;	<span class="comment">//同步字节, 固定为0x47,表示后面的是一个TS分组</span></span><br><span class="line">	<span class="keyword">unsigned</span> transport_error_indicator    : <span class="number">1</span>;	<span class="comment">//传输误码指示符</span></span><br><span class="line">	<span class="keyword">unsigned</span> payload_unit_start_indicator : <span class="number">1</span>;	<span class="comment">//效荷载单元起始指示符</span></span><br><span class="line">	<span class="keyword">unsigned</span> transport_priority           : <span class="number">1</span>;	<span class="comment">//传输优先, 1表示高优先级,传输机制可能用到，解码用不着</span></span><br><span class="line">	<span class="keyword">unsigned</span> PID                          : <span class="number">13</span>;	<span class="comment">//PID</span></span><br><span class="line">	<span class="keyword">unsigned</span> transport_scrambling_control : <span class="number">2</span>;	<span class="comment">//传输加扰控制</span></span><br><span class="line">	<span class="keyword">unsigned</span> adaption_field_control       : <span class="number">2</span>;	<span class="comment">//自适应控制 01仅含有效负载，10仅含调整字段，11含有调整字段和有效负载。为00解码器不进行处理</span></span><br><span class="line">	<span class="keyword">unsigned</span> continuity_counter           : <span class="number">4</span>;	<span class="comment">//连续计数器 一个4bit的计数器，范围0-15</span></span><br><span class="line">&#125; TS_packet_header;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TS包的标识(即sync_byte)为<code>0x47</code>，并且为了确保这个TS包里的数据有效，所以我们一开始查找<code>47 40 00</code>这三组16进制数</p>
<blockquote>
<p>包头大小: <code>4Byte</code></p>
</blockquote>
</blockquote>
<ul>
<li><p><code>adaption_field_control</code> : 调整字段控制</p>
<ul>
<li>0x00 : reserved for future use by ISO/IEC</li>
<li>0x01 : 无调整字段,仅含有效负载</li>
<li>0x10 : 仅含调整字段,无有效负载</li>
<li>0x11 : 调整字段后含有效负载<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">if (adaption_field_control == '10' || adaption_field_control == '11') &#123;</span><br><span class="line">        adaption_fields() <span class="comment">//调整字段的处理</span></span><br><span class="line">&#125;</span><br><span class="line">if (adaption_field_control == '01' || adaption_field_control == '11') &#123;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N ; i++) <span class="comment">//N值 = 184 - 调整字段的字节数</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>continuity_counter</code> : 用于对传输误码进行检测。在发送端对所有的包都做0-15的循环计数，在接收终端，如发现循环计数器的值有中断，表明数据在传输中有丢失。</p>
</li>
</ul>
<h3 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program Association Table</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PAT_Packet_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> table_id                        : <span class="number">8</span>;	<span class="comment">//固定为0x00 ，标志是该表是PAT</span></span><br><span class="line">	<span class="keyword">unsigned</span> section_syntax_indicator        : <span class="number">1</span>; 	<span class="comment">//段语法标志位，固定为1</span></span><br><span class="line">	<span class="keyword">unsigned</span> zero                            : <span class="number">1</span>; 	<span class="comment">//0</span></span><br><span class="line">	<span class="keyword">unsigned</span> reserved_1                      : <span class="number">2</span>; 	<span class="comment">//保留位</span></span><br><span class="line">	<span class="keyword">unsigned</span> section_length                  : <span class="number">12</span>;	<span class="comment">//表示这个字节后面有用的字节数，包括CRC32</span></span><br><span class="line">	<span class="keyword">unsigned</span> transport_stream_id             : <span class="number">16</span>;	<span class="comment">//该传输流的ID，区别于一个网络中其它多路复用的流</span></span><br><span class="line">	<span class="keyword">unsigned</span> reserved_2                      : <span class="number">2</span>; 	<span class="comment">//保留位</span></span><br><span class="line">	<span class="keyword">unsigned</span> version_number                  : <span class="number">5</span>; 	<span class="comment">//范围0-31，表示PAT的版本号</span></span><br><span class="line">	<span class="keyword">unsigned</span> current_next_indicator          : <span class="number">1</span>; 	<span class="comment">//发送的PAT是当前有效还是下一个PAT有效</span></span><br><span class="line">	<span class="keyword">unsigned</span> section_number                  : <span class="number">8</span>; 	<span class="comment">//分段的号码。PAT可能分为多段传输，第一段为00，以后每个分段加1，最多可能有256个分段</span></span><br><span class="line">	<span class="keyword">unsigned</span> last_section_number             : <span class="number">8</span>; 	<span class="comment">//最后一个分段的号码</span></span><br><span class="line">	<span class="comment">// for(i=0; i&lt;N; i++) &#123;  //N = (section_length - 4(CRC的4Byte) - 5(section_lengt以后的5Byte))/4</span></span><br><span class="line">	<span class="keyword">unsigned</span> program_number                  : <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> reserved_3                      : <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> network_PID                     : <span class="number">16</span>;	<span class="comment">// 或者program_map_PID</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">unsigned</span> CRC_32                          : <span class="number">32</span>;</span><br><span class="line">&#125; PAT_Packet;</span><br></pre></td></tr></table></figure>
<h3 id="PMT"><a href="#PMT" class="headerlink" title="PMT"></a>PMT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program Map Table</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PMT_Packet_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">unsigned</span> table_id                        : <span class="number">8</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> section_syntax_indicator        : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> zero                            : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> reserved_1                      : <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> section_length                  : <span class="number">12</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> program_number                  : <span class="number">16</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> reserved_2                      : <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> version_number                  : <span class="number">5</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> current_next_indicator          : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> section_number                  : <span class="number">8</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> last_section_number             : <span class="number">8</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> reserved_3                      : <span class="number">3</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> PCR_PID                         : <span class="number">13</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> reserved_4                      : <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> program_info_length             : <span class="number">12</span>;</span><br><span class="line">     <span class="comment">// for(i=0; i&lt;N; i++) &#123;</span></span><br><span class="line">     <span class="keyword">unsigned</span> stream_type                     : <span class="number">8</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> reserved_5                      : <span class="number">3</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> elementary_PID                  : <span class="number">13</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> reserved_6                      : <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> ES_info_length                  : <span class="number">12</span>;</span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     <span class="keyword">unsigned</span> CRC_32                          : <span class="number">32</span>;</span><br><span class="line">&#125; PMT_Packet;</span><br></pre></td></tr></table></figure>
<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	0.000000000			MPEG TS	188	 Service Description Table (SDT)</span><br><span class="line">2	0.000055764			MPEG TS	188	 Program Association Table (PAT)</span><br><span class="line">3	0.000111529			MPEG TS	188	 Program Map Table (PMT)</span><br><span class="line">4	0.000167294			MPEG TS	188	 [MP2T fragment of a reassembled packet]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开始时解析到的数据包:<code>SDT-&gt;PAT-&gt;PMT</code></p>
</blockquote>
<p>SDT包只出现在TS文件的开头，而PAT和PMT包，每隔<code>42Packet</code>将出现一次。</p>
<h3 id="SDT"><a href="#SDT" class="headerlink" title="SDT"></a>SDT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frame 1: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits)</span><br><span class="line">    Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138)</span><br><span class="line">    Arrival Time: Jan  1, 1970 08:00:00.000000000 CST</span><br><span class="line">    [Time shift for this packet: 0.000000000 seconds]</span><br><span class="line">    Epoch Time: 0.000000000 seconds</span><br><span class="line">    [Time delta from previous captured frame: 0.000000000 seconds]</span><br><span class="line">    [Time delta from previous displayed frame: 0.000000000 seconds]</span><br><span class="line">    [Time since reference or first frame: 0.000000000 seconds]</span><br><span class="line">    Frame Number: 1</span><br><span class="line">    Frame Length: 188 bytes (1504 bits)</span><br><span class="line">    Capture Length: 188 bytes (1504 bits)</span><br><span class="line">    [Frame is marked: False]</span><br><span class="line">    [Frame is ignored: False]</span><br><span class="line">    [Protocols in frame: mp2t:mpeg_sect:dvb_sdt]</span><br><span class="line">ISO/IEC 13818-1 PID=0x11 CC=0</span><br><span class="line">    Header: 0x47401110</span><br><span class="line">        0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47)</span><br><span class="line">        .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0</span><br><span class="line">        .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1</span><br><span class="line">        .... .... ..0. .... .... .... .... .... = Transport Priority: 0</span><br><span class="line">        .... .... ...0 0000 0001 0001 .... .... = PID: Unknown (0x0011)</span><br><span class="line">        .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0)</span><br><span class="line">        .... .... .... .... .... .... ..01 .... = Adaptation Field Control: Payload only (0x1)</span><br><span class="line">        .... .... .... .... .... .... .... 0000 = Continuity Counter: 0</span><br><span class="line">    [MPEG2 PCR Analysis]</span><br><span class="line">    Pointer: 0</span><br><span class="line">DVB Service Description Table</span><br><span class="line">    Table ID: Service Description Table (SDT), current network (0x42)</span><br><span class="line">    1... .... .... .... = Syntax indicator: 1</span><br><span class="line">    .111 .... .... .... = Reserved: 0x7</span><br><span class="line">    .... 0000 0010 0101 = Length: 37</span><br><span class="line">    Transport Stream ID: 0x0001</span><br><span class="line">    11.. .... = Reserved: 0x3</span><br><span class="line">    ..00 000. = Version Number: 0x00</span><br><span class="line">    .... ...1 = Current/Next Indicator: Currently applicable (1)</span><br><span class="line">    Section Number: 0</span><br><span class="line">    Last Section Number: 0</span><br><span class="line">    Original Network ID: 0xff01</span><br><span class="line">    Reserved: 0xff</span><br><span class="line">    Service 0x0001</span><br><span class="line">        Service ID: 0x0001</span><br><span class="line">        1111 11.. = Reserved: 0x3f</span><br><span class="line">        .... ..0. = EIT Schedule Flag: 0</span><br><span class="line">        .... ...0 = EIT Present Following Flag: 0</span><br><span class="line">        100. .... .... .... = Running Status: Running (0x4)</span><br><span class="line">        ...0 .... .... .... = Free CA Mode: Not Scrambled (0x0)</span><br><span class="line">        .... 0000 0001 0100 = Descriptors Loop Length: 0x014</span><br><span class="line">        Descriptor Tag=0x48</span><br><span class="line">            Descriptor Tag: Service Descriptor (0x48)</span><br><span class="line">            Descriptor Length: 18</span><br><span class="line">            Service Type: digital television service (0x01)</span><br><span class="line">            Provider Name Length: 6</span><br><span class="line">            [Default character table (Latin)]</span><br><span class="line">            Service Provider Name: FFmpeg</span><br><span class="line">            Service Name Length: 9</span><br><span class="line">            [Default character table (Latin)]</span><br><span class="line">            Service Name: Service01</span><br><span class="line">    CRC 32: 0x777c43ca [unverified]</span><br><span class="line">    [CRC 32 Status: Unverified]</span><br><span class="line">Stuffing</span><br><span class="line">    Stuffing: ffffffffffffffffffffffffffffffffffffffffffffffff...</span><br></pre></td></tr></table></figure>
<h3 id="PAT-1"><a href="#PAT-1" class="headerlink" title="PAT"></a>PAT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frame 2: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits)</span><br><span class="line">    Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138)</span><br><span class="line">    Arrival Time: Jan  1, 1970 08:00:00.000055764 CST</span><br><span class="line">    [Time shift for this packet: 0.000000000 seconds]</span><br><span class="line">    Epoch Time: 0.000055764 seconds</span><br><span class="line">    [Time delta from previous captured frame: 0.000055764 seconds]</span><br><span class="line">    [Time delta from previous displayed frame: 0.000055764 seconds]</span><br><span class="line">    [Time since reference or first frame: 0.000055764 seconds]</span><br><span class="line">    Frame Number: 2</span><br><span class="line">    Frame Length: 188 bytes (1504 bits)</span><br><span class="line">    Capture Length: 188 bytes (1504 bits)</span><br><span class="line">    [Frame is marked: False]</span><br><span class="line">    [Frame is ignored: False]</span><br><span class="line">    [Protocols in frame: mp2t:mpeg_sect:mpeg_pat]</span><br><span class="line">ISO/IEC 13818-1 PID=0x0 CC=0</span><br><span class="line">    Header: 0x47400010</span><br><span class="line">        0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47)</span><br><span class="line">        .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0</span><br><span class="line">        .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1</span><br><span class="line">        .... .... ..0. .... .... .... .... .... = Transport Priority: 0</span><br><span class="line">        .... .... ...0 0000 0000 0000 .... .... = PID: Program Association Table (0x0000)</span><br><span class="line">        .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0)</span><br><span class="line">        .... .... .... .... .... .... ..01 .... = Adaptation Field Control: Payload only (0x1)</span><br><span class="line">        .... .... .... .... .... .... .... 0000 = Continuity Counter: 0</span><br><span class="line">    [MPEG2 PCR Analysis]</span><br><span class="line">    Pointer: 0    //自适应区,1Byte,如果为0 表示没有自适应区</span><br><span class="line">MPEG2 Program Association Table</span><br><span class="line">    Table ID: Program Association Table (PAT) (0x00)</span><br><span class="line">    1... .... .... .... = Syntax indicator: 1</span><br><span class="line">    .011 .... .... .... = Reserved: 0x3</span><br><span class="line">    .... 0000 0000 1101 = Length: 13</span><br><span class="line">    Transport Stream ID: 0x0001</span><br><span class="line">    11.. .... = Reserved: 0x3</span><br><span class="line">    ..00 000. = Version Number: 0x00</span><br><span class="line">    .... ...1 = Current/Next Indicator: Currently applicable</span><br><span class="line">    Section Number: 0</span><br><span class="line">    Last Section Number: 0</span><br><span class="line">    Program 0x0001 -&gt; PID 0x1000</span><br><span class="line">        Program Number: 0x0001</span><br><span class="line">        111. .... .... .... = Reserved: 0x7</span><br><span class="line">        ...1 0000 0000 0000 = Program Map PID: 0x1000</span><br><span class="line">    CRC 32: 0x2ab104b2 [unverified]</span><br><span class="line">    [CRC 32 Status: Unverified]</span><br><span class="line">Stuffing</span><br><span class="line">    Stuffing: ffffffffffffffffffffffffffffffffffffffffffffffff...</span><br></pre></td></tr></table></figure>
<h3 id="PMT-1"><a href="#PMT-1" class="headerlink" title="PMT"></a>PMT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frame 3: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits)</span><br><span class="line">    Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138)</span><br><span class="line">    Arrival Time: Jan  1, 1970 08:00:00.000111529 CST</span><br><span class="line">    [Time shift for this packet: 0.000000000 seconds]</span><br><span class="line">    Epoch Time: 0.000111529 seconds</span><br><span class="line">    [Time delta from previous captured frame: 0.000055765 seconds]</span><br><span class="line">    [Time delta from previous displayed frame: 0.000055765 seconds]</span><br><span class="line">    [Time since reference or first frame: 0.000111529 seconds]</span><br><span class="line">    Frame Number: 3</span><br><span class="line">    Frame Length: 188 bytes (1504 bits)</span><br><span class="line">    Capture Length: 188 bytes (1504 bits)</span><br><span class="line">    [Frame is marked: False]</span><br><span class="line">    [Frame is ignored: False]</span><br><span class="line">    [Protocols in frame: mp2t:mpeg_sect:mpeg_pmt]</span><br><span class="line">ISO/IEC 13818-1 PID=0x1000 CC=0</span><br><span class="line">    Header: 0x47500010</span><br><span class="line">        0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47)</span><br><span class="line">        .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0</span><br><span class="line">        .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1</span><br><span class="line">        .... .... ..0. .... .... .... .... .... = Transport Priority: 0</span><br><span class="line">        .... .... ...1 0000 0000 0000 .... .... = PID: Unknown (0x1000)</span><br><span class="line">        .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0)</span><br><span class="line">        .... .... .... .... .... .... ..01 .... = Adaptation Field Control: Payload only (0x1)</span><br><span class="line">        .... .... .... .... .... .... .... 0000 = Continuity Counter: 0</span><br><span class="line">    [MPEG2 PCR Analysis]</span><br><span class="line">    Pointer: 0</span><br><span class="line">MPEG2 Program Map Table</span><br><span class="line">    Table ID: Program Map Table (PMT) (0x02)</span><br><span class="line">    1... .... .... .... = Syntax indicator: 1</span><br><span class="line">    .011 .... .... .... = Reserved: 0x3</span><br><span class="line">    .... 0000 0001 1101 = Length: 29</span><br><span class="line">    Program Number: 0x0001</span><br><span class="line">    11.. .... = Reserved: 0x3</span><br><span class="line">    ..00 000. = Version Number: 0x00</span><br><span class="line">    .... ...1 = Current/Next Indicator: Currently applicable (0x1)</span><br><span class="line">    Section Number: 0</span><br><span class="line">    Last Section Number: 0</span><br><span class="line">    111. .... .... .... = Reserved: 0x7</span><br><span class="line">    ...0 0001 0000 0000 = PCR PID: 0x0100</span><br><span class="line">    1111 .... .... .... = Reserved: 0xf</span><br><span class="line">    .... 0000 0000 0000 = Program Info Length: 0x000</span><br><span class="line">    Stream PID=0x0100</span><br><span class="line">        Stream type: AVC video stream as defined in ITU-T Rec. H.264 | ISO/IEC 14496-10 Video (0x1b)</span><br><span class="line">        111. .... .... .... = Reserved: 0x7</span><br><span class="line">        ...0 0001 0000 0000 = Elementary PID: 0x0100</span><br><span class="line">        1111 .... .... .... = Reserved: 0xf</span><br><span class="line">        .... 0000 0000 0000 = ES Info Length: 0x000</span><br><span class="line">    Stream PID=0x0101</span><br><span class="line">        Stream type: ISO/IEC 11172 Audio (0x03)</span><br><span class="line">        111. .... .... .... = Reserved: 0x7</span><br><span class="line">        ...0 0001 0000 0001 = Elementary PID: 0x0101</span><br><span class="line">        1111 .... .... .... = Reserved: 0xf</span><br><span class="line">        .... 0000 0000 0110 = ES Info Length: 0x006</span><br><span class="line">        Descriptor Tag=0x0a</span><br><span class="line">            Descriptor Tag: ISO 639 Language Descriptor (0x0a)</span><br><span class="line">            Descriptor Length: 4</span><br><span class="line">            ISO 639 Language Code: und</span><br><span class="line">            ISO 639 Language Type: Undefined (0x00)</span><br><span class="line">    CRC 32: 0x30afbe63 [unverified]</span><br><span class="line">    [CRC 32 Status: Unverified]</span><br><span class="line">Stuffing</span><br><span class="line">    Stuffing: ffffffffffffffffffffffffffffffffffffffffffffffff...</span><br></pre></td></tr></table></figure>
<h3 id="packet"><a href="#packet" class="headerlink" title="packet"></a>packet</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frame 4: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits)</span><br><span class="line">    Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138)</span><br><span class="line">    Arrival Time: Jan  1, 1970 08:00:00.000167294 CST</span><br><span class="line">    [Time shift for this packet: 0.000000000 seconds]</span><br><span class="line">    Epoch Time: 0.000167294 seconds</span><br><span class="line">    [Time delta from previous captured frame: 0.000055765 seconds]</span><br><span class="line">    [Time delta from previous displayed frame: 0.000055765 seconds]</span><br><span class="line">    [Time since reference or first frame: 0.000167294 seconds]</span><br><span class="line">    Frame Number: 4</span><br><span class="line">    Frame Length: 188 bytes (1504 bits)</span><br><span class="line">    Capture Length: 188 bytes (1504 bits)</span><br><span class="line">    [Frame is marked: False]</span><br><span class="line">    [Frame is ignored: False]</span><br><span class="line">    [Protocols in frame: mp2t]</span><br><span class="line">ISO/IEC 13818-1 PID=0x100 CC=0</span><br><span class="line">    Header: 0x47410030</span><br><span class="line">        0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47)</span><br><span class="line">        .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0</span><br><span class="line">        .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1</span><br><span class="line">        .... .... ..0. .... .... .... .... .... = Transport Priority: 0</span><br><span class="line">        .... .... ...0 0001 0000 0000 .... .... = PID: Unknown (0x0100)</span><br><span class="line">        .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0)</span><br><span class="line">        .... .... .... .... .... .... ..11 .... = Adaptation Field Control: Adaptation Field and Payload (0x3)</span><br><span class="line">        .... .... .... .... .... .... .... 0000 = Continuity Counter: 0</span><br><span class="line">    [MPEG2 PCR Analysis]</span><br><span class="line">    Adaptation Field Length: 7</span><br><span class="line">    Adaptation Field</span><br><span class="line">        0... .... = Discontinuity Indicator: 0</span><br><span class="line">        .1.. .... = Random Access Indicator: 1</span><br><span class="line">        ..0. .... = Elementary Stream Priority Indicator: 0</span><br><span class="line">        ...1 .... = PCR Flag: 1</span><br><span class="line">        .... 0... = OPCR Flag: 0</span><br><span class="line">        .... .0.. = Splicing Point Flag: 0</span><br><span class="line">        .... ..0. = Transport Private Data Flag: 0</span><br><span class="line">        .... ...0 = Adaptation Field Extension Flag: 0</span><br><span class="line">        Program Clock Reference: 0x000000000132a20c</span><br><span class="line">Reassembled in: 7139</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>组播（多播）</title>
    <url>/post/18736.html</url>
    <content><![CDATA[<blockquote>
<p>组播是指在IP网络中将数据包以尽力传送的形式发送到某个确定的节点集合（即组播组），其基本思想是：源主机（即组播源）只发送一份数据，其目的地址为组播组地址；组播组中的所有接收者都可收到同样的数据拷贝，并且只有组播组内的主机可以接收该数据，而其它主机则不能收到。</p>
</blockquote>
<p>组播技术有效地解决了<code>单点发送、多点接收</code>的问题，实现了IP网络中点到多点的高效数据传送，能够大量节约网络带宽、降低网络负载。作为一种与单播和广播并列的通信方式，组播的意义不仅在于此。更重要的是，可以利用网络的组播特性方便地提供一些新的增值业务，包括在线直播、网络电视、远程教育、远程医疗、网络电台、实时视频会议等互联网的信息服务领域</p>
<p><img src="/images/net/multicast/multicast.png" alt="组播"></p>
<a id="more"></a>
<h2 id="组播技术实现"><a href="#组播技术实现" class="headerlink" title="组播技术实现"></a>组播技术实现</h2><p>组播技术的实现需要解决以下几方面问题：</p>
<ol>
<li>组播源向一组确定的接收者发送信息，而如何来标识这组确定的接收者？——这需要用到<code>组播地址机制</code>；</li>
<li>接收者通过加入组播组来实现对组播信息的接收，而接收者是如何动态地加入或离开组播组的？——即如何进行<code>组成员关系管理</code>；</li>
<li>组播报文在网络中是如何被转发并最终到达接收者的？——即<code>组播报文转发</code>的过程；</li>
<li>组播报文的转发路径（即组播转发树）是如何构建的？——这是由各<code>组播路由协议</code>来完成的。</li>
</ol>
<h2 id="组播地址机制"><a href="#组播地址机制" class="headerlink" title="组播地址机制"></a>组播地址机制</h2><h3 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h3><p><img src="/images/net/multicast/ip_format.gif" alt="ip format"></p>
<p>IP组播地址前四位均为“1110”</p>
<p>IP组播地址用于标识一个IP组播组。IANA把D类地址空间分配给组播使用，范围从<code>224.0.0.0</code>到<code>239.255.255.255</code>。</p>
<p><img src="/images/net/multicast/ip_class.gif" alt="ip class"></p>
<p><strong>组播地址划分:</strong></p>
<ol>
<li>224.0.0.0到224.0.0.255被IANA预留，地址224.0.0.0保留不做分配，其它地址供路由协议及拓扑查找和维护协议使用。该范围内的地址属于局部范畴，不论TTL为多少，都不会被路由器转发；</li>
<li>224.0.1.0到238.255.255.255为用户可用的组播地址，在全网范围内有效。其中232.0.0.0/8为SSM组地址，而其余则属于ASM组地址。有关ASM和SSM的详细介绍，请参见“2.5  组播模型分类”一节；</li>
<li>239.0.0.0到239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效，也属于ASM组地址。使用本地管理组地址可以灵活定义组播域的范围，以实现不同组播域之间的地址隔离，从而有助于在不同组播域内重复使用相同组播地址而不会引起冲突。</li>
</ol>
<p><strong><em>说明：</em></strong></p>
<blockquote>
<p><code>224.0.1.0/24</code>网段内的一些组播地址也被IANA预留给了某些组播应用。譬如，<code>224.0.1.1</code>被预留给NTP（Network Time Protocol，网络时间协议）所使用。</p>
</blockquote>
<h2 id="组成员关系管理"><a href="#组成员关系管理" class="headerlink" title="组成员关系管理"></a>组成员关系管理</h2><p>组成员关系管理是指在<code>路由器/交换机</code>上建立直联网段内的组成员关系信息，具体说，就是各接口/端口下有哪些组播组的成员。</p>
<h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>IGMP运行于<code>主机和与主机直连的路由器</code>之间，其实现的功能是双向的：</p>
<ul>
<li>一方面，主机通过IGMP通知路由器希望接收某个特定组播组的信息；</li>
<li>另一方面，路由器通过IGMP周期性地查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的收集与维护。</li>
</ul>
<p>通过IGMP，在路由器中记录的信息是某个组播组是否在本地有组成员，而不是组播组与主机之间的对应关系。</p>
<p>目前IGMP有以下三个版本：</p>
<ol>
<li><code>IGMPv1（RFC 1112）</code>中定义了基本的组成员查询和报告过程；</li>
<li><code>IGMPv2（RFC 2236）</code>在IGMPv1的基础上添加了组成员快速离开的机制等；</li>
<li><code>IGMPv3（RFC 3376）</code>中增加的主要功能是成员可以指定接收或拒绝来自某些组播源的报文，以实现对SSM模型的支持。</li>
</ol>
<h4 id="IGMPv2的工作原理"><a href="#IGMPv2的工作原理" class="headerlink" title="IGMPv2的工作原理"></a>IGMPv2的工作原理</h4><p><img src="/images/net/multicast/IGMPv2.gif" alt="IGMPv2"></p>
<p>当同一个网段内有多个IGMP路由器时，IGMPv2通过查询器选举机制从中选举出唯一的查询器。查询器周期性地发送普遍组查询消息进行成员关系查询，主机通过发送报告消息来响应查询。而作为组成员的路由器，其行为也与普通主机一样，响应其它路由器的查询。</p>
<p>当主机要加入组播组时，不必等待查询消息，而是主动发送报告消息；当主机要离开组播组时，也会主动发送离开组消息，查询器收到离开组消息后，会发送特定组查询消息来确定该组的所有组成员是否都已离开。</p>
<p>通过上述机制，在路由器里建立起一张表，其中记录了路由器各接口所对应子网上都有哪些组的成员。当路由器收到发往组G的组播数据后，只向那些有G的成员的接口转发该数据。至于组播数据在路由器之间如何转发则由组播路由协议决定，而不是IGMP的功能。</p>
<h4 id="抓包信息"><a href="#抓包信息" class="headerlink" title="抓包信息"></a>抓包信息</h4><p><img src="/images/net/multicast/multicast_start_package.png" alt="组播初始化数据包"></p>
<p><strong><em>IGMPv2 destination address</em></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Message Type</th>
<th style="text-align:center">Multicast Address</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">General Query</td>
<td style="text-align:center">All hosts (224.0.0.1)</td>
</tr>
<tr>
<td style="text-align:center">Group-Specific Query</td>
<td style="text-align:center">The group being queried</td>
</tr>
<tr>
<td style="text-align:center">Membership Report</td>
<td style="text-align:center">The group being reported</td>
</tr>
<tr>
<td style="text-align:center">Leave Group    All</td>
<td style="text-align:center">routers (224.0.0.2)</td>
</tr>
</tbody>
</table>
<p>组播相关的含义：</p>
<ol>
<li><p>IGMPv2: Membership Query, general</p>
<blockquote>
<p>发给所有主机</p>
</blockquote>
</li>
<li><p>IGMPv2: Membership Report group 239.0.0.11</p>
<blockquote>
<p>收到后，回应组播地址</p>
</blockquote>
</li>
</ol>
<h3 id="IGMP-Snooping"><a href="#IGMP-Snooping" class="headerlink" title="IGMP Snooping"></a>IGMP Snooping</h3><p>IGMP是针对IP层设计的，只能记录路由器上的三层接口与IP组播地址的对应关系。但在很多情况下，组播报文不可避免地要经过一些交换机，如果没有一种机制将二层端口与组播MAC地址对应起来，组播报文就会转发给交换机的所有端口，这显然会浪费大量的系统资源。</p>
<p>IGMP Snooping的出现就可以解决这个问题，其工作原理为：主机发往IGMP查询器的报告消息经过交换机时，交换机对这个消息进行监听并记录下来，为端口和组播MAC地址建立起映射关系；当交换机收到组播数据时，根据这样的映射关系，只向连有组成员的端口转发组播数据。</p>
<h2 id="组播编程"><a href="#组播编程" class="headerlink" title="组播编程"></a>组播编程</h2><p>多播的程序设计使用setsockopt()函数和getsockopt()函数来实现，组播的选项是<code>IP层</code>的，其选项值和含义</p>
<table>
<thead>
<tr>
<th style="text-align:center">getsockopt()/setsockopt()的选项</th>
<th style="text-align:center">含    义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP_MULTICAST_TTL</td>
<td style="text-align:center">设置多播组数据的TTL值</td>
</tr>
<tr>
<td style="text-align:center">IP_ADD_MEMBERSHIP</td>
<td style="text-align:center">在指定接口上加入组播组</td>
</tr>
<tr>
<td style="text-align:center">IP_DROP_MEMBERSHIP</td>
<td style="text-align:center">退出组播组</td>
</tr>
<tr>
<td style="text-align:center">IP_MULTICAST_IF</td>
<td style="text-align:center">获取默认接口或设置接口</td>
</tr>
<tr>
<td style="text-align:center">IP_MULTICAST_LOOP</td>
<td style="text-align:center">禁止组播数据回送</td>
</tr>
</tbody>
</table>
<h2 id="实例–视频会议"><a href="#实例–视频会议" class="headerlink" title="实例–视频会议"></a>实例–视频会议</h2><p><img src="/images/net/multicast/multicast_r_s_samp.png" alt="组播实例"></p>
<ol>
<li>路由器新建两个AP（AP-S和AP-R），其中均开启组播功能，为什么建两个，作用，关系</li>
<li>R1和R2两个加入组播（239.0.0.1）</li>
</ol>
<h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><ol>
<li><p>建立socket</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">localAddr</span></span></span><br><span class="line"><span class="class"><span class="title">memset</span>(<span class="title">localAddr</span>.<span class="title">sin_zero</span>, 0, <span class="title">sizeof</span>(<span class="title">localAddr</span>.<span class="title">sin_zero</span>));</span></span><br><span class="line">localAddr.sin_family = AF_INET;</span><br><span class="line">localAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">localAddr.sin_port = htons(netParam-&gt;local_port);	<span class="comment">//port(Random): Pick an even integer in range [1024, 65534)</span></span><br><span class="line">bind(fd, (<span class="keyword">const</span> struct sockaddr *)&amp;localAddr, <span class="keyword">sizeof</span>(localAddr));</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remoteAddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(remoteAddr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(remoteAddr.sin_zero));</span><br><span class="line">remoteAddr.sin_family = AF_INET;</span><br><span class="line">remoteAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">remoteAddr.sin_port = htons(netParam-&gt;remote_port); 	<span class="comment">//port: 15550</span></span><br><span class="line">ret = inet_pton(AF_INET, netParam-&gt;remoteip, &amp;remoteAddr.sin_addr);	<span class="comment">//remoteip: 239.0.0.1</span></span><br><span class="line">ret = <span class="built_in">connect</span>(fd, (<span class="keyword">const</span> struct sockaddr *)&amp;remoteAddr, <span class="keyword">sizeof</span>(remoteAddr));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>通过connect指定了连接的IP和端口后，可以通过<code>netstat</code>命令查看<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;# netstat -n</span><br><span class="line">&gt; Active Internet connections (w/o servers)</span><br><span class="line">&gt; Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">&gt; tcp        0      0 192.168.100.2:7236      192.168.100.3:37536     ESTABLISHED</span><br><span class="line">&gt; udp        0      0 192.168.100.2:55226     239.0.0.11:15550        ESTABLISHED</span><br><span class="line">&gt; udp        0      0 192.168.100.2:55227     239.0.0.11:15551        ESTABLISHED</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><blockquote>
<p>为啥建立两个AP？</p>
</blockquote>
<h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><blockquote>
<p>测试代码实现</p>
</blockquote>
<p>在绑定后使用connect进行指定ip和port连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remoteAddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(remoteAddr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(remoteAddr.sin_zero));</span><br><span class="line">remoteAddr.sin_family = AF_INET;  <span class="comment">/* 建立新的连接 */</span></span><br><span class="line"><span class="comment">//remoteAddr.sin_family = AF_INET;  /* 断开旧的连接 */</span></span><br><span class="line">inet_pton(AF_INET,player-&gt;rtpUdp.rip, &amp;remoteAddr.sin_addr);</span><br><span class="line">remoteAddr.sin_port = htons(player-&gt;rtpUdp.rport);   <span class="comment">//port: 0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ret = <span class="built_in">connect</span>(player-&gt;rtpUdp.fd,(struct sockaddr *)&amp;remoteAddr,remoteAddrLen);</span><br><span class="line">&#125; <span class="keyword">while</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># netstat -n</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 192.168.100.3:40964     192.168.100.2:7236      ESTABLISHED</span><br><span class="line">udp        0      0 239.0.0.11:15550        192.168.100.2:*         ESTABLISHED   #Foreign port: 0</span><br><span class="line">udp        0      0 239.0.0.11:15551        192.168.100.2:1         ESTABLISHED</span><br></pre></td></tr></table></figure>
<h2 id="注意–无法得到数据原因"><a href="#注意–无法得到数据原因" class="headerlink" title="注意–无法得到数据原因"></a>注意–无法得到数据原因</h2><blockquote>
<p>select一直出现timeout</p>
</blockquote>
<ol>
<li>接收组播的网络端口（也就是R端），必须设置该组播的IP，负责接收不到组播数据</li>
<li>数据包被操作系统过滤掉了，所以系统调用socket无法看到数据包。</li>
</ol>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="ifconfig-–-判断是支持组播"><a href="#ifconfig-–-判断是支持组播" class="headerlink" title="ifconfig – 判断是支持组播"></a>ifconfig – 判断是支持组播</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig</span></span><br><span class="line">wlan0     Link encap:Ethernet  HWaddr 04:E6:76:C3:63:DC</span><br><span class="line">          inet addr:192.168.100.2  Bcast:192.168.100.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:1413 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:316 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:88628 (86.5 KiB)  TX bytes:40942 (39.9 KiB)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>UP</code>: 代表网卡开启状态</li>
<li><code>BROADCAST</code>: 支持广播</li>
<li><code>RUNNING</code>: 代表网卡的网线被接上</li>
<li><code>MULTICAST</code>: 支持组播</li>
<li><code>RX packets</code>和<code>TX packets</code>: 表示网卡接收和发送的数据包个数，<strong><em>但是由于端口的错误等，可能导致select或recv超时或者接收不到数据</em></strong></li>
<li><code>RX bytes</code>和<code>TX bytes</code>: 表示接收和发送的数据大小</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>R端加入组播的实现： Client</p>
<p><a href="https://raw.githubusercontent.com/Winddoing/CodeWheel/master/socket/multicast/multicast-tst.c" target="_blank" rel="noopener">Code：</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VX_RTP_MUL_IP	<span class="meta-string">"239.0.0.11"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VX_RTP_LOCAL_PORT 15550</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VX_RTP_MUL_IP	<span class="meta-string">"225.0.0.37"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VX_RTP_LOCAL_PORT 12345</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_set_nonblock</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flags, res;</span><br><span class="line"></span><br><span class="line">	flags = fcntl(s, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (flags &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		flags = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = fcntl(s, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">"fcntl return err:%d!\n"</span>, res);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>, n = <span class="number">0</span>, sock_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> recmsg[BUFLEN + <span class="number">1</span>];</span><br><span class="line">	fd_set rfds;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">mreq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> yes=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*UDP*/</span></span><br><span class="line">	fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create udp socket error %d"</span>, -errno);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	socket_set_nonblock(fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 允许多个应用绑定同一个本地端口接收数据包 */</span></span><br><span class="line">	ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,<span class="keyword">sizeof</span>(yes));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"setsockopt: SO_REUSEADDR error, ret=%d\n"</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 禁止组播数据回环 */</span></span><br><span class="line">	<span class="keyword">if</span>( setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, (<span class="keyword">char</span> *)&amp;loop, <span class="keyword">sizeof</span>(loop)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"setsockopt: IP_MULTICAST_LOOP error, ret=%d\n"</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 加入组播 */</span></span><br><span class="line">	mreq.imr_multiaddr.s_addr=inet_addr(VX_RTP_MUL_IP);</span><br><span class="line">	mreq.imr_interface.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	ret = setsockopt(fd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&amp;mreq,<span class="keyword">sizeof</span>(mreq));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"setsockopt: IP_ADD_MEMBERSHIP error, ret=%d\n"</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(addr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr.sin_zero));</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	addr.sin_port = htons(VX_RTP_LOCAL_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置网卡的组播IP !!! */</span></span><br><span class="line">	ret = inet_pton(AF_INET, VX_RTP_MUL_IP, &amp;addr.sin_addr);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Set network card multicast ip error, ret=%d\n"</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 绑定网卡 */</span></span><br><span class="line">	ret = bind(fd, (<span class="keyword">const</span> struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Bind socket error, ret=%d\n"</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"create rtp udp socket %d ok\n"</span>,fd);</span><br><span class="line"></span><br><span class="line">	sock_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">	<span class="comment">/* 循环接收网络上来的组播消息 */</span></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		tv.tv_sec = <span class="number">1</span>;</span><br><span class="line">		tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;rfds);</span><br><span class="line">		FD_SET(fd, &amp;rfds);</span><br><span class="line"></span><br><span class="line">		ret = select(fd + <span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d, Socket select error\n"</span>, __func__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == ret) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d, select timeout\n"</span>, __func__, __LINE__);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//struct sockaddr_in tmp_addr;</span></span><br><span class="line">		<span class="comment">//socklen_t addr_len = sizeof(tmp_addr);</span></span><br><span class="line">		<span class="comment">//bzero (recmsg, BUFLEN + 1);</span></span><br><span class="line"></span><br><span class="line">eagain:</span><br><span class="line">		<span class="comment">//n = recvfrom(fd, recmsg, BUFLEN, 0, (struct sockaddr*) &amp;addr, (socklen_t*)&amp;sock_len);</span></span><br><span class="line">		<span class="comment">//n = recvfrom(fd, recmsg, BUFLEN, 0, (struct sockaddr*) &amp;tmp_addr, &amp;addr_len);</span></span><br><span class="line">		n = recv(fd, recmsg, BUFLEN, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"recvfrom err in udptalk!, n: %d, errno: %d\n"</span>, n, -errno);</span><br><span class="line">			<span class="keyword">if</span> (EAGAIN == errno)</span><br><span class="line">				<span class="keyword">goto</span> eagain;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"recv data siez: %d\n"</span>, n);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 成功接收到数据报 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> * tmp = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)recmsg;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">"s: %d, peer: 0x%08x\n"</span>, n, tmp[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">	<span class="keyword">if</span>(fd &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Server：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_PORT 12345</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_GROUP <span class="meta-string">"225.0.0.37"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> *message=<span class="string">"Hello, World!"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create what looks like an ordinary UDP socket */</span></span><br><span class="line">	<span class="keyword">if</span> ((fd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"socket"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up destination address */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_family=AF_INET;</span><br><span class="line">	addr.sin_addr.s_addr=inet_addr(HELLO_GROUP);</span><br><span class="line">	addr.sin_port=htons(HELLO_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"message: %s, (HEX: 0x%08x)\n"</span>, message, *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)message);</span><br><span class="line">	<span class="comment">/* now just sendto() our destination! */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sendto(fd,message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (struct sockaddr *) &amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"sendto"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>); <span class="comment">//会影响接受端select的超时时间，延时越大，select的超时越大</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/jianchaolv/article/details/7909948" target="_blank" rel="noopener">组播技术</a></li>
<li><a href="https://blog.csdn.net/samtaoys/article/details/51981323" target="_blank" rel="noopener">组播学习笔记</a></li>
<li><a href="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/#0-tsina-1-67000-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">单播，组播(多播)，广播以及任播</a></li>
<li><a href="https://www.cnblogs.com/ghj1976/p/5276452.html" target="_blank" rel="noopener">组播（Multicast）传输</a></li>
<li><a href="http://blog.chinaunix.net/uid-28458801-id-5085099.html" target="_blank" rel="noopener">多播,IP_MULTICAST_TTL,IP_ADD_MEMBERSHIP,IP_MULTICAST_IF,IP_DROP_MEMBERSHIP</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>组播</tag>
      </tags>
  </entry>
  <entry>
    <title>组播--IGMPv2</title>
    <url>/post/39626.html</url>
    <content><![CDATA[<blockquote>
<p>IGMP 是Internet Group Management Protocol（互联网组管理协议）的简称。它是TCP/IP 协议族中负责IP 组播成员管理的协议，用来在IP 主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>IGMPv1（由<a href="https://www.rfc-editor.org/rfc/rfc1112.txt" target="_blank" rel="noopener">RFC 1112</a> 定义）</li>
<li>IGMPv2（由<a href="https://www.rfc-editor.org/rfc/rfc2236.txt" target="_blank" rel="noopener">RFC 2236</a> 定义）</li>
<li>IGMPv3（由<a href="https://www.rfc-editor.org/rfc/rfc3376.txt" target="_blank" rel="noopener">RFC 3376</a> 定义）</li>
</ul>
<p>所有版本的IGMP都支持ASM（Any-Source Multicast，任意信源组播）模型；IGMPv3可以直接应用于SSM（Source-Specific Multicast，指定信源组播）模型，而IGMPv1和IGMPv2则需要在IGMP SSM Mapping技术的支持下才能应用于SSM模型。</p>
<h2 id="IGMP工作原理"><a href="#IGMP工作原理" class="headerlink" title="IGMP工作原理"></a>IGMP工作原理</h2><ul>
<li><p>第一阶段： 当某个主机加入新的组播时，该主机应向多播租的多播地址发送一个IGMP报文，声明自己要成为该租的成员。本地的多播路由器收到IGMP报文后，还要利用多播路由选择协议把这种组成员关系转发给因特网上的其他多播路由器。</p>
</li>
<li><p>第二阶段： 组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组成员。只要有一个主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</p>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h2 id="IGMP-snooping-和-IGMP-proxy"><a href="#IGMP-snooping-和-IGMP-proxy" class="headerlink" title="IGMP snooping 和 IGMP proxy"></a>IGMP snooping 和 IGMP proxy</h2><h3 id="IGMP-snooping"><a href="#IGMP-snooping" class="headerlink" title="IGMP snooping"></a>IGMP snooping</h3><blockquote>
<p>是运行在二层设备上的组播约束的机制，用于管理和控制组播组。</p>
</blockquote>
<h3 id="IGMP-proxy"><a href="#IGMP-proxy" class="headerlink" title="IGMP proxy"></a>IGMP proxy</h3><blockquote>
<p>是靠拦截用户和路由器之间的IGMP报文建立组播表，Proxy设备的上联端口执行主机的角色，下联端口执行路由器的角色。</p>
</blockquote>
<h2 id="IGMPv1"><a href="#IGMPv1" class="headerlink" title="IGMPv1"></a>IGMPv1</h2><p>IGMPv1 主要基于查询和响应机制来完成对组播组成员的管理。</p>
<p>当一个网段内有多台组播路由器时，由于它们都能从主机那里收到IGMP 成员关系报告报文（Membership Report Message），因此只需要其中一台路由器发送IGMP 查询报文（Query Message）就足够了。这就需要有一个查询器（Querier）的选举机制来确定由哪台路由器作为IGMP查询器。</p>
<p>对于IGMPv1 来说，由组播路由协议（如PIM）选举出唯一的组播信息转发者DR（Designated Router，指定路由器）作为IGMP 查询器</p>
<p><img src="/images/net/multicast/igmpv1.jpg" alt="IGMPv1"></p>
<p>IGMPv1 没有专门定义<code>离开组播组</code>的报文。当运行IGMPv1 的主机离开某组播组时，将不会向其要离开的组播组发送报告报文。当网段中不再存在该组播组的成员后，IGMP 路由器将收不到任何发往该组播组的报告报文，于是IGMP 路由器在一段时间之后便删&gt;除该组播组所对应的组播转发项。</p>
<h2 id="IGMPv2"><a href="#IGMPv2" class="headerlink" title="IGMPv2"></a>IGMPv2</h2><p>与IGMPv1 相比，IGMPv2 增加了<code>查询器选举机制</code>和<code>离开组机制</code>。</p>
<h3 id="查询器选举机制"><a href="#查询器选举机制" class="headerlink" title="查询器选举机制"></a>查询器选举机制</h3><p>在IGMPv1 中，当某共享网段上存在多个组播路由器时，由组播路由协议（如PIM）选举的指定路由器充当查询器。</p>
<p>在IGMPv2 中，增加了独立的查询器选举机制，其选举过程如下：</p>
<ol>
<li>所有IGMPv2路由器在初始时都认为自己是查询器，并向本地网段内的所有主机和路由器发送IGMP普遍组查询（General Query）报文（目的地址为224.0.0.1）；</li>
<li>本地网段中的其它IGMPv2路由器在收到该报文后，将报文的源IP地址与自己的接口地址作比较。通过比较， IP地址最小的路由器将成为查询器，其它路由器成为非查询器（Non-Querier）；</li>
<li>所有非查询器上都会启动一个定时器（即其它查询器存在时间定时器Other Querier Present Timer）。在该定时器超时前，如果收到了来自查询器的IGMP 查询报文，则重置该定时器；否则，就认为原查询器失效，并发起新的查询器选举过程。</li>
</ol>
<h3 id="离开组机制"><a href="#离开组机制" class="headerlink" title="离开组机制"></a>离开组机制</h3><p>在IGMPv1 中，主机离开组播组时不会向组播路由器发出任何通知，导致组播路由器只能依靠组播组成员查询的响应超时来获知组播组成员的离开。</p>
<p>而在IGMPv2中，当一个主机离开某组播组时：</p>
<ol>
<li>该主机向本地网段内的所有组播路由器（目的地址为224.0.0.2）发送离开组（Leave Group）报文；</li>
<li>当查询器收到该报文后， 向该主机所声明要离开的那个组播组发送特定组查询（Group-Specific Query）报文（目的地址字段和组地址字段均填充为所要查询的组播组地址）；</li>
<li>如果该网段内还有该组播组的其它成员，则这些成员在收到特定组查询报文后，会在该报文中所设定的最大响应时间（Max Response Time）内发送成员关系报告报文；</li>
<li>如果在最大响应时间内收到了该组播组其它成员发送的成员关系报告报文，查询器就会继续维护该组播组的成员关系；否则，查询器将认为该网段内已无该组播组的成员，于是不再维护这个组播组的成员关系。</li>
</ol>
<h3 id="IGMPv2报文格式"><a href="#IGMPv2报文格式" class="headerlink" title="IGMPv2报文格式"></a>IGMPv2报文格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0             7 8             1516                             31</span><br><span class="line">+--------------+---------------+-------------------------------+-++</span><br><span class="line">|    Type      | max_resp_time |           CheckSum            | |</span><br><span class="line">+--------------+---------------+-------------------------------+ 8Byte</span><br><span class="line">|                    Group Address                             | |</span><br><span class="line">+--------------------------------------------------------------+-++</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Type</code> :</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Type</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x11</td>
<td style="text-align:center">Membership Query(成员查询)</td>
</tr>
<tr>
<td style="text-align:center">0X12</td>
<td style="text-align:center">Version 1 Membership Report(版本1成员报告)</td>
</tr>
<tr>
<td style="text-align:center">0X16</td>
<td style="text-align:center">Version 2 Membership Report(版本2成员报告)</td>
</tr>
<tr>
<td style="text-align:center">0X17</td>
<td style="text-align:center">Leave Group(离开组)</td>
</tr>
</tbody>
</table>
<ul>
<li><code>max_resp_time</code>: 在发出响应报告前的以1/10秒为单位的最长时间，<code>缺省值为10秒</code>。新的最大响应时间（以1/10秒为单位）字段允许查询用路由器为它的查询报文指定准确的查询间隔响应时间。IGMP版本2主机在随机选择它们的应时间值时以此作为上限。</li>
</ul>
<blockquote>
<p>从路由器接收到一条查询消息后，主机会为其所属的每个组播组都配置一个计时器。计时器的值在 0 到最大响应时间之间随机选定。当其中任何一个计时器的值减为 0时，主机就会发送该组播组的成员报告消息。合理配置最大响应时间，可以使主机快速响应查询信息，路由器也就能快速地掌握组播组成员的存在状况。</p>
</blockquote>
<ul>
<li><code>Group Address</code>: 组地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Internet Group Management Protocol</span><br><span class="line">    [IGMP Version: 2]</span><br><span class="line">    Type: Membership Report (0x16)</span><br><span class="line">    Max Resp Time: 0.0 sec (0x00)</span><br><span class="line">    Checksum: 0xfaf3 [correct]</span><br><span class="line">    [Checksum Status: Good]</span><br><span class="line">    Multicast Address: 239.0.0.11</span><br></pre></td></tr></table></figure>
<h3 id="设置max-resp-time"><a href="#设置max-resp-time" class="headerlink" title="设置max_resp_time"></a>设置max_resp_time</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip igmp snooping query-max-response-time seconds</span><br></pre></td></tr></table></figure>
<h2 id="IGMPv3"><a href="#IGMPv3" class="headerlink" title="IGMPv3"></a>IGMPv3</h2><p>IGMPv3 在兼容和继承IGMPv1 和IGMPv2 的基础上，进一步增强了主机的控制能力，并增强了查询和报告报文的功能。</p>
<h2 id="IGMP-snooping查询器"><a href="#IGMP-snooping查询器" class="headerlink" title="IGMP snooping查询器"></a>IGMP snooping查询器</h2><p>在运行了IGMP的组播网络中，会有一台三层组播设备充当IGMP查询器，负责发送<code>IGMP查询报文</code>，使三层组播设备能够在网络层<code>建立并维护组播转发表项，从而在网络层正常转发组播数据</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/livelylittlefish/article/details/4286142" target="_blank" rel="noopener">IGMP技术总结</a></li>
<li><a href="https://blog.csdn.net/shanzhizi/article/details/7645330" target="_blank" rel="noopener">IGMPv3协议报文格式参考</a></li>
<li><a href="https://blog.csdn.net/mingzznet/article/details/9253607" target="_blank" rel="noopener">IGMP Snooping概念和配置方法—交换</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_c079d59e0102whjg.html" target="_blank" rel="noopener">IGMPV2基本原理</a></li>
<li><a href="https://blog.csdn.net/achejq/article/details/7347214" target="_blank" rel="noopener">IGMP Snooping技术学习笔记</a></li>
<li><a href="http://blog.51cto.com/rongshu/1900182" target="_blank" rel="noopener">H3C F1000-S防火墙基础配置及telnet登录！</a></li>
<li><a href="http://www.h3c.com/cn/d_200805/605838_30003_0.htm" target="_blank" rel="noopener">IGMP Snooping技术介绍</a></li>
<li><a href="https://blog.csdn.net/todd911/article/details/38689681" target="_blank" rel="noopener">《TCP/IP详解卷2：实现》笔记–IGMP:Internet组管理协议</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>net</tag>
        <tag>igmp</tag>
      </tags>
  </entry>
  <entry>
    <title>NTP服务</title>
    <url>/post/12403.html</url>
    <content><![CDATA[<p>NTP是网络时间协议(Network Time Protocol)，它是用来同步网络中各个计算机的时间的协议。<br>通俗：Ntp是一种授时的软件<br>用途是把计算机的时钟同步到世界协调时UTC，其精度在<code>局域网内可达0.1ms</code>，在互联网上绝大多数的地方其精度可以达到<code>1-50ms</code>。</p>
<a id="more"></a>
<h2 id="搭建NTP-Server"><a href="#搭建NTP-Server" class="headerlink" title="搭建NTP Server"></a>搭建NTP Server</h2><h3 id="ubuntu-deepin平台安装"><a href="#ubuntu-deepin平台安装" class="headerlink" title="ubuntu/deepin平台安装"></a>ubuntu/deepin平台安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ntp</span><br></pre></td></tr></table></figure>
<h3 id="配置NTP"><a href="#配置NTP" class="headerlink" title="配置NTP"></a>配置NTP</h3><p>修改<code>/etc/ntp.conf</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ntp.conf</span><br><span class="line"></span><br><span class="line">driftfile /var/lib/ntp/ntp.drift</span><br><span class="line">statistics loopstats peerstats clockstats</span><br><span class="line">filegen loopstats file loopstats type day enable</span><br><span class="line">filegen peerstats file peerstats type day enable</span><br><span class="line">filegen clockstats file clockstats type day enable</span><br><span class="line">server ntp.ubuntu.com</span><br><span class="line">restrict -4 default kod notrap nomodify nopeer noquery</span><br><span class="line">restrict -6 default kod notrap nomodify nopeer noquery</span><br><span class="line">restrict 192.168.1.0 mask 255.255.255.0 nomodify   #&lt;+++++主要是允许能同步的服务器所在的内部网段</span><br><span class="line">restrict 127.0.0.1</span><br><span class="line">restrict ::1V</span><br></pre></td></tr></table></figure>
<h4 id="权限设定部分"><a href="#权限设定部分" class="headerlink" title="权限设定部分"></a>权限设定部分</h4><p>权限设定主要以<code>restrict</code>这个参数来设定，主要的语法为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">restrict IP mask netmask_IP parameter</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其中IP可以是软体位址，也可以是 default ，default 就类似0.0.0.0<br>如果 paramter完全没有设定，那就表示该 IP (或网域) 『没有任何限制！』</p>
</blockquote>
<p>paramter:</p>
<ul>
<li>ignore：关闭所有的NTP 连线服务</li>
<li>nomodify：表示Client 端不能更改 Server 端的时间参数，不过Client端仍然可以透过Server 端來进行网络较时。</li>
<li>notrust：该 Client 除非通过认证，否则该 Client 来源将被视为不信任网域</li>
<li>noquery：不提供 Client 端的时间查询</li>
</ul>
<h3 id="重启NTP服务"><a href="#重启NTP服务" class="headerlink" title="重启NTP服务"></a>重启NTP服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/ntp restart</span><br></pre></td></tr></table></figure>
<h3 id="使用-对时"><a href="#使用-对时" class="headerlink" title="使用-对时"></a>使用-对时</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure>
<h2 id="移植NTP服务"><a href="#移植NTP服务" class="headerlink" title="移植NTP服务"></a>移植NTP服务</h2><p>移植其中包括客户端和服务端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">wget https://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p11.tar.gz</span><br><span class="line">tar zxvf ntp-4.2.8p11.tar.gz</span><br><span class="line">cd ntp-4.2.8p11</span><br><span class="line">PWD=`pwd`</span><br><span class="line">echo "xxxxxxxxxxxx$PWD"</span><br><span class="line">rm $PWD/install -rf</span><br><span class="line">mkdir $PWD/install</span><br><span class="line">echo "./configure --host=arm-linux CC=arm-gcc49-linux-gnueabi-gcc --prefix=$PWD/install/  --with-yielding-select=yes"</span><br><span class="line">./configure --host=arm-linux CC=arm-gcc49-linux-gnueabi-gcc --prefix=$PWD/install/  --with-yielding-select=yes</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntpdate 192.168.1.11</span><br></pre></td></tr></table></figure>
<h3 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h3><blockquote>
<p>注意：用<code>date</code>命令查看之后显示的是UTC时间（世界标准时间），比北京时间（CST=UTC+8）相差8个小时，所以需要设置时区</p>
</blockquote>
<p>设置时区为CST时间, 把redhat或者ubuntu系统目录<code>/usr/share/zoneinfo/Asia</code>中的文件<code>Shanghai</code>拷贝到开发板目录/etc中并且改名为<code>localtime</code>之后，用命令reboot重启即可</p>
<h2 id="busybox–ntpd"><a href="#busybox–ntpd" class="headerlink" title="busybox–ntpd"></a>busybox–ntpd</h2><p><a href="https://elixir.bootlin.com/busybox/1.28.4/source/examples/var_service/ntpd" target="_blank" rel="noopener">busybox:ntpd</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BusyBox v1.25.1 (2018-05-24 14:59:56 CST) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: ntpd [-dnqNwl -I IFACE] [-S PROG] [-p PEER]...</span><br><span class="line"></span><br><span class="line">NTP client/server</span><br><span class="line"></span><br><span class="line">        -d      Verbose</span><br><span class="line">        -n      Do not daemonize</span><br><span class="line">        -q      Quit after clock is set</span><br><span class="line">        -N      Run at high priority</span><br><span class="line">        -w      Do not set time (only query peers), implies -n</span><br><span class="line">        -S PROG Run PROG after stepping time, stratum change, and every 11 mins</span><br><span class="line">        -p PEER Obtain time from PEER (may be repeated)</span><br><span class="line">        -l      Also run as server on port 123</span><br><span class="line">        -I IFACE Bind server to IFACE, implies -l</span><br></pre></td></tr></table></figure>
<h3 id="clinet"><a href="#clinet" class="headerlink" title="clinet"></a>clinet</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntpd -p 192.168.1.11 -qNn</span><br></pre></td></tr></table></figure>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntpd -ddnNl</span><br></pre></td></tr></table></figure>
<h2 id="应用–RTP网络延时"><a href="#应用–RTP网络延时" class="headerlink" title="应用–RTP网络延时"></a>应用–RTP网络延时</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>有A和B两个开发板并且通过WIFI直连（P2P）使用TCP协议搭建了RTP，使用RTP进行视频传输，计算其中的网络延时</p>
<blockquote>
<p>A — 服务器 — 接收端 — R<br>B — 客户端 — 发射端 — S</p>
</blockquote>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><h4 id="打时间戳"><a href="#打时间戳" class="headerlink" title="打时间戳"></a>打时间戳</h4><p><code>gettimeofday</code>获取的时间存放在<code>unsigned long long</code>中需要64bit的空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rtp_time_r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">rtp_time_r = <span class="number">1000000</span> * now.tv_sec + now.tv_usec;</span><br></pre></td></tr></table></figure>
<h4 id="long-long和char转换"><a href="#long-long和char转换" class="headerlink" title="long long和char转换"></a>long long和char转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> dst[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rtpTime = <span class="number">0x1234567898765</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rtp_time_s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">56</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(dst, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;  i &lt; <span class="keyword">sizeof</span>(rtpTime);  i++) &#123;</span><br><span class="line">		dst[<span class="number">19</span> - i] = （<span class="keyword">unsigned</span> <span class="keyword">char</span>）((rtpTime &gt;&gt; j) &amp; <span class="number">0xFF</span>);</span><br><span class="line">		<span class="comment">//printf("===&gt; func: %s, line: %d, rtpTime: %016llx, %d, dst[%d]=%02x\n",</span></span><br><span class="line">				__func__, __LINE__, (rtpTime &gt;&gt; j) &amp; <span class="number">0xFF</span>, j, <span class="number">19</span> - i, dst[<span class="number">19</span> - i]);</span><br><span class="line">		j -= <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf("===&gt; func: %s, line: %d\n", __func__, __LINE__);</span></span><br><span class="line">	j = <span class="number">56</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;  i &lt; <span class="keyword">sizeof</span>(rtp_time_s);  i++) &#123;</span><br><span class="line">		rtp_time_s |= (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)dst[<span class="number">19</span> - i] &lt;&lt; j;</span><br><span class="line">		j -= <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d,  old: %016llx\n"</span>, __func__, __LINE__, rtpTime);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d,  new: %016llx\n"</span>, __func__, __LINE__, rtp_time_s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同的gcc编译器，编译完的运行结果不一样，测试<code>gcc version 6.4.0 20170724 (Debian 6.4.0-2)</code>编译运行结果错误</p>
</blockquote>
<p>在嵌入式交叉编译中，测试结果正常：</p>
<blockquote>
<p>===&gt; func: main, line: 38,  old: 0001234567898765<br>===&gt; func: main, line: 39,  new: 0001234567898765</p>
</blockquote>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><blockquote>
<p>一帧数据将会被拆分成多个RTP包进行传输</p>
</blockquote>
<ol>
<li>在S端对每一帧数据中的RTP打入相同的时间戳Ts</li>
<li>在R端将接收到的S端头中的时间戳解析Ts，并且此时获取R端的时间戳Tr</li>
<li>判断一帧的数据，并计算R和S的网络延时</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">t_count_t</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> t_count_r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> t_count_s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> time_sum_r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> time_sum_s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">rtp_time_s_t</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">rtp_time_r_t</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rtp_time_diff = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rtp_time_max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rtp_time_min = <span class="number">0xffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_rtp_head_time</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> <span class="built_in">line</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rtp_time_r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rtp_time_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取Ｓ端的时间戳</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">56</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;  i &lt; <span class="keyword">sizeof</span>(rtp_time_s);  i++) &#123;</span><br><span class="line">        rtp_time_s |= (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)data[<span class="number">19</span> - i] &lt;&lt; j;</span><br><span class="line">        j -= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 获取Ｒ端的时间戳</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;now, <span class="number">0</span>, <span class="keyword">sizeof</span>(now));</span><br><span class="line">    gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">    rtp_time_r = <span class="number">1000000</span> * now.tv_sec + now.tv_usec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 判断并计算一帧数据的时间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">rtp_time_s_t</span> != rtp_time_s) &#123;</span><br><span class="line">        <span class="keyword">t_count_t</span>++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">t_count_t</span> &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">rtp_time_r_t</span> &gt;= <span class="keyword">rtp_time_s_t</span>) &#123;</span><br><span class="line">                t_count_r++;</span><br><span class="line">                rtp_time_diff = <span class="keyword">rtp_time_r_t</span> - <span class="keyword">rtp_time_s_t</span>;</span><br><span class="line">                time_sum_r += rtp_time_diff;</span><br><span class="line">                rtp_time_max = (rtp_time_max &gt; rtp_time_diff) ? rtp_time_max : rtp_time_diff;</span><br><span class="line">                rtp_time_min = (rtp_time_min &lt; rtp_time_diff) ? rtp_time_min : rtp_time_diff;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t_count_s++;</span><br><span class="line">                time_sum_s += (<span class="keyword">rtp_time_s_t</span> - <span class="keyword">rtp_time_r_t</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">rtp_time_s_t</span> = rtp_time_s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">rtp_time_r_t</span> = rtp_time_r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4. 判断一万帧数据后打印结果</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">t_count_t</span> % <span class="number">10000</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%llu, t_count_r=%llu, time_sum_r=%llu, v=%llu, max:%llu, min:%llu\n"</span>,</span><br><span class="line">                <span class="keyword">t_count_t</span>, t_count_r, time_sum_r, (t_count_r != <span class="number">0</span>) ? (time_sum_r / t_count_r):<span class="number">111111</span>, rtp_time_max, rtp_time_min);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%llu, t_count_s=%llu, time_sum_s=%llu, v=%llu\n"</span>,</span><br><span class="line">                <span class="keyword">t_count_t</span>, t_count_s, time_sum_s, (t_count_s != <span class="number">0</span>) ? (time_sum_s / t_count_s):<span class="number">111111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><ol>
<li>先启动Ｒ，并进行授时</li>
<li>启动Ｓ端，并进行授时</li>
<li>视频传输，等待计算结果</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>R端必须先启动授时，然后启动S端进行授时，方可进行正常的测试</li>
<li><strong>如果S端先进行授时，而R端后进行授时，那么在R端解析到的S端时间有可能比R端的时间小，导致计算出现负数（越界），最后的结果偏差离谱</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/zgrjkflmkyc/article/details/45098831" target="_blank" rel="noopener">移植ntp服务到arm-linux平台</a></li>
<li><a href="https://www.cnblogs.com/smartxuchao/p/6440524.html" target="_blank" rel="noopener">So Easy-Ntp嵌入式软件移植</a></li>
<li><a href="https://blog.csdn.net/mmz_xiaokong/article/details/8700979" target="_blank" rel="noopener">ubuntu搭建NTP服务器</a></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>ntp</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的shell命令</title>
    <url>/post/1644.html</url>
    <content><![CDATA[<p>常用的shell命令： <code>find</code>, <code>cat</code></p>
<a id="more"></a>
<h2 id="查看中断与CPU的绑定关系"><a href="#查看中断与CPU的绑定关系" class="headerlink" title="查看中断与CPU的绑定关系"></a>查看中断与CPU的绑定关系</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/interrupts | grep intel | cut -d: -f1 | while read i; do echo -ne irq":$i\t bind_cpu: "; cat /proc/irq/$i/smp_affinity_list; done | sort -n -t' ' -k3</span><br></pre></td></tr></table></figure>
<h2 id="内存读写速度测试"><a href="#内存读写速度测试" class="headerlink" title="内存读写速度测试"></a>内存读写速度测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/dev/null bs=1M count=1024</span><br></pre></td></tr></table></figure>
<h2 id="查看当前CPU运行频率"><a href="#查看当前CPU运行频率" class="headerlink" title="查看当前CPU运行频率"></a>查看当前CPU运行频率</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch -n 0.1 "cat /proc/cpuinfo | grep \"^[c]pu MHz\""</span><br></pre></td></tr></table></figure>
<h2 id="文件指定行数的字符大写转小写"><a href="#文件指定行数的字符大写转小写" class="headerlink" title="文件指定行数的字符大写转小写"></a>文件指定行数的字符大写转小写</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find -name "*.md" | xargs sed -i '4,9s/.*/\L&amp;/'</span><br></pre></td></tr></table></figure>
<h2 id="删除所有文件行尾空格"><a href="#删除所有文件行尾空格" class="headerlink" title="删除所有文件行尾空格"></a>删除所有文件行尾空格</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find source/_posts/ -name "*.md" | xargs sed -i 's/[ ]*$//g'</span><br></pre></td></tr></table></figure>
<h2 id="进程CPU占有率排序"><a href="#进程CPU占有率排序" class="headerlink" title="进程CPU占有率排序"></a>进程CPU占有率排序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps H -eo user,pid,ppid,tid,time,%cpu,cmd --sort=%cpu</span><br></pre></td></tr></table></figure>
<h2 id="判断进程在哪个CPU核运行的方法"><a href="#判断进程在哪个CPU核运行的方法" class="headerlink" title="判断进程在哪个CPU核运行的方法"></a>判断进程在哪个CPU核运行的方法</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -o pid,psr,cmd -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>PSR</code>: 进程分配的CPU id</p>
</blockquote>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p><code>top</code>命令也可以显示CPU被分配给哪个进程</p>
<ul>
<li>进入<code>top</code>后，按<code>f</code>键，出现Fields Management管理界面，(空格键选中)选择<code>P</code>选项(P = Last Used Cpu (SMP))</li>
<li>top界面中目前使用的CPU将出现在”P”（或“PSR”）列下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看单独一个进程的信息</p>
</blockquote>
<h2 id="杀死僵尸进程"><a href="#杀死僵尸进程" class="headerlink" title="杀死僵尸进程"></a>杀死僵尸进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -HUP &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<h2 id="iptux–局域网数据传输–飞秋"><a href="#iptux–局域网数据传输–飞秋" class="headerlink" title="iptux–局域网数据传输–飞秋"></a>iptux–局域网数据传输–飞秋</h2><blockquote>
<p>Linux中的iptux与window中的飞秋可以相互进行文件传输</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install iptux</span><br></pre></td></tr></table></figure>
<ul>
<li><p>调整防火墙以允许使用TCP/UDP<code>2425</code>端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 2425</span><br></pre></td></tr></table></figure>
</li>
<li><p>中文乱码<br>设置编码方式: <code>cp936</code>(or <code>gbk</code>)</p>
<blockquote>
<p>工具栏设置: Tools -&gt; Preferences -&gt; System -&gt; Candidate network conding: <code>cp936</code></p>
</blockquote>
</li>
<li><p>配置文件</p>
<ul>
<li>配置文件: <code>.iptux/config.json</code></li>
<li>日志: <code>.config/iptux/</code></li>
</ul>
</li>
</ul>
<h2 id="数据销毁和日志清理"><a href="#数据销毁和日志清理" class="headerlink" title="数据销毁和日志清理"></a>数据销毁和日志清理</h2><h3 id="bleachbit"><a href="#bleachbit" class="headerlink" title="bleachbit"></a>bleachbit</h3><blockquote>
<p>bleachbit 是一款开源免费的系统清理工具，功能类似 Windows 平台的 CCleaner</p>
</blockquote>
<h3 id="shred"><a href="#shred" class="headerlink" title="shred"></a>shred</h3><blockquote>
<p>shred 功能简单的说就是涂鸦，把一个文件用随机的字符码篡改的一塌糊涂。其宗旨就是更安全地帮助删除一个机密文件</p>
</blockquote>
<h3 id="wipe"><a href="#wipe" class="headerlink" title="wipe"></a>wipe</h3><blockquote>
<p>可安全地删除磁存储器中的文件，后续无法恢复已删除文件或目录的内容。</p>
</blockquote>
<h2 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h2><ul>
<li>lscpu</li>
<li>lshw</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lscpu</span></span><br><span class="line">...</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                256</span><br><span class="line">On-line CPU(s) list:   0-255</span><br><span class="line">Thread(s) per core:    4</span><br><span class="line">Core(s) per socket:    32</span><br><span class="line">Socket(s):             2</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Model:                 1</span><br><span class="line">CPU max MHz:           2500.0000</span><br><span class="line">CPU min MHz:           1000.0000</span><br><span class="line">BogoMIPS:              400.00</span><br></pre></td></tr></table></figure>
<ul>
<li><code>socket</code>: 主板上插CPU槽的数量</li>
<li><code>core</code>: CPU上的核数(物理核)</li>
<li><code>thread</code>: core上的硬件线程数(逻辑核)</li>
</ul>
<h2 id="nproc"><a href="#nproc" class="headerlink" title="nproc"></a>nproc</h2><blockquote>
<p>获取可用CPU的数量</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nproc</span><br></pre></td></tr></table></figure>
<h2 id="apt-build-dep"><a href="#apt-build-dep" class="headerlink" title="apt build-dep"></a>apt build-dep</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get build-dep mesa</span><br></pre></td></tr></table></figure>
<blockquote>
<p>build-dep causes apt-get to install/remove packages in an attempt to satisfy the build dependencies for a source package. By default the dependencies are satisfied to build the package natively. If desired a host-architecture can be specified with the <code>--host-architecture</code> option instead.</p>
</blockquote>
<p>根据源码编译时所需的关系包进行搜索并下载安装.建立要编译软件的环境.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt build-dep mesa</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  autopoint debhelper dh-autoreconf dh-strip-nondeterminism lib32gcc1 lib32stdc++6 libc6-i386 libclang-9-dev libclang-common-9-dev libclang1-9</span><br><span class="line">  libclc-dev libfile-stripnondeterminism-perl libglvnd-core-dev libobjc-7-dev libobjc4 libpfm4 libset-scalar-perl libva-dev libva-glx2</span><br><span class="line">  libvdpau-dev libvulkan-dev llvm-9 llvm-9-dev llvm-9-runtime llvm-9-tools po-debconf python-pygments python-yaml python3-pygments quilt</span><br><span class="line">The following packages will be upgraded:</span><br><span class="line">  cpp-7 g++-7 gcc-7 gcc-7-base gcc-8-base libasan4 libatomic1 libcc1-0 libcilkrts5 libgcc-7-dev libgcc1 libgomp1 libitm1 liblsan0 libmpx2</span><br><span class="line">  libquadmath0 libstdc++-7-dev libstdc++6 libtsan0 libubsan0</span><br><span class="line">20 upgraded, 30 newly installed, 0 to remove and 44 not upgraded.</span><br><span class="line">Need to get 101 MB of archives.</span><br><span class="line">After this operation, 477 MB of additional disk space will be used.</span><br><span class="line">Do you want to continue? [Y/n]</span><br></pre></td></tr></table></figure>
<h2 id="tasksel"><a href="#tasksel" class="headerlink" title="tasksel"></a>tasksel</h2><p><code>tasksel</code>命令是用来安装“任务”的，任务就是一些软件的组合，比如LAMP这个任务，就是由apache，php，MySQL等软件包组成，tasksel安装任务就是安装一系列的软件包而已。</p>
<blockquote>
<p>通过tasksel可以直接在server版，进行ubuntu桌面的安装</p>
</blockquote>
<h3 id="ubuntu-Desktop"><a href="#ubuntu-Desktop" class="headerlink" title="ubuntu Desktop"></a>ubuntu Desktop</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo tasksel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tasksel选择ubuntu Desktop进行安装，等待安装完成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tasksel install ubuntu-desktop</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$tasksel --list-tasks</span><br><span class="line">u kubuntu-live	Kubuntu live CD</span><br><span class="line">u lubuntu-live-gtk	Lubuntu live CD (GTK part)</span><br><span class="line">u ubuntu-budgie-live	Ubuntu Budgie live CD</span><br><span class="line">u ubuntu-live	Ubuntu live CD</span><br><span class="line">u ubuntu-mate-live	Ubuntu MATE Live CD</span><br><span class="line">u ubuntustudio-dvd-live	Ubuntu Studio live DVD</span><br><span class="line">u vanilla-gnome-live	Ubuntu GNOME live CD</span><br><span class="line">u xubuntu-live	Xubuntu live CD</span><br><span class="line">u cloud-image	Ubuntu Cloud Image (instance)</span><br><span class="line">u dns-server	DNS server</span><br><span class="line">u kubuntu-desktop	Kubuntu desktop</span><br><span class="line">u kubuntu-full	Kubuntu full</span><br><span class="line">u lamp-server	LAMP server</span><br><span class="line">u lubuntu-core	Lubuntu minimal installation</span><br><span class="line">u lubuntu-desktop	Lubuntu Desktop</span><br><span class="line">u lubuntu-gtk-core	Lubuntu minimal installation (GTK part)</span><br><span class="line">u lubuntu-gtk-desktop	Lubuntu Desktop (GTK part)</span><br><span class="line">u lubuntu-qt-core	Lubuntu minimal installation (Qt part)</span><br><span class="line">u lubuntu-qt-desktop	Lubuntu Qt Desktop (Qt part)</span><br><span class="line">i mail-server	Mail server</span><br><span class="line">u postgresql-server	PostgreSQL database</span><br><span class="line">i print-server	Print server</span><br><span class="line">i samba-server	Samba file server</span><br><span class="line">u ubuntu-budgie-desktop	Ubuntu Budgie desktop</span><br><span class="line">i ubuntu-desktop	Ubuntu desktop</span><br><span class="line">u ubuntu-mate-core	Ubuntu MATE minimal</span><br><span class="line">u ubuntu-mate-desktop	Ubuntu MATE desktop</span><br><span class="line">u ubuntustudio-audio	Audio recording and editing suite</span><br><span class="line">u ubuntustudio-desktop	Ubuntu Studio desktop</span><br><span class="line">u ubuntustudio-desktop-core	Ubuntu Studio minimal DE installation</span><br><span class="line">u ubuntustudio-fonts	Large selection of font packages</span><br><span class="line">u ubuntustudio-graphics	2D/3D creation and editing suite</span><br><span class="line">u ubuntustudio-photography	Photograph touchup and editing suite</span><br><span class="line">u ubuntustudio-publishing	Publishing applications</span><br><span class="line">u ubuntustudio-video	Video creation and editing suite</span><br><span class="line">u vanilla-gnome-desktop	Vanilla GNOME desktop</span><br><span class="line">u xubuntu-core	Xubuntu minimal installation</span><br><span class="line">u xubuntu-desktop	Xubuntu desktop</span><br><span class="line">i openssh-server	OpenSSH server</span><br><span class="line">u server	Basic Ubuntu server</span><br></pre></td></tr></table></figure>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@linfeng etc]# find . -type f -name "*" | xargs grep "root/init.sh"</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-type f</code> : 表示只找文件</li>
<li><code>-name &quot;xxx&quot;</code> :  表示查找特定文件；也可以不写，表示找所有文件</li>
</ul>
<h3 id="批量修改文件名后缀"><a href="#批量修改文件名后缀" class="headerlink" title="批量修改文件名后缀"></a>批量修改文件名后缀</h3><blockquote>
<p>mv ./htxynl.f90 ./htxynl.f77</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.f90&quot; | awk -F &quot;.&quot; &apos;&#123;print $2&#125;&apos; | xargs -i -t mv .&#123;&#125;.f90  .&#123;&#125;.f77</span><br></pre></td></tr></table></figure>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><blockquote>
<p>cat和重定向进行写文件操作</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$cat &gt; test.sh &lt;&lt; EOF</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> this is <span class="built_in">test</span></span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>结束方式：</p>
<ul>
<li>输入<code>EOF</code>，最好使用EOF</li>
<li>使用<code>Ctrl+d</code></li>
</ul>
<p>写入方式：</p>
<ul>
<li><code>&gt;</code> : 以覆盖文件内容的方式，若此文件不存在，则创建</li>
<li><code>&gt;&gt;</code> : 以追加的方式写入文件</li>
</ul>
<h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make USE_NINJA=false USE_CLANG_PLATFORM_BUILD=false 2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure>
<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="跨服务器拷贝文件"><a href="#跨服务器拷贝文件" class="headerlink" title="跨服务器拷贝文件"></a>跨服务器拷贝文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xbin="u-boot-with-spl-mbr-gpt.bin"</span><br><span class="line">xdst="user@192.168.10.44:/home/user/x2000_ddr_test"</span><br><span class="line"></span><br><span class="line">scp $xbin fpga@192.168.4.13:/tmp/$xbin</span><br><span class="line">ssh fpga@192.168.4.13 "scp /tmp/$xbin $xdst"</span><br></pre></td></tr></table></figure>
<h3 id="ssh的key值"><a href="#ssh的key值" class="headerlink" title="ssh的key值"></a>ssh的key值</h3><ol>
<li><p>权限必须是<code>600</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加key值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看生效key值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试key值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>免密登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id ssh name@ip</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用多个key值</p>
<blockquote>
<p>man ssh_config</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /etc/ssh/ssh_config ~/.ssh/config</span><br></pre></td></tr></table></figure>
<p>编辑~/.ssh/config<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">#   StrictHostKeyChecking ask</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    IdentityFile ~/.ssh/xxxx</span><br><span class="line">#   IdentityFile ~/.ssh/id_dsa</span><br><span class="line">#   IdentityFile ~/.ssh/id_ecdsa</span><br><span class="line">#   IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="ssh登录到远程的特定目录"><a href="#ssh登录到远程的特定目录" class="headerlink" title="ssh登录到远程的特定目录"></a>ssh登录到远程的特定目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -t xx@192.168.1.1 "cd /home/xx/test; bash"</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -t xx@192.168.1.1 "cd /home/xx/test &amp;&amp; bash"</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>-t</code> :标志用于强制分配伪终端</li>
</ul>
<h3 id="通过root账户ssh登录"><a href="#通过root账户ssh登录" class="headerlink" title="通过root账户ssh登录"></a>通过root账户ssh登录</h3><blockquote>
<p>在ubuntu系统中默认不能使用root账户进行ssh登录</p>
</blockquote>
<p>开启root账户登录ssh，打开<code>/etc/ssh/sshd_config</code>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认配置<code>#PermitRootLogin prohibit-password</code></p>
</blockquote>
<p>重启ssh服务<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart sshd.service</span><br></pre></td></tr></table></figure></p>
<h3 id="ssh数据的压缩传输"><a href="#ssh数据的压缩传输" class="headerlink" title="ssh数据的压缩传输"></a>ssh数据的压缩传输</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -CX xxx@192.168.1.1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-C</code>: 压缩传输模式</li>
<li><code>-X</code>: 启用X11转发,远程打开使用图形应用</li>
</ul>
<h2 id="tftp"><a href="#tftp" class="headerlink" title="tftp"></a>tftp</h2><blockquote>
<p>开发板（busybox）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tftp -g -r user/xxxx/system.tar 192.168.4.13</span><br></pre></td></tr></table></figure>
<p>tftp的服务器(PC):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/default/tftpd-hpa</span></span><br><span class="line"></span><br><span class="line">TFTP_USERNAME="tftp"</span><br><span class="line">TFTP_DIRECTORY="/home/"</span><br><span class="line">TFTP_ADDRESS="0.0.0.0:69"</span><br><span class="line">TFTP_OPTIONS="--secure"</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: /etc/default/tftpd-hpa</p>
</blockquote>
<h2 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h2><blockquote>
<p>解压，制作 ramdisk</p>
</blockquote>
<ul>
<li>解压<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gunzip rootfs.cpio.gz</span><br><span class="line">mkdir tmp</span><br><span class="line">cd tmp</span><br><span class="line">cpio -i -F ../rootfs.cpio</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>code: <a href="https://raw.githubusercontent.com/Winddoing/MyCode/master/android/debug/unzip_ramdisk.sh" target="_blank" rel="noopener">unzip_ramdisk.sh</a></p>
</blockquote>
<ul>
<li>制作<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . | cpio -o -Hnewc |gzip -9 &gt; ../image.cpio.gz</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>-H</code>: 选项指定打包文件的具体格式，要生成init ramfs，只能用<code>newc</code>格式</p>
</blockquote>
<h2 id="minicom"><a href="#minicom" class="headerlink" title="minicom"></a>minicom</h2><p>记录串口的输出日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mkdir dd</span><br><span class="line">echo "while [ 1 ];do killall minicom; sleep 36000;done" &gt; ./b.sh</span><br><span class="line">chmod +x ./b.sh</span><br><span class="line">./b.sh &amp;</span><br><span class="line"></span><br><span class="line">while [ 1 ]</span><br><span class="line">do</span><br><span class="line">	ff=`date +%Y%m%d%H%M`;</span><br><span class="line">	echo $ff;</span><br><span class="line">	minicom -w -C ./dd/$ff -o;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<ul>
<li><p>串口输出增加时间戳：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl + a ; n</span><br></pre></td></tr></table></figure>
</li>
<li><p>串口打印内存信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl + a; f; m</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>Ctrl + a; f</code>(send break)进行发送命令，<code>m</code>查看当前内存状态的命令</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">break signal</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">查看当前内存状态的命令</td>
</tr>
</tbody>
</table>
<blockquote>
<p>内核提供接口<code>drivers/tty/sysrq.c</code>,通过按键的方式获取内核的调试信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct sysrq_key_op *sysrq_key_table[36] = &#123;</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 0 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 1 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 2 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 3 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 4 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 5 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 6 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 7 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 8 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 9 */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * a: Don&apos;t use for system provided sysrqs, it is handled specially on</span><br><span class="line">	 * sparc and will never arrive.</span><br><span class="line">	 */</span><br><span class="line">	NULL,				/* a */</span><br><span class="line">	&amp;sysrq_reboot_op,		/* b */</span><br><span class="line">	&amp;sysrq_crash_op,		/* c &amp; ibm_emac driver debug */</span><br><span class="line">	&amp;sysrq_showlocks_op,		/* d */</span><br><span class="line">	&amp;sysrq_term_op,			/* e */</span><br><span class="line">	&amp;sysrq_moom_op,			/* f */</span><br><span class="line">	/* g: May be registered for the kernel debugger */</span><br><span class="line">	NULL,				/* g */</span><br><span class="line">	NULL,				/* h - reserved for help */</span><br><span class="line">	&amp;sysrq_kill_op,			/* i */</span><br><span class="line">#ifdef CONFIG_BLOCK</span><br><span class="line">	&amp;sysrq_thaw_op,			/* j */</span><br><span class="line">#else</span><br><span class="line">	NULL,				/* j */</span><br><span class="line">#endif</span><br><span class="line">	&amp;sysrq_SAK_op,			/* k */</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	&amp;sysrq_showallcpus_op,		/* l */</span><br><span class="line">#else</span><br><span class="line">	NULL,				/* l */</span><br><span class="line">#endif</span><br><span class="line">	&amp;sysrq_showmem_op,		/* m */</span><br><span class="line">	&amp;sysrq_unrt_op,			/* n */</span><br><span class="line">	/* o: This will often be registered as &apos;Off&apos; at init time */</span><br><span class="line">	NULL,				/* o */</span><br><span class="line">	&amp;sysrq_showregs_op,		/* p */</span><br><span class="line">	&amp;sysrq_show_timers_op,		/* q */</span><br><span class="line">	&amp;sysrq_unraw_op,		/* r */</span><br><span class="line">	&amp;sysrq_sync_op,			/* s */</span><br><span class="line">	&amp;sysrq_showstate_op,		/* t */</span><br><span class="line">	&amp;sysrq_mountro_op,		/* u */</span><br><span class="line">	/* v: May be registered for frame buffer console restore */</span><br><span class="line">	NULL,				/* v */</span><br><span class="line">	&amp;sysrq_showstate_blocked_op,	/* w */</span><br><span class="line">	/* x: May be registered on ppc/powerpc for xmon */</span><br><span class="line">	/* x: May be registered on sparc64 for global PMU dump */</span><br><span class="line">	NULL,				/* x */</span><br><span class="line">	/* y: May be registered on sparc64 for global register dump */</span><br><span class="line">	NULL,				/* y */</span><br><span class="line">	&amp;sysrq_ftrace_dump_op,		/* z */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="sshfs"><a href="#sshfs" class="headerlink" title="sshfs"></a>sshfs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sshfs xxx@192.168.1.2:/home_back/xxx/work/aaa /home/user/aaa -o gid=1000,uid=1000,allow_other</span><br></pre></td></tr></table></figure>
<h2 id="md5sum-—-字符串"><a href="#md5sum-—-字符串" class="headerlink" title="md5sum — 字符串"></a>md5sum — 字符串</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -n <span class="string">'123456'</span> | md5sum</span></span><br><span class="line">e10adc3949ba59abbe56e057f20f883e  -</span><br></pre></td></tr></table></figure>
<h2 id="查看硬盘型号和序列号"><a href="#查看硬盘型号和序列号" class="headerlink" title="查看硬盘型号和序列号"></a>查看硬盘型号和序列号</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo hdparm -i /dev/sda</span><br></pre></td></tr></table></figure>
<h2 id="获取计算机硬件信息"><a href="#获取计算机硬件信息" class="headerlink" title="获取计算机硬件信息"></a>获取计算机硬件信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dmidecode</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dmidecode遵循SMBIOS/DMI标准，其输出的信息包括BIOS、系统、主板、处理器、内存、缓存等等。</p>
</blockquote>
<h2 id="格式化xml"><a href="#格式化xml" class="headerlink" title="格式化xml"></a>格式化xml</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xmllint --format run_xunit.xml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在vim中直接敲xml,进行格式化</p>
</blockquote>
<h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><blockquote>
<p>Too Long Don’t Read!</p>
</blockquote>
<p>查找各种命令的常用例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install tldr</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tldr ps</span></span><br><span class="line">ps</span><br><span class="line">Information about running processes.</span><br><span class="line"></span><br><span class="line"> - List all running processes:</span><br><span class="line">   ps aux</span><br><span class="line"></span><br><span class="line"> - List all running processes including the full command string:</span><br><span class="line">   ps auxww</span><br><span class="line"></span><br><span class="line"> - Search for a process that matches a string:</span><br><span class="line">   ps aux | grep &#123;&#123;string&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - List all processes of the current user in extra full format:</span><br><span class="line">   ps --user $(id -u) -F</span><br><span class="line"></span><br><span class="line"> - List all processes of the current user as a tree:</span><br><span class="line">   ps --user $(id -u) f</span><br><span class="line"></span><br><span class="line"> - Get the parent pid of a process:</span><br><span class="line">   ps -o ppid= -p &#123;&#123;pid&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h2><p>命令相关参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">显示每个CPU的运行情况</td>
</tr>
<tr>
<td style="text-align:center"><code>z</code></td>
<td style="text-align:center">进入高亮模式（终端红色字体）</td>
</tr>
<tr>
<td style="text-align:center"><code>b</code></td>
<td style="text-align:center">高亮显示正在运行的命令</td>
</tr>
<tr>
<td style="text-align:center"><code>c</code></td>
<td style="text-align:center">显示command列的所有信息，包括参数</td>
</tr>
<tr>
<td style="text-align:center"><code>t</code></td>
<td style="text-align:center">更直观的方式展示task/cpu信息，像htop一样</td>
</tr>
<tr>
<td style="text-align:center"><code>m</code></td>
<td style="text-align:center">更直观的方式展示memory信息，像htop一样</td>
</tr>
<tr>
<td style="text-align:center"><code>M</code></td>
<td style="text-align:center">根据内存使用率进行排序，%MEM列</td>
</tr>
<tr>
<td style="text-align:center"><code>P</code></td>
<td style="text-align:center">根据CPU使用率进行排序，%CPU列</td>
</tr>
</tbody>
</table>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><blockquote>
<p>参考：<a href="https://www.cnblogs.com/edwardlost/archive/2010/09/17/1829145.html" target="_blank" rel="noopener">sed命令详解</a></p>
</blockquote>
<h3 id="将当前目录-包括子目录-文件中的特定字符串并进行替换"><a href="#将当前目录-包括子目录-文件中的特定字符串并进行替换" class="headerlink" title="将当前目录(包括子目录)文件中的特定字符串并进行替换"></a>将当前目录(包括子目录)文件中的特定字符串并进行替换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i s/jpeg_encode.h/jpeg_codec.h/g `grep jpeg_encode.h -rl --include="*.c" ./`</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-i</code> :表示操作的是文件</li>
<li><code>反引号</code> :表示将grep命令的的结果作为操作文件</li>
</ul>
<h3 id="当前目录文件替换"><a href="#当前目录文件替换" class="headerlink" title="当前目录文件替换"></a>当前目录文件替换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i s/xxxx/yyyy/g ./*.txt</span><br></pre></td></tr></table></figure>
<h2 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h2><blockquote>
<p>用于获得某一个库/模块的所有编译相关的信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">pkg-config --libs --cflags gl</span></span><br><span class="line">-I/usr/include/libdrm -lGL</span><br></pre></td></tr></table></figure>
<h3 id="pkg-config默认的搜索路径"><a href="#pkg-config默认的搜索路径" class="headerlink" title="pkg-config默认的搜索路径"></a>pkg-config默认的搜索路径</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">pkg-config --variable pc_path pkg-config</span></span><br><span class="line">/usr/local/lib/x86_64-linux-gnu/pkgconfig:/usr/local/lib/pkgconfig:/usr/local/share/pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig</span><br></pre></td></tr></table></figure>
<h3 id="PKG-CONFIG-PATH"><a href="#PKG-CONFIG-PATH" class="headerlink" title="PKG_CONFIG_PATH"></a>PKG_CONFIG_PATH</h3><p>配置pkgconfig文件路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>
<h2 id="运行时库的连接"><a href="#运行时库的连接" class="headerlink" title="运行时库的连接"></a>运行时库的连接</h2><ul>
<li>在环境变量<code>LD_LIBRARY_PATH</code>中指明库的搜索路径。</li>
<li>在<code>/etc/ld.so.conf</code>文件中添加库的搜索路径。</li>
</ul>
<h3 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h3><p>配置运行时加载库的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<h2 id="命令行直接打开浏览器进入指定网页"><a href="#命令行直接打开浏览器进入指定网页" class="headerlink" title="命令行直接打开浏览器进入指定网页"></a>命令行直接打开浏览器进入指定网页</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$firefox --new-window https://winddoing.github.io</span><br></pre></td></tr></table></figure>
<h2 id="命令行直接打开文件管理（ubuntu）"><a href="#命令行直接打开文件管理（ubuntu）" class="headerlink" title="命令行直接打开文件管理（ubuntu）"></a>命令行直接打开文件管理（ubuntu）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$nautilus</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/my-blog/archive/2008/12/10/1351753.html" target="_blank" rel="noopener">minicom中文手册</a></li>
</ol>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Git操作</title>
    <url>/post/53101.html</url>
    <content><![CDATA[<p>记录平时对git的使用方法和技巧</p>
<a id="more"></a>
<h2 id="创建本地git库"><a href="#创建本地git库" class="headerlink" title="创建本地git库"></a>创建本地git库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir test.git</span><br></pre></td></tr></table></figure>
<p>进入test.git<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init --bare --shared</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Window下进行跨平台的clone操作，下载链接前需要添加<code>ssh</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; git remote add origin ssh://hostname@192.168.1.1:/test.git</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Linux:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; git remote add origin hostname@192.168.1.1:/test.git</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch branch_name</span><br></pre></td></tr></table></figure>
<p>删除本地分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d branch_name</span><br></pre></td></tr></table></figure></p>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout  branch_name</span><br></pre></td></tr></table></figure>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone  URL</span><br></pre></td></tr></table></figure>
<p>下载较大工程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 URL</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>depth用于指定克隆深度，为1即表示只克隆最近一次commit.</p>
</blockquote>
<h2 id="创建本地镜像仓库"><a href="#创建本地镜像仓库" class="headerlink" title="创建本地镜像仓库"></a>创建本地镜像仓库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --mirror &lt;URL&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新镜像库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote update</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<h3 id="日志规范"><a href="#日志规范" class="headerlink" title="日志规范"></a>日志规范</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul>
<li><code>feat</code>：新功能（feature）</li>
<li><code>fix</code>：修补bug</li>
<li><code>docs</code>：文档（documentation）</li>
<li><code>style</code>： 格式（不影响代码运行的变动）</li>
<li><code>refactor</code>：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li><code>test</code>：增加测试</li>
<li><code>chore</code>：构建过程或辅助工具的变动</li>
</ul>
<h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<h4 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h4><p>subject是 commit 目的的简短描述，不超过50个字符。填写要求：以动词开头</p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push 远程库名  分支名</span><br></pre></td></tr></table></figure>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull 远程库名  分支名</span><br></pre></td></tr></table></figure>
<h2 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add -A    #添加所有修改</span><br></pre></td></tr></table></figure>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git log -n     #查看前n条日志</span><br><span class="line">git log --stat  #查看日志的修改情况</span><br><span class="line">git log -p       #查看日志的具体修改</span><br><span class="line">git log &lt;filename/dirname&gt;  #查看该文件或目录的修改日志</span><br><span class="line">git log -S [keyword]  #在提交log中搜索关键词</span><br></pre></td></tr></table></figure>
<h3 id="tig"><a href="#tig" class="headerlink" title="tig"></a>tig</h3><blockquote>
<p>命令行下查看git历史提交记录的工具</p>
</blockquote>
<h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt; #将该文件从缓冲区撤回</span><br></pre></td></tr></table></figure>
<h2 id="查看远程库"><a href="#查看远程库" class="headerlink" title="查看远程库"></a>查看远程库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>添加远程库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="获取远程库中的最新版本，但与git-pull-不同它不会merge"><a href="#获取远程库中的最新版本，但与git-pull-不同它不会merge" class="headerlink" title="获取远程库中的最新版本，但与git pull 不同它不会merge"></a>获取远程库中的最新版本，但与git pull 不同它不会merge</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  fetch  远程库名  分支名</span><br></pre></td></tr></table></figure>
<p>作用：可以对比远程库与当前本地的差异。</p>
<h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>作用：一个稳定的版本或者完成一个功能，为了发布或者保存而打的标签，主要是发布</p>
<h2 id="切换标签"><a href="#切换标签" class="headerlink" title="切换标签"></a>切换标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;Tag&gt;</span><br></pre></td></tr></table></figure>
<h2 id="暂存当前改动"><a href="#暂存当前改动" class="headerlink" title="暂存当前改动"></a>暂存当前改动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<blockquote>
<p>保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行git status命令，就会发现当前是一个干净的工作区，没有任何改动。使用git stash save ‘message…’可以添加一些注释</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<blockquote>
<p>显示保存进度的列表。也就意味着，git stash命令可以多次执行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop [–index] [stash_id]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash apply [–index] [stash_id]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了不删除恢复的进度之外，其余和git stash pop 命令一样。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash drop [stash_id]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除所有存储的进度。</p>
</blockquote>
<h2 id="恢复本地错误操作"><a href="#恢复本地错误操作" class="headerlink" title="恢复本地错误操作"></a>恢复本地错误操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git reflog -h</span><br><span class="line">usage: git reflog [ show | expire | delete ]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>show</code>: 显示所有条目,缺省值</li>
<li><code>expire</code>: 删除掉更老的reflog条目</li>
<li><code>delete</code>: 从reflog中删除一个条目</li>
</ul>
</blockquote>
<h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><ol>
<li><p>添加模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule add projectB.git projectB</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用子模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>克隆项目后，默认子模块目录下无任何内容。需要在项目根目录执行此命令完成子模块的下载</p>
<p><strong>在clone整个项目时添加递归参数:<code>--recurse-submodules</code></strong></p>
</blockquote>
<ol start="3">
<li><p>删除子模块</p>
<ol>
<li><code>rm -rf 子模块目录</code> 删除子模块目录及源码</li>
<li><code>vi .gitmodules</code> 删除项目目录下.gitmodules文件中子模块相关条目</li>
<li><code>vi .git/config</code> 删除配置项中子模块相关条目</li>
<li><code>rm .git/module/*</code> 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可</li>
</ol>
</li>
</ol>
<p>执行完成后，再执行添加子模块命令即可，如果仍然报错，执行如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm --cached 子模块名称</span><br></pre></td></tr></table></figure></p>
<h2 id="commit统计"><a href="#commit统计" class="headerlink" title="commit统计"></a>commit统计</h2><p>可以大致了解一下每个人对这个项目提交的commit数量和大致的贡献度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git summary</span><br></pre></td></tr></table></figure>
<h2 id="git获取最近一次提交的commit-id"><a href="#git获取最近一次提交的commit-id" class="headerlink" title="git获取最近一次提交的commit-id"></a>git获取最近一次提交的commit-id</h2><ul>
<li><p>获取完整commit id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rev-parse HEAD</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取short commit id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rev-parse --short HEAD</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="git无法忽略target-或者不生效的情况"><a href="#git无法忽略target-或者不生效的情况" class="headerlink" title=".git无法忽略target,或者不生效的情况"></a>.git无法忽略target,或者不生效的情况</h2><p><code>.gitignore</code>未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;update .gitignore&apos;</span><br></pre></td></tr></table></figure>
<h2 id="强制更新代码"><a href="#强制更新代码" class="headerlink" title="强制更新代码"></a>强制更新代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master --force</span><br></pre></td></tr></table></figure>
<ul>
<li>错误：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: error: denying non-fast-forward refs/heads/master (you should pull first)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>该消息表示您不允许进行非快进推送, 远程存储库很可能在其配置中<code>denyNonFastforwards = true</code>, 要更改设置，请执行<code>git config receive.denynonfastforwards false</code></p>
</blockquote>
<h2 id="从git中打包代码"><a href="#从git中打包代码" class="headerlink" title="从git中打包代码"></a>从git中打包代码</h2><ul>
<li><p>打包某一个分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git archive --format=tar.gz --output &quot;output.tar.gz&quot; master</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包某一个commit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git archive --format=tar.gz --output &quot;output.tar.gz&quot; ac1c53d</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包某些目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git archive --format=tar.gz --output &quot;output.tar.gz&quot; master dir1 dir2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h2><ul>
<li><p>合并指定分支到当前分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge [branch_name]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择一个commit，合并到当前分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick [branch_name]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><ul>
<li>查看指定文件什么人在什么时间修改过<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git blame [filename]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="git服务器"><a href="#git服务器" class="headerlink" title="git服务器"></a>git服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git daemon --export-all --verbose --base-path=.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--export-all</code>: “–base-path”下所有的repo仓库</li>
<li><code>--base-path=.</code>: 定义为当前目录</li>
<li><code>--verbose</code>: 任何操作都会给当前repo通知</li>
</ul>
<h2 id="svn仓库迁移至git"><a href="#svn仓库迁移至git" class="headerlink" title="svn仓库迁移至git"></a>svn仓库迁移至git</h2><ul>
<li>svn的日志提交者与git相关用户进行绑定<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn log -q | awk -F &apos;|&apos; &apos;/^r/ &#123;sub(&quot;^ &quot;, &quot;&quot;, $2); sub(&quot; $&quot;, &quot;&quot;, $2); print $2&quot; = &quot;$2&quot; &lt;&quot;$2&quot;&gt;&quot;&#125;&apos; | sort -u &gt; users.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>users.txt</code>的意义仅在于，将svn里面的提交者日志，注意是提交者，不是svn里面所有的用户信息都得关联</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaa = git-aaa &lt;aaa@xx.com&gt; #用户名 邮件地址</span><br><span class="line">bbb = git-bbb &lt;bbb@xx.com&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>git-svn</code>进行下载并提交</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install git-svn</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git svn clone &lt;SVN_URL&gt; --no-metadata --trunk=&quot;svnproject&quot; --tags=&quot;tags&quot; --branches=&quot;svnbranches&quot; --authors-file=users.txt --preserve-empty-dirs project-dir</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--no-metadata</code>: 阻止git导出SVN包含的一些无用信息</li>
<li><code>--trunk=&quot;svnproject&quot;</code>: 指定导出仓库的主干项目路径，默认trunk</li>
<li><code>--tags=&quot;tags&quot;</code>: 日志标记</li>
<li><code>--branches=&quot;svnbranches&quot;</code>: 指定svn的分支项目路径</li>
<li><code>--authors-file=users.txt</code>: 指定svn帐号在git中的映射</li>
<li><code>--preserve-empty-dirs</code>: 保留原SVN项目中的空目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;GIT-URL&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master #--all</span><br></pre></td></tr></table></figure>
<h2 id="修改已提交的用户名和邮箱"><a href="#修改已提交的用户名和邮箱" class="headerlink" title="修改已提交的用户名和邮箱"></a>修改已提交的用户名和邮箱</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git filter-branch --commit-filter '</span><br><span class="line">if [ "$GIT_AUTHOR_EMAIL" = "old_email@email.com" ];</span><br><span class="line">then</span><br><span class="line">    GIT_AUTHOR_NAME="new_name";</span><br><span class="line">    GIT_AUTHOR_EMAIL="new_email@email.com";</span><br><span class="line">    git commit-tree "$@";</span><br><span class="line">else</span><br><span class="line">    git commit-tree "$@";</span><br><span class="line">    fi' HEAD</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注</strong>:可以修改但是在github中还是可以看到之前的用户名,效果不太好</p>
</blockquote>
<ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">7.6 Git 工具 - 重写历史</a></li>
</ul>
<h2 id="命令行工具——tig"><a href="#命令行工具——tig" class="headerlink" title="命令行工具——tig"></a>命令行工具——tig</h2><ul>
<li>commit操作： <code>上/下键</code>可以选择log中的commit</li>
<li>查看修改信息： <code>j/k</code></li>
<li>展示commit-id： <code>shift+x</code></li>
</ul>
<h2 id="删除已删除文件或目录的所以历史记录"><a href="#删除已删除文件或目录的所以历史记录" class="headerlink" title="删除已删除文件或目录的所以历史记录"></a>删除已删除文件或目录的所以历史记录</h2><ul>
<li><p>删除文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch pom.xml' --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git filter-branch --force --index-filter 'git rm --cached -r --ignore-unmatch qemu/qemu-4.2.0/' --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除回收</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf .git/refs/original/</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="rebase方式合并分支，分支在一条线"><a href="#rebase方式合并分支，分支在一条线" class="headerlink" title="rebase方式合并分支，分支在一条线"></a>rebase方式合并分支，分支在一条线</h2><ol>
<li><p>checkout到需要合并的分支feature</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>在feature分支上合并master分支的修改，生成一个新的分支版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果存在冲突解决冲突</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git mergetool</span><br><span class="line">git rebase —continue</span><br></pre></td></tr></table></figure>
</li>
<li><p>checkout到master分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并新的feature分支到master分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并完毕，可以删除feature分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch --delete feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交更新</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master --force</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="删除已提交的commit"><a href="#删除已提交的commit" class="headerlink" title="删除已提交的commit"></a>删除已提交的commit</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i [commit-id]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>commit-id: 为要删除的commit的下一个commit号</p>
</blockquote>
<p>示例：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick 1821834 add gnuplot test</span><br><span class="line">pick 5522ce1 add gnuplot test shell</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Rebase e6fcac3..5522ce1 onto e6fcac3 (2 commands)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Commands:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> e, edit &lt;commit&gt; = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> f, fixup &lt;commit&gt; = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x, <span class="built_in">exec</span> &lt;<span class="built_in">command</span>&gt; = run <span class="built_in">command</span> (the rest of the line) using shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b, <span class="built_in">break</span> = stop here (<span class="built_in">continue</span> rebase later with <span class="string">'git rebase --continue'</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [<span class="comment"># &lt;oneline&gt;]</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .       create a merge commit using the original merge commit<span class="string">'s</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .       message (or the oneline, <span class="keyword">if</span> no original merge commit was</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .       specified). Use -c &lt;commit&gt; to reword the commit message.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> However, <span class="keyword">if</span> you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>将需要删除的commit前面的<code>pick</code>改写为<code>drop</code>后，保存退出</p>
</blockquote>
<ul>
<li>退出后，可能存在冲突通过<code>git mergetool</code>解决掉冲突后，使用<code>git rebase —continue</code>继续直到解决完所有冲突提示rebase成功，删除完成。</li>
<li>如果中途不想删除后，可以通过<code>git rebase --abort</code>终止删除动作</li>
</ul>
<h2 id="仓库地址为http时-用户名密码保存"><a href="#仓库地址为http时-用户名密码保存" class="headerlink" title="仓库地址为http时,用户名密码保存"></a>仓库地址为http时,用户名密码保存</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要在第一次使用该仓库时,输入用户名密码后,会以配置文件(.git-credentials)保存到本地,后期使用不再需要输入用户名密码</p>
</blockquote>
<p>删除保存的用户名密码配置文件:<code>rm ~/.git-credentials</code></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --add core.compression -1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>compression 是压缩的意思，从clone的终端输出就知道，服务器会压缩目标文件，然后传输到客户端，客户端再解压。取值为 [-1, 9]，-1 以 zlib 为默认压缩库，0 表示不进行压缩，1..9 是压缩速度与最终获得文件大小的不同程度的权衡，数字越大，压缩越慢，当然得到的文件会越小。</p>
</blockquote>
<h2 id="DoTo"><a href="#DoTo" class="headerlink" title="DoTo"></a>DoTo</h2><ol>
<li><a href="http://blog.jobbole.com/109466/" target="_blank" rel="noopener">Git 最佳实践：分支管理</a></li>
<li><a href="https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git-config.html" target="_blank" rel="noopener">git-config(1) Manual Page</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Cgroup框架的实现</title>
    <url>/post/3438.html</url>
    <content><![CDATA[<p>CGoup核心主要创建一系列sysfs文件，用户空间可以通过这些节点控制CGroup各子系统行为，以及各子系统模块根据参数。在执行过程中或调度进程到不同CPU上，或控制CPU占用时间，或控制IO带宽等等。另外，在每个系统的proc文件系统中都有一个cgroup，显示该进程对应的CGroup各子系统信息。</p>
<p><img src="/images/cgroup/cgroup_struct.png" alt="cgroup strutc"></p>
<a id="more"></a>
<h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol: CGROUPS [=y]</span><br><span class="line">Type  : boolean</span><br><span class="line">Prompt: Control Group support</span><br><span class="line">  Location:</span><br><span class="line">      -&gt; General setup</span><br><span class="line"></span><br><span class="line">Symbol: CGROUP_SCHED [=y]</span><br><span class="line">Type  : boolean</span><br><span class="line">Prompt: Group CPU scheduler</span><br><span class="line">  Location:</span><br><span class="line">      -&gt; General setup</span><br><span class="line">	        -&gt; Control Group support (CGROUPS [=y])</span><br></pre></td></tr></table></figure>
<p>通过<code>CONFIG_CGROUPS</code>配置cgroup框架的实现,<code>CONFIG_CGROUP_SCHED</code>控制CPU子系统。</p>
<h2 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mount -t cgroup -o cpu cgroup /mnt/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir tst_cgroup</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rmdir tst_cgroup</span></span><br></pre></td></tr></table></figure>
<p>在文件系统中cgroup的挂载目录,也就是cgroup虚拟文件系统的根目录用数据结构<code>struct cgroupfs_root</code>表示.而cgroup用<code>struct cgroup</code>表示.</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>主要用于对进程不同资源的管理和配置，以及进程和cgroup之间的关系。</p>
<h3 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* Control Group info protected by css_set_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> __<span class="title">rcu</span> *<span class="title">cgroups</span>;</span></span><br><span class="line">	<span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct task_struct</code>中并没有一个直接的成员指向cgroup,而是指向了<code>struct css_set</code>的结构, css_set存储路与进程相关的cgroup信息。</p>
<p><code>cg_list</code>: 是一个链表结构，用于将连到同一个css_set的进程组织成一个链表。</p>
<h3 id="css-set"><a href="#css-set" class="headerlink" title="css_set"></a>css_set</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A css_set is a structure holding pointers to a set of</span></span><br><span class="line"><span class="comment"> * cgroup_subsys_state objects. This saves space in the task struct</span></span><br><span class="line"><span class="comment"> * object and speeds up fork()/exit(), since a single inc/dec and a</span></span><br><span class="line"><span class="comment"> * list_add()/del() can bump the reference count on the entire cgroup</span></span><br><span class="line"><span class="comment"> * set for a task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reference count */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> refcount;  <span class="comment">//引用计数，因为一个css_set可以被多个进程共用，这些进程的cgroup信息相同</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List running through all cgroup groups in the same hash</span></span><br><span class="line"><span class="comment">	 * slot. Protected by css_set_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List running through all tasks using this cgroup</span></span><br><span class="line"><span class="comment">	 * group. Protected by css_set_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List of cg_cgroup_link objects on link chains from</span></span><br><span class="line"><span class="comment">	 * cgroups referenced from this css_set. Protected by</span></span><br><span class="line"><span class="comment">	 * css_set_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">//由cg_cgroup_link组成的链表，链表上每一项cg_cgroup_link都指向和css_set关联的cgroup.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_links</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set of subsystem states, one for each subsystem. This array</span></span><br><span class="line"><span class="comment">	 * is immutable after creation apart from the init_css_set</span></span><br><span class="line"><span class="comment">	 * during subsystem registration (at boot time) and modular subsystem</span></span><br><span class="line"><span class="comment">	 * loading/unloading.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *css_set关联的css.每一个subsystem对应数组中相应id的项。</span></span><br><span class="line"><span class="comment">     *subsys应当包括所有子系统的css.如果此css_set没有制定某个subsystem的css或者subsystem没有mount，则默认初始化为根css.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span> <span class="comment">//是进程与一个特定子系统相关的信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For RCU-protected deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/cgroup.h</p>
</blockquote>
<p>主要用来描述一个个子系统，通过<code>cgroup_subsys_state</code>定义不同子系统的相关控制信息，<code>hlist</code>将同一个子系统下的所有css_set组织成一个hash表，方便内核查找特定的css_set.<br><code>tasks</code>指向所有连到此css_set的进程连成的链表。</p>
<p>那从<code>struct css_set</code>怎么转换到cgroup呢? 再来看一个辅助的数据结构<code>struct cg_cgroup_link</code></p>
<h3 id="cgroup-subsys-state"><a href="#cgroup-subsys-state" class="headerlink" title="cgroup_subsys_state"></a>cgroup_subsys_state</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Per-subsystem/per-cgroup state maintained by the system. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The cgroup that this subsystem is attached to. Useful</span></span><br><span class="line"><span class="comment">     * for subsystems that want to know about the cgroup</span></span><br><span class="line"><span class="comment">     * hierarchy structure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgroup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * State maintained by the cgroup system to allow subsystems</span></span><br><span class="line"><span class="comment">     * to be "busy". Should be accessed via css_get(),</span></span><br><span class="line"><span class="comment">     * css_tryget() and css_put().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_t</span> refcnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="comment">/* ID for this css, if possible */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">css_id</span> __<span class="title">rcu</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to put @cgroup-&gt;dentry on the last css_put() */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">dput_work</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/cgroup.h</p>
</blockquote>
<p>cgroup指针指向了一个cgroup结构，也就是进程属于的cgroup.</p>
<p>进程受到子系统的控制，实际上是通过加入到特定的cgroup实现的，因为cgroup在特定的层级上，而子系统又是附加到曾经上的 。通过以上三个结构，进程就可以和cgroup关联起来了 ：</p>
<blockquote>
<p>task_struct-&gt;css_set-&gt;cgroup_subsys_state-&gt;cgroup。</p>
</blockquote>
<p><img src="/images/cgroup/task_cgroup_relation.png" alt="task cgroup"></p>
<h3 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;		<span class="comment">/* "unsigned long" so bitops work */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * count users of this cgroup. &gt;0 means busy, but doesn't</span></span><br><span class="line"><span class="comment">	 * necessarily indicate the number of tasks in the cgroup</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> id;				<span class="comment">/* ida allocated in-hierarchy ID */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We link our 'sibling' struct into our parent's 'children'.</span></span><br><span class="line"><span class="comment">	 * Our children link their 'sibling' into our 'children'.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>	<span class="comment">/* my parent's children */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>	<span class="comment">/* my children */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">files</span>;</span>		<span class="comment">/* my files */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">parent</span>;</span>		<span class="comment">/* my parent */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span>		<span class="comment">/* cgroup fs entry, RCU protected */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a copy of dentry-&gt;d_name, and it's needed because</span></span><br><span class="line"><span class="comment">	 * we can't use dentry-&gt;d_name in cgroup_path().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * You must acquire rcu_read_lock() to access cgrp-&gt;name, and</span></span><br><span class="line"><span class="comment">	 * the only place that can change it is rename(), which is</span></span><br><span class="line"><span class="comment">	 * protected by parent dir's i_mutex.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Normally you should use cgroup_name() wrapper rather than</span></span><br><span class="line"><span class="comment">	 * access it directly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_name</span> __<span class="title">rcu</span> *<span class="title">name</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Private pointers for each registered subsystem */</span></span><br><span class="line">    <span class="comment">//此cgroup关联subsystem的css结构，每个subsystem的css在数组中对应subsys[subsystem-&gt;subsys_id].</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroupfs_root</span> *<span class="title">root</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List of cg_cgroup_links pointing at css_sets with</span></span><br><span class="line"><span class="comment">	 * tasks in this cgroup. Protected by css_set_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">css_sets</span>;</span> <span class="comment">//通过cs_cgroup_link指向此cgroup关联的css_set</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">allcg_node</span>;</span>	<span class="comment">/* cgroupfs_root-&gt;allcg_list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cft_q_node</span>;</span>	<span class="comment">/* used during cftype add/rm */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Linked list running through all cgroups that can</span></span><br><span class="line"><span class="comment">	 * potentially be reaped by the release agent. Protected by</span></span><br><span class="line"><span class="comment">	 * release_list_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">release_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * list of pidlists, up to two for each namespace (one for procs, one</span></span><br><span class="line"><span class="comment">	 * for tasks); created on demand.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pidlists</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">pidlist_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For RCU-protected deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">free_work</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List of events which userspace want to receive */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">event_list</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> event_list_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* directory xattrs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">simple_xattrs</span> <span class="title">xattrs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sibling</code>,<code>children</code>和<code>parent</code>三个list_head负责将同一层级的cgroup连接成一颗cgroup树。</li>
<li><code>subsys</code>是一个指针数组，存储一组指向cgroup_subsys_state的指针。这组指针指向了此cgroup跟各个子系统相关的信息</li>
<li><code>root</code>指向了一个cgroupfs_root的结构，就是cgroup所在的层级对应的结构体</li>
</ul>
<p>cgroup和css_set是多对多的关系，既：一个css_set可以对应多个cgroup,同时一个cgroup也可以被多个css_set所包含。<br>这种多对多的映射关系，是通过cg_cgroup_link这个中间结构来关联的。</p>
<h3 id="cg-cgroup-link"><a href="#cg-cgroup-link" class="headerlink" title="cg_cgroup_link"></a>cg_cgroup_link</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Link structure for associating css_set objects with cgroups */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cg_cgroup_link</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * List running through cg_cgroup_links associated with a</span></span><br><span class="line"><span class="comment">     * cgroup, anchored on cgroup-&gt;css_sets</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cgrp_link_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgrp</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * List running through cg_cgroup_links pointing at a</span></span><br><span class="line"><span class="comment">     * single css_set object, anchored on css_set-&gt;cg_links</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_link_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> *<span class="title">cg</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个cg_cgroup_link需要包含两类信息，即关联的cgroup和css_set信息，一个cg_cgroup_link可以让一个cgroup和一个css_set相关联。但是正如我们前面所说，css_set和cgroup是多对多的对应关系，所以，一个css_set需要保存多个cg_cgroup_link，一个cgroup也需要保存多个cg_cgroup_link信息。具体来说，css_set中的cg_links维护了一个链表，链表中的元素为cg_cgroup_link中的cg_link_list.cgroup中的css_set也维护了一个cg_cgroup_link链表，链表中元素为cgrp_link_list.</p>
<p><code>cgrp_link_list</code>连入到<code>cgroup-&gt;css_set</code>指向的链表，cgrp则指向此<code>cg_cgroup_link</code>相关的cgroup。</p>
<p><code>cg_link_list</code>则连入到<code>css_set-&gt;cg_links</code>指向的链表,cg则指向此<code>cg_cgroup_link</code>相关的css_set。</p>
<h3 id="cgroupfs-root"><a href="#cgroupfs-root" class="headerlink" title="cgroupfs_root"></a>cgroupfs_root</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A cgroupfs_root represents the root of a cgroup hierarchy, and may be</span></span><br><span class="line"><span class="comment"> * associated with a superblock to form an active hierarchy.  This is</span></span><br><span class="line"><span class="comment"> * internal to cgroup core.  Don't access directly from controllers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroupfs_root</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span>  <span class="comment">//cgroup文件系统的超级块</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The bitmask of subsystems intended to be attached to this</span></span><br><span class="line"><span class="comment">	 * hierarchy</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> subsys_mask; <span class="comment">//hierarchy相关联的subsys 位图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unique id for this hierarchy. */</span></span><br><span class="line">	<span class="keyword">int</span> hierarchy_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The bitmask of subsystems currently attached to this hierarchy */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> actual_subsys_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* A list running through the attached subsystems */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">subsys_list</span>;</span> <span class="comment">//hierarchy中的subsys链表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The root cgroup for this hierarchy */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> <span class="title">top_cgroup</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tracks how many cgroups are currently defined in hierarchy.*/</span></span><br><span class="line">	<span class="keyword">int</span> number_of_cgroups;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* A list running through the active hierarchies */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">root_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All cgroups on this root, cgroup_mutex protected */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">allcg_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hierarchy-specific flags */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IDs for cgroups in this hierarchy */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ida</span> <span class="title">cgroup_ida</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The path to use for release notifications. */</span></span><br><span class="line">	<span class="keyword">char</span> release_agent_path[PATH_MAX];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The name for this hierarchy - may be empty */</span></span><br><span class="line">	<span class="keyword">char</span> name[MAX_CGROUP_ROOT_NAMELEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>top_cgroup</code>指向了所在层级的根cgroup，也就是创建层级时自动创建的那个cgroup。</p>
<h3 id="cgroup-subsys"><a href="#cgroup-subsys" class="headerlink" title="cgroup_subsys"></a>cgroup_subsys</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Control Group subsystem type.</span></span><br><span class="line"><span class="comment"> * See Documentation/cgroups/cgroups.txt for details</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *(*<span class="title">css_alloc</span>)(<span class="title">struct</span> <span class="title">cgroup</span> *<span class="title">cgrp</span>);</span></span><br><span class="line">    <span class="keyword">int</span> (*css_online)(struct cgroup *cgrp);</span><br><span class="line">    <span class="keyword">void</span> (*css_offline)(struct cgroup *cgrp);</span><br><span class="line">    <span class="keyword">void</span> (*css_free)(struct cgroup *cgrp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*allow_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);</span><br><span class="line">    <span class="keyword">int</span> (*can_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);</span><br><span class="line">    <span class="keyword">void</span> (*cancel_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">attach</span>)(struct cgroup *cgrp, struct cgroup_taskset *tset);</span><br><span class="line">    <span class="keyword">void</span> (*fork)(struct task_struct *task);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">exit</span>)(struct cgroup *cgrp, struct cgroup *old_cgrp,</span><br><span class="line">             struct task_struct *task);</span><br><span class="line">    <span class="keyword">void</span> (*bind)(struct cgroup *root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> subsys_id;</span><br><span class="line">    <span class="keyword">int</span> disabled;</span><br><span class="line">    <span class="keyword">int</span> early_init;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * True if this subsys uses ID. ID is not available before cgroup_init()</span></span><br><span class="line"><span class="comment">     * (not available in early_init time.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">bool</span> use_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If %false, this subsystem is properly hierarchical -</span></span><br><span class="line"><span class="comment">     * configuration, resource accounting and restriction on a parent</span></span><br><span class="line"><span class="comment">     * cgroup cover those of its children.  If %true, hierarchy support</span></span><br><span class="line"><span class="comment">     * is broken in some ways - some subsystems ignore hierarchy</span></span><br><span class="line"><span class="comment">     * completely while others are only implemented half-way.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It's now disallowed to create nested cgroups if the subsystem is</span></span><br><span class="line"><span class="comment">     * broken and cgroup core will emit a warning message on such</span></span><br><span class="line"><span class="comment">     * cases.  Eventually, all subsystems will be made properly</span></span><br><span class="line"><span class="comment">     * hierarchical and this will go away.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> broken_hierarchy;</span><br><span class="line">     <span class="keyword">bool</span> warned_broken_hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CGROUP_TYPE_NAMELEN 32</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Link to parent, and list entry in parent's children.</span></span><br><span class="line"><span class="comment">      * Protected by cgroup_lock()</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cgroupfs_root</span> *<span class="title">root</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span></span><br><span class="line">     <span class="comment">/* used when use_id == true */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">idr</span>;</span></span><br><span class="line">     <span class="keyword">spinlock_t</span> id_lock;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* list of cftype_sets */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cftsets</span>;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* base cftypes, automatically [de]registered with subsys itself */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> *<span class="title">base_cftypes</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cftype_set</span> <span class="title">base_cftset</span>;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* should be defined only by modular subsystems */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>Cgroup_subsys定义了一组操作，让各个子系统根据各自的需要去实现。这个相当于C++中抽象基类，然后各个特定的子系统对应cgroup_subsys则是实现了相应操作的子类。类似的思想还被用在了cgroup_subsys_state中，cgroup_subsys_state并未定义控制信息，而只是定义了各个子系统都需要的共同信息，比如该cgroup_subsys_state从属的cgroup。然后各个子系统再根据各自的需要去定义自己的进程控制信息结构体，最后在各自的结构体中将cgroup_subsys_state包含进去，这样通过Linux内核的container_of等宏就可以通过cgroup_subsys_state来获取相应的结构体。</p>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p><img src="/images/cgroup/cgroup_data_struct.jpeg" alt="cgroup data struct"></p>
<table>
<thead>
<tr>
<th style="text-align:center">数据结构</th>
<th style="text-align:center">划分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cgroupfs_root</td>
<td style="text-align:center">层级（hierarchy）</td>
</tr>
<tr>
<td style="text-align:center">css_set</td>
<td style="text-align:center">子系统（subsystem）</td>
</tr>
<tr>
<td style="text-align:center">cgroup</td>
<td style="text-align:center">进程控制组</td>
</tr>
</tbody>
</table>
<h2 id="cgroup初始化"><a href="#cgroup初始化" class="headerlink" title="cgroup初始化"></a>cgroup初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">	\-&gt;cgroup_init_early();</span><br><span class="line">		\-&gt;init_cgroup_root</span><br><span class="line">		\-&gt;cgroup_init_subsys</span><br><span class="line">	\-&gt;cgroup_init();</span><br><span class="line">		\-&gt;cgroup_init_subsys</span><br><span class="line">		\-&gt;kobject_create_and_add</span><br><span class="line">		\-&gt;register_filesystem</span><br></pre></td></tr></table></figure>
<h3 id="cgroup-init-early"><a href="#cgroup-init-early" class="headerlink" title="cgroup_init_early"></a>cgroup_init_early</h3><p>第一阶段：主要进行数据结构的初始化和链表之间关系的绑定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">cgroup_init_early</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atomic_set(&amp;init_css_set.refcount, <span class="number">1</span>);</span><br><span class="line">    INIT_LIST_HEAD(&amp;init_css_set.cg_links); <span class="comment">//初始化全局结构体struct css_set init</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;init_css_set.tasks);</span><br><span class="line">    INIT_HLIST_NODE(&amp;init_css_set.hlist);</span><br><span class="line">    css_set_count = <span class="number">1</span>;  <span class="comment">//系统中struct css_set计数</span></span><br><span class="line">    init_cgroup_root(&amp;rootnode); <span class="comment">//初始化全局结构体struct cgroupfs_root</span></span><br><span class="line">    root_count = <span class="number">1</span>;		<span class="comment">//系统中的层级计数</span></span><br><span class="line">    init_task.cgroups = &amp;init_css_set; <span class="comment">//使系统的初始化进程cgroup指向init_css_set</span></span><br><span class="line"></span><br><span class="line">    init_css_set_link.cg = &amp;init_css_set;</span><br><span class="line">	<span class="comment">/* dummytop is a shorthand for the dummy hierarchy's top cgroup */</span></span><br><span class="line">    init_css_set_link.cgrp = dummytop;</span><br><span class="line"></span><br><span class="line">    list_add(&amp;init_css_set_link.cgrp_link_list,</span><br><span class="line">         &amp;rootnode.top_cgroup.css_sets);</span><br><span class="line">    list_add(&amp;init_css_set_link.cg_link_list,</span><br><span class="line">         &amp;init_css_set.cg_links);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对一些需要在系统启动时初始化的subsys进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CGROUP_SUBSYS_COUNT; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">ss</span> = <span class="title">subsys</span>[<span class="title">i</span>];</span></span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span> (ss-&gt;early_init)</span><br><span class="line">            cgroup_init_subsys(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cgroup-init"><a href="#cgroup-init" class="headerlink" title="cgroup_init"></a>cgroup_init</h3><p>第二阶段： 主要生成cgroup虚拟文件系统</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cgroup_init - cgroup initialization</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Register cgroup filesystem and /proc file, and initialize</span></span><br><span class="line"><span class="comment"> * any subsystems that didn't request early init.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">cgroup_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    err = bdi_init(&amp;cgroup_backing_dev_info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CGROUP_SUBSYS_COUNT; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">ss</span> = <span class="title">subsys</span>[<span class="title">i</span>];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* at bootup time, we don't worry about modular subsystems */</span></span><br><span class="line">        <span class="keyword">if</span> (!ss || ss-&gt;<span class="keyword">module</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ss-&gt;early_init)</span><br><span class="line">            cgroup_init_subsys(ss);</span><br><span class="line">        <span class="keyword">if</span> (ss-&gt;use_id)</span><br><span class="line">            cgroup_init_idr(ss, init_css_set.subsys[ss-&gt;subsys_id]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add init_css_set to the hash table */</span></span><br><span class="line">    key = css_set_hash(init_css_set.subsys);</span><br><span class="line">    hash_add(css_set_table, &amp;init_css_set.hlist, key);</span><br><span class="line">    BUG_ON(!init_root_id(&amp;rootnode));</span><br><span class="line">	...</span><br><span class="line">    cgroup_kobj = kobject_create_and_add(<span class="string">"cgroup"</span>, fs_kobj);</span><br><span class="line"></span><br><span class="line">    err = register_filesystem(&amp;cgroup_fs_type);</span><br><span class="line"></span><br><span class="line">    proc_create(<span class="string">"cgroups"</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;proc_cgroupstats_operations);</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.bdi_init用于初始化后备存储器的一些字段，这些字段包括回写链表、回写锁等，关系到读写策略，和挂载关系并不大</p>
<h3 id="subsys"><a href="#subsys" class="headerlink" title="subsys"></a>subsys</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUBSYS(_x) [_x ## _subsys_id] = &amp;_x ## _subsys,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_SUBSYS_ENABLED(option) IS_BUILTIN(option)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cgroup_subsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_SUBSYS_ENABLED(CONFIG_CGROUP_DEBUG)</span></span><br><span class="line">SUBSYS(debug)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: kernel/cgroup.c</p>
</blockquote>
<h2 id="cgroup文件系统的挂载"><a href="#cgroup文件系统的挂载" class="headerlink" title="cgroup文件系统的挂载"></a>cgroup文件系统的挂载</h2><blockquote>
<p>mount -t cgroup -o cpu cgroup /mnt/</p>
</blockquote>
<h3 id="注册："><a href="#注册：" class="headerlink" title="注册："></a>注册：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">cgroup_fs_type</span> = &#123;</span></span><br><span class="line">	.name = <span class="string">"cgroup"</span>,</span><br><span class="line">	.mount = cgroup_mount,</span><br><span class="line">	.kill_sb = cgroup_kill_sb,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="调用关系："><a href="#调用关系：" class="headerlink" title="调用关系："></a>调用关系：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyS_mount</span><br><span class="line">	\-&gt;do_mount</span><br><span class="line">		\-&gt;vfs_kern_mount</span><br><span class="line">			\-&gt;mount_fs</span><br><span class="line">				\-&gt;cgroup_mount</span><br><span class="line">					\-&gt;cgroup_populate_dir  //生成基础的文件属性</span><br></pre></td></tr></table></figure>
<p>cgoup基础的文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*for hysterical raisins, we can't put this on the older files*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CGROUP_FILE_GENERIC_PREFIX <span class="meta-string">"cgroup."</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> <span class="title">files</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">"tasks"</span>,</span><br><span class="line">        .<span class="built_in">open</span> = cgroup_tasks_open,</span><br><span class="line">        .write_u64 = cgroup_tasks_write,</span><br><span class="line">        .<span class="built_in">release</span> = cgroup_pidlist_release,</span><br><span class="line">        .mode = S_IRUGO | S_IWUSR,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = CGROUP_FILE_GENERIC_PREFIX <span class="string">"procs"</span>,</span><br><span class="line">        .<span class="built_in">open</span> = cgroup_procs_open,</span><br><span class="line">        .write_u64 = cgroup_procs_write,</span><br><span class="line">        .<span class="built_in">release</span> = cgroup_pidlist_release,</span><br><span class="line">        .mode = S_IRUGO | S_IWUSR,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">"notify_on_release"</span>,</span><br><span class="line">        .read_u64 = cgroup_read_notify_on_release,</span><br><span class="line">        .write_u64 = cgroup_write_notify_on_release,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = CGROUP_FILE_GENERIC_PREFIX <span class="string">"event_control"</span>,</span><br><span class="line">        .write_string = cgroup_write_event_control,</span><br><span class="line">        .mode = S_IWUGO,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">"cgroup.clone_children"</span>,</span><br><span class="line">        .flags = CFTYPE_INSANE,</span><br><span class="line">        .read_u64 = cgroup_clone_children_read,</span><br><span class="line">        .write_u64 = cgroup_clone_children_write,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">"cgroup.sane_behavior"</span>,</span><br><span class="line">        .flags = CFTYPE_ONLY_ON_ROOT,</span><br><span class="line">        .read_seq_string = cgroup_sane_behavior_show,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">"release_agent"</span>,</span><br><span class="line">        .flags = CFTYPE_ONLY_ON_ROOT,</span><br><span class="line">        .read_seq_string = cgroup_release_agent_show,</span><br><span class="line">        .write_string = cgroup_release_agent_write,</span><br><span class="line">        .max_write_len = PATH_MAX,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; &#125; <span class="comment">/* terminate */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="创建子cgroup"><a href="#创建子cgroup" class="headerlink" title="创建子cgroup"></a>创建子cgroup</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyS_mkdirat</span><br><span class="line">	\-&gt;cgroup_mkdir</span><br><span class="line">		\-&gt;cgroup_create</span><br></pre></td></tr></table></figure>
<h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><blockquote>
<p>echo $$ &gt; task</p>
</blockquote>
<p>将当前进程迁移到一个cgroup中：</p>
<p>Open:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do_sys_open</span><br><span class="line"> |-&gt;do_filp_open</span><br><span class="line">   |-&gt; path_openat.isra.13</span><br><span class="line">     |-&gt;do_last.isra.12</span><br><span class="line">       |-&gt;finish_open</span><br><span class="line">         |-&gt;do_dentry_open.isra.2</span><br><span class="line">		   |-&gt;cgroup_pidlist_open</span><br></pre></td></tr></table></figure></p>
<p>Write:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyS_write</span><br><span class="line">  |-&gt;vfs_write</span><br><span class="line">    |-&gt;cgroup_file_write</span><br><span class="line">      |-&gt;cgroup_tasks_write</span><br><span class="line">        |-&gt;attach_task_by_pid</span><br></pre></td></tr></table></figure></p>
<h2 id="DEBUG子系统实现"><a href="#DEBUG子系统实现" class="headerlink" title="DEBUG子系统实现"></a>DEBUG子系统实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> <span class="title">debug_subsys</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"debug"</span>,</span><br><span class="line">    .css_alloc = debug_css_alloc,</span><br><span class="line">    .css_free = debug_css_free,</span><br><span class="line">    .subsys_id = debug_subsys_id,</span><br><span class="line">    .base_cftypes = debug_files,</span><br><span class="line">&#125;;                                           SS</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://files.cnblogs.com/files/lisperl/cgroups%E4%BB%8B%E7%BB%8D.pdf" target="_blank" rel="noopener">Linux Cgroups 详解</a></li>
<li><a href="https://blog.csdn.net/zhangyifei216/article/details/49491549" target="_blank" rel="noopener">Cgroup框架分析</a></li>
<li><a href="http://www.xuebuyuan.com/624249.html" target="_blank" rel="noopener">Linux cgroup机制分析之框架分析</a></li>
<li><a href="http://www.cnblogs.com/arnoldlu/p/6208443.html" target="_blank" rel="noopener">Android/Linux下CGroup框架分析及其使用</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio驱动总结--ALSA</title>
    <url>/post/50356.html</url>
    <content><![CDATA[<p>接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结</p>
<a id="more"></a>
<h2 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h2><ul>
<li>Sample：样本长度(位宽)，音频数据最基本的单位，常见的有8位和16位。</li>
<li>Channel：声道数，分为单声道mono和立体声stereo。</li>
<li>Frame：帧，构成一个声音单元，Frame = Sample <em> channel, sample</em>channel/8 Byte。</li>
<li>Rate：又称Sample rate，采样率，即每秒的采样次数，针对帧而言。</li>
<li>Interleaved：交错模式，一种音频数据的记录方式，在交错模式下，数据以连续桢的形式存放，即首先记录完桢1的左声道样本和右声道样本（假设为立体声），再开始桢2的记录。而在非交错模式下，首先记录的是一个周期内所有桢的左声道样本，再记录右声道样本，数据是以连续通道的方式存储。多数情况下使用交错模式。</li>
<li>Period size：周期，每次硬件中断处理音频数据的帧数，对于音频设备的数据读写，以此为单位。</li>
<li>Buffer size：数据缓冲区大小，这里特指runtime的buffer size，而不是snd_pcm_hardware定义的buffer_bytes_max。</li>
<li>码率: (编码速率), 码率 = 采样频率 <em> 位宽 </em> 声道个数</li>
</ul>
<p><strong><em>采样率和实际的分频误差在5%左右</em></strong></p>
<blockquote>
<p><strong>Period</strong></p>
<p>The interval between interrupts from the hardware. This defines the input latency, since the CPU will not have any idea that there is data waiting until the audio interface interrupts it.</p>
<p>The audio interface has a “pointer” that marks the current position for read/write in its h/w buffer. The pointer circles around the buffer as long as the interface is running.</p>
<p>Typically, there are an integral number of periods per traversal of the h/w buffer, but not always. There is at least one card (ymfpci)<br>that generates interrupts at a fixed rate indepedent of the buffer size (which can be changed), resulting in some “odd” effects compared to more traditional designs.</p>
<p>Note: h/w generally defines the interrupt in frames, though not always.</p>
<p>Alsa’s period size setting will affect how much work the CPU does. if you set the period size low, there will be more interrupts and the work that is done every interrupt will be done more often. So, if you don’t care about low latency,<br>set the period size large as possible and you’ll have more CPU cycles for other things. The defaults that ALSA provides are in the middle of the range, typically.</p>
<p>(from an old AlsaDevel thread[1], quoting Paul Davis)</p>
<p>Retrieved from “<a href="http://alsa.opensrc.org/Period&quot;" target="_blank" rel="noopener">http://alsa.opensrc.org/Period&quot;</a></p>
<p>来自：<a href="http://alsa.opensrc.org/Period" target="_blank" rel="noopener">http://alsa.opensrc.org/Period</a></p>
<p><strong>FramesPeriods</strong></p>
<p>A frame is equivalent of one sample being played, irrespective of the number of channels or the number of bits. e.g.</p>
<ul>
<li>1 frame of a Stereo 48khz 16bit PCM stream is 4 bytes.</li>
<li>1 frame of a 5.1 48khz 16bit PCM stream is 12 bytes.<br>A period is the number of frames in between each hardware interrupt. The poll() will return once a period.<br>The buffer is a ring buffer. The buffer size always has to be greater than one period size. Commonly this is 2*period size, but some hardware can do 8 periods per buffer. It is also possible for the buffer size to not be an integer multiple of the period size.<br>Now, if the hardware has been set to 48000Hz , 2 periods, of 1024 frames each, making a buffer size of 2048 frames. The hardware will interrupt 2 times per buffer. ALSA will endeavor to keep the buffer as full as possible. Once the first period of samples has<br>been played, the third period of samples is transfered into the space the first one occupied while the second period of samples is being played. (normal ring buffer behaviour).</li>
</ul>
<p>Additional example</p>
<p>Here is an alternative example for the above discussion.<br>Say we want to work with a stereo, 16-bit, 44.1 KHz stream, one-way (meaning, either in playback or in capture direction). Then we have:</p>
<ul>
<li>‘stereo’ = number of channels: 2</li>
<li>1 analog sample is represented with 16 bits = 2 bytes</li>
<li>1 frame represents 1 analog sample from all channels; here we have 2 channels, and so:<ul>
<li>1 frame = (num_channels) <em> (1 sample in bytes) = (2 channels) </em> (2 bytes (16 bits) per sample) = 4 bytes (32 bits)</li>
</ul>
</li>
<li>To sustain 2x 44.1 KHz analog rate - the system must be capable of data transfer rate, in Bytes/sec:<ul>
<li>Bps_rate = (num_channels) <em> (1 sample in bytes) </em> (analog_rate) = (1 frame) <em> (analog_rate) = ( 2 channels ) </em> (2 bytes/sample) <em> (44100 samples/sec) = 2</em>2*44100 = 176400 Bytes/sec<br>Now, if ALSA would interrupt each second, asking for bytes - we’d need to have 176400 bytes ready for it (at end of each second), in order to sustain analog 16-bit stereo @ 44.1Khz.</li>
</ul>
</li>
<li>If it would interrupt each half a second, correspondingly for the same stream we’d need 176400/2 = 88200 bytes ready, at each interrupt;</li>
<li>if the interrupt hits each 100 ms, we’d need to have 176400*(0.1/1) = 17640 bytes ready, at each interrupt.<br>We can control when this PCM interrupt is generated, by setting a period size, which is set in frames.</li>
<li>Thus, if we set 16-bit stereo @ 44.1Khz, and the period_size to 4410 frames =&gt; (for 16-bit stereo @ 44.1Khz, 1 frame equals 4 bytes - so 4410 frames equal 4410*4 = 17640 bytes) =&gt; an interrupt will be generated each 17640 bytes - that is, each 100 ms.</li>
<li>Correspondingly, buffer_size should be at least 2<em>period_size = 2</em>4410 = 8820 frames (or 8820*4 = 35280 bytes).<br>It seems (writing-an-alsa-driver.pdf), however, that it is the ALSA runtime that decides on the actual buffer_size and period_size, depending on: the requested number of channels, and their respective properties (rate and sampling resolution) - as well as the<br>parameters set in the snd_pcm_hardware structure (in the driver).<br>Also, the following quote may be relevant, from <a href="http://mailman.alsa-project.org/pipermail/alsa-devel/2007-April/000474.html" target="_blank" rel="noopener">http://mailman.alsa-project.org/pipermail/alsa-devel/2007-April/000474.html</a>:</li>
</ul>
<blockquote>
<blockquote>
<p>The “frame” represents the unit, 1 frame = # channels x sample_bytes.<br>In your case, 1 frame corresponds to 2 channels x 16 bits = 4 bytes.</p>
<p>The periods is the number of periods in a ring-buffer.  In OSS, called<br>as “fragments”.</p>
<p>So,</p>
<ul>
<li>buffer_size = period_size * periods</li>
<li>period_bytes = period_size * bytes_per_frame</li>
<li>bytes_per_frame = channels * bytes_per_sample</li>
</ul>
</blockquote>
<p>I still don’t understand what ‘period_size’ and a ‘period’ is?</p>
</blockquote>
<p>The “period” defines the frequency to update the status, usually viathe invokation of interrupts.  The “period_size” defines the frame sizes corresponding to the “period time”.  This term corresponds to the “fragment size” on OSS.  On major sound hardwares,<br>a ring-buffer is divided to several parts and an irq is issued on each boundary. The period_size defines the size of this chunk.</p>
<p>On some hardwares, the irq is controlled on the basis of a timer.  In this case, the period is defined as the timer frequency to invoke an irq.</p>
<p>来自：<a href="http://alsa-project.org/main/index.php/FramesPeriods" target="_blank" rel="noopener">http://alsa-project.org/main/index.php/FramesPeriods</a></p>
</blockquote>
<h2 id="音频处理软件"><a href="#音频处理软件" class="headerlink" title="音频处理软件"></a>音频处理软件</h2><blockquote>
<p> Audacity 2.0.5</p>
</blockquote>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>主要由音频总线(I2S,PCM)和控制总线(I2C或SPI)组成。</p>
<p><img src="/images/audio/alsa/alsa-hardware-link.png" alt="alsa-hardware-link"></p>
<p><img src="/images/audio/alsa/audio-hardware.png" alt="audio-hardware"></p>
<h2 id="alsa-ASOC"><a href="#alsa-ASOC" class="headerlink" title="alsa - ASOC"></a>alsa - ASOC</h2><p>在内核设备驱动层，ALSA提供了alsa-driver，同时在应用层，ALSA为我们提供了alsa-lib，应用程序只要调用alsa-lib提供的API，即可以完成对底层音频硬件的控制。</p>
<p><img src="/images/audio/alsa/alsa-struct.png" alt="alsa-struct"></p>
<p>ASoC被分为<code>Machine</code>、<code>Platform</code>和<code>Codec</code>三大部分。其中的Machine驱动负责Platform和Codec之间的耦合和设备或板子特定的代码。Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。</p>
<ul>
<li>machine<br>用于描述设备组件信息和特定的控制如耳机/外放等。</li>
</ul>
<blockquote>
<p>是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个<code>载体</code>。</p>
</blockquote>
<p>这一部分将平台驱动和Codec驱动绑定在一起，描述了板级的硬件特征。主要负责Platform和Codec之间的耦合以及部分和设备或板子特定的代码。Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。ASoC的一切都从Machine驱动开始，包括声卡的注册，绑定Platform和Codec驱动等等</p>
<ul>
<li>Platform<br>用于实现平台相关的DMA驱动和音频接口等。</li>
</ul>
<blockquote>
<p>一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。</p>
</blockquote>
<p>这一部分只关心CPU本身，不关心Codec。主要处理两个问题：<code>DMA引擎</code>和<code>SoC集成的PCM、I2S或AC &#39;97数字接口控制</code>。主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：<code>snd_soc_platform_driver</code>和<code>snd_soc_dai_driver</code>。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。</p>
<ul>
<li>Codec<br>用于实现平台无关的功能，如寄存器读写接口，音频接口，各widgets的控制接口和DAPM的实现等</li>
</ul>
<blockquote>
<p>字面上的意思就是编解码器，Codec里面包含了I2S接口、D/A、A/D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。</p>
</blockquote>
<p>这一部分只关心Codec本身，与CPU平台相关的特性不由此部分操作。在移动设备中，Codec的作用可以归结为4种，分别是：</p>
<ol>
<li>对PCM等信号进行D/A转换，把数字的音频信号转换为模拟信号。</li>
<li>对Mic、Linein或者其他输入源的模拟信号进行A/D转换，把模拟的声音信号转变CPU能够处理的数字信号。</li>
<li>对音频通路进行控制，比如播放音乐，收听调频收音机，又或者接听电话时，音频信号在codec内的流通路线是不一样的。</li>
<li>对音频信号做出相应的处理，例如音量控制，功率放大，EQ控制等等。</li>
</ol>
<p>ASoC对Codec的这些功能都定义好了一些列相应的接口，以方便地对Codec进行控制。ASoC对Codec驱动的一个基本要求是：<code>驱动程序的代码必须要做到平台无关性，以方便同一个Codec的代码不经修改即可用在不同的平台上</code>。</p>
<p><img src="/images/audio/alsa/alas-asoc-arch.png" alt="alsa-asoc-arch"></p>
<p>ASoC对于Alsa来说，就是分别注册PCM/CONTROL类型的snd_device设备，并实现相应的操作方法集。图中DAI是数字音频接口，用于配置音频数据格式等。</p>
<ul>
<li>Codec驱动向ASoC注册<code>snd_soc_codec</code>和<code>snd_soc_dai</code>设备。</li>
<li>Platform驱动向ASoC注册<code>snd_soc_platform</code>和<code>snd_soc_dai</code>设备。</li>
<li>Machine驱动通过<code>snd_soc_dai_link</code>绑定codec/dai/platform.</li>
</ul>
<p>Widget是各个组件内部的小单元。处在活动通路上电，不在活动通路下电。ASoC的DAPM正是通过控制这些Widget的上下电达到动态电源管理的效果。</p>
<ul>
<li>path描述与其它widget的连接关系。</li>
<li>event用于通知该widget的上下电状态。</li>
<li>power指示当前的上电状态。</li>
<li>control实现空间用户接口用于控制widget的音量/通路切换等。</li>
</ul>
<p>对驱动开者来说，就可以很好的解耦了：</p>
<ul>
<li>codec驱动的开发者，实现codec的IO读写方法，描述DAI支持的数据格式/操作方法和Widget的连接关系就可以了;</li>
<li>soc芯片的驱动开发者，Platform实现snd_pcm的操作方法集和DAI的配置如操作 DMA，I2S/AC97/PCM的设定等;</li>
<li>板级的开发者，描述Machine上codec与platform之间的总线连接， earphone/Speaker的布线情况就可以了。</li>
</ul>
<h3 id="DAPM"><a href="#DAPM" class="headerlink" title="DAPM"></a>DAPM</h3><h3 id="DPCM"><a href="#DPCM" class="headerlink" title="DPCM"></a>DPCM</h3><blockquote>
<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/sound/soc/dpcm.rst?h=v4.16-rc5" target="_blank" rel="noopener">Dynamic PCM</a></p>
</blockquote>
<h2 id="PCM设备"><a href="#PCM设备" class="headerlink" title="PCM设备"></a>PCM设备</h2><h3 id="放音-–-应用"><a href="#放音-–-应用" class="headerlink" title="放音 – 应用"></a>放音 – 应用</h3><blockquote>
<p><code>tinyplay</code>播放音乐</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># strace  tinyplay  pcmrec.wav</span></span><br><span class="line">execve(<span class="string">"/usr/bin/tinyplay"</span>, [<span class="string">"tinyplay"</span>, <span class="string">"pcmrec.wav"</span>], [<span class="comment">/* 16 vars */</span>]) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">"pcmrec.wav"</span>, O_RDONLY)            = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//读取wav格式的音频文件的头数据</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"RIFF$\342\4\0WAVEfmt \20\0\0\0\1\0\2\0@\37\0\0\0&#125;\0\0"</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次打开`pcmC0D0p`设备节点, 重新设置硬件参数</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">"/dev/snd/pcmC0D0p"</span>, O_RDWR)       = <span class="number">4</span></span><br><span class="line"><span class="comment">//ioctl - cmd=SNDRV_PCM_IOCTL_HW_REFINE</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0xc25c4110</span>, <span class="number">0x412178</span>)          = <span class="number">0</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次打开`pcmC0D0p`设备节点, 进行音频播放的准备工作和播放</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">"/dev/snd/pcmC0D0p"</span>, O_RDWR)       = <span class="number">4</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_INFO`</span></span><br><span class="line">ioctl(<span class="number">4</span>, AGPIOC_ACQUIRE <span class="keyword">or</span> APM_IOC_STANDBY, <span class="number">0x7f83f3cc</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_HW_PARAMS`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0xc25c4111</span>, <span class="number">0x7f83f170</span>)        = <span class="number">0</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_SW_PARAMS`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0xc0684113</span>, <span class="number">0x7f83f5ec</span>)        = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在播放期间响应Ctrl+C的中断信号</span></span><br><span class="line">rt_sigaction(SIGINT, &#123;<span class="number">0x10000000</span>, [RT_65 RT_67], <span class="number">0x401240</span> <span class="comment">/* SA_??? */</span>&#125;, &#123;SIG_DFL, [RT_67 RT_68 RT_72 RT_74 RT_75 RT_77 RT_81 RT_89 RT_90 RT_91 RT_93 RT_94], <span class="number">0</span>&#125;, <span class="number">16</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ioctl - cmd=`SNDRV_PCM_IOCTL_SYNC_PTR`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\320\367\200\367\370\370`\370\220\370\330\370@\372h\371\240\371\320\374\230\373\240\374\341\5\301\1\241\5\221\25"</span>..., <span class="number">12288</span>) = <span class="number">12288</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"a\0361\36\241\f\10\376\300\374\320\375\30\375\360\375\340\375\0\377\320\377(\377\370\376p\375p\374\321\0"</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_PREPARE`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x20004140</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_WRITEI_FRAMES`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\201\21\301\27q\30\261\25\301\20Q\6x\375h\373\370\373\230\374\210\374x\374p\374\220\374\30\375 \375"</span>..., <span class="number">12288</span>) = <span class="number">12288</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\201\35\1%\241'\301\32\341\t@\377\250\374\220\372\20\373\30\374\340\373X\374H\374X\376\201\v\321\32"</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">//while()&#123; 循环读取播放 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\370\375\10\376 \376\210\376X\376x\376\250\376\350\376\360\376\260\376(\377H\377q\0\301\5\1\vq\21"</span>..., <span class="number">12288</span>) = <span class="number">12288</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\221\0021\n\21\f\241\5x\376\30\377\300\377(\377\1\1!\3q\4Q\3\301\4\240\377h\376\210\377"</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"P\377\0\377!\0\361\6Q\t\230\377@\376\250\377X\377\361\3\1\16\241\n!\0!\6A\16\241\v"</span>..., <span class="number">12288</span>) = <span class="number">4652</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">""</span>, <span class="number">4096</span>)                       = <span class="number">0</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">""</span>, <span class="number">16384</span>)                      = <span class="number">0</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x76fe9000</span>, <span class="number">65536</span>)               = <span class="number">0</span></span><br><span class="line"><span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"Playing sample: 2 ch, 8000 hz, 1"</span>..., <span class="number">38</span>) = <span class="number">38</span>  <span class="comment">//printf</span></span><br><span class="line">exit_group(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="为什么open两次pcmC0D0p设备节点"><a href="#为什么open两次pcmC0D0p设备节点" class="headerlink" title="为什么open两次pcmC0D0p设备节点"></a>为什么open两次pcmC0D0p设备节点</h4><ol>
<li>第一次打开<code>pcmC0D0p</code>,主要为了重新规范硬件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_hw_params</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_mask</span> <span class="title">masks</span>[<span class="title">SNDRV_PCM_HW_PARAM_LAST_MASK</span> -</span></span><br><span class="line"><span class="class">                   <span class="title">SNDRV_PCM_HW_PARAM_FIRST_MASK</span> + 1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_mask</span> <span class="title">mres</span>[5];</span>    <span class="comment">/* reserved masks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_interval</span> <span class="title">intervals</span>[<span class="title">SNDRV_PCM_HW_PARAM_LAST_INTERVAL</span> -</span></span><br><span class="line"><span class="class">                        <span class="title">SNDRV_PCM_HW_PARAM_FIRST_INTERVAL</span> + 1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_interval</span> <span class="title">ires</span>[9];</span>    <span class="comment">/* reserved intervals */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rmask;     <span class="comment">/* W: requested masks */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cmask;     <span class="comment">/* R: changed masks */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> info;      <span class="comment">/* R: Info flags for returned setup */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> msbits;        <span class="comment">/* R: used most significant bits */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rate_num;      <span class="comment">/* R: rate numerator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rate_den;      <span class="comment">/* R: rate denominator */</span></span><br><span class="line">    <span class="keyword">snd_pcm_uframes_t</span> fifo_size;    <span class="comment">/* R: chip FIFO size in frames */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> reserved[<span class="number">64</span>]; <span class="comment">/* reserved for future */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>file: include/uapi/sound/asound.h</p>
</blockquote>
<p>主要是将用户空间的snd_pcm_hw_params信息和内核空间的进行对比和规范化</p>
<ol start="2">
<li>第二次打开<code>pcmC0D0p</code>,主要为了进行音频播放的准备和播放音频信号</li>
</ol>
<h4 id="为什么read音频文件两次-并且读的数据大小不一致"><a href="#为什么read音频文件两次-并且读的数据大小不一致" class="headerlink" title="为什么read音频文件两次,并且读的数据大小不一致"></a>为什么read音频文件两次,并且读的数据大小不一致</h4><p>tinyplay中播放时,每次只读取一部分(16KB)的音频文件进行播放<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span> = pcm_frames_to_bytes(pcm, pcm_get_buffer_size(pcm)); <span class="comment">//size=16384Byte=16KB</span></span><br><span class="line"><span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="comment">//buffer 临时存放音频文件的数据的buf</span></span><br><span class="line">	<span class="comment">//size   一次读取的大小(16384Byte)</span></span><br><span class="line">	<span class="comment">//file   打开的音频文件描述符</span></span><br><span class="line">    num_read = fread(<span class="built_in">buffer</span>, <span class="number">1</span>, <span class="built_in">size</span>, file);</span><br><span class="line">    <span class="keyword">if</span> (num_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pcm_write(pcm, <span class="built_in">buffer</span>, num_read)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error playing sample\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num_read == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">if</span>(pcm_write(pcm, <span class="built_in">buffer</span>, <span class="built_in">size</span>))&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error playing sample\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (!<span class="built_in">close</span> &amp;&amp; num_read &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>在进行strace时,一次播放进行了两次的read系统调用,将每一次read数据的大小相加(12288+4096=16384Byte),正好与malloc的buffer大小一致.因此两次的read是由用户空间的函数进行数据分割的.</p>
<h4 id="用户空间申请buffer大小的依据"><a href="#用户空间申请buffer大小的依据" class="headerlink" title="用户空间申请buffer大小的依据"></a>用户空间申请buffer大小的依据</h4><p>在播放当前歌曲时,所申请的buffer大小为16KB,为什么申请16K?</p>
<p>音频信息:</p>
<table>
<thead>
<tr>
<th style="text-align:center">采样率</th>
<th style="text-align:center">通道</th>
<th style="text-align:center">位宽(format)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">44100Hz</td>
<td style="text-align:center">2</td>
<td style="text-align:center">16bit</td>
</tr>
</tbody>
</table>
<blockquote>
<p>4KB的buffer大小为<code>tinyplay</code>默认大小,<code>period_size = 1024</code>, <code>period_count = 4</code>决定了buffer大小,而<code>period_size</code>可以进行修改默认大小.</p>
</blockquote>
<p>需要申请buffer的大小: 1024 <em> 4 </em> 2 * (16 / 8) = 16384</p>
<h3 id="放音-–-内核"><a href="#放音-–-内核" class="headerlink" title="放音 – 内核"></a>放音 – 内核</h3><h4 id="ASOC接口"><a href="#ASOC接口" class="headerlink" title="ASOC接口"></a>ASOC接口</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* create a new pcm */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">soc_new_pcm</span><span class="params">(struct snd_soc_pcm_runtime *rtd, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* ASoC PCM operations */</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic) &#123;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">open</span>       = dpcm_fe_dai_open;</span><br><span class="line">		rtd-&gt;ops.hw_params  = dpcm_fe_dai_hw_params;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">prepare</span>    = dpcm_fe_dai_prepare;</span><br><span class="line">		rtd-&gt;ops.trigger    = dpcm_fe_dai_trigger;</span><br><span class="line">		rtd-&gt;ops.hw_free    = dpcm_fe_dai_hw_free;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">close</span>      = dpcm_fe_dai_close;</span><br><span class="line">		rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class="line">		rtd-&gt;ops.ioctl      = soc_pcm_ioctl;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//回调函数</span></span><br><span class="line">		rtd-&gt;ops.<span class="built_in">open</span>       = soc_pcm_open;</span><br><span class="line">		rtd-&gt;ops.hw_params  = soc_pcm_hw_params;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">prepare</span>    = soc_pcm_prepare;</span><br><span class="line">		rtd-&gt;ops.trigger    = soc_pcm_trigger;</span><br><span class="line">		rtd-&gt;ops.hw_free    = soc_pcm_hw_free;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">close</span>      = soc_pcm_close;</span><br><span class="line">		rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class="line">		rtd-&gt;ops.ioctl      = soc_pcm_ioctl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops) &#123;</span><br><span class="line">		rtd-&gt;ops.ack        = platform-&gt;driver-&gt;ops-&gt;ack;</span><br><span class="line">		rtd-&gt;ops.copy       = platform-&gt;driver-&gt;ops-&gt;copy;</span><br><span class="line">		rtd-&gt;ops.silence    = platform-&gt;driver-&gt;ops-&gt;silence;</span><br><span class="line">		rtd-&gt;ops.page       = platform-&gt;driver-&gt;ops-&gt;page;</span><br><span class="line">		rtd-&gt;ops.mmap       = platform-&gt;driver-&gt;ops-&gt;mmap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (playback)</span><br><span class="line">		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (capture)</span><br><span class="line">		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: sound/soc/soc-pcm.c</p>
</blockquote>
<h5 id="soc-pcm-open"><a href="#soc-pcm-open" class="headerlink" title="soc_pcm_open"></a>soc_pcm_open</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int soc_pcm_open(struct snd_pcm_substream *substream)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	// CPU &lt;I2S&gt; : jz_i2s_startup</span><br><span class="line">	if (cpu_dai-&gt;driver-&gt;ops-&gt;startup) &#123;</span><br><span class="line">		 ret = cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai);</span><br><span class="line">	&#125;</span><br><span class="line">	// Platform &lt;DMA&gt; : jz_pcm_open</span><br><span class="line">	if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;open) &#123;</span><br><span class="line">		 ret = platform-&gt;driver-&gt;ops-&gt;open(substream);</span><br><span class="line">	&#125;</span><br><span class="line">	// Codec &lt;idec_d3&gt; : jz_icdc_startup</span><br><span class="line">	if (codec_dai-&gt;driver-&gt;ops-&gt;startup) &#123;</span><br><span class="line">		 ret = codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai);</span><br><span class="line">	&#125;</span><br><span class="line"> 	// Machine &lt;link&gt; : phoenix_spk_sup  file:sound/soc/ingenic/asoc-board/phoenix_icdc.c</span><br><span class="line">	if (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;startup) &#123;</span><br><span class="line">		 ret = rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="soc-pcm-hw-params"><a href="#soc-pcm-hw-params" class="headerlink" title="soc_pcm_hw_params"></a>soc_pcm_hw_params</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_hw_params</span><span class="params">(struct snd_pcm_substream *substream,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct snd_pcm_hw_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 ...</span><br><span class="line">	 <span class="comment">// Machine &lt;link&gt; : phoenix_i2s_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = rtd-&gt;dai_link-&gt;ops-&gt;hw_params(substream, params);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">// Codec &lt;idec_d3&gt; : icdc_d3_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = codec_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, codec_dai);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">// CPU &lt;I2S&gt; : jz_i2s_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = cpu_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, cpu_dai);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">// Platform &lt;DMA&gt; : jz_pcm_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = platform-&gt;driver-&gt;ops-&gt;hw_params(substream, params);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="soc-pcm-prepare"><a href="#soc-pcm-prepare" class="headerlink" title="soc_pcm_prepare"></a>soc_pcm_prepare</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_prepare</span><span class="params">(struct snd_pcm_substream *substream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Machine &lt;link&gt; : phoenix_i2s_hw_params</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;<span class="built_in">prepare</span>) &#123;</span><br><span class="line">		ret = rtd-&gt;dai_link-&gt;ops-&gt;<span class="built_in">prepare</span>(substream);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; :	jz_pcm_prepare</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>) &#123;</span><br><span class="line">		ret = platform-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>(substream);</span><br><span class="line">	&#125;</span><br><span class="line">   	<span class="comment">// Codec &lt;idec_d3&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>) &#123;</span><br><span class="line">		ret = codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>(substream, codec_dai);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// CPU &lt;I2S&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>) &#123;</span><br><span class="line">		ret = cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>(substream, cpu_dai);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="soc-pcm-trigger"><a href="#soc-pcm-trigger" class="headerlink" title="soc_pcm_trigger"></a>soc_pcm_trigger</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_trigger</span><span class="params">(struct snd_pcm_substream *substream, <span class="keyword">int</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Codec &lt;idec_d3&gt; : icdc_d3_trigger</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class="line">		ret = codec_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, codec_dai);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; :	jz_pcm_trigger</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class="line">		ret = platform-&gt;driver-&gt;ops-&gt;trigger(substream, cmd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// CPU &lt;I2S&gt; : jz_i2s_trigger</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class="line">		ret = cpu_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, cpu_dai);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="soc-pcm-hw-free"><a href="#soc-pcm-hw-free" class="headerlink" title="soc_pcm_hw_free"></a>soc_pcm_hw_free</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_hw_free</span><span class="params">(struct snd_pcm_substream *substream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* free any machine hw params */</span></span><br><span class="line">	<span class="comment">// Machine &lt;link&gt; : phoenix_i2s_hw_free</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_free)</span><br><span class="line">		rtd-&gt;dai_link-&gt;ops-&gt;hw_free(substream);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free any DMA resources */</span></span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; : snd_pcm_lib_free_pages</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class="line">		platform-&gt;driver-&gt;ops-&gt;hw_free(substream);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now free hw params for the DAIs  */</span></span><br><span class="line">	<span class="comment">// Codec &lt;idec_d3&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class="line">		codec_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, codec_dai);</span><br><span class="line">	<span class="comment">// CPU &lt;I2S&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class="line">		cpu_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, cpu_dai);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="soc-pcm-pointer"><a href="#soc-pcm-pointer" class="headerlink" title="soc_pcm_pointer"></a>soc_pcm_pointer</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">snd_pcm_uframes_t</span> <span class="title">soc_pcm_pointer</span><span class="params">(struct snd_pcm_substream *substream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Platform &lt;DMA&gt; :</span></span><br><span class="line">    <span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;pointer)</span><br><span class="line">        offset = platform-&gt;driver-&gt;ops-&gt;pointer(substream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">delay</span>)</span><br><span class="line">        <span class="built_in">delay</span> += cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">delay</span>(substream, cpu_dai);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">delay</span>)</span><br><span class="line">        <span class="built_in">delay</span> += codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">delay</span>(substream, codec_dai);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (platform-&gt;driver-&gt;<span class="built_in">delay</span>)</span><br><span class="line">        <span class="built_in">delay</span> += platform-&gt;driver-&gt;<span class="built_in">delay</span>(substream, codec_dai);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="soc-pcm-close"><a href="#soc-pcm-close" class="headerlink" title="soc_pcm_close"></a>soc_pcm_close</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_close</span><span class="params">(struct snd_pcm_substream *substream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="comment">// CPU &lt;I2S&gt; : jz_i2s_shutdown</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">shutdown</span>)</span><br><span class="line">		cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">shutdown</span>(substream, cpu_dai);</span><br><span class="line">	<span class="comment">// Codec &lt;idec_d3&gt; : jz_icdc_shutdown</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">shutdown</span>)</span><br><span class="line">		codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">shutdown</span>(substream, codec_dai);</span><br><span class="line">	<span class="comment">// Machine &lt;link&gt; : phoenix_spk_sdown</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;<span class="built_in">shutdown</span>)</span><br><span class="line">		rtd-&gt;dai_link-&gt;ops-&gt;<span class="built_in">shutdown</span>(substream);</span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; :	jz_pcm_close</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;<span class="built_in">close</span>)</span><br><span class="line">		platform-&gt;driver-&gt;ops-&gt;<span class="built_in">close</span>(substream);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|(sound/core/pcm_native.c )</span><br><span class="line">|-&gt; snd_pcm_playback_open</span><br><span class="line">  \</span><br><span class="line">  |-&gt; snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);</span><br><span class="line">    \</span><br><span class="line">    |-&gt; <span class="keyword">while</span>(<span class="number">1</span>)&#123; snd_pcm_open_file(file, pcm, stream); schedule(); &#125;</span><br><span class="line">      \</span><br><span class="line">      |-&gt; snd_pcm_open_substream</span><br><span class="line">		\</span><br><span class="line">		|-&gt; substream-&gt;ops-&gt;<span class="built_in">open</span>(substream)</span><br><span class="line">		  |(sound/soc/soc-pcm.c)</span><br><span class="line">		  |-&gt; soc_pcm_open</span><br><span class="line">			\</span><br><span class="line">			|-&gt; cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai);</span><br><span class="line">			  \_**snd_soc_register_component** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_i2s_startup)</span><br><span class="line">			|-&gt; codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai);</span><br><span class="line">			  \_**snd_soc_register_codec** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_icdc_startup)</span><br><span class="line">			|-&gt; rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);</span><br><span class="line">			  \_ **snd_soc_register_card** -&gt; snd_soc_dai_link -&gt; snd_soc_ops (.startup = phoenix_spk_sup)</span><br></pre></td></tr></table></figure>
<h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><blockquote>
<p>ioctl幻数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取声卡信息返回给用户空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_INFO _IOR(<span class="meta-string">'A'</span>, 0x01, struct snd_pcm_info)</span></span><br><span class="line"><span class="comment">//硬件参数重新规范</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_HW_REFINE _IOWR(<span class="meta-string">'A'</span>, 0x10, struct snd_pcm_hw_params)</span></span><br><span class="line"><span class="comment">//设置硬件参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_HW_PARAMS _IOWR(<span class="meta-string">'A'</span>, 0x11, struct snd_pcm_hw_params)</span></span><br><span class="line"><span class="comment">//设置软件参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_SW_PARAMS _IOWR(<span class="meta-string">'A'</span>, 0x13, struct snd_pcm_sw_params)</span></span><br><span class="line"><span class="comment">//准备操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_PREPARE _IO(<span class="meta-string">'A'</span>, 0x40)</span></span><br><span class="line"><span class="comment">//从用户空间把音频数据拿过来，从wav文件中读出数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_WRITEI_FRAMES _IOW(<span class="meta-string">'A'</span>, 0x50, struct snd_xferi)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(`sound/core/pcm_native.c`)</span><br><span class="line">|-&gt;	snd_pcm_playback_ioctl</span><br><span class="line">|</span><br><span class="line">|-&gt; snd_pcm_playback_ioctl1 --&gt; 判断cmd &lt;SNDRV_PCM_IOCTL_WRITEI_FRAMES&gt;</span><br><span class="line">|(`sound/core/pcm_lib.c`)</span><br><span class="line">|-&gt; snd_pcm_lib_write --- &gt; struct snd_pcm_substream *substream</span><br><span class="line">|</span><br><span class="line">|-&gt; snd_pcm_lib_write1</span><br><span class="line">		|_call_back--&gt;snd_pcm_lib_write_transfer(数据传输:copy和map)</span><br><span class="line">			|_.(内存和DMA之间的数据传递, 循环搬送直到播放完毕)</span><br><span class="line">					char *hwbuf = runtime-&gt;dma_area + frames_to_bytes(runtime, hwoff);</span><br><span class="line">					if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))</span><br><span class="line">		|</span><br><span class="line">		|-&gt; snd_pcm_start(substream) //**启动传输(只是在开始时,调用一次)**</span><br><span class="line">			|</span><br><span class="line">			|-&gt; snd_pcm_action</span><br><span class="line">				|</span><br><span class="line">				|-&gt; snd_pcm_action_single</span><br><span class="line">					|</span><br><span class="line">					|-&gt; &#123;</span><br><span class="line">							res = ops-&gt;pre_action(substream, state);</span><br><span class="line">							if (res &lt; 0)</span><br><span class="line"> 						   		return res;</span><br><span class="line">							res = ops-&gt;do_action(substream, state);</span><br><span class="line">							if (res == 0)</span><br><span class="line"> 						   		ops-&gt;post_action(substream, state);</span><br><span class="line">							else if (ops-&gt;undo_action)</span><br><span class="line">						    	ops-&gt;undo_action(substream, state);</span><br><span class="line">						&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: sound/core/pcm_native.c</p>
</blockquote>
<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>通过系统调用close, 到release进行关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.release =      snd_pcm_release</span><br><span class="line"></span><br><span class="line">snd_pcm_release</span><br><span class="line">  |</span><br><span class="line">  |-&gt; snd_pcm_release_substream</span><br><span class="line">	|</span><br><span class="line">	|-&gt; snd_pcm_drop</span><br><span class="line">	  |</span><br><span class="line">	  |-&gt; snd_pcm_stop</span><br><span class="line">		|</span><br><span class="line">		|-&gt; snd_pcm_action(&amp;snd_pcm_action_stop, substream, state)</span><br><span class="line">	|</span><br><span class="line">	|-&gt; substream-&gt;ops-&gt;hw_free(substream)</span><br><span class="line">	|-&gt; substream-&gt;ops-&gt;close(substream)</span><br></pre></td></tr></table></figure>
<h2 id="control设备"><a href="#control设备" class="headerlink" title="control设备"></a>control设备</h2><h2 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h2><h2 id="数据路由"><a href="#数据路由" class="headerlink" title="数据路由"></a>数据路由</h2><h2 id="amixer的设置"><a href="#amixer的设置" class="headerlink" title="amixer的设置"></a>amixer的设置</h2><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>ASoC添加了debugfs和ftrace的调试支持。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t debugfs none /mnt/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat available_events | grep <span class="string">"asoc"</span></span></span><br><span class="line">asoc:snd_soc_cache_sync</span><br><span class="line">asoc:snd_soc_jack_notify</span><br><span class="line">asoc:snd_soc_jack_report</span><br><span class="line">asoc:snd_soc_jack_irq</span><br><span class="line">asoc:snd_soc_dapm_connected</span><br><span class="line">asoc:snd_soc_dapm_input_path</span><br><span class="line">asoc:snd_soc_dapm_output_path</span><br><span class="line">asoc:snd_soc_dapm_walk_done</span><br><span class="line">asoc:snd_soc_dapm_widget_event_done</span><br><span class="line">asoc:snd_soc_dapm_widget_event_start</span><br><span class="line">asoc:snd_soc_dapm_widget_power</span><br><span class="line">asoc:snd_soc_dapm_done</span><br><span class="line">asoc:snd_soc_dapm_start</span><br><span class="line">asoc:snd_soc_bias_level_done</span><br><span class="line">asoc:snd_soc_bias_level_start</span><br><span class="line">asoc:snd_soc_preg_read</span><br><span class="line">asoc:snd_soc_preg_write</span><br><span class="line">asoc:snd_soc_reg_read</span><br><span class="line">asoc:snd_soc_reg_write</span><br></pre></td></tr></table></figure>
<ul>
<li>在DEBUGFS下，可以查看一个各个组件及widgets的状态。</li>
<li>在FTRACE下，<code>echo asoc &gt; tracing/set_event</code>打开调试，就可以<code>cat /mnt/tracing/trace</code>查看widget的上下电顺序， 通路的切换等。</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="频响"><a href="#频响" class="headerlink" title="频响"></a>频响</h3><blockquote>
<p>频率响应 简称频响，英文名称是<code>Frequency Response</code>，在电子学上用来描述一台仪器对于不同频率的信号的处理能力的差异。</p>
</blockquote>
<h3 id="扫频"><a href="#扫频" class="headerlink" title="扫频"></a>扫频</h3><blockquote>
<p>利用正弦波信号的频率随时间在一定范围内反复扫描</p>
</blockquote>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>audio</tag>
        <tag>alsa</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot</title>
    <url>/post/47503.html</url>
    <content><![CDATA[<p>Bootloader 是在操作系统运行之前执行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射表，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备。</p>
<p>uboot引导系统启动, UBoot包含两个阶段的启动，一个是SPL启动，一个是正常的启动我们称为第二阶段Uboot。当然，我们也可以选择使用SPL和不使用，主要根据CPU中的SRAM（或者cache，bootram阶段需要初始化完成）的大小，如果不能放下uboot大小，则必须先使用SPL启动，进行DDR的初始化，以获取更大的可以空间。</p>
<blockquote>
<p>Version: u-boot-201307</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------------+-----------------------------------+</span><br><span class="line">|                |                                   |</span><br><span class="line">|  spl           |             uboot                 |</span><br><span class="line">|                |                                   |</span><br><span class="line">+----------------+-----------------------------------+</span><br></pre></td></tr></table></figure>
<p>在编译的过程中,这两个阶段通过<code>CONFIG_SPL_BUILD</code>宏将编译分离。拥有不同的配置，所以许多地方的宏是和SPL的不一样。而且链接的文件也不一致。</p>
<ul>
<li><p>SPL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./arch/mips/cpu/xburst/x1000/u-boot-spl.lds</span><br></pre></td></tr></table></figure>
</li>
<li><p>uboot：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/arch/mips/cpu/u-boot.lds</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p><img src="/images/uboot/uboot_stage.png" alt="uboot stage"></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程:"></a>流程:</h2><p><img src="/images/uboot/uboot_boot.png" alt="uboot boot"></p>
<h2 id="SPL"><a href="#SPL" class="headerlink" title="SPL"></a>SPL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u-boot-spl.lds</span><br><span class="line">ENTRY: _start (start.S)</span><br><span class="line">		\-&gt;board_init_f (soc.c)</span><br><span class="line">			-&gt;board_init_r (spl.c)</span><br></pre></td></tr></table></figure>
<h3 id="u-boot-spl-lds"><a href="#u-boot-spl-lds" class="headerlink" title="u-boot-spl.lds"></a>u-boot-spl.lds</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SPL_TEXT_BASE        0xf4001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SPL_MAX_SIZE     (12 * 1024)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MEMORY &#123; .sram : ORIGIN = CONFIG_SPL_TEXT_BASE,\</span><br><span class="line">		LENGTH = CONFIG_SPL_MAX_SIZE &#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(mips)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	.text      :</span><br><span class="line">	&#123;</span><br><span class="line">		__start = .;</span><br><span class="line">		*(.start_section*)</span><br><span class="line">		*(.text*)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		. = ALIGN(4);</span><br><span class="line">		__bss_start = .;</span><br><span class="line">		*(.sbss.*)</span><br><span class="line">		*(.bss.*)</span><br><span class="line">		*(COMMON)</span><br><span class="line">		. = ALIGN(4);</span><br><span class="line">		__bss_end = .;</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="/downloads/uboot/u-boot-spl.lds.txt">u-boot-spl.lds</a></p>
</blockquote>
<p>在bootram将SPL搬到静态ram中后，执行SPL的代码将从<code>_start</code>开始。</p>
<h3 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define RESERVED_FOR_SC(x) .space 1536, x</span><br><span class="line"></span><br><span class="line">	.set noreorder</span><br><span class="line"></span><br><span class="line">	.globl _start</span><br><span class="line">	.section .start_section</span><br><span class="line">_start:</span><br><span class="line">	/* magic value (&quot;MSPL&quot;) */</span><br><span class="line">	.word 0x4d53504c</span><br><span class="line">	.space 508, 0</span><br><span class="line">	RESERVED_FOR_SC(0)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SPL_VERSION</span><br><span class="line">	.word (0x00000000 | CONFIG_SPL_VERSION)</span><br><span class="line">	.space (512-20),0</span><br><span class="line">#else</span><br><span class="line">	.space (512-16),0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* Invalidate BTB */</span><br><span class="line">	mfc0	v0, CP0_CONFIG, 7</span><br><span class="line">	nop</span><br><span class="line">	ori	v0, v0, 2 /* MMU类型：BAT类型*/</span><br><span class="line">	mtc0	v0, CP0_CONFIG, 7</span><br><span class="line">	nop</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * CU0=UM=EXL=IE=0, BEV=ERL=1, IP2~7=1</span><br><span class="line">	 */</span><br><span class="line">	li	t0, 0x0040FC04</span><br><span class="line">	mtc0	t0, CP0_STATUS</span><br><span class="line"></span><br><span class="line">	/* CAUSE register */</span><br><span class="line">	/* IV=1, use the specical interrupt vector (0x200) */</span><br><span class="line">	li	t1, 0x00800000</span><br><span class="line">	mtc0	t1, CP0_CAUSE</span><br><span class="line"></span><br><span class="line">	.set push</span><br><span class="line">	.set	mips32</span><br><span class="line">init_caches:</span><br><span class="line">	li	t0, CONF_CM_CACHABLE_NONCOHERENT</span><br><span class="line">	mtc0	t0, CP0_CONFIG</span><br><span class="line">	nop</span><br><span class="line"></span><br><span class="line">	/* enable idx-store-data cache insn */</span><br><span class="line">	li      t0, 0x20000000</span><br><span class="line">	mtc0    t0, CP0_ECC</span><br><span class="line"></span><br><span class="line">	li	t1, KSEG0		/* Start address */</span><br><span class="line">#define CACHE_ALLOC_END (CONFIG_SYS_DCACHE_SIZE)</span><br><span class="line"></span><br><span class="line">	ori     t2, t1, CACHE_ALLOC_END	/* End address */</span><br><span class="line">	mtc0	zero, CP0_TAGLO, 0</span><br><span class="line">	mtc0	zero, CP0_TAGLO, 1</span><br><span class="line">cache_clear_a_line:</span><br><span class="line">	cache   INDEX_STORE_TAG_I, 0(t1)</span><br><span class="line">	cache   INDEX_STORE_TAG_D, 0(t1)</span><br><span class="line">	addiu   t1, t1, CONFIG_SYS_CACHELINE_SIZE</span><br><span class="line">	bne     t1, t2, cache_clear_a_line</span><br><span class="line">	nop</span><br><span class="line">	.set pop</span><br><span class="line"></span><br><span class="line">	/* Set up stack */</span><br><span class="line">#ifdef CONFIG_SPL_STACK</span><br><span class="line">	li	sp, CONFIG_SPL_STACK</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	j	board_init_f</span><br><span class="line">	nop</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="/downloads/uboot/spl_start.S">start.S</a></p>
</blockquote>
<ol>
<li>设置spl的空间布局,加载识别区域，SC填充区域等</li>
<li>选择MMU类型</li>
<li>通过SR，使能异常向量和配置中断屏蔽位</li>
<li>配置一个特殊的中断异常入口（0x200）</li>
<li>初始化cache</li>
<li>跳转<code>board_init_f</code></li>
</ol>
<h3 id="soc-c"><a href="#soc-c" class="headerlink" title="soc.c"></a>soc.c</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="bd-t"><a href="#bd-t" class="headerlink" title="bd_t"></a>bd_t</h5><blockquote>
<p>保存板子参数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bd_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    bi_baudrate;    <span class="comment">/*serial console baudrate*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   bi_arch_number; <span class="comment">/*unique id for this board*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   bi_boot_params; <span class="comment">/*where this board expects params*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   bi_memstart;    <span class="comment">/*start of DRAM memory*/</span></span><br><span class="line">    <span class="keyword">phys_size_t</span> bi_memsize; <span class="comment">/*size  of DRAM memory in bytes*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   bi_flashstart;  <span class="comment">/*start of FLASH memory*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   bi_flashsize;   <span class="comment">/*size  of FLASH memory*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   bi_flashoffset; <span class="comment">/*reserved area for startup monitor*/</span></span><br><span class="line">&#125; <span class="keyword">bd_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/include/asm/u-boot.h</p>
</blockquote>
<h5 id="gd-t"><a href="#gd-t" class="headerlink" title="gd_t"></a>gd_t</h5><blockquote>
<p>全局的系统初始化参数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> &#123;</span></span><br><span class="line">	<span class="keyword">bd_t</span> *bd;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> baudrate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_clk;	<span class="comment">/* CPU clock in Hz!		*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bus_clk;</span><br><span class="line">	<span class="comment">/* We cannot bracket this with CONFIG_PCI due to mpc5xxx */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pci_clk;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mem_clk;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_LCD) || defined(CONFIG_VIDEO)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fb_base;	<span class="comment">/* Base address of framebuffer mem */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BOARD_TYPES</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> board_type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> have_console;	<span class="comment">/* serial_init() was called */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PRE_CONSOLE_BUFFER</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> precon_buf_idx;	<span class="comment">/* Pre-Console buffer index */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODEM_SUPPORT</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> do_mdm_init;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> be_quiet;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> env_addr;	<span class="comment">/* Address  of Environment struct */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> env_valid;	<span class="comment">/* Checksum of Environment valid? */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ram_top;	<span class="comment">/* Top address of RAM used by U-Boot */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> relocaddr;	<span class="comment">/* Start address of U-Boot in RAM */</span></span><br><span class="line">	<span class="keyword">phys_size_t</span> ram_size;	<span class="comment">/* RAM size */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mon_len;	<span class="comment">/* monitor len */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> irq_sp;		<span class="comment">/* irq stack pointer */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_addr_sp;	<span class="comment">/* start_addr_stackpointer */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> reloc_off;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">new_gd</span>;</span>	<span class="comment">/* relocated global data */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *fdt_blob;	<span class="comment">/* Our device tree, NULL if none */</span></span><br><span class="line">	<span class="keyword">void</span> *new_fdt;		<span class="comment">/* Relocated FDT */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fdt_size;	<span class="comment">/* Space reserved for relocated FDT */</span></span><br><span class="line">	<span class="keyword">void</span> **jt;		<span class="comment">/* jump table */</span></span><br><span class="line">	<span class="keyword">char</span> env_buf[<span class="number">32</span>];	<span class="comment">/* buffer for getenv() before reloc. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">	<span class="keyword">void</span>		*trace_buff;	<span class="comment">/* The trace buffer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arch_global_data</span> <span class="title">arch</span>;</span>	<span class="comment">/* architecture-specific data */</span></span><br><span class="line">&#125; <span class="keyword">gd_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/asm-generic/global_data.h</p>
</blockquote>
<h4 id="board-init-f"><a href="#board-init-f" class="headerlink" title="board_init_f"></a>board_init_f</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_f</span><span class="params">(ulong dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*Set global data pointer*/</span></span><br><span class="line">	gd = &amp;gdata;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*Setup global info*/</span></span><br><span class="line">	gd-&gt;arch.gi = &amp;ginfo;</span><br><span class="line"></span><br><span class="line">	gpio_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*Init uart first*/</span></span><br><span class="line">	enable_uart_clk();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPL_SERIAL_SUPPORT</span></span><br><span class="line">	preloader_console_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ERROR EPC %x\n"</span>, read_c0_errorepc());</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"Timer init\n"</span>);</span><br><span class="line">	timer_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPL_CORE_VOLTAGE</span></span><br><span class="line">	debug(<span class="string">"Set core voltage:%dmv\n"</span>, CONFIG_SPL_CORE_VOLTAGE);</span><br><span class="line">	spl_regulator_set_voltage(REGULATOR_CORE, CONFIG_SPL_CORE_VOLTAGE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPL_MEM_VOLTAGE</span></span><br><span class="line">	debug(<span class="string">"Set mem voltage:%dmv\n"</span>, CONFIG_SPL_MEM_VOLTAGE);</span><br><span class="line">	spl_regulator_set_voltage(REGULATOR_MEM, CONFIG_SPL_MEM_VOLTAGE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"CLK stop\n"</span>);</span><br><span class="line">	clk_prepare();</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"PLL init\n"</span>);</span><br><span class="line">	pll_init();</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"CLK init\n"</span>);</span><br><span class="line">	clk_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HW_WATCHDOG</span></span><br><span class="line">	debug(<span class="string">"WATCHDOG init\n"</span>);</span><br><span class="line">	hw_watchdog_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	debug(<span class="string">"SDRAM init\n"</span>);</span><br><span class="line">	sdram_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DDR_TEST</span></span><br><span class="line">	ddr_basic_tests();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*Clear the BSS*/</span></span><br><span class="line">	<span class="built_in">memset</span>(__bss_start, <span class="number">0</span>, (<span class="keyword">char</span> *)&amp;__bss_end - __bss_start);</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"board_init_r\n"</span>);</span><br><span class="line">	board_init_r(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/mips/cpu/xburst/x1000/soc.c</p>
</blockquote>
<ol>
<li>初始化GPIO</li>
<li>使能串口时钟，初始化串口</li>
<li>初始化timer</li>
<li>初始化时钟,配置CPU，DDR和外设的时钟大小</li>
<li>初始化看门狗</li>
<li>初始化DDR</li>
<li>清除BSS段</li>
</ol>
<h5 id="ginfo"><a href="#ginfo" class="headerlink" title="ginfo"></a>ginfo</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm-generic/global_data.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm (<span class="meta-string">"k0"</span>)</span></span><br><span class="line"></span><br><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"><span class="keyword">gd_t</span> gdata __attribute__ ((section(<span class="string">".data"</span>)));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_info</span> <span class="title">ginfo</span> __<span class="title">attribute__</span> ((<span class="title">section</span>(".<span class="title">data</span>"))) = &#123;</span></span><br><span class="line">    .extal      = CONFIG_SYS_EXTAL,</span><br><span class="line">    .cpufreq    = CONFIG_SYS_CPU_FREQ,</span><br><span class="line">    .ddrfreq    = CONFIG_SYS_MEM_FREQ,</span><br><span class="line">    .uart_idx   = CONFIG_SYS_UART_INDEX,</span><br><span class="line">    .baud_rate  = CONFIG_BAUDRATE,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统信息的结构体 (gd 是指 Global Data, bd 是指 Board info Data) 应该存放于在 DRAM 控制器未初始化之前就能使用的空间中，比如TCSM中。</p>
<h5 id="为什么要清除BSS段？"><a href="#为什么要清除BSS段？" class="headerlink" title="为什么要清除BSS段？"></a>为什么要清除BSS段？</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Clear the BSS */</span></span><br><span class="line"><span class="built_in">memset</span>(__bss_start, <span class="number">0</span>, (<span class="keyword">char</span> *)&amp;__bss_end - __bss_start);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可执行程序包括BSS段、代码段、数据段。BSS（Block Started by Symbol）通常指用来存放程序中未初始化的全局变量和静态变量的一块内存区域，特点是可读可写，在程序执行之前BSS段会自动清0。所以，未初始化的全局变量在程序执行之前已经成0</p>
</blockquote>
<p>bss段起源于unix中。变量分两种，<code>全局变量</code>和<code>局部变量</code>。局部变量是保留在栈中的，根据C语言规定，如果对局部变量不进行初始化，初始值是不确定的，在栈中位置也不固定。全局变量有专门的数据段存储，且初始化值为0，且位置是固定的。综上，数据分为俩种，<code>位置固定（全局，数据段）</code>，<code>位置不固定（局部-栈里）</code>。</p>
<p>其实，数据段里的这么多<code>全局变量都初始化为0存在目标文件中是没有必要的，增大了存储空间使用</code>。所以就把数据段里边数据，也即未初始化全局变量存放到了BSS段里边. 并未占有真正的空间。<code>当有目标文件被载入的时候，清除bss段，将全局变量清0</code>, 其实也是在为bss段分配空间.</p>
<h4 id="board-init-r"><a href="#board-init-r" class="headerlink" title="board_init_r"></a>board_init_r</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *dummy1, ulong dummy2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 boot_device;</span><br><span class="line">	<span class="keyword">char</span> *cmdargs = <span class="literal">NULL</span>;</span><br><span class="line">	debug(<span class="string">"&gt;&gt;spl:board_init_r()\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_SPL_MALLOC_START</span></span><br><span class="line">	mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START,</span><br><span class="line">			CONFIG_SYS_SPL_MALLOC_SIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_PPC</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * timer_init() does not exist on PPC systems. The timer is initialized</span></span><br><span class="line"><span class="comment">	 * and enabled (decrementer) in interrupt_init() here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	timer_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPL_BOARD_INIT</span></span><br><span class="line">	spl_board_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	boot_device = spl_boot_device();</span><br><span class="line">	debug(<span class="string">"boot device - %d\n"</span>, boot_device);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PALLADIUM</span></span><br><span class="line">	spl_board_prepare_for_linux();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">switch</span> (boot_device) &#123;</span><br><span class="line">	<span class="keyword">case</span> BOOT_DEVICE_MMC1:</span><br><span class="line">	<span class="keyword">case</span> BOOT_DEVICE_MMC2:</span><br><span class="line">	<span class="keyword">case</span> BOOT_DEVICE_MMC2_2:</span><br><span class="line">		spl_mmc_load_image();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		debug(<span class="string">"SPL: Un-supported Boot Device\n"</span>);</span><br><span class="line">		hang();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (spl_image.os) &#123;</span><br><span class="line">	<span class="keyword">case</span> IH_OS_U_BOOT:</span><br><span class="line">		debug(<span class="string">"Jumping to U-Boot\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPL_OS_BOOT</span></span><br><span class="line">	<span class="keyword">case</span> IH_OS_LINUX:</span><br><span class="line">		debug(<span class="string">"Jumping to Linux\n"</span>);</span><br><span class="line">		spl_board_prepare_for_linux();</span><br><span class="line"></span><br><span class="line">		cmdargs = cmdargs ? cmdargs : CONFIG_SYS_SPL_ARGS_ADDR;</span><br><span class="line">		cmdargs = spl_board_process_bootargs(cmdargs);</span><br><span class="line"></span><br><span class="line">		debug(<span class="string">"get cmdargs: %s.\n"</span>, cmdargs);</span><br><span class="line">		jump_to_image_linux((<span class="keyword">void</span> *)cmdargs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		debug(<span class="string">"Unsupported OS image.. Jumping nevertheless..\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jump_to_image_no_args(&amp;spl_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: common/spl/spl.c</p>
</blockquote>
<ol>
<li>从存储介质（sd/emmc）读取uboot，并跳转到uboot执行</li>
<li>在SPL运行完后，已可以直接加载kernel或相应的BIN文件执行</li>
</ol>
<h3 id="执行C代码所必需的条件或者环境？"><a href="#执行C代码所必需的条件或者环境？" class="headerlink" title="执行C代码所必需的条件或者环境？"></a>执行C代码所必需的条件或者环境？</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">la  sp, STACK_TOP   <span class="comment">// sp</span></span><br><span class="line">j   main</span><br><span class="line">nop</span><br></pre></td></tr></table></figure>
<ol>
<li>禁止看门狗，防止CPU不断的重启</li>
<li>设置堆栈</li>
</ol>
<h3 id="SPL执行阶段其栈空间的位置？"><a href="#SPL执行阶段其栈空间的位置？" class="headerlink" title="SPL执行阶段其栈空间的位置？"></a>SPL执行阶段其栈空间的位置？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   TCSM</span><br><span class="line">+-------------+ &lt;-+ 0xb2400000</span><br><span class="line">|  .data .bss |       4K</span><br><span class="line">+----------+--+ &lt;-+ 0xb2401000</span><br><span class="line">|    stack |  |       4K</span><br><span class="line">+----------v--+ &lt;-+ 0xb2402000</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">|   load spl  |       24KB</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">+-------------+ &lt;-+ 0xb2408000</span><br></pre></td></tr></table></figure>
<p>CPU上电后，在bootrom中执行时，由于其是固化的代码段（只读）。因此在上电初期将Data段，BSS段以及栈指定到TCSM中（一个静态RAM，CPU上电即可以使用）。bootrom中一些外围设备如sd boot的SD控制器等初始化完成后，在SD卡中将SPL加载到TCSM中，bootrom的PC跳入SPL进行执行，此时<strong><em>依然使用bootrom的栈空间</em></strong>。</p>
<h2 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u-boot.lds</span><br><span class="line">__start （start.S）</span><br><span class="line">	-&gt;board_init_f (arch/mips/lib/board.c)</span><br><span class="line">		-&gt;relocate_code (start.S)</span><br><span class="line">				-&gt;board_init_r (arch/mips/lib/board.c)</span><br></pre></td></tr></table></figure>
<h3 id="u-boot-lds"><a href="#u-boot-lds" class="headerlink" title="u-boot.lds"></a>u-boot.lds</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(mips)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	. = 0x00000000;</span><br><span class="line"></span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text*)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data*)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	. = .;</span><br><span class="line">	_gp = ALIGN(16) + 0x7ff0;  /*32KB*/</span><br><span class="line"></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="/downloads/uboot/u-boot.lds.txt">u-boot.lds</a></p>
</blockquote>
<h3 id="start-S-1"><a href="#start-S-1" class="headerlink" title="start.S"></a>start.S</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_SDRAM_BASE       0x80000000 <span class="comment">/* cached (KSEG0) address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_INIT_SP_OFFSET   0x400000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.set noreorder</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">.text</span><br><span class="line">_start:</span><br><span class="line">/* Initialize $gp */</span><br><span class="line">bal	1f</span><br><span class="line"> nop</span><br><span class="line">.word	_gp</span><br><span class="line">1:</span><br><span class="line">lw	gp, 0(ra)</span><br><span class="line"></span><br><span class="line">/* Set up temporary stack */</span><br><span class="line">li	sp, CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_INIT_SP_OFFSET</span><br><span class="line"></span><br><span class="line">la	t9, board_init_f</span><br><span class="line">jr	t9</span><br><span class="line"> nop</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="/downloads/uboot/uboot_start.S">start.S</a></p>
</blockquote>
<ol>
<li>重新设置栈指针<code>0x80400000</code>,</li>
<li>跳转<code>board_init_f</code></li>
</ol>
<blockquote>
<p><code>CONFIG_SYS_SDRAM_BASE ＝ 0x8000 0000</code> ，是 MIPS 虚拟寻址空间中<code>kseg0</code>段的起始地址（参考《 See MIPS Run 》），它经过 CPU TLB 翻译后是 DRAM 内存的起始物理地址。</p>
</blockquote>
<h4 id="为什么不直接跳转，而使用jr"><a href="#为什么不直接跳转，而使用jr" class="headerlink" title="为什么不直接跳转，而使用jr"></a>为什么不直接跳转，而使用<code>jr</code></h4><p>这样就可以知道代码的位置,而不是标号值。</p>
<h3 id="board-c"><a href="#board-c" class="headerlink" title="board.c"></a>board.c</h3><h4 id="uboot内存布局："><a href="#uboot内存布局：" class="headerlink" title="uboot内存布局："></a>uboot内存布局：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_SDRAM_BASE       0x80000000 <span class="comment">/* cached (KSEG0) address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_SDRAM_MAX_TOP    0x90000000 <span class="comment">/* don't run into IO space */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_INIT_SP_OFFSET   0x400000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_LOAD_ADDR        0x88000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MEMTEST_START    0x80000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MEMTEST_END      0x88000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_TEXT_BASE        0x80100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MONITOR_BASE     CONFIG_SYS_TEXT_BASE</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------------+ &lt;-+ 0x9000 0000</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|     LOAD_ADDR     |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">+-------------------+ &lt;-+ 0x8800 0000</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">+-------------------+ &lt;-+ 0x8040 0000</span><br><span class="line">|                   |</span><br><span class="line">|      STACK        |</span><br><span class="line">|                   |</span><br><span class="line">+-------------------+ &lt;-+ 0x8010 0000</span><br><span class="line">|     TEXT BASE     |</span><br><span class="line">+-------------------+ &lt;-+ 0x8000 0000</span><br></pre></td></tr></table></figure>
<h4 id="board-init-f-1"><a href="#board-init-f-1" class="headerlink" title="board_init_f"></a>board_init_f</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_f</span><span class="params">(ulong bootflag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">gd_t</span> gd_data, *id;</span><br><span class="line">	<span class="keyword">bd_t</span> *bd;</span><br><span class="line">	<span class="keyword">init_fnc_t</span> **init_fnc_ptr;</span><br><span class="line">	ulong addr, addr_sp, len;</span><br><span class="line">	ulong *s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Pointer is writable since we allocated a register for it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gd = &amp;gd_data;</span><br><span class="line">	<span class="comment">/* compiler optimization barrier needed for GCC &gt;= 3.4 */</span></span><br><span class="line">	__asm__ __volatile__(<span class="string">""</span> : : : <span class="string">"memory"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>((<span class="keyword">void</span> *)gd, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*init_fnc_ptr)() != <span class="number">0</span>)</span><br><span class="line">			hang();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now that we have DRAM mapped and working, we can</span></span><br><span class="line"><span class="comment">	 * relocate the code and continue running from DRAM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr = CONFIG_SYS_SDRAM_BASE + gd-&gt;ram_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_SDRAM_MAX_TOP</span></span><br><span class="line">	addr = MIN(addr, CONFIG_SYS_SDRAM_MAX_TOP);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We can reserve some RAM "on top" here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* round down to next 4 kB limit.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);	<span class="comment">//addr &amp;= ~0x0FFF 这种计算是常用的地址对齐，向下 4K 字节对齐</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Top of RAM usable for U-Boot at: %08lx\n"</span>, addr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LCD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FB_ADDR</span></span><br><span class="line">	gd-&gt;fb_base = CONFIG_FB_ADDR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">/* reserve memory for LCD display (always full pages) */</span></span><br><span class="line">	addr = lcd_setmem(addr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reserving %ldk for LCDC at: %08lx\n"</span>, len &gt;&gt; <span class="number">10</span>, addr);</span><br><span class="line">	gd-&gt;fb_base = addr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FB_ADDR */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_LCD */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reserve memory for U-Boot code, data &amp; bss</span></span><br><span class="line"><span class="comment">	 * round down to next 16 kB limit</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	len = bss_end() - CONFIG_SYS_MONITOR_BASE;</span><br><span class="line">	addr -= len;</span><br><span class="line">	addr &amp;= ~(<span class="number">16</span> * <span class="number">1024</span> - <span class="number">1</span>); <span class="comment">// 向下 64K 字节对齐</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reserving %ldk for U-Boot at: %08lx\n"</span>, len &gt;&gt; <span class="number">10</span>, addr);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Reserve memory for malloc() arena.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp = addr - TOTAL_MALLOC_LEN;	<span class="comment">// 划分 malloc() 使用的空间，即所谓的堆空间</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reserving %dk for malloc() at: %08lx\n"</span>,</span><br><span class="line">			TOTAL_MALLOC_LEN &gt;&gt; <span class="number">10</span>, addr_sp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * (permanently) allocate a Board Info struct</span></span><br><span class="line"><span class="comment">	 * and a permanent copy of the "global" data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp -= <span class="keyword">sizeof</span>(<span class="keyword">bd_t</span>);</span><br><span class="line">	bd = (<span class="keyword">bd_t</span> *)addr_sp;</span><br><span class="line">	gd-&gt;bd = bd;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reserving %zu Bytes for Board Info at: %08lx\n"</span>,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">bd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line">	addr_sp -= <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>);</span><br><span class="line">	id = (<span class="keyword">gd_t</span> *)addr_sp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reserving %zu Bytes for Global Data at: %08lx\n"</span>,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reserve memory for boot params.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp -= CONFIG_SYS_BOOTPARAMS_LEN;</span><br><span class="line">	bd-&gt;bi_boot_params = addr_sp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Reserving %dk for boot params() at: %08lx\n"</span>,</span><br><span class="line">			CONFIG_SYS_BOOTPARAMS_LEN &gt;&gt; <span class="number">10</span>, addr_sp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Finally, we set up a new (bigger) stack.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Leave some safety gap for SP, force alignment on 16 byte boundary</span></span><br><span class="line"><span class="comment">	 * Clear initial stack frame</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp -= <span class="number">16</span>;</span><br><span class="line">	addr_sp &amp;= ~<span class="number">0xF</span>; <span class="comment">// 栈空间 16 字节对齐</span></span><br><span class="line">	s = (ulong *)addr_sp;</span><br><span class="line">	*s-- = <span class="number">0</span>;</span><br><span class="line">	*s-- = <span class="number">0</span>;</span><br><span class="line">	addr_sp = (ulong)s;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stack Pointer at: %08lx\n"</span>, addr_sp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Save local variables to board info struct</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bd-&gt;bi_memstart	= CONFIG_SYS_SDRAM_BASE;	<span class="comment">/* start of DRAM */</span></span><br><span class="line">	bd-&gt;bi_memsize	= gd-&gt;ram_size;		<span class="comment">/* size of DRAM in bytes */</span></span><br><span class="line">	bd-&gt;bi_baudrate	= gd-&gt;baudrate;		<span class="comment">/* Console Baudrate */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将在临时栈空间中的 GD 数据拷贝入 DRAM 中，至此， BD 和 GD 都已经存在于 DRAM 中了</span></span><br><span class="line">	<span class="built_in">memcpy</span>(id, (<span class="keyword">void</span> *)gd, <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>));</span><br><span class="line"></span><br><span class="line">	relocate_code(addr_sp, id, addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*NOTREACHED - relocate_code() does not return*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用init_sequence 函数队列，对板子进行一些初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * initialization sequence configurable to the user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The requirements for any new initalization function is simple: it</span></span><br><span class="line"><span class="comment"> * receives a pointer to the "global data" structure as it's only</span></span><br><span class="line"><span class="comment"> * argument, and returns an integer return code, where 0 means</span></span><br><span class="line"><span class="comment"> * "continue" and != 0 means "fatal error, hang the system".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(<span class="keyword">init_fnc_t</span>)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init_fnc_t</span> *init_sequence[] = &#123;</span><br><span class="line">	 board_early_init_f,</span><br><span class="line">	 timer_init,</span><br><span class="line">	 env_init,		<span class="comment">/* initialize environment */</span></span><br><span class="line">#ifdef CONFIG_INCA_IP</span><br><span class="line">	 incaip_set_cpuclk,	<span class="comment">/* set cpu clock according to env. variable */</span></span><br><span class="line">#endif</span><br><span class="line">	 init_baudrate,		<span class="comment">/* initialize baudrate settings */</span></span><br><span class="line">	 serial_init,		<span class="comment">/* serial communications setup */</span></span><br><span class="line">	 console_init_f,</span><br><span class="line">	 display_banner,		<span class="comment">/* say that we are here */</span></span><br><span class="line">	 checkboard,</span><br><span class="line">	 init_func_ram,</span><br><span class="line">	 <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>为uboot在DRAM中执行准备条件</li>
</ul>
<h4 id="relocate-code"><a href="#relocate-code" class="headerlink" title="relocate_code"></a>relocate_code</h4><p>重定位，U-boot运行后将自己的代码段,数据段,BSS 段等搬到DRAM 中的另一个位置继续运行.</p>
<p><strong>目的：</strong></p>
<ol>
<li>为kernel腾出内存的低端空间，防止kernel解压覆盖uboot。</li>
<li>对于由静态存储器（spiflash nandflash）启动，这个relocation是必须的，将代码搬到DRAM中运行</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">relocate_code(addr_sp, id, addr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>id: 之前在 U-boot 的 1M 空间中分配的 GD 结构体的地址<br>addr: U-boot 重新定位到 DRAM 之后的代码起始地址</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * void relocate_code (addr_sp, gd, addr_moni)</span><br><span class="line"> *</span><br><span class="line"> * This &quot;function&quot; does not return, instead it continues in RAM</span><br><span class="line"> * after relocating the monitor code.</span><br><span class="line"> *</span><br><span class="line"> * a0 = addr_sp</span><br><span class="line"> * a1 = gd</span><br><span class="line"> * a2 = destination address</span><br><span class="line"> */</span><br><span class="line">	.globl	relocate_code</span><br><span class="line">	.ent	relocate_code</span><br><span class="line">relocate_code:</span><br><span class="line">	move	sp, a0			# set new stack pointer</span><br><span class="line"></span><br><span class="line">	li	t0, CONFIG_SYS_MONITOR_BASE</span><br><span class="line">	sub	t6, a2, t0		# t6 &lt;-- relocation offset</span><br><span class="line"></span><br><span class="line">	la	t3, in_ram</span><br><span class="line">	lw	t2, -12(t3)		# t2 &lt;-- __image_copy_end</span><br><span class="line">	move	t1, a2</span><br><span class="line"></span><br><span class="line">	add	gp, t6			# adjust gp</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * t0 = source address</span><br><span class="line">	 * t1 = target address</span><br><span class="line">	 * t2 = source end address</span><br><span class="line">	 */</span><br><span class="line">1:</span><br><span class="line">	lw	t3, 0(t0)</span><br><span class="line">	sw	t3, 0(t1)</span><br><span class="line">	addu	t0, 4</span><br><span class="line">	blt	t0, t2, 1b</span><br><span class="line">	 addu	t1, 4</span><br><span class="line"></span><br><span class="line">	/* If caches were enabled, we would have to flush them here. */</span><br><span class="line"></span><br><span class="line">	/* flush d-cache */</span><br><span class="line">	li	t0, KSEG0</span><br><span class="line">	or	t1, t0, CONFIG_SYS_DCACHE_SIZE</span><br><span class="line">2:</span><br><span class="line">	cache	INDEX_WRITEBACK_INV_D, 0(t0)</span><br><span class="line">	bne	t0, t1, 2b</span><br><span class="line">	 addi	t0, CONFIG_SYS_CACHELINE_SIZE</span><br><span class="line"></span><br><span class="line">	sync</span><br><span class="line"></span><br><span class="line">	/* flush i-cache */</span><br><span class="line">	li	t0, KSEG0</span><br><span class="line">	or	t1, t0, CONFIG_SYS_ICACHE_SIZE</span><br><span class="line">3:</span><br><span class="line">	cache	INDEX_INVALIDATE_I, 0(t0)</span><br><span class="line">	bne	t0, t1, 3b</span><br><span class="line">	 addi	t0, CONFIG_SYS_CACHELINE_SIZE</span><br><span class="line"></span><br><span class="line">	/* Invalidate BTB */</span><br><span class="line">	mfc0	t0, CP0_CONFIG, 7</span><br><span class="line">	nop</span><br><span class="line">	ori	t0, 2</span><br><span class="line">	mtc0	t0, CP0_CONFIG, 7</span><br><span class="line">	nop</span><br><span class="line"></span><br><span class="line">	/* Jump to where we&apos;ve relocated ourselves */</span><br><span class="line">	addi	t0, a2, in_ram - _start</span><br><span class="line">	jr	t0</span><br><span class="line">	 nop</span><br><span class="line"></span><br><span class="line">	.word	__rel_dyn_end</span><br><span class="line">	.word	__rel_dyn_start</span><br><span class="line">	.word	__image_copy_end</span><br><span class="line">	.word	_GLOBAL_OFFSET_TABLE_</span><br><span class="line">	.word	num_got_entries</span><br><span class="line"></span><br><span class="line">in_ram:</span><br><span class="line">	/*</span><br><span class="line">	 * Now we want to update GOT.</span><br><span class="line">	 *</span><br><span class="line">	 * GOT[0] is reserved. GOT[1] is also reserved for the dynamic object</span><br><span class="line">	 * generated by GNU ld. Skip these reserved entries from relocation.</span><br><span class="line">	 */</span><br><span class="line">	lw	t3, -4(t0)		# t3 &lt;-- num_got_entries</span><br><span class="line">	lw	t4, -8(t0)		# t4 &lt;-- _GLOBAL_OFFSET_TABLE_</span><br><span class="line">	add	t4, t6			# t4 now holds relocated _G_O_T_</span><br><span class="line">	addi	t4, t4, 8		# skipping first two entries</span><br><span class="line">	li	t2, 2</span><br><span class="line">1:</span><br><span class="line">	lw	t1, 0(t4)</span><br><span class="line">	beqz	t1, 2f</span><br><span class="line">	 add	t1, t6</span><br><span class="line">	sw	t1, 0(t4)</span><br><span class="line">2:</span><br><span class="line">	addi	t2, 1</span><br><span class="line">	blt	t2, t3, 1b</span><br><span class="line">	 addi	t4, 4</span><br><span class="line"></span><br><span class="line">	/* Update dynamic relocations */</span><br><span class="line">	lw	t1, -16(t0)		# t1 &lt;-- __rel_dyn_start</span><br><span class="line">	lw	t2, -20(t0)		# t2 &lt;-- __rel_dyn_end</span><br><span class="line"></span><br><span class="line">	b	2f			# skip first reserved entry</span><br><span class="line">	 addi	t1, 8</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">	lw	t3, -4(t1)		# t3 &lt;-- relocation info</span><br><span class="line"></span><br><span class="line">	sub	t3, 3</span><br><span class="line">	bnez	t3, 2f			# skip non R_MIPS_REL32 entries</span><br><span class="line">	 nop</span><br><span class="line"></span><br><span class="line">	lw	t3, -8(t1)		# t3 &lt;-- location to fix up in FLASH</span><br><span class="line"></span><br><span class="line">	lw	t4, 0(t3)		# t4 &lt;-- original pointer</span><br><span class="line">	add	t4, t6			# t4 &lt;-- adjusted pointer</span><br><span class="line"></span><br><span class="line">	add	t3, t6			# t3 &lt;-- location to fix up in RAM</span><br><span class="line">	sw	t4, 0(t3)</span><br><span class="line"></span><br><span class="line">2:</span><br><span class="line">	blt	t1, t2, 1b</span><br><span class="line">	 addi	t1, 8			# each rel.dyn entry is 8 bytes</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Clear BSS</span><br><span class="line">	 *</span><br><span class="line">	 * GOT is now relocated. Thus __bss_start and __bss_end can be</span><br><span class="line">	 * accessed directly via $gp.</span><br><span class="line">	 */</span><br><span class="line">	la	t1, __bss_start		# t1 &lt;-- __bss_start</span><br><span class="line">	la	t2, __bss_end		# t2 &lt;-- __bss_end</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">	sw	zero, 0(t1)</span><br><span class="line">	blt	t1, t2, 1b</span><br><span class="line">	 addi	t1, 4</span><br><span class="line"></span><br><span class="line">	move	a0, a1			# a0 &lt;-- gd</span><br><span class="line">	la	t9, board_init_r</span><br><span class="line">	jr	t9</span><br><span class="line">	 move	a1, a2</span><br><span class="line"></span><br><span class="line">	.end	relocate_code</span><br></pre></td></tr></table></figure>
<ol>
<li>移动gp指针</li>
<li>复制代码到RAM中</li>
<li>刷新一下cache</li>
<li>跳到RAM代码当中去（in_ram）,in_ram的主要工作是：更新GOT;清空BSS段；最后跳到<code>board_init_r</code>。</li>
</ol>
<h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><ol>
<li>如何对函数进行寻址调用</li>
<li>如何对全局变量进行寻址操作（读写）</li>
<li>对于全局指针变量中存储的其他变量或函数地址在relocation之后如何操作</li>
</ol>
<h5 id="uboot-GOT"><a href="#uboot-GOT" class="headerlink" title="uboot GOT"></a>uboot GOT</h5><blockquote>
<p>GOTs(global offset tables):是uboot能跳转到不同空间运行的原理.</p>
</blockquote>
<p>一个完整可运行的bin文件，link时指定的链接地址，load时的加载地址，运行时的运行地址，这3个地址应该是一致的。但是<code>relocation</code>后运行地址不同于加载地址，特别是链接地址，uboot任何进行函数跳转？？？</p>
<p>compiler在cc时加入<code>-fpic</code>或<code>-fpie</code>选项，会在目标文件中生成GOT（global offset table），将本文件中需要relocate的值存放在GOT中，函数尾部的Label来存储GOT的offset以及其中变量的offset，变量寻址首先根据尾部Label相对寻址找到GOT地址，以及变量地址在GOT中的位置，从而确定变量地址，这样对于目标文件统一修改GOT中的值，就修改了变量地址的offset，完成了relocation。</p>
<p>ld时加入-pie选项，就会将GOT并入到<code>rel.dyn</code>段中，uboot在relocate_code中统一根据rel.dyn段修改需要relocation的数值</p>
<h5 id="划分RAM"><a href="#划分RAM" class="headerlink" title="划分RAM"></a>划分RAM</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|    boot params   |</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|    Global Data   |</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|    Board Info    |</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|   mallco(+env)   |</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|   uboot code     |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>
<h4 id="board-init-r-1"><a href="#board-init-r-1" class="headerlink" title="board_init_r"></a>board_init_r</h4><blockquote>
<p>This is the next part if the initialization sequence: we are now running from RAM and have a “normal” C environment, i. e. global data can be written, BSS has been cleared, the stack size in not that critical any more, etc.</p>
</blockquote>
<p>此时已在DRAM中运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SYS_NO_FLASH</span></span><br><span class="line">	ulong <span class="built_in">size</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">bd_t</span> *bd;</span><br><span class="line"></span><br><span class="line">	gd = id;</span><br><span class="line">	gd-&gt;flags |= GD_FLG_RELOC;	<span class="comment">/* tell others: relocation done */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now running in RAM - U-Boot at: %08lx\n"</span>, dest_addr);</span><br><span class="line"></span><br><span class="line">	gd-&gt;relocaddr = dest_addr;</span><br><span class="line">	gd-&gt;reloc_off = dest_addr - CONFIG_SYS_MONITOR_BASE;</span><br><span class="line"></span><br><span class="line">	monitor_flash_len = image_copy_end() - dest_addr;</span><br><span class="line"></span><br><span class="line">	board_early_init_r();</span><br><span class="line"></span><br><span class="line">	serial_initialize();</span><br><span class="line"></span><br><span class="line">	bd = gd-&gt;bd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The Malloc area is immediately below the monitor copy in DRAM */</span></span><br><span class="line">	mem_malloc_init(CONFIG_SYS_MONITOR_BASE + gd-&gt;reloc_off -</span><br><span class="line">			TOTAL_MALLOC_LEN, TOTAL_MALLOC_LEN);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SYS_NO_FLASH</span></span><br><span class="line">	<span class="comment">/* configure available FLASH banks */</span></span><br><span class="line">	<span class="built_in">size</span> = flash_init();</span><br><span class="line">	display_flash_config(<span class="built_in">size</span>);</span><br><span class="line">	bd-&gt;bi_flashstart = CONFIG_SYS_FLASH_BASE;</span><br><span class="line">	bd-&gt;bi_flashsize = <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_SYS_MONITOR_BASE == CONFIG_SYS_FLASH_BASE</span></span><br><span class="line">	bd-&gt;bi_flashoffset = monitor_flash_len;	<span class="comment">/* reserved area for U-Boot */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	bd-&gt;bi_flashoffset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	bd-&gt;bi_flashstart = <span class="number">0</span>;</span><br><span class="line">	bd-&gt;bi_flashsize = <span class="number">0</span>;</span><br><span class="line">	bd-&gt;bi_flashoffset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MMC</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"MMC:   "</span>);</span><br><span class="line">	mmc_initialize(bd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* relocate environment function pointers etc. */</span></span><br><span class="line">	env_relocate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*leave this here (after malloc(), environment and PCI are working)*/</span></span><br><span class="line">	<span class="comment">/* Initialize stdio devices */</span></span><br><span class="line">	stdio_init();</span><br><span class="line"></span><br><span class="line">	jumptable_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the console (after the relocation and devices init) */</span></span><br><span class="line">	console_init_r();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize from environment */</span></span><br><span class="line">	load_addr = getenv_ulong(<span class="string">"loadaddr"</span>, <span class="number">16</span>, load_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_USB_GADGET</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">board_usb_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	board_usb_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MISC_INIT_R)</span></span><br><span class="line">	<span class="comment">/* miscellaneous platform dependent initialisations */</span></span><br><span class="line">	misc_init_r();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BITBANGMII</span></span><br><span class="line">	bb_miiphy_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_CMD_NET)</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Net:   "</span>);</span><br><span class="line">	eth_initialize(gd-&gt;bd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* main_loop() can return to retry autoboot, if so just run it again. */</span></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">		main_loop();</span><br><span class="line">	<span class="comment">/*NOTREACHED - no way out of command loop except booting*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化串口</li>
<li>初始化系统内存分配函数</li>
<li>如果使用MMC存储介质，初始化MMC设备</li>
<li>初始化环境变量的指针,将 env_ptr 指针及其指向的地址初始化，用来存放环境变量结构体，然后将 flash 中的环境变量拷贝到内存中。</li>
<li>初始化sdio设备</li>
<li>初始化网络设备</li>
<li>进去命令循环（即整个boot的工作循环），接受用户从串口输入的命令，然后进行相应的工作</li>
</ol>
<h3 id="main-loop"><a href="#main-loop" class="headerlink" title="main_loop"></a>main_loop</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_loop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, <span class="string">"main_loop"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*刷新LCD*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_UPDATE_TFTP)</span></span><br><span class="line">	update_tftp(<span class="number">0U</span>L);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_UPDATE_TFTP */</span></span></span><br><span class="line"><span class="comment">/*从环境变量中取得bootdelay 内核等待延时*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BOOTDELAY</span></span><br><span class="line">	process_boot_delay();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Main Loop for Monitor Command Processing</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		len = readline (CONFIG_SYS_PROMPT);</span><br><span class="line"></span><br><span class="line">		flag = <span class="number">0</span>;	<span class="comment">/* assume no special flags for now */</span></span><br><span class="line">		<span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">strcpy</span> (lastcommand, console_buffer);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">			flag |= CMD_FLAG_REPEAT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">puts</span> (<span class="string">"&lt;INTERRUPT&gt;\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rc = run_command(lastcommand, flag); <span class="comment">//执行命令</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* invalid command or not repeatable, forget it */</span></span><br><span class="line">			lastcommand[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file:common/main.c</p>
</blockquote>
<h3 id="do-bootm"><a href="#do-bootm" class="headerlink" title="do_bootm"></a>do_bootm</h3><p>将内核解压缩，然后调用do_bootm_linux引导内核</p>
<h3 id="do-bootm-linux"><a href="#do-bootm-linux" class="headerlink" title="do_bootm_linux"></a>do_bootm_linux</h3><p>启动内核</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/skyflying2012/article/details/37660265" target="_blank" rel="noopener">uboot的relocation原理详细分析</a></li>
</ol>
]]></content>
      <categories>
        <category>uboot</category>
      </categories>
      <tags>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>时钟线中串联电阻的作用--阻抗匹配</title>
    <url>/post/20813.html</url>
    <content><![CDATA[<p>时钟线上接电阻，对整个电路的影响，和输出时钟的影响</p>
<blockquote>
<p>如果阻抗不匹配会有什么不良后果呢？如果不匹配，则会形成反射，能量传递不过去，降低效率；会在传输线上形成驻波（简单的理解，就是有些地方信号强，有些地方信号弱），导致传输线的有效功率容量降低；功率发射不出去，甚至会损坏发射设备。</p>
</blockquote>
<a id="more"></a>
<h2 id="信号线电阻串联应用"><a href="#信号线电阻串联应用" class="headerlink" title="信号线电阻串联应用"></a>信号线电阻串联应用</h2><p><code>高速信号线</code>中才考虑使用这样的电阻，在<code>低频信号线</code>，一般是直接连接；</p>
<p>作用：</p>
<blockquote>
<p>第一:<code>阻抗匹配</code>。因为信号源的阻抗很低，跟信号线之间阻抗不匹配，串上一个电阻后，可改善匹配情况，以减少反射，避免振荡等；</p>
</blockquote>
<blockquote>
<p>第二：可以<code>减少信号边沿的陡峭程度</code>，从而减少高频噪声以及过冲等，因为串联的电阻，跟信号线的分布电容以及负载的输入电容等形成一个<code>RC电路</code>，这样就会降低信号边沿的陡峭程度，如果一个信号的边沿非常陡峭，含有大量的高频成分，将会辐射干扰，另外，也容易产生过冲；</p>
</blockquote>
<h2 id="阻抗匹配"><a href="#阻抗匹配" class="headerlink" title="阻抗匹配"></a>阻抗匹配</h2><p><code>阻抗匹配</code>是指<code>信号源</code>或者<code>传输线</code>跟<code>负载</code>之间的一种合适的搭配方式阻抗匹配分为<code>低频</code>和<code>高频</code>两种情况</p>
<p>先从<code>直流电压源驱动一个负载</code>入手。由于实际的电压源，总是有<code>内阻</code>的（请参看输出阻抗一问），我们可以把一个实际电压源，等效成一个理想的电压源跟一个电阻r串联的模型。</p>
<p><img src="/images/2018/07/DC-cicuit-1.png" alt="直流电路"></p>
<p>假设负载电阻为R，电源电动势为U，内阻为r，那么我们可以计算：</p>
<ul>
<li>负载R的电流为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I=U/(R+r)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>负载电阻R越小，则输出电流越大。</p>
</blockquote>
<ul>
<li>负载R的电压为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uo=IR=U/[1+(r/R)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>负载电阻R越大，则输出电压Uo越高。</p>
</blockquote>
<ul>
<li>负载R消耗的功率为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P=I^2×R=[U/(R+r)]^2×R=U^2×R/(R^2+2xR×r+r^2)</span><br><span class="line">      =U^2×R/[(R-r)^2+4×R×r]</span><br><span class="line">      =U^2/&#123;[(R-r)2/R]+4×r&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>对于一个给定的信号源，其<code>内阻r是固定</code>的，而负载电阻R则是由我们来选择的注意式中<code>[(R-r)2/R]</code>:<br>当<code>R=r</code>时，<code>[(R-r)2/R]</code>可取得最小值0，这时负载电阻R上可获得最大输出功率Pmax=U^2/(4×r)即，当<code>负载电阻跟信号源内阻相等时，负载可获得最大输出功率</code>，这就是我们常说的阻抗匹配之一。</p>
</blockquote>
<p>对于纯电阻电路，<code>此结论同样适用于低频电路及高频电路</code>，当交流电路中含有容性或感性阻抗时，结论有所改变，就是需要信号源与负载阻抗的实部相等，虚部互为相反数，这叫做共扼匹配；</p>
<p>在低频电路中，我们一般不考虑传输线的匹配问题，只考虑信号源跟负载之间的情况，因为低频信号的波长相对于传输线来说很长，传输线可以看成是“短线”，反射可以不考虑（可以这么理解：因为线短，即使反射回来，跟原信号还是一样的）</p>
<p>在高频电路中，我们还必须考虑反射的问题当信号的频率很高时，则信号的波长就很短，当波长短得跟传输线长度可以比拟时，反射信号叠加在原信号上将会改变原信号的形状，如果传输线的特征阻抗跟负载阻抗不相等（即不匹配）时，在负载端就会产生反射。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>如果是高速信号线上串小电阻，那就应该是终端阻抗匹配</li>
<li>如果是GPIO口上串了小电阻，很可能是抗小能量电压脉冲</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.sina.com.cn/s/blog_6db275da0100z85j.html" target="_blank" rel="noopener">信号线时钟线地址线GPIO串联小电阻作用</a></li>
</ul>
]]></content>
      <categories>
        <category>电子电路</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title>RC电路</title>
    <url>/post/40769.html</url>
    <content><![CDATA[<p>由电阻R和电容C组成的电路称为阻容电路，简称<code>RC电路</code></p>
<a id="more"></a>
<h2 id="RC串联电路"><a href="#RC串联电路" class="headerlink" title="RC串联电路"></a>RC串联电路</h2><h2 id="RC并联电路"><a href="#RC并联电路" class="headerlink" title="RC并联电路"></a>RC并联电路</h2><h2 id="RC-串并联电路"><a href="#RC-串并联电路" class="headerlink" title="RC 串并联电路"></a>RC 串并联电路</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://baijiahao.baidu.com/s?id=1579574575136458010&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">RC电路（一）RC串联、并联电路详解</a></li>
</ul>
]]></content>
      <categories>
        <category>电子电路</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title>网络带宽测试</title>
    <url>/post/21135.html</url>
    <content><![CDATA[<p><code>iperf</code>是一个网络性能测试工具。Iperf可以测试TCP和UDP带宽质量。Iperf可以测量最大TCP带宽，具有多种参数和UDP特性。 Iperf可以报告带宽，延迟抖动和数据包丢失。利用Iperf这一特性，可以用来测试一些网络设备如路由器，防火墙，交换机等的性能。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><p>下载地址： <a href="https://iperf.fr/iperf-download.php" target="_blank" rel="noopener">here</a></p>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">IPERF_VERSION="3.1.3"</span><br><span class="line">ARM_GCC="arm-linux-gnueabihf-gcc"</span><br><span class="line">PWD=`pwd`</span><br><span class="line"></span><br><span class="line">wget https://iperf.fr/download/source/iperf-$&#123;IPERF_VERSION&#125;-source.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf iperf-$&#123;IPERF_VERSION&#125;-source.tar.gz</span><br><span class="line"></span><br><span class="line">cd iperf-$&#123;IPERF_VERSION&#125;/</span><br><span class="line">mkdir install</span><br><span class="line"></span><br><span class="line">./configure  --host=arm-linux CC=$&#123;ARM_GCC&#125; --prefix=$&#123;PWD&#125;/install</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iperf --<span class="built_in">help</span></span></span><br><span class="line">Usage: iperf [-s|-c host] [options]</span><br><span class="line">       iperf [-h|--help] [-v|--version]</span><br><span class="line"></span><br><span class="line">Client/Server:</span><br><span class="line">  -f, --format    [kmKM]   format to report: Kbits, Mbits, KBytes, MBytes</span><br><span class="line">  -i, --interval  #        seconds between periodic bandwidth reports</span><br><span class="line">  -l, --len       #[KM]    length of buffer to read or write (default 8 KB)</span><br><span class="line">  -m, --print_mss          print TCP maximum segment size (MTU - TCP/IP header)</span><br><span class="line">  -o, --output    &lt;filename&gt; output the report or error message to this specified file</span><br><span class="line">  -p, --port      #        server port to listen on/connect to</span><br><span class="line">  -u, --udp                use UDP rather than TCP</span><br><span class="line">  -w, --window    #[KM]    TCP window size (socket buffer size)</span><br><span class="line">  -B, --bind      &lt;host&gt;   bind to &lt;host&gt;, an interface or multicast address</span><br><span class="line">  -C, --compatibility      for use with older versions does not sent extra msgs</span><br><span class="line">  -M, --mss       #        set TCP maximum segment size (MTU - 40 bytes)</span><br><span class="line">  -N, --nodelay            set TCP no delay, disabling Nagle's Algorithm</span><br><span class="line">  -V, --IPv6Version        Set the domain to IPv6</span><br><span class="line"></span><br><span class="line">Server specific:</span><br><span class="line">  -s, --server             run in server mode</span><br><span class="line">  -U, --single_udp         run in single threaded UDP mode</span><br><span class="line">  -D, --daemon             run the server as a daemon</span><br><span class="line"></span><br><span class="line">Client specific:</span><br><span class="line">  -b, --bandwidth #[KM]    for UDP, bandwidth to send at in bits/sec</span><br><span class="line">                           (default 1 Mbit/sec, implies -u)</span><br><span class="line">  -c, --client    &lt;host&gt;   run in client mode, connecting to &lt;host&gt;</span><br><span class="line">  -d, --dualtest           Do a bidirectional test simultaneously</span><br><span class="line">  -n, --num       #[KM]    number of bytes to transmit (instead of -t)</span><br><span class="line">  -r, --tradeoff           Do a bidirectional test individually</span><br><span class="line">  -t, --time      #        time in seconds to transmit for (default 10 secs)</span><br><span class="line">  -F, --fileinput &lt;name&gt;   input the data to be transmitted from a file</span><br><span class="line">  -I, --stdin              input the data to be transmitted from stdin</span><br><span class="line">  -L, --listenport #       port to receive bidirectional tests back on</span><br><span class="line">  -P, --parallel  #        number of parallel client threads to run</span><br><span class="line">  -T, --ttl       #        time-to-live, for multicast (default 1)</span><br><span class="line">  -Z, --linux-congestion &lt;algo&gt;  set TCP congestion control algorithm (Linux only)</span><br><span class="line"></span><br><span class="line">Miscellaneous:</span><br><span class="line">  -x, --reportexclude [CDMSV]   exclude C(connection) D(data) M(multicast) S(settings) V(server) reports</span><br><span class="line">  -y, --reportstyle C      report as a Comma-Separated Values</span><br><span class="line">  -h, --help               print this message and quit</span><br><span class="line">  -v, --version            print version information and quit</span><br><span class="line"></span><br><span class="line">[KM] Indicates options that support a K or M suffix for kilo- or mega-</span><br><span class="line"></span><br><span class="line">The TCP window size option can be set by the environment variable</span><br><span class="line">TCP_WINDOW_SIZE. Most other options can be set by an environment variable</span><br><span class="line">IPERF_&lt;long option name&gt;, such as IPERF_BANDWIDTH.</span><br><span class="line"></span><br><span class="line">Report bugs to &lt;iperf-users@lists.sourceforge.net&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">命令行选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-i, –interval</td>
<td style="text-align:left">设置每次报告之间的时间间隔，单位为秒。如果设置为非零值，就会按照此时间间隔输出测试报告。默认值为零。</td>
</tr>
<tr>
<td style="text-align:left">-l, –len #[KM]</td>
<td style="text-align:left">设置读写缓冲区的长度。TCP方式默认为8KB，UDP方式默认为1470字节。</td>
</tr>
<tr>
<td style="text-align:left">-p, –port</td>
<td style="text-align:left">设置端口，与服务器端的监听端口一致。默认是5001端口，与ttcp的一样。</td>
</tr>
<tr>
<td style="text-align:left">-u, –udp</td>
<td style="text-align:left">使用UDP方式而不是TCP方式。参看-b选项。</td>
</tr>
<tr>
<td style="text-align:left">Server</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">-s, –server</td>
<td style="text-align:left">Iperf服务器模式</td>
</tr>
<tr>
<td style="text-align:left">-c, –client host</td>
<td style="text-align:left">如果Iperf运行在服务器模式，并且用-c参数指定一个主机，那么Iperf将只接受指定主机的连接。此参数不能工作于UDP模式。</td>
</tr>
<tr>
<td style="text-align:left">Client</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">-c, –client host</td>
<td style="text-align:left">运行Iperf的客户端模式，连接到指定的Iperf服务器端。</td>
</tr>
<tr>
<td style="text-align:left">-t, –time #</td>
<td style="text-align:left">设置传输的总时间。Iperf在指定的时间内，重复的发送指定长度的数据包。默认是10秒钟。参考-l与-n选项。</td>
</tr>
<tr>
<td style="text-align:left">-P, –parallel #</td>
<td style="text-align:left">线程数。指定客户端与服务端之间使用的线程数。默认是1线程。需要客户端与服务器端同时使用此参数。</td>
</tr>
<tr>
<td style="text-align:left">-d, –dualtest</td>
<td style="text-align:left">运行双测试模式。这将使服务器端反向连接到客户端，使用-L 参数中指定的端口（或默认使用客户端连接到服务器端的端口）。这些在操作的同时就立即完成了。如果你想要一个交互的测试，请尝试-r参数。</td>
</tr>
</tbody>
</table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>带宽测试通常采用<code>UDP模式</code>，因为能测出极限带宽、时延抖动、丢包率。在进行测试时，首先以链路理论带宽作为数据发送速率进行测试，例如，从客户端到服务器之间的链路的理论带宽为100Mbps，先用<code>-b 100M</code>进行测试，然后根据测试结果（包括实际带宽，时延抖动和丢包率），再以实际带宽作为数据发送速率进行测试，会发现时延抖动和丢包率比第一次好很多，重复测试几次，就能得出稳定的实际带宽。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>服务器端：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf -s</span><br></pre></td></tr></table></figure></p>
<p>客户端：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf -c 192.168.1.1 -t 60</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在tcp模式下，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf -c 192.168.1.1  -P 30 -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端同时向服务器端发起30个连接线程。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf -c 192.168.1.1  -d -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进行上下行带宽测试。</p>
</blockquote>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>服务器端：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf -u -s</span><br></pre></td></tr></table></figure></p>
<p>客户端：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf -u -c 192.168.1.1 -b 100M -t 60</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在udp模式下，以100Mbps为数据发送速率，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf -u -c 192.168.1.1 -b 5M -P 30 -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端同时向服务器端发起30个连接线程，以5Mbps为数据发送速率。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf -u -c 192.168.1.1 -b 100M -d -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以100M为数据发送速率，进行上下行带宽测试。</p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell字符串处理——配置文件获取版本号</title>
    <url>/post/35545.html</url>
    <content><![CDATA[<p>字符串的截取和最后一个字符的删除</p>
<a id="more"></a>
<p>配置文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">software_version  = xxxxxxx-V1.0.2</span><br><span class="line">hdmi_info=1920*1080p@60@48000</span><br><span class="line">wlan_ip=  0.0.0.0</span><br><span class="line">mac_address=  00:00:00:00:00:00</span><br><span class="line">encode_rate  =8192</span><br><span class="line">wfd_mode_tcp  =true</span><br></pre></td></tr></table></figure></p>
<p>过滤脚本：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CFGD_CONF="$&#123;OSDRV_DIR&#125;/conf/db/cfgd.conf"</span><br><span class="line">software_version=`grep "software_version" $&#123;VANXUM_CFGD_CONF&#125; | awk '&#123;sub(/.$/,"")&#125;1' | awk '&#123;print $3&#125;'`</span><br><span class="line"></span><br><span class="line">echo "current software_version: [$&#123;software_version&#125;]"</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>awk &#39;{sub(/.$/,&quot;&quot;)}1&#39;</code>: 去掉最后一个字符</li>
<li><code>awk &#39;{print $3}&#39;</code>：输出版本号</li>
</ul>
<blockquote>
<p>直接使用grep得到的<code>software_version</code>这行最后一个字符是<code>？</code>，影响输出结果因此要去掉</p>
</blockquote>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg学习笔记——环境搭建</title>
    <url>/post/24238.html</url>
    <content><![CDATA[<ul>
<li>本地环境：<code>ubuntu18.04</code></li>
<li>FFmpeg版本：<code>3.4.4</code></li>
</ul>
<a id="more"></a>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y  nasm</span><br></pre></td></tr></table></figure>
<h3 id="编译FFmpeg"><a href="#编译FFmpeg" class="headerlink" title="编译FFmpeg"></a>编译FFmpeg</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PWD=`pwd`</span><br><span class="line">build_dir="ffmpeg"</span><br><span class="line">ffmpeg_version="n3.4.4"</span><br><span class="line">build_out="out"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function local_env_prepare()</span><br><span class="line">&#123;</span><br><span class="line">	sudo apt-get install -y  nasm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ffmpeg_prepare()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if [ ! -d $build_dir ]; then</span><br><span class="line">		mkdir $build_dir</span><br><span class="line">	fi</span><br><span class="line">	echo "Download FFmpeg ..."</span><br><span class="line"></span><br><span class="line">	if [ -f $&#123;PWD&#125;/$&#123;build_dir&#125;/$&#123;ffmpeg_version&#125;.tar.gz ]; then</span><br><span class="line">		return 3</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	wget -P $build_dir https://github.com/FFmpeg/FFmpeg/archive/$&#123;ffmpeg_version&#125;.tar.gz</span><br><span class="line"></span><br><span class="line">	tar zxvf $build_dir/$&#123;ffmpeg_version&#125;.tar.gz -C $build_dir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ffmpeg_build()</span><br><span class="line">&#123;</span><br><span class="line">	local root_pwd=$PWD</span><br><span class="line">	cd ./$&#123;build_dir&#125;/FFmpeg-$&#123;ffmpeg_version&#125;</span><br><span class="line">	echo "Currect dir $PWD"</span><br><span class="line"></span><br><span class="line">	if [ -d $&#123;root_pwd&#125;/$&#123;build_dir&#125;/$&#123;build_out&#125; ]; then</span><br><span class="line">		return 4</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	./configure --enable-shared  --prefix=$&#123;root_pwd&#125;/$&#123;build_dir&#125;/$&#123;build_out&#125;</span><br><span class="line">	echo "./configure --enable-shared  --prefix=$&#123;root_pwd&#125;/$&#123;build_dir&#125;/$&#123;build_out&#125;"</span><br><span class="line">	make</span><br><span class="line">	make install</span><br><span class="line"></span><br><span class="line">	cd -</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">local_env_prepare</span></span><br><span class="line"></span><br><span class="line">ffmpeg_prepare</span><br><span class="line">if [ $? == 3 ]; then</span><br><span class="line">	echo "FFmpeg Installation package [$&#123;ffmpeg_version&#125;.tar.gz] already exists"</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">ffmpeg_build</span><br><span class="line">if [ $? == 4 ]; then</span><br><span class="line">	echo "Already built exit !!!"</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_CONSTANT_MACROS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavcodec/avcodec.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavformat/avformat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavutil/avutil.h"</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"FFmpeg Test!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	av_register_all();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"FFmpeg version:"</span> &lt;&lt; avcodec_version() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有代码：<a href="https://github.com/Winddoing/ffmpeg-study.git" target="_blank" rel="noopener">https://github.com/Winddoing/ffmpeg-study.git</a></p>
]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>多媒体硬件接口-HDMI、VGA</title>
    <url>/post/57610.html</url>
    <content><![CDATA[<p>常用的多媒体硬件接口的特性和基本数据传输原理</p>
<a id="more"></a>
<h2 id="HDMI"><a href="#HDMI" class="headerlink" title="HDMI"></a>HDMI</h2><blockquote>
<p>H-High，D-Definition，M-Multimedia，I-Interface；高清晰度多媒体接口</p>
</blockquote>
<h3 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h3><p><img src="/images/2018/08/hdmi_hardware_port.png" alt="hdmi_hardware_port"></p>
<blockquote>
<p>19pin脚</p>
<ul>
<li><code>TMDS</code> data channels (6 pins)</li>
<li><code>TMDS</code> clock channel (2 pins)</li>
<li>Consumer Electronics Control (CEC) (1 pin)</li>
<li>Display Data Channel (DDC)(1 pin)</li>
<li>+5V power (1 pin)</li>
<li>Hot Plug Detect (1 pin)</li>
<li>TMDS Shield Lines (4 pins designated in yellow)</li>
<li>CEC/DDC Ground (1 pin)</li>
</ul>
</blockquote>
<h3 id="逻辑接口"><a href="#逻辑接口" class="headerlink" title="逻辑接口"></a>逻辑接口</h3><p><img src="/images/2018/08/hdmi_in_out.png" alt="hdmi_in_out"></p>
<p>信号介绍：</p>
<ol>
<li>4对<code>TMDS差分信号</code>：1对时钟+3对数据:<ul>
<li>TMDS通道0传输B信号，同时H信号和V信号也嵌入该通道</li>
<li>TMDS通道1传输G信号</li>
<li>TMDS通道2传输R信号，R和G通道的多余位置用来传输音频信号</li>
</ul>
</li>
<li><code>CEC</code>：消费电子控制通道，通过这条通道可以控制设备之间的交互</li>
<li><code>DDC</code>：就是<code>I²C信号</code>，主要是获取显示器的基本信息(比如EDID信息)</li>
<li><code>HPD</code>：热插拔信号，该信号比较重要，当HPD引脚大于2V，TMDS才会输出。因此，如果屏幕没有显示，首先要测量该信号</li>
</ol>
<blockquote>
<ul>
<li><code>DCC</code>遵守的是I2C协议，EDID 存储在一个ROM 芯片中，HDMI协议规定ROM的I2C 地址必须是<code>0xA0</code>.电路设计中DDC端口上需要安装上拉电阻，电阻值最小要求达到1.3K。</li>
<li><code>CEC</code>是一套完整的协议，电子设备可以借着CEC信号让用者可控制HDMI接口上所连接的装置。如单键播放(One Touch Play)，系统待机(System Standby)。 即是如果用者将影碟放进蓝光播放器时，电视会由于CEC信号的通知而自动开机，然后视频通道亦会自动切换到播放器连接的通道上。而当用者关掉电视时，CEC信号亦会通知HDMI相连接的装置一同进入待机。由于这样，所以就可以完全变成单一遥控器控制所有HDMI连接的装置。</li>
</ul>
</blockquote>
<p>HDMI接口中的数据信号采用的是S最小化传输<code>差分信号</code>协议。这种协议会将标准8bit数据转换为10bit信号，并且在转换过程中使用<code>微分传送</code>。</p>
<h3 id="CEC"><a href="#CEC" class="headerlink" title="CEC"></a>CEC</h3><p>CEC是<code>单总线协议</code>，通过Phsical address Discovery Process机制来分配物理地址，DDC信号把物理地址传输到设备中。当一个带CEC功能的设备获取到一个物理地址的时候，他将进行以下处理：</p>
<ol>
<li>主动申请分配与设备类型相应的逻辑地址</li>
<li>通过广播的方式来报告物理地址和对应的逻辑地址，实现绑定。</li>
</ol>
<h3 id="最大分辨率"><a href="#最大分辨率" class="headerlink" title="最大分辨率"></a>最大分辨率</h3><p><img src="/images/2018/08/hdmi_interface_max_pix.png" alt="hdmi_interface_max_pix"></p>
<blockquote>
<p>接口所支持的协议不同，最大分辨率将不同</p>
</blockquote>
<h2 id="VGA"><a href="#VGA" class="headerlink" title="VGA"></a>VGA</h2><p>VGA（Video Graphics Array）即<code>视频图形阵列</code>，是IBM在1987年随PS/2（PS/2 原是“Personal System 2”的意思，“个人系统2”.</p>
<p>VGA接口就是显卡上面输出模拟信号的接口。VGA接口是一种<code>D型接口</code>，上面共有<code>15针孔</code>，分成3排，每排5个，</p>
<p><img src="/images/2018/08/vga_hardware_port.png" alt="vga_hardware_port"></p>
<p>DDC:Display Data Channel(显示数据通道)， 用于EDID信息的传送，其实就是<code>I2C</code>数据线。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>VGA显示中，FPGA需要产生５个信号分别是：行<code>同步信号HS</code>、<code>场同步信号VS</code>、<code>R</code>、<code>G</code>、<code>B</code>三基色信号。</p>
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HS</td>
<td style="text-align:left">行同步信号（3.3V）</td>
</tr>
<tr>
<td style="text-align:center">VS</td>
<td style="text-align:left">场 / 帧 同步信号（3.3V）</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:left">红基色 （0~0.714V 模拟信号）</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:left">绿基色 （0~0.714V 模拟信号）</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:left">蓝基色 （0~0.714V 模拟信号）</td>
</tr>
</tbody>
</table>
<h3 id="最大分辨率-1"><a href="#最大分辨率-1" class="headerlink" title="最大分辨率"></a>最大分辨率</h3><p>VGA接口所能支持的最大分辨率是<code>2048X1536px</code></p>
<h2 id="DVI"><a href="#DVI" class="headerlink" title="DVI"></a>DVI</h2><p>DVI（Digital Visual Interface），即数字视频接口.</p>
<p><img src="/images/2018/09/dvi_interface.png" alt="DVI_interface"></p>
<p>DVI是基于<code>TMDS(Transition Minimized Differential Signaling)</code>，转换<code>最小差分信号</code>技术来传输数字信号，TMDS运用先进的编码算法把8bit数据(R、G、B中的每路基色信号)通过最小转换编码为10bit数据(包含行场同步信息、时钟信息、数据DE、纠错等)，经过DC平衡后，采用差分信号传输数据，它和LVDS、TTL相比有较好的电磁兼容性能，可以用低成本的专用电缆实现长距离、高质量的数字信号传输。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li>DVI-A（12+5）</li>
<li>DVI-D（24+1/18+1）: 只有数字接口</li>
<li>DVI-I（24+5）: 有数字和模拟接口</li>
</ol>
<h3 id="最大分辨率-2"><a href="#最大分辨率-2" class="headerlink" title="最大分辨率"></a>最大分辨率</h3><ul>
<li>DVI-I单通道最大分辨率:<code>1920x1200,60Hz</code></li>
<li>DVI-I双通道最大分辨率:<code>2560x1600,60Hz/1920x1200,120Hz</code></li>
<li>DVI-D单通道最大分辨率:<code>1920x1200,60Hz</code></li>
<li>DVI-D双通道最大分辨率:<code>2560x1600,60Hz/1920x1080,120Hz</code></li>
</ul>
<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>DisplayPort也是一种高清数字显示接口标准，可以连接电脑和显示器，也可以连接电脑和家庭影院。</p>
<p><img src="/images/2018/09/dp_interface.png" alt="dp_interface"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/huangyangquan/article/details/77487116" target="_blank" rel="noopener">HDMI接口基础知识及硬件设计</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>音视频同步</title>
    <url>/post/56216.html</url>
    <content><![CDATA[<p>音视频同步主要指两类：</p>
<ul>
<li>a. 同一设备播放音视频数据之间的同步</li>
<li>b. 不同设备（同一个音视频源通过组播播放）时，多个设备之间的音视频同步。（特例）<blockquote>
<p>在使用组播进行多路投放时，视频数据画面同步，但是音频数据不同步，没有丢音效果。</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h2 id="同一设备"><a href="#同一设备" class="headerlink" title="同一设备"></a>同一设备</h2><p>标准规定在原始音频和视频流中,<code>PTS</code>的间隔不能超过0.7s，出现在TS包头的PCR间隔不能超过0.1s。</p>
<p>同步模式：</p>
<ul>
<li>以音频为准</li>
<li>以视频为准</li>
</ul>
<blockquote>
<p>在音频和视频数据中的什么作为参考？？？</p>
</blockquote>
<h2 id="不同设备"><a href="#不同设备" class="headerlink" title="不同设备"></a>不同设备</h2><p><img src="/images/net/multicast/multicast_r_s_samp.png" alt="场景"></p>
<blockquote>
<p><strong>问题</strong>：实际视频投放中，视频画面同步，但是音频数据存在不同步现象。</p>
</blockquote>
<h3 id="音频产生不同步的可能性："><a href="#音频产生不同步的可能性：" class="headerlink" title="音频产生不同步的可能性："></a>音频产生不同步的可能性：</h3><ol>
<li>网络延时。</li>
<li>R端音频处理缓存区过大，数据处理之间存在时间差所致。</li>
<li>R端socket的接收buffer过大。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/wangguchangqing/p/5900426.html" target="_blank" rel="noopener">FFmpeg学习6：视音频同步</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>NEC红外遥控协议</title>
    <url>/post/34467.html</url>
    <content><![CDATA[<h2 id="nec"><a href="#nec" class="headerlink" title="nec"></a>nec</h2><ul>
<li><code>8位</code>地址码，<code>8位</code>命令码</li>
<li>完整发射两次地址码和命令码，以提高可靠性</li>
<li>脉冲时间长短调制方式</li>
<li><code>38KHz</code>载波频率</li>
<li>位时间<code>1.12ms</code>或<code>2.25ms</code></li>
</ul>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.sbprojects.net/knowledge/ir/nec.php" target="_blank" rel="noopener">NEC Protocol</a></li>
<li><a href="https://blog.csdn.net/jerryutscn/article/details/7201352" target="_blank" rel="noopener">NEC红外遥控协议理解与实现</a></li>
<li><a href="https://blog.csdn.net/techelefeng/article/details/45972583" target="_blank" rel="noopener">红外遥控器工作原理</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>IGMP snooping 查询器</title>
    <url>/post/51576.html</url>
    <content><![CDATA[<p>igmp在本地网络上的<code>主机</code>和<code>路由器</code>之间传达组成员信息，路由器定时向所有主机组多播igmp查询。主机多播igmp报告报文以响应查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00:43:16.580029 IP (tos 0x0, ttl 1, id 0, offset 0, flags [DF], proto IGMP (2), length 28)</span><br><span class="line">     192.168.99.112 &gt; 224.0.0.1: igmp query v1</span><br><span class="line">00:43:17.460173 IP (tos 0xc0, ttl 1, id 0, offset 0, flags [DF], proto IGMP (2), length 32, options (RA))</span><br><span class="line">     192.168.99.64 &gt; 239.0.0.11: igmp v1 report 239.0.0.11</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="IGMPv1报文格式"><a href="#IGMPv1报文格式" class="headerlink" title="IGMPv1报文格式"></a>IGMPv1报文格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+---------------------------------------------------------------</span><br><span class="line">|Version| Type  |    Unused     |           Checksum            |</span><br><span class="line">+---------------------------------------------------------------</span><br><span class="line">|                         Group Address                         |</span><br><span class="line">+---------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">长度</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Version</td>
<td style="text-align:center">4比特</td>
<td style="text-align:left">IGMP版本号，在IGMPv1中应为0x1。</td>
</tr>
<tr>
<td style="text-align:center">Type</td>
<td style="text-align:center">4比特</td>
<td style="text-align:left">即IGMP报文类型： 1 = Host Membership Query 主机成员查询; 2 = Host Membership Report 主机成员报告</td>
</tr>
<tr>
<td style="text-align:center">Unused</td>
<td style="text-align:center">8比特</td>
<td style="text-align:left">未使用的字段，发送时必须填0，接收时忽略。</td>
</tr>
<tr>
<td style="text-align:center">Checksum</td>
<td style="text-align:center">16比特</td>
<td style="text-align:left">IGMP消息的校验和。该字段在进行校验计算时设为0。当传送报文的时候，必须计算该校验字并插入到该字段中去。当接收包的时候，该校验字必须在处理该包之前进行检验。</td>
</tr>
<tr>
<td style="text-align:center">Group Address</td>
<td style="text-align:center">32比特</td>
<td style="text-align:left">组播地址。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>IGMPv1协议主要基于查询和响应机制完成组播组管理，支持查询和加入报文，处理过程与IGMPv2相同。IGMPv1与IGMPv2的不同之处是：主机离开组播组时不主动发送离开报文，收到查询消息后不反馈Report消息，待维护组成员关系的定时器超时后，路由器删除组记录。</p>
</blockquote>
<h2 id="协议栈结构"><a href="#协议栈结构" class="headerlink" title="协议栈结构"></a>协议栈结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">|             IGMPv1            |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|      IP (Protocol = 0x02)     |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|              L2               |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|              L1               |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure>
<p>IGMPv1消息封装在<code>IP报文</code>中。IP头部的Protocol字段值为0x02，用来<code>标识数据部分封装了IGMP消息</code>。</p>
<p>IP报文头的目的地址字段用来标识该IGMP消息的目的接收端。IP报文头的TTL字段值为1，表示IGMP消息只在本地网段传播。</p>
<p>格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                            +---------------------+------------------------+</span><br><span class="line">                            |type|code|   cksum   |       group addr       |</span><br><span class="line">                            +---------------------+------------------------+</span><br><span class="line">                            ^                                              ^</span><br><span class="line">                            |                                              |</span><br><span class="line">                            |                                              |</span><br><span class="line">                            +-------+                          +----------+</span><br><span class="line">                                    |                          |</span><br><span class="line">                                    |                          |</span><br><span class="line">+--------------------------------------------------------------+</span><br><span class="line">|                                   |                          |</span><br><span class="line">|              IP首部                |                          |</span><br><span class="line">|                                   |                          |</span><br><span class="line">+-----------------------------------+--------------------------+</span><br><span class="line">&lt;------------------------ IP数据包     -------------------------&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">igmp</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> igmp_type;             <span class="comment">/* IGMP type */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> igmp_code;             <span class="comment">/* routing code */</span></span><br><span class="line">  <span class="keyword">uint16_t</span> igmp_cksum;           <span class="comment">/* checksum */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">igmp_group</span>;</span>     <span class="comment">/* group address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Message types, including version number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_MEMBERSHIP_QUERY       0x11    <span class="comment">/* membership query         */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_V1_MEMBERSHIP_REPORT   0x12    <span class="comment">/* Ver. 1 membership report */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_V2_MEMBERSHIP_REPORT   0x16    <span class="comment">/* Ver. 2 membership report */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_V2_LEAVE_GROUP     0x17    <span class="comment">/* Leave-group message      */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_DVMRP          0x13    <span class="comment">/* DVMRP routing message    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_PIM            0x14    <span class="comment">/* PIM routing message      */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_TRACE          0x15</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_MTRACE_RESP        0x1e    <span class="comment">/* traceroute resp.(to sender)*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_MTRACE         0x1f    <span class="comment">/* mcast traceroute messages  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_MAX_HOST_REPORT_DELAY  10  <span class="comment">/* max delay for response to     */</span></span></span><br><span class="line">                        <span class="comment">/*  query (in seconds) according */</span></span><br><span class="line">                        <span class="comment">/*  to RFC1112                   */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IGMP_TIMER_SCALE        10  <span class="comment">/* denotes that the igmp code field */</span></span></span><br><span class="line">                        <span class="comment">/* specifies time in 10th of seconds */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>/usr/include/netinet/igmp.h</p>
</blockquote>
<p><strong>校验</strong>：<code>TCP</code>、<code>UDP</code>、<code>ICMP</code>、<code>IGMP</code>包首部中的检验和都是针对整个包（首部和数据部分）做检验的。</p>
<h3 id="IGMP-MEMBERSHIP-QUERY"><a href="#IGMP-MEMBERSHIP-QUERY" class="headerlink" title="IGMP_MEMBERSHIP_QUERY"></a>IGMP_MEMBERSHIP_QUERY</h3><p>成员关系查询，RFC1075推荐多播路由器每<code>120秒</code>至少发布一次IGMP成员关系查询。把查询发给224.0.0.1组（所有主机组）。</p>
<h3 id="IGMP-HOST-MEMEBER-REPORT-amp-amp-IGMP-V2-MEMBERSHIP-REPORT"><a href="#IGMP-HOST-MEMEBER-REPORT-amp-amp-IGMP-V2-MEMBERSHIP-REPORT" class="headerlink" title="IGMP_HOST_MEMEBER_REPORT &amp;&amp; IGMP_V2_MEMBERSHIP_REPORT"></a>IGMP_HOST_MEMEBER_REPORT &amp;&amp; IGMP_V2_MEMBERSHIP_REPORT</h3><p>成员关系报告</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">cksum</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cksum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> short_len = len / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; short_len; i++) &#123;</span><br><span class="line">        cksum += ((<span class="keyword">uint16_t</span>*)buf)[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span>) &#123;</span><br><span class="line">        cksum += ((<span class="keyword">uint8_t</span>*)buf)[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cksum = (cksum &gt;&gt; <span class="number">16</span>) + (cksum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    cksum = cksum + (cksum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (~cksum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>IP数据报的检验和：</p>
<p>为了计算一份数据报的I P检验和，首先把检验和字段置为0。然后，对首部中每个16 bit进行二进制反码求和（整个首部看成是由一串16 bit的字组成），结果存在检验和字段中。当收到一份I P数据报后，同样对首部中每个16 bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">igmp</span> <span class="title">igmp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">mgroup</span>, <span class="title">allhosts</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dst</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create socket */</span></span><br><span class="line">sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_IGMP);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multicast groups */</span></span><br><span class="line">mgroup.s_addr = inet_addr(<span class="string">"0.0.0.0"</span>);</span><br><span class="line"><span class="keyword">if</span> (mgroup.s_addr == INADDR_NONE) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Invalid multicast group '0.0.0.0'"</span>);</span><br><span class="line">     <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"> allhosts.s_addr = inet_addr(<span class="string">"224.0.0.1"</span>);</span><br><span class="line"> <span class="keyword">if</span> (allhosts.s_addr == INADDR_NONE) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Invalid multicast group '224.0.0.1'"</span>);</span><br><span class="line">     <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* IGMPv1 query */</span></span><br><span class="line"> igmp.igmp_type = IGMP_MEMBERSHIP_QUERY;</span><br><span class="line"> igmp.igmp_code = <span class="number">0</span>;</span><br><span class="line"> igmp.igmp_cksum = <span class="number">0</span>;</span><br><span class="line"> igmp.igmp_group = mgroup;</span><br><span class="line"> igmp.igmp_cksum = cksum(&amp;igmp, <span class="keyword">sizeof</span>(igmp));</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Destination */</span></span><br><span class="line"> dst.sin_family = AF_INET;</span><br><span class="line"> dst.sin_port = htons(<span class="number">0</span>);</span><br><span class="line"> dst.sin_addr = allhosts;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Transmit loop */</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (sendto(sockfd, &amp;igmp, <span class="keyword">sizeof</span>(igmp), <span class="number">0</span>, (struct sockaddr*)&amp;dst, <span class="keyword">sizeof</span>(dst)) == <span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Could not send IGMP query: %s"</span>, strerror(errno));</span><br><span class="line">     &#125;</span><br><span class="line">     sleep(options-&gt;interval);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>网络-ping命令</title>
    <url>/post/51638.html</url>
    <content><![CDATA[<p>判断网络的连通性和延时情况，通常使用<code>ping</code>命令。</p>
<p>ping发送一个<code>ICMP回声请求</code>消息给目的地并报告是否收到所希望的<code>ICMP回声应答</code>。它是用来检查网络是否通畅或者网络连接速度的命令</p>
<a id="more"></a>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ping -help</span><br><span class="line">Usage: ping [-aAbBdDfhLnOqrRUvV64] [-c count] [-i interval] [-I interface]</span><br><span class="line">            [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]</span><br><span class="line">            [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]</span><br><span class="line">            [-w deadline] [-W timeout] [hop1 ...] destination</span><br><span class="line">Usage: ping -6 [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]</span><br><span class="line">             [-l preload] [-m mark] [-M pmtudisc_option]</span><br><span class="line">             [-N nodeinfo_option] [-p pattern] [-Q tclass] [-s packetsize]</span><br><span class="line">             [-S sndbuf] [-t ttl] [-T timestamp_option] [-w deadline]</span><br><span class="line">             [-W timeout] destination</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:left">ping的次数</td>
</tr>
<tr>
<td style="text-align:center">-W</td>
<td style="text-align:left">一次ping的超时时间</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td style="text-align:left">发送数据包的大小，默认为32字节，最大可以定义到65500字节</td>
</tr>
</tbody>
</table>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>网络上的机器都有唯一确定的IP地址，我们给目标IP地址发送一个数据包，对方就要返回一个同样大小的数据包，根据返回的数据包我们可以确定目标主机的存在，可以初步判断目标主机的操作系统等。</p>
<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&gt; 28	26.646884	192.168.100.3	192.168.100.2	ICMP	98	Echo (ping) request  id=0xdc04, seq=0/0, ttl=64 (reply in 29)</span><br><span class="line">&lt;-- 29	26.646957	192.168.100.2	192.168.100.3	ICMP	98	Echo (ping) reply    id=0xdc04, seq=0/0, ttl=64 (request in 28）</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li><p>判断本地tcp/ip协议是否正常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping 127.0.0.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序中判断网络连接情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_S_CONNECT_NUM; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rIpList[i].valid == <span class="number">1</span>) &#123;</span><br><span class="line">        retry_num = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cmd, <span class="number">0</span>, <span class="number">120</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="built_in">sprintf</span>(cmd, <span class="string">"ping %s -c 1 -W 1 &gt; /dev/null"</span>, rIpList[i].ipstr);</span><br><span class="line">retry:</span><br><span class="line">        ret = system(cmd);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; retry_num) &#123;</span><br><span class="line">            retry_num--;</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> || !retry_num) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ip: %s, disconnected retry:%d !!!\n"</span>, rIpList[i].ipstr, retry_num);</span><br><span class="line">            VXLOG(<span class="string">"ip: %s, disconnected retry:%d !!!\n"</span>, rIpList[i].ipstr, retry_num);</span><br><span class="line">            rIpList[i].valid = <span class="number">0</span>;</span><br><span class="line">            alive--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>socket编程--网站</title>
    <url>/post/23509.html</url>
    <content><![CDATA[<p>一个有价值的网络编程的网站： <a href="https://www.winsocketdotnetworkprogramming.com/clientserversocketnetworkcommunication8chap.html" target="_blank" rel="noopener">https://www.winsocketdotnetworkprogramming.com/clientserversocketnetworkcommunication8chap.html</a></p>
<a id="more"></a>
<h2 id="The-Tenouk’s-Linux-Socket-network-programming-tutorial"><a href="#The-Tenouk’s-Linux-Socket-network-programming-tutorial" class="headerlink" title="The Tenouk’s Linux Socket (network) programming tutorial"></a>The Tenouk’s Linux Socket (network) programming tutorial</h2><p><a href="https://www.tenouk.com/cnlinuxsockettutorials.html" target="_blank" rel="noopener">https://www.tenouk.com/cnlinuxsockettutorials.html</a></p>
<h2 id="ORYX-embedded"><a href="#ORYX-embedded" class="headerlink" title="ORYX embedded"></a>ORYX embedded</h2><p><img src="/images/2018/08/net_layout.png" alt="net-layout"></p>
<ul>
<li><a href="https://www.oryx-embedded.com/" target="_blank" rel="noopener">https://www.oryx-embedded.com</a></li>
</ul>
<h3 id="相关协议源码"><a href="#相关协议源码" class="headerlink" title="相关协议源码"></a>相关协议源码</h3><blockquote>
<p><a href="https://www.oryx-embedded.com/doc/files.html" target="_blank" rel="noopener">源码目录</a></p>
</blockquote>
<p><img src="/images/2018/08/net_protocol_code.png" alt="net-protocol-code"></p>
]]></content>
  </entry>
  <entry>
    <title>Socket recv —— Connection reset by peer (104)</title>
    <url>/post/33577.html</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = recv(socket_fd, buf, len, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在接收数据时:</p>
<p>有时<code>recv</code>的返回值<code>n&lt;0</code>，错误码：<code>104（Connection reset by peer）</code>，为啥？</p>
<p>有时<code>recv</code>的返回值<code>n=0</code>,对端socket关闭，如果对端socket没有关闭，为啥<code>n=0</code>？</p>
<a id="more"></a>
<h2 id="Connection-reset-by-peer-ECONNRESET-104"><a href="#Connection-reset-by-peer-ECONNRESET-104" class="headerlink" title="Connection reset by peer : (ECONNRESET 104)"></a>Connection reset by peer : (ECONNRESET 104)</h2><p>socket <code>read/recv</code>过程中，对方socket中断，<code>read/recv</code>会先返回已经发送的字节数,再次write时返回-1,errno号为<code>ECONNRESET(104)</code>.即：<strong>read/recv 一个已收到<code>RST</code>的socket，系统会发SIGPIPE信号给该进程，如果将这个信号交给系统处理或者直接忽略掉了，read/recv都返回EPIPE错误</strong>.因此对于socket通信一定要捕获此信号，进行适当处理 ，否则程序的异常退出将会给你带来灾难。</p>
<blockquote>
<p>The client’s call to <code>readline</code> may happen before the server’s RST is received by the client, or it may happen after.<br>If the readline happens before the RST is received, as we’ve shown in our example, the result is an unexpected EOF in the client.<br>But if the RST arrives first, the result is an <code>ECONNRESET (&quot;Connection reset by peer&quot;)</code> error return from readline.<br>What happens if the client ignores the error return from readline and writes more data to the server?<br>This can happen, for example, if the client needs to perform two writes to the server before reading anything back, with the first write eliciting the RST.<br>The rule that applies is: When a process writes to a socket that has received an RST, the SIGPIPE signal is sent to the process.<br>The default action of this signal is to terminate the process, so the process must catch the signal to avoid being involuntarily terminated.<br>If the process either catches the signal and returns from the signal handler, or ignores the signal, the write operation returns EPIPE.</p>
</blockquote>
<h3 id="tcp-syncookies"><a href="#tcp-syncookies" class="headerlink" title="tcp_syncookies"></a>tcp_syncookies</h3><p>在高并发的情况下，内核会认为系统受到了SYN flood攻击，会发送cookies（possible SYN flooding on port 80. Sending cookies），这样会减慢影响请求的速度，所以在应用服务武器上设置下这个参数为0禁用系统保护就可以进行大并发测试了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 0</span><br></pre></td></tr></table></figure></p>
<h2 id="返回值-n-0"><a href="#返回值-n-0" class="headerlink" title="返回值: n==0"></a>返回值: n==0</h2><blockquote>
<p>When a stream socket peer has performed an orderly shutdown, the return value will be 0 (the traditional “end-of-file” return).<br>Datagram sockets in various domains (e.g., the UNIX and Internet domains) permit zero-length datagrams.  When such a datagram is received, the return value is 0.</p>
<blockquote>
<p>form <code>man recv</code></p>
</blockquote>
</blockquote>
<ul>
<li><p>产生的原因：<br>对端socket关闭，但是在实际的使用中对端的socket没有进行close的情况下有时也会返回<code>0</code>，这个可能就是数据传输中对端发送了长度为<code>0</code>的数据</p>
</li>
<li><p>解决方法：<br>在实际应用开发中我们需要进行错误处理时，将返回值小于等于0的状态进行统一处理。也就是在<code>accept</code>建立一个新的连接后，创建一个独立的线程进行数据的收发，如果在收发的过程中返回值出现错误时，关闭该socket和线程进入主进程重新建立一个连接继续进行数据收发（注意C/S端均得进行这样的处理）</p>
</li>
</ul>
<p><img src="/images/2020/10/socket_tcp.png" alt="Socket TCP"></p>
<blockquote>
<p>在Server端其实存在两socket连接，listen监听的是主的socket描述符(一直存在直到主动关闭)，而当每一次accept时将会重新创建一个新的socket描述符用于数据的收发</p>
</blockquote>
<ul>
<li><p>client端创建一个单独的线程进行数据处理，比如进行数据读取，<code>connect</code>建立连接后，通过<code>recvfrom</code>进行读取，如果在读取数据正常没有出现任何异常时，利用<code>recvfrom</code>函数的阻塞功能将该线程阻塞住直到对端再一次发送数据，但是如果出现任何异常（函数返回值&lt;=0）时,退出重新与对端建立新的连接后，继续数据读取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">do_readn_sync</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> n, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> numRead;   <span class="comment">/* # of bytes fetched by last read() */</span></span><br><span class="line">    <span class="keyword">size_t</span> totRead;    <span class="comment">/* Total # of bytes read so far */</span></span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">buffer</span>;</span><br><span class="line">    <span class="keyword">for</span>(totRead = <span class="number">0</span>; totRead &lt; n;) &#123;</span><br><span class="line">        numRead = recvfrom(fd, buf, n - totRead, flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numRead == <span class="number">0</span>)        <span class="comment">/* EOF */</span></span><br><span class="line">            <span class="keyword">return</span> totRead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numRead == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;       <span class="comment">/* Interrupted -- restart read() */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">/* Other error */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        totRead += numRead;</span><br><span class="line">        buf += numRead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totRead;             <span class="comment">/* Must be 'n' bytes if we get here */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Returns number of bytes read, 0 on EOF, or -1 on error</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn_sync</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_readn_sync(fd, <span class="built_in">buffer</span>, n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _do_data_read()</span><br><span class="line">&#123;</span><br><span class="line">    #业务数据判断满足的读取条件</span><br><span class="line">:next</span><br><span class="line">    fd = socket();</span><br><span class="line">    <span class="built_in">connect</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      ret = readn(vm_input_fd, (<span class="keyword">void</span> *)buff, datalen);</span><br><span class="line">    &#125; <span class="keyword">while</span>(ret&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd) &#123;</span><br><span class="line">      <span class="built_in">close</span>(fd);</span><br><span class="line">      fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>server端： 在<code>accept</code>建立一个新的连接后，创建一个独立的线程进行数据的收发，如果在收发的过程中返回值出现错误时，关闭该socket和线程进入主进程重新建立一个连接继续进行数据收发</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 伪代码</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _do_data_write(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    ret = send()</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">close</span>(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fd = socket();</span><br><span class="line">    bind();</span><br><span class="line">    <span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        new_fd = accept();</span><br><span class="line"></span><br><span class="line">        #也可以fork出一个进程进行处理</span><br><span class="line">        pthread_create(&amp;tid, &amp;attr, _do_data_write, (<span class="keyword">void</span> *)new_fd);</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h2><blockquote>
<p>socket编程中，<code>TCP_NODELAY</code>选项是用来控制是否开启<code>Nagle算法</code>，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数</p>
</blockquote>
<p>在TCP数据传输中，如果需要提高数据的实时性需要将<code>Nagle算法</code>关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Disable Nagle */</span></span><br><span class="line"><span class="keyword">int</span> disable_nagle;</span><br><span class="line"><span class="keyword">int</span> nagleopt_len = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != getsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;disable_nagle, &amp;nagleopt_len)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"getsockopt TCP_NODELAY fail: %s\n"</span>, strerror(errno));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//printf("old TCP_NODELAY: %d\n", disable_nagle);</span></span><br><span class="line">&#125;</span><br><span class="line">disable_nagle = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;disable_nagle, <span class="number">4</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt TCP_NODELAY fail: %s\n"</span>, strerror(errno));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//printf("new TCP_NODELAY: %d\n", disable_nagle);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/hguisu/article/details/38700899" target="_blank" rel="noopener">TCP连接的状态详解以及故障排查</a></li>
<li><a href="https://blog.csdn.net/uestc_huan/article/details/5863614" target="_blank" rel="noopener">Linux网络编程socket错误分析</a></li>
<li><a href="http://xmarker.blog.163.com/blog/static/226484057201462263815783/" target="_blank" rel="noopener">apache ab压力测试报错（apr_socket_recv: Connection reset by peer (104)）</a></li>
<li><a href="https://www.cnblogs.com/kex1n/p/7461124.html" target="_blank" rel="noopener">socket recv阻塞与非阻塞error总结</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>WIFI配置中涉及到的相关名词</title>
    <url>/post/1797.html</url>
    <content><![CDATA[<p>AP配置中遇到的相关名词，作用及含义：<br><a id="more"></a></p>
<ul>
<li><code>AP模式</code>: Access Point，提供无线接入服务，允许其它无线设备接入，提供数据访问，一般的无线路由/网桥工作在该模式下。AP和AP之间允许相互连接</li>
<li><code>sta模式</code>: Station, 类似于无线终端，sta本身并不接受无线的接入，它可以连接到AP，一般无线网卡即工作在该模式</li>
</ul>
<h2 id="WMM"><a href="#WMM" class="headerlink" title="WMM"></a>WMM</h2><p><code>WMM</code>是一个英文缩写，是指<code>Wi-Fi多媒体</code></p>
<h2 id="u-apsd"><a href="#u-apsd" class="headerlink" title="u-apsd"></a>u-apsd</h2><h2 id="AAA"><a href="#AAA" class="headerlink" title="AAA"></a>AAA</h2><p>AAA是<code>认证（Authentication）</code>、<code>授权（Authorization）</code>和<code>计费（Accounting）</code>的简称，是网络安全中进行访问控制的一种安全管理机制，提供认证、授权和计费三种安全服务。</p>
<ul>
<li>认证（Authentication）：是对用户的身份进行验证，判断其是否为合法用户。</li>
<li>授权（Authorization）：是对通过认证的用户，授权其可以使用哪些服务。</li>
<li>计费（Accounting）：是记录用户使用网络服务的资源情况，这些信息将作为计费的依据。</li>
</ul>
<h2 id="EDCA"><a href="#EDCA" class="headerlink" title="EDCA"></a>EDCA</h2><ul>
<li><a href="https://blog.csdn.net/lin_shuqing/article/details/75099047" target="_blank" rel="noopener">EDCA机制详解</a></li>
</ul>
<h2 id="频宽-（20MHz、40MHz、80MHz）"><a href="#频宽-（20MHz、40MHz、80MHz）" class="headerlink" title="频宽 （20MHz、40MHz、80MHz）"></a>频宽 （20MHz、40MHz、80MHz）</h2><p>指的是你的路由器的<code>发射频率宽度</code>， 也就是<code>信道带宽</code>。</p>
<p>频宽越大，传输中受到的干扰也就越大；但是频宽大时，数据传输带宽也会变大。</p>
<table>
<thead>
<tr>
<th style="text-align:center">频宽</th>
<th style="text-align:center">传输带宽</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">20MHz</td>
<td style="text-align:center">65M</td>
</tr>
<tr>
<td style="text-align:center">40MHz</td>
<td style="text-align:center">150M</td>
</tr>
<tr>
<td style="text-align:center">80MHz</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="802-11ac"><a href="#802-11ac" class="headerlink" title="802.11ac"></a>802.11ac</h2><p>IEEE 802.11ac，是一个802.11无线局域网（WLAN）通信标准，它通过<code>5GHz频带</code>（也是其得名原因）进行通信。理论上，它能够提供最多1Gbps带宽进行多站式无线局域网通信，或是最少500Mbps的单一连接传输带宽。</p>
<h2 id="穿透性"><a href="#穿透性" class="headerlink" title="穿透性"></a>穿透性</h2><p>5GHz信号的波长要比2.4GHz信号的要短，而<code>波长越短的电磁波穿透力就越强</code>。但因为 <strong>频率越高消耗在穿透上的能量越大，导致信号浪费，设备接受到的反而是反射衍射过来的信号</strong>。2.4Ghz下，衍射和反射比5Ghz要多，因此设备接受到的信号反而强。</p>
<h2 id="协议标准"><a href="#协议标准" class="headerlink" title="协议标准"></a>协议标准</h2><table>
<thead>
<tr>
<th style="text-align:center">标准号</th>
<th style="text-align:center">IEEE 802.11b</th>
<th style="text-align:center">IEEE 802.11a</th>
<th style="text-align:center">IEEE 802.11g</th>
<th style="text-align:center">IEEE 802.11n</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标准发布时间</td>
<td style="text-align:center">1999年9月</td>
<td style="text-align:center">1999年9月</td>
<td style="text-align:center">2003年6月</td>
<td style="text-align:center">2009年9月</td>
</tr>
<tr>
<td style="text-align:center">工作频率范围</td>
<td style="text-align:center">2.4－2.4835GHz</td>
<td style="text-align:center">5.150－5.350GHz 5.475－5.725GHz 5.725－5.850GHz</td>
<td style="text-align:center">2.4－2.4835GHz</td>
<td style="text-align:center">2.4－2.4835GHz 5.150－5.850GHz</td>
</tr>
<tr>
<td style="text-align:center">非重叠信道数</td>
<td style="text-align:center">3</td>
<td style="text-align:center">24</td>
<td style="text-align:center">3</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">物理速率（Mbps）</td>
<td style="text-align:center">11</td>
<td style="text-align:center">54</td>
<td style="text-align:center">54</td>
<td style="text-align:center">600</td>
</tr>
<tr>
<td style="text-align:center">实际吞吐量（Mbps）</td>
<td style="text-align:center">6</td>
<td style="text-align:center">24</td>
<td style="text-align:center">24</td>
<td style="text-align:center">100以上</td>
</tr>
<tr>
<td style="text-align:center">频宽（MHz）</td>
<td style="text-align:center">20</td>
<td style="text-align:center">20</td>
<td style="text-align:center">20</td>
<td style="text-align:center">20/40</td>
</tr>
<tr>
<td style="text-align:center">调制方式</td>
<td style="text-align:center">CCK/DSSS</td>
<td style="text-align:center">OFDM</td>
<td style="text-align:center">CCK/DSSS/OFDM</td>
<td style="text-align:center">MIMO-OFDM/DSSS/CCK</td>
</tr>
<tr>
<td style="text-align:center">兼容性</td>
<td style="text-align:center">802.11b</td>
<td style="text-align:center">802.11a</td>
<td style="text-align:center">802.11b/g</td>
<td style="text-align:center">802.11a/b/g/n</td>
</tr>
</tbody>
</table>
<h2 id="2-4G频段"><a href="#2-4G频段" class="headerlink" title="2.4G频段"></a>2.4G频段</h2><p>WiFi总共有14个信道<br><img src="/images/2018/08/net_wifi_sig_chl.png" alt="net_wifi_sig_chl"></p>
<blockquote>
<ul>
<li>IEEE 802.11b/g标准工作在2.4G频段，频率范围为2.400—2.4835GHz，共<code>83.5M</code>带宽</li>
<li>划分为14个子信道</li>
<li>每个子信道宽度为<code>22MHz</code>, 有效带宽为<code>20MHz</code>, 另外还有<code>2MHz</code>的强制隔离频带（类似于公路上的隔离带）</li>
<li>相邻信道的中心频点间隔<code>5MHz</code></li>
<li>相邻的多个信道存在频率重叠(如1信道与2、3、4、5信道有频率重叠)</li>
<li>整个频段内只有<code>3个（1、6、11）</code>互不干扰信道</li>
</ul>
</blockquote>
<p><strong><code>802.11b</code>和<code>802.11g</code>的工作频段在2.4GHz（2.4GHz-2.4835GHz），其可用带宽为83.5MHz，<code>中国划分为13个信道</code>，每个信道带宽为22MHz</strong></p>
<h3 id="信道划分"><a href="#信道划分" class="headerlink" title="信道划分"></a>信道划分</h3><p><code>信道</code>也称作<code>通道(Channel)</code>、<code>频段</code>，是以无线信号（电磁波）作为传输载体的数据信号传送通道。无线网络（路由器、AP热点、电脑无线网卡）可在多个信道上运行。在无线信号覆盖范围内的各种无线网络设备应该尽量使用不同的信道，以避免信号之间的干扰。</p>
<p>中心频率为<code>2412MHz</code>的1信道，其频率范围为<code>2401~2423MHz</code></p>
<blockquote>
<p>freq = 2400 + 20/2 + 2 + 5 * (channel - 1) MHz</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">信道</th>
<th style="text-align:center">中心频率</th>
<th style="text-align:center">信道</th>
<th style="text-align:center">中心频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2412MHz</td>
<td style="text-align:center">8</td>
<td style="text-align:center">2447MHz</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2417MHz</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2452MHz</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2422MHz</td>
<td style="text-align:center">10</td>
<td style="text-align:center">2457MHz</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2427MHz</td>
<td style="text-align:center">11</td>
<td style="text-align:center">2462MHz</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2432MHz</td>
<td style="text-align:center">12</td>
<td style="text-align:center">2467MHz</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">2437MHz</td>
<td style="text-align:center">13</td>
<td style="text-align:center">2472MHz</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">2442MHz</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>在WiFi的世界中，有一条原则雷打不动，那就是在同一信道范围内，同一时刻，只有一台设备可以发信号，其他设备都需要等待。</strong></p>
</blockquote>
<p><img src="/images/2018/11/wifi_channel_2_4g.png" alt="wifi_channel_2.4G"></p>
<h2 id="5G频段"><a href="#5G频段" class="headerlink" title="5G频段"></a>5G频段</h2><blockquote>
<p>freq = 5000 + 5 * channel</p>
</blockquote>
<p><img src="/images/2018/11/wifi_channel_5g.png" alt="wifi_channel_5G"></p>
<h2 id="网络划分："><a href="#网络划分：" class="headerlink" title="网络划分："></a>网络划分：</h2><p>在ISO/IEC 8802规范划分数据链路层（Data Link Layer）而得到的<code>Logic Link Control Sub Layer（简称LLC）</code>和<code>Medium Acess Control Sub Layer（简称MAC）</code>。</p>
<p><img src="/images/2018/08/net_80211_data_link_layer.png" alt="net_80211_data_link_layer"></p>
<ul>
<li><code>MAC Sub Layer</code>（Media Acess Control SubLayer：媒介访问控制子层）：该子层的目的是为了解决局域网（Local Area Network，以后简写为LAN）中<code>共用信道的使用产生竞争时</code>，如何分配信道的使用权问题。目前LAN中常用的媒介访问控制方法是CSMA/CD（争用型介质访问控制）。由于无线网络的特殊性，MAC的控制方法略有不同。我们将在下文介绍相关内容。</li>
<li><code>LLC Sub Layer</code>（逻辑链路控制子层）：该子层实现了两个站点之间帧的交换，实现端到端（源到目的），<code>无差错的帧传输和应答功能及流量控制功能</code>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/huguohu2006/article/details/52250119" target="_blank" rel="noopener">WIFI的传输信道与标准WIFI的频道传输能力</a></li>
<li><a href="https://blog.csdn.net/innost/article/details/20651445" target="_blank" rel="noopener">《深入理解Android：Wi-Fi，NFC和GPS》章节连载[节选]–第三章 Wi-Fi基础知识</a></li>
<li><a href="https://blog.csdn.net/dxpqxb/article/details/80969760" target="_blank" rel="noopener">世界各个地区WIFI 2.4G及5G信道划分表（附无线通信频率分配表）</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>wifi</category>
      </categories>
      <tags>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>方向</title>
    <url>/post/7367.html</url>
    <content><![CDATA[<p><img src="/images/2018/08/way.png" alt="way"></p>
<blockquote>
<p><strong>想升高。有两样东西，那就必须作鹰，或者作爬行动物。</strong>  ——巴尔扎克</p>
</blockquote>
<a id="more"></a>
<p>新工作已经按个月了，与之前的工作方式和工作内容都有很大的差别。但是没有排斥的感觉，会有烦恼和抱怨，可是也有充实吧。</p>
<p>从底层到上层的工作，与之前设想的基本一致，上一份工作中对驱动的理解和对音频方面的工作，与新工作中视频的工作方向，打算以后的主要针对音视频方面发展。</p>
<h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><ul>
<li>底层驱动（存储，音频）</li>
<li>对linux系统和CPU的了解</li>
<li>底层程序的执行原理的认识[C和汇报（mips）了解]</li>
</ul>
<h2 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h2><ul>
<li>网络编程欠缺</li>
<li>应用层的软件开发欠缺</li>
<li>视频相关知识欠缺</li>
</ul>
<h2 id="方向：【音视频】"><a href="#方向：【音视频】" class="headerlink" title="方向：【音视频】"></a>方向：【音视频】</h2><ul>
<li>视频相关知识</li>
<li>视频的采集（V4L2）</li>
<li>视频编解码</li>
</ul>
<h2 id="设想："><a href="#设想：" class="headerlink" title="设想："></a>设想：</h2><p>以底层为基础自下而上的接触和学习相关技能，完善自己的知识体系。</p>
<p><img src="/images/2018/08/knowledge_struct.png" alt="知识体系"></p>
]]></content>
  </entry>
  <entry>
    <title>C语言——锁</title>
    <url>/post/37537.html</url>
    <content><![CDATA[<p><code>锁</code>：原子锁, 线程安全</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">++_a;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	++_a 大致可以拆分为下面三步(MIPS 指令)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	1' 把 _a 的值放入`寄存器$1`中   【lw】</span></span><br><span class="line"><span class="comment">	2' 把`寄存器$1`中值加1    【add】</span></span><br><span class="line"><span class="comment">	3' 返回`寄存器$1`中值并且设置给a   【sw】</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>自加1</code>和<code>自减1</code>：在GCC中提供了相应的原子指令操作，排除多线程对一个变量的操作的不可预期性。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value, ...)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="原子锁与自旋锁"><a href="#原子锁与自旋锁" class="headerlink" title="原子锁与自旋锁"></a>原子锁与自旋锁</h2><blockquote>
<p>原子锁和自旋锁的本质相同，通过对一个变量的<code>自加</code>和<code>自减</code>操作（这里的<code>自加</code>、<code>自减</code>都是通过一条原子指令完成），判断临界区的可操作性。</p>
</blockquote>
<h2 id="memory-barrier"><a href="#memory-barrier" class="headerlink" title="memory barrier"></a>memory barrier</h2><p>memory barrier有几种类型：</p>
<ul>
<li><code>acquire barrier</code> : 不允许将barrier之后的内存读取指令移到barrier之前（linux kernel中的wmb()）。</li>
<li><code>release barrier</code> : 不允许将barrier之前的内存读取指令移到barrier之后 (linux kernel中的rmb())。</li>
<li><code>full barrier</code>    : 以上两种barrier的合集(linux kernel中的mb())。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__sync_synchronize (...)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GCC: This builtin issues a <code>full memory barrier</code>.</p>
</blockquote>
<h2 id="应用层：原子锁"><a href="#应用层：原子锁" class="headerlink" title="应用层：原子锁"></a>应用层：原子锁</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _H_SIMPLEC_SCATOM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _H_SIMPLEC_SCATOM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__GNUC__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// v += a ; return v;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_ADD(v, a)		__sync_add_and_fetch(&amp;(v), (a))</span></span><br><span class="line"><span class="comment">// type tmp = v ; v = a; return tmp;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_SET(v, a)		__sync_lock_test_and_set(&amp;(v), (a))</span></span><br><span class="line"><span class="comment">// v &amp;= a; return v;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_AND(v, a)		__sync_and_and_fetch(&amp;(v), (a))</span></span><br><span class="line"><span class="comment">// return ++v;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_INC(v) 		__sync_add_and_fetch(&amp;(v), 1)</span></span><br><span class="line"><span class="comment">// return --v;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_DEC(v) 		__sync_sub_and_fetch(&amp;(v), 1)</span></span><br><span class="line"><span class="comment">// bool b = v == c; b ? v=a : ; return b;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_CAS(v, c, a)	__sync_bool_compare_and_swap(&amp;(v), (c), (a))</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 保证代码不乱序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_SYNC() 		__sync_synchronize()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对ATOM_LOCK 解锁, 当然 直接调用相当于 v = 0;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_UNLOCK(v)		__sync_lock_release(&amp;(v))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __GNUC__</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 试图加锁, 用法举例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 if(ATOM_TRYLOCK(v)) &#123;</span></span><br><span class="line"><span class="comment">		 // 已经有人加锁了, 处理返回事件</span></span><br><span class="line"><span class="comment">		...</span></span><br><span class="line"><span class="comment">	 &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 // 得到锁资源, 开始处理</span></span><br><span class="line"><span class="comment">	 ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 ATOM_UNLOCK(v);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 返回1表示已经有人加锁了, 竞争锁失败.</span></span><br><span class="line"><span class="comment"> * 返回0表示得到锁资源, 竞争锁成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_TRYLOCK(v)		ATOM_SET(v, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 使用方式:</span></span><br><span class="line"><span class="comment">//  int lock = 0;</span></span><br><span class="line"><span class="comment">//  ATOM_LOCK(lock);</span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="comment">//  ATOM_UNLOCK(lock);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM_LOCK(v)		while(ATOM_SET(v, 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !_H_SIMPLEC_SCATOM</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>scatom.h</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/atom.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_iFlagAtom = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORK_SIZE 5000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORKER_COUNT 10</span></span><br><span class="line"><span class="keyword">pthread_t</span> g_tWorkerID[WORKER_COUNT];</span><br><span class="line"><span class="keyword">int</span> g_iSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thr_worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"WORKER THREAD %08X STARTUP\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;WORK_SIZE; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (g_iFlagAtom) &#123;</span><br><span class="line">			ATOM_INC(g_iSum);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//ATOM_LOCK(lock);</span></span><br><span class="line">			g_iSum ++;</span><br><span class="line">			<span class="comment">//ATOM_UNLOCK(lock);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thr_management</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"MANAGEMENT THREAD %08X STARTUP\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;WORKER_COUNT;++i) &#123;</span><br><span class="line">		pthread_join(g_tWorkerID[i], <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ALL WORKER THREADS FINISHED.\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tManagementID;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create (&amp;tManagementID, <span class="literal">NULL</span>, thr_management, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;WORKER_COUNT;++i) &#123;</span><br><span class="line">		pthread_create(&amp;g_tWorkerID[i], <span class="literal">NULL</span>, thr_worker, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CREATED %d WORKER THREADS\n"</span>, i);</span><br><span class="line">	pthread_join(tManagementID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;<span class="built_in">end</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"THE SUM: %d\n"</span>, g_iSum);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Run time: %ldms\n"</span>, <span class="number">1000</span> * (<span class="built_in">end</span>.tv_sec - start.tv_sec) + (<span class="built_in">end</span>.tv_usec - start.tv_usec) / <span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果</p>
<ul>
<li><p>g_iSum++</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THE SUM: 14617872</span><br><span class="line">Run time: 201ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>ATOM_INC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THE SUM: 50000000</span><br><span class="line">Run time: 1612ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>ATOM_LOCK</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THE SUM: 50000000</span><br><span class="line">Run time: 11821ms</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _H_SIMPLEC_SCRWLOCK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _H_SIMPLEC_SCRWLOCK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"scatom.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create simple write and read lock</span></span><br><span class="line"><span class="comment"> * struct rwlock need zero.</span></span><br><span class="line"><span class="comment"> * is scatom ext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init need all is 0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rwlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> rlock;</span><br><span class="line">	<span class="keyword">int</span> wlock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add read lock</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rwlock_rlock</span><span class="params">(struct rwlock * lock)</span></span>;</span><br><span class="line"><span class="comment">// add write lock</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rwlock_wlock</span><span class="params">(struct rwlock * lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add write lock</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rwlock_unrlock</span><span class="params">(struct rwlock * lock)</span></span>;</span><br><span class="line"><span class="comment">// unlock write</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rwlock_unwlock</span><span class="params">(struct rwlock * lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !_H_SIMPLEC_SCRWLOCK</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add read lock</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">rwlock_rlock(struct rwlock * lock) &#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// 看是否有人在试图读, 得到并防止代码位置优化</span></span><br><span class="line">		<span class="keyword">while</span> (lock-&gt;wlock)</span><br><span class="line">			ATOM_SYNC();</span><br><span class="line"></span><br><span class="line">		ATOM_INC(lock-&gt;rlock);</span><br><span class="line">		<span class="comment">// 没有写占用, 开始读了</span></span><br><span class="line">		<span class="keyword">if</span> (!lock-&gt;wlock)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 还是有写, 删掉添加的读</span></span><br><span class="line">		ATOM_DEC(lock-&gt;rlock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock read lock</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">rwlock_unrlock(struct rwlock * lock) &#123;</span><br><span class="line">	ATOM_DEC(lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ add <span class="built_in">write</span> lock</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">rwlock_wlock(struct rwlock * lock) &#123;</span><br><span class="line">	ATOM_LOCK(lock-&gt;wlock);</span><br><span class="line">	<span class="comment">// 等待读占用锁</span></span><br><span class="line">	<span class="keyword">while</span> (lock-&gt;rlock)</span><br><span class="line">		ATOM_SYNC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock write lock</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">rwlock_unwlock(struct rwlock * lock) &#123;</span><br><span class="line">	ATOM_UNLOCK(lock-&gt;wlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">Built-in functions for atomic memory access</a></li>
<li><a href="https://github.com/wangzhione/cdesignbook/blob/master/%E7%AC%AC3%E7%AB%A0-%E6%B0%94%E5%8A%9F-%E5%8E%9F%E5%AD%90%E9%94%81%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/README.md" target="_blank" rel="noopener">原子锁线程协程</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中__attribute__的作用</title>
    <url>/post/12087.html</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sc3</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>attribute</code>：属性，主要是用来在<code>函数</code>或<code>数据声明</code>中设置其属性,与编译器相关</p>
</blockquote>
<p>GNU C的一大特色就是<code>__attribute__</code>机制。<code>__attribute__</code>可以设置<code>函数属性（Function Attribute）</code>、<code>变量属性（Variable Attribute）</code>和<code>类型属性（Type Attribute）</code>。</p>
<ul>
<li>语法格式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__attribute__ ((attribute-list))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h2 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h2><ul>
<li>数据声明：<ul>
<li><code>__attribute__ ((packed))</code>: 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。</li>
<li><code>__attribute__((aligned(n)))</code>: 内存对齐，指定内存对齐n字节</li>
</ul>
</li>
<li>函数声明：<ul>
<li><code>__attribute__((noreturn))</code>: 的作用告诉编译器这个函数不会返回给调用者，以便编译器在优化时去掉不必要的函数返回代码。</li>
<li><code>__attribute__((weak))</code>: 虚函数，弱符号</li>
</ul>
</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sc1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sc1: sizeof-char*  = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc1));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sc3</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sc3: packed sizeof-char*  = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc3));</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc1: sizeof-char*  = 16</span><br><span class="line">sc3: packed sizeof-char*  = 9</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。</p>
<h3 id="aligned-n"><a href="#aligned-n" class="headerlink" title="aligned(n)"></a>aligned(n)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(4))) <span class="title">sc5</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(4))) <span class="title">sc6</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sc5: aligned 4 sizeof-char*  = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc5));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sc6: aligned 4 sizeof-char[] = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc6));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(2))) <span class="title">sc7</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(2))) <span class="title">sc8</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sc7: aligned 2 sizeof-char*  = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc7));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sc8: aligned 2 sizeof-char[] = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc8));</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc5: aligned 4 sizeof-char*  = 16</span><br><span class="line">sc6: aligned 4 sizeof-char[] = 4</span><br><span class="line">sc7: aligned 2 sizeof-char*  = 16</span><br><span class="line">sc8: aligned 2 sizeof-char[] = 2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="noreturn"><a href="#noreturn" class="headerlink" title="noreturn"></a>noreturn</h3><blockquote>
<p>This attribute tells the compiler that the function won’t ever return, and this can be used to suppress errors about code paths not being reached. The C library functions abort() and exit() are both declared with this attribute:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span>)</span>   __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数不会返回。</p>
<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  __attribute__((weak))  func(...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>func转成<code>弱符号类型</code></p>
<ul>
<li>如果遇到<code>强符号类型</code>（即外部模块定义了func, <code>extern int func(void);</code>），那么我们在本模块执行的func将会是外部模块定义的func。</li>
<li>如果外部模块没有定义，那么将会调用这个弱符号，也就是在本地定义的func，直接返回了一个1（返回值视具体情况而定）相当于增加了一个<code>默认函数</code>。</li>
</ul>
</blockquote>
<p><strong>原理</strong>：<code>链接器</code>发现同时存在<code>弱符号</code>和<code>强符号</code>，就先选择强符号，如果发现不存在强符号，只存在弱符号，则选择弱符号。如果都不存在：静态链接，恭喜，编译时报错，动态链接：对不起，系统无法启动。</p>
<blockquote>
<p>weak属性只会在静态库(.o .a )中生效，动态库(.so)中不会生效。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/wangzhaotongalex/article/details/22729215" target="_blank" rel="noopener">#define PACK_STRUCT <em>attribute</em> ((<em>packed</em>))编译器按字独立分配</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中char*和char[]的区别</title>
    <url>/post/44009.html</url>
    <content><![CDATA[<ul>
<li><code>char *c</code> : char型指针，只表示所指向的内存单元</li>
<li><code>char []</code> : 表示数组型的内存单元</li>
</ul>
<p><strong>结论</strong>： <code>char a[]</code>或<code>char a[0]</code>形式的定义在<code>结构体</code>中不占内存大小。</p>
<a id="more"></a>
<p><strong>以下所有测试在<code>64bit</code>系统中进行，结果与32bit系统存在差别。</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> int_a;</span><br><span class="line">    <span class="keyword">int</span>* int_a_p;</span><br><span class="line">    <span class="keyword">char</span> char_b;</span><br><span class="line">    <span class="keyword">char</span>* char_b_p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\tSystem Data Width:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof int(%ld), int*(%ld), char(%ld), char*(%ld)\n"</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(int_a), <span class="keyword">sizeof</span>(int_a_p), <span class="keyword">sizeof</span>(char_b), <span class="keyword">sizeof</span>(char_b_p));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *c1 = <span class="string">"a b c d"</span>;</span><br><span class="line">	<span class="keyword">char</span> c2[] = <span class="string">"a b c d"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c1: %s\n"</span>, c1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c2: %s\n"</span>, c2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c1-c1[0]=%c\n"</span>, c1[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c2-c2[0]=%c\n"</span>, c2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//c1[0] = 'x'; /* Segmentation fault (core dumped) */</span></span><br><span class="line">	c2[<span class="number">0</span>] = <span class="string">'y'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c1-c1[0]=%c\n"</span>, c1[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c2-c2[0]=%c\n"</span>, c2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sc1</span> &#123;</span></span><br><span class="line">		<span class="keyword">char</span> a;</span><br><span class="line">		<span class="keyword">char</span> *b;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sc2</span> &#123;</span></span><br><span class="line">		<span class="keyword">char</span> a;</span><br><span class="line">		<span class="keyword">char</span> b[];</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sc2_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sc1: sizeof-char*  = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc1)); <span class="comment">//8 + 8</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sc2: sizeof-char[] = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc2)); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sc2_1: packed sizeof-char[0] = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc2_1)); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sc3</span> &#123;</span></span><br><span class="line">		<span class="keyword">char</span> a;</span><br><span class="line">		<span class="keyword">char</span> *b;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sc4</span> &#123;</span></span><br><span class="line">		<span class="keyword">char</span> a;</span><br><span class="line">		<span class="keyword">char</span> b[];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sc3: packed sizeof-char*  = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc3)); <span class="comment">//1 + 8</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sc4: packed sizeof-char[] = %ld\n"</span>, <span class="keyword">sizeof</span>(struct sc4)); <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>运行：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System Data Width:</span><br><span class="line">sizeof int(4), int*(8), char(1), char*(8)</span><br><span class="line">c1: a b c d</span><br><span class="line">c2: a b c d</span><br><span class="line">c1-c1[0]=a</span><br><span class="line">c2-c2[0]=a</span><br><span class="line">c1-c1[0]=a</span><br><span class="line">c2-c2[0]=y</span><br><span class="line">sc1: sizeof-char*  = 16</span><br><span class="line">sc2: sizeof-char[] = 1</span><br><span class="line">sc2_1: packed sizeof-char[0] = 1</span><br><span class="line">sc3: packed sizeof-char*  = 9</span><br><span class="line">sc4: packed sizeof-char[] = 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="内存地址对比"><a href="#内存地址对比" class="headerlink" title="内存地址对比"></a>内存地址对比</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sc1</span> <span class="title">sc1_a</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tsc1_a addr: %p\n"</span>, &amp;sc1_a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tsc1_a.a addr: %p\n"</span>, &amp;sc1_a.a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tsc1_a.b addr: %p\n"</span>, &amp;sc1_a.b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sc2</span> <span class="title">sc2_a</span>, <span class="title">sc2_b</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tsc2_a addr: %p\n"</span>, &amp;sc2_a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tsc2_a.a addr: %p\n"</span>, &amp;sc2_a.a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tsc2_a.b addr: %p\n"</span>, &amp;sc2_a.b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tsc2_b addr: %p\n"</span>, &amp;sc2_b);</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc1_a addr: 0x7ffd44ed7d60</span><br><span class="line">sc1_a.a addr: 0x7ffd44ed7d60</span><br><span class="line">sc1_a.b addr: 0x7ffd44ed7d68</span><br><span class="line">sc2_a addr: 0x7ffd44ed7d7e</span><br><span class="line">sc2_a.a addr: 0x7ffd44ed7d7e</span><br><span class="line">sc2_a.b addr: 0x7ffd44ed7d7f</span><br><span class="line">sc2_b addr: 0x7ffd44ed7d7f</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>在结构体中使用<code>char buf[]</code>形式的定义，不占用内存空间</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>内核部分结构体：如MMC中sdhci的结构体定义<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdhci_host</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>[<span class="number">0</span>] ____cacheline_aligned;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>利于将自定义结构体部分和公共结构体之间相关联。</p>
<p>自定义结构体：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdhci_custom</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> xxx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdhci_host</span> *<span class="title">host</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdhci_custom</span> *<span class="title">custom</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性申请内存看见</span></span><br><span class="line">host = kmalloc(<span class="keyword">sizeof</span>(struct sdhci_host) + <span class="keyword">sizeof</span>(struct sdhci_custom));</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义结构体位置</span></span><br><span class="line">custom = host-&gt;<span class="keyword">private</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/u010383937/article/details/78528750" target="_blank" rel="noopener"><code>____cacheline_aligned</code>和<code>____cacheline_aligned_in_smp</code></a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg学习笔记——ffmpeg命令</title>
    <url>/post/41754.html</url>
    <content><![CDATA[<p>ffmpeg命令相关用法。</p>
<blockquote>
<ul>
<li>环境： <code>ubuntu 18.04</code></li>
<li>ffmpeg版本： <code>3.4.4-0ubuntu0.18.04.1</code></li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="制作ts流"><a href="#制作ts流" class="headerlink" title="制作ts流"></a>制作ts流</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -ss 00:00:12 -to 00:00:13 -vcodec libx264 -g 1 -crf 1 test.ts</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ts流中包含I帧</p>
</blockquote>
<p>参数解析：</p>
<ul>
<li><code>-i</code>： 设定输入流（input）</li>
<li><code>-ss time_off</code>： 开始时间</li>
<li><code>-to time_stop</code>： 结束时间</li>
<li><code>-vcodec codec</code>：设定视频编解码器，未设定时则使用与输入流相同的编解码器，(‘copy’ to copy stream)<ul>
<li>libx264： ts流</li>
</ul>
</li>
<li><code>-g &lt;int&gt;</code>：关键帧(I帧)间隔控制</li>
<li><code>-crf &lt;int&gt;</code>：（Constant Rate Factor） 量化比例的范围为0~51，其中0为无损模式，23为缺省值，51可能是最差的。该数字越小，图像质量越好</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i water.mp4 -codec copy -bsf:v h264_mp4toannexb water.ts</span><br></pre></td></tr></table></figure>
<h2 id="转H264"><a href="#转H264" class="headerlink" title="转H264"></a>转H264</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i water.mp4 -c:v copy -bsf:v h264_mp4toannexb -an water.h264</span><br></pre></td></tr></table></figure>
<h2 id="wav转mp4"><a href="#wav转mp4" class="headerlink" title="wav转mp4"></a>wav转mp4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i water.wmv -c:v libx264 -strict -2 water.mp4</span><br></pre></td></tr></table></figure>
<h2 id="mp4转yuv"><a href="#mp4转yuv" class="headerlink" title="mp4转yuv"></a>mp4转yuv</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i food.mp4 food.yuv</span><br></pre></td></tr></table></figure>
<h2 id="ffmpge帮助信息"><a href="#ffmpge帮助信息" class="headerlink" title="ffmpge帮助信息"></a>ffmpge帮助信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -h full &gt; help.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本调试——bash</title>
    <url>/post/18379.html</url>
    <content><![CDATA[<p>shell脚本调试：</p>
<a id="more"></a>
<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>帮助信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$bash -c &quot;help set&quot;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set: set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]</span><br><span class="line">    Set or unset values of shell options and positional parameters.</span><br><span class="line"></span><br><span class="line">    Change the value of shell attributes and positional parameters, or</span><br><span class="line">    display the names and values of shell variables.</span><br><span class="line"></span><br><span class="line">    Options:</span><br><span class="line">      -a  Mark variables which are modified or created for export.</span><br><span class="line">      -b  Notify of job termination immediately.</span><br><span class="line">      -e  Exit immediately if a command exits with a non-zero status.</span><br><span class="line">      -f  Disable file name generation (globbing).</span><br><span class="line">      -h  Remember the location of commands as they are looked up.</span><br><span class="line">      -k  All assignment arguments are placed in the environment for a</span><br><span class="line">          command, not just those that precede the command name.</span><br><span class="line">      -m  Job control is enabled.</span><br><span class="line">      -n  Read commands but do not execute them.</span><br><span class="line">      -o option-name</span><br><span class="line">          Set the variable corresponding to option-name:</span><br><span class="line">              allexport    same as -a</span><br><span class="line">              braceexpand  same as -B</span><br><span class="line">              emacs        use an emacs-style line editing interface</span><br><span class="line">              errexit      same as -e</span><br><span class="line">              errtrace     same as -E</span><br><span class="line">              functrace    same as -T</span><br><span class="line">              hashall      same as -h</span><br><span class="line">              histexpand   same as -H</span><br><span class="line">              history      enable command history</span><br><span class="line">              ignoreeof    the shell will not exit upon reading EOF</span><br><span class="line">              interactive-comments</span><br><span class="line">                           allow comments to appear in interactive commands</span><br><span class="line">              keyword      same as -k</span><br><span class="line">              monitor      same as -m</span><br><span class="line">              noclobber    same as -C</span><br><span class="line">              noexec       same as -n</span><br><span class="line">              noglob       same as -f</span><br><span class="line">              nolog        currently accepted but ignored</span><br><span class="line">              notify       same as -b</span><br><span class="line">              nounset      same as -u</span><br><span class="line">              onecmd       same as -t</span><br><span class="line">              physical     same as -P</span><br><span class="line">              pipefail     the return value of a pipeline is the status of</span><br><span class="line">                           the last command to exit with a non-zero status,</span><br><span class="line">                           or zero if no command exited with a non-zero status</span><br><span class="line">              posix        change the behavior of bash where the default</span><br><span class="line">                           operation differs from the Posix standard to</span><br><span class="line">                           match the standard</span><br><span class="line">              privileged   same as -p</span><br><span class="line">              verbose      same as -v</span><br><span class="line">              vi           use a vi-style line editing interface</span><br><span class="line">              xtrace       same as -x</span><br><span class="line">      -p  Turned on whenever the real and effective user ids do not match.</span><br><span class="line">          Disables processing of the $ENV file and importing of shell</span><br><span class="line">          functions.  Turning this option off causes the effective uid and</span><br><span class="line">          gid to be set to the real uid and gid.</span><br><span class="line">      -t  Exit after reading and executing one command.</span><br><span class="line">      -u  Treat unset variables as an error when substituting.</span><br><span class="line">      -v  Print shell input lines as they are read.</span><br><span class="line">      -x  Print commands and their arguments as they are executed.</span><br><span class="line">      -B  the shell will perform brace expansion</span><br><span class="line">      -C  If set, disallow existing regular files to be overwritten</span><br><span class="line">          by redirection of output.</span><br><span class="line">      -E  If set, the ERR trap is inherited by shell functions.</span><br><span class="line">      -H  Enable ! style history substitution.  This flag is on</span><br><span class="line">          by default when the shell is interactive.</span><br><span class="line">      -P  If set, do not resolve symbolic links when executing commands</span><br><span class="line">          such as cd which change the current directory.</span><br><span class="line">      -T  If set, the DEBUG trap is inherited by shell functions.</span><br><span class="line">      --  Assign any remaining arguments to the positional parameters.</span><br><span class="line">          If there are no remaining arguments, the positional parameters</span><br><span class="line">          are unset.</span><br><span class="line">      -   Assign any remaining arguments to the positional parameters.</span><br><span class="line">          The -x and -v options are turned off.</span><br><span class="line"></span><br><span class="line">    Using + rather than - causes these flags to be turned off.  The</span><br><span class="line">    flags can also be used upon invocation of the shell.  The current</span><br><span class="line">    set of flags may be found in $-.  The remaining n ARGs are positional</span><br><span class="line">    parameters and are assigned, in order, to $1, $2, .. $n.  If no</span><br><span class="line">    ARGs are given, all shell variables are printed.</span><br><span class="line"></span><br><span class="line">    Exit Status:</span><br><span class="line">    Returns success unless an invalid option is given.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-x</code>: 执行过程中打印出执行的命令。</li>
<li><code>-v</code>: 执行时打印脚本中的所有信息。</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">bash -x a.sh</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell获取git信息和编译时间</title>
    <url>/post/56769.html</url>
    <content><![CDATA[<p>记录软件版本每一个编译的时间和log信息：</p>
<a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">GIT_SHA1=`(git show-ref --head --hash=8 2&gt; /dev/null || echo 00000000) | head -n1`</span><br><span class="line">GIT_DIRTY=`git diff --no-ext-diff 2&gt; /dev/null | wc -l`</span><br><span class="line">BUILD_ID=`uname -n`"-"`date +%Y%m%d%H%M%S`</span><br><span class="line">test -f release.h || touch release.h</span><br><span class="line">(cat release.h | grep SHA1 | grep $GIT_SHA1) &amp;&amp; \</span><br><span class="line">(cat release.h | grep DIRTY | grep $GIT_DIRTY) &amp;&amp; exit 0 # Already up-to-date</span><br><span class="line">echo "#define REDIS_GIT_SHA1 \"$GIT_SHA1\"" &gt; release.h</span><br><span class="line">echo "#define REDIS_GIT_DIRTY \"$GIT_DIRTY\"" &gt;&gt; release.h</span><br><span class="line">echo "#define REDIS_BUILD_ID \"$BUILD_ID\"" &gt;&gt; release.h</span><br><span class="line"><span class="meta">#</span><span class="bash">touch release.c <span class="comment"># Force recompile of release.c</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>结果：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define REDIS_GIT_SHA1 &quot;ed5b0648&quot;</span><br><span class="line">#define REDIS_GIT_DIRTY &quot;13&quot;</span><br><span class="line">#define REDIS_BUILD_ID &quot;xxxx-pc-20180918152335&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>release.h</p>
</blockquote>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>socket错误号</title>
    <url>/post/54884.html</url>
    <content><![CDATA[<p>socket编程中的出现的错误号基本含义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = sendto(fd, msg, msgLen, <span class="number">0</span>, (struct sockaddr*)&amp;un, <span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d sendto errno:%d\n"</span>, getpid(), errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="错误号—errno"><a href="#错误号—errno" class="headerlink" title="错误号—errno"></a>错误号—errno</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 135</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d: %s\n"</span>, i, strerror(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: Success</span><br><span class="line">1: Operation not permitted</span><br><span class="line">2: No such file or directory</span><br><span class="line">3: No such process</span><br><span class="line">4: Interrupted system call</span><br><span class="line">5: Input/output error</span><br><span class="line">6: No such device or address</span><br><span class="line">7: Argument list too long</span><br><span class="line">8: Exec format error</span><br><span class="line">9: Bad file descriptor</span><br><span class="line">10: No child processes</span><br><span class="line">11: Resource temporarily unavailable</span><br><span class="line">12: Cannot allocate memory</span><br><span class="line">13: Permission denied</span><br><span class="line">14: Bad address</span><br><span class="line">15: Block device required</span><br><span class="line">16: Device or resource busy</span><br><span class="line">17: File exists</span><br><span class="line">18: Invalid cross-device link</span><br><span class="line">19: No such device</span><br><span class="line">20: Not a directory</span><br><span class="line">21: Is a directory</span><br><span class="line">22: Invalid argument</span><br><span class="line">23: Too many open files in system</span><br><span class="line">24: Too many open files</span><br><span class="line">25: Inappropriate ioctl for device</span><br><span class="line">26: Text file busy</span><br><span class="line">27: File too large</span><br><span class="line">28: No space left on device</span><br><span class="line">29: Illegal seek</span><br><span class="line">30: Read-only file system</span><br><span class="line">31: Too many links</span><br><span class="line">32: Broken pipe</span><br><span class="line">33: Numerical argument out of domain</span><br><span class="line">34: Numerical result out of range</span><br><span class="line">35: Resource deadlock avoided</span><br><span class="line">36: File name too long</span><br><span class="line">37: No locks available</span><br><span class="line">38: Function not implemented</span><br><span class="line">39: Directory not empty</span><br><span class="line">40: Too many levels of symbolic links</span><br><span class="line">41: Unknown error 41</span><br><span class="line">42: No message of desired type</span><br><span class="line">43: Identifier removed</span><br><span class="line">44: Channel number out of range</span><br><span class="line">45: Level 2 not synchronized</span><br><span class="line">46: Level 3 halted</span><br><span class="line">47: Level 3 reset</span><br><span class="line">48: Link number out of range</span><br><span class="line">49: Protocol driver not attached</span><br><span class="line">50: No CSI structure available</span><br><span class="line">51: Level 2 halted</span><br><span class="line">52: Invalid exchange</span><br><span class="line">53: Invalid request descriptor</span><br><span class="line">54: Exchange full</span><br><span class="line">55: No anode</span><br><span class="line">56: Invalid request code</span><br><span class="line">57: Invalid slot</span><br><span class="line">58: Unknown error 58</span><br><span class="line">59: Bad font file format</span><br><span class="line">60: Device not a stream</span><br><span class="line">61: No data available</span><br><span class="line">62: Timer expired</span><br><span class="line">63: Out of streams resources</span><br><span class="line">64: Machine is not on the network</span><br><span class="line">65: Package not installed</span><br><span class="line">66: Object is remote</span><br><span class="line">67: Link has been severed</span><br><span class="line">68: Advertise error</span><br><span class="line">69: Srmount error</span><br><span class="line">70: Communication error on send</span><br><span class="line">71: Protocol error</span><br><span class="line">72: Multihop attempted</span><br><span class="line">73: RFS specific error</span><br><span class="line">74: Bad message</span><br><span class="line">75: Value too large for defined data type</span><br><span class="line">76: Name not unique on network</span><br><span class="line">77: File descriptor in bad state</span><br><span class="line">78: Remote address changed</span><br><span class="line">79: Can not access a needed shared library</span><br><span class="line">80: Accessing a corrupted shared library</span><br><span class="line">81: .lib section in a.out corrupted</span><br><span class="line">82: Attempting to link in too many shared libraries</span><br><span class="line">83: Cannot exec a shared library directly</span><br><span class="line">84: Invalid or incomplete multibyte or wide character</span><br><span class="line">85: Interrupted system call should be restarted</span><br><span class="line">86: Streams pipe error</span><br><span class="line">87: Too many users</span><br><span class="line">88: Socket operation on non-socket</span><br><span class="line">89: Destination address required</span><br><span class="line">90: Message too long</span><br><span class="line">91: Protocol wrong type for socket</span><br><span class="line">92: Protocol not available</span><br><span class="line">93: Protocol not supported</span><br><span class="line">94: Socket type not supported</span><br><span class="line">95: Operation not supported</span><br><span class="line">96: Protocol family not supported</span><br><span class="line">97: Address family not supported by protocol</span><br><span class="line">98: Address already in use</span><br><span class="line">99: Cannot assign requested address</span><br><span class="line">100: Network is down</span><br><span class="line">101: Network is unreachable</span><br><span class="line">102: Network dropped connection on reset</span><br><span class="line">103: Software caused connection abort</span><br><span class="line">104: Connection reset by peer</span><br><span class="line">105: No buffer space available</span><br><span class="line">106: Transport endpoint is already connected</span><br><span class="line">107: Transport endpoint is not connected</span><br><span class="line">108: Cannot send after transport endpoint shutdown</span><br><span class="line">109: Too many references: cannot splice</span><br><span class="line">110: Connection timed out</span><br><span class="line">111: Connection refused</span><br><span class="line">112: Host is down</span><br><span class="line">113: No route to host</span><br><span class="line">114: Operation already in progress</span><br><span class="line">115: Operation now in progress</span><br><span class="line">116: Stale file handle</span><br><span class="line">117: Structure needs cleaning</span><br><span class="line">118: Not a XENIX named type file</span><br><span class="line">119: No XENIX semaphores available</span><br><span class="line">120: Is a named type file</span><br><span class="line">121: Remote I/O error</span><br><span class="line">122: Disk quota exceeded</span><br><span class="line">123: No medium found</span><br><span class="line">124: Wrong medium type</span><br><span class="line">125: Operation canceled</span><br><span class="line">126: Required key not available</span><br><span class="line">127: Key has expired</span><br><span class="line">128: Key has been revoked</span><br><span class="line">129: Key was rejected by service</span><br><span class="line">130: Owner died</span><br><span class="line">131: State not recoverable</span><br><span class="line">132: Operation not possible due to RF-kill</span><br><span class="line">133: Memory page has hardware error</span><br><span class="line">134: Unknown error 134</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><ul>
<li>include/uapi/asm-generic/errno-base.h/<a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/errno-base.h" target="_blank" rel="noopener">_ASM_GENERIC_ERRNO_BASE_H</a></li>
<li>include/uapi/asm-generic/errno.h/<a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/errno.h" target="_blank" rel="noopener">_ASM_GENERIC_ERRNO_H</a><blockquote>
<p>Linux内核中的位置</p>
</blockquote>
</li>
</ul>
<h3 id="111：-ECONNREFUSED"><a href="#111：-ECONNREFUSED" class="headerlink" title="111： ECONNREFUSED"></a>111： ECONNREFUSED</h3><blockquote>
<p>A connect() on a stream socket found no one listening on the remote address.</p>
</blockquote>
<blockquote>
<p>From: <code>man connect</code></p>
</blockquote>
<ol>
<li><p>拒绝连接。一般发生在连接建立时</p>
<ul>
<li>拔服务器端网线测试，客户端设置keep alive时，recv较快返回0， 先收到ECONNREFUSED (Connection refused)错误码，其后都是ETIMEOUT。</li>
</ul>
</li>
<li><p>an error returned from connect(), so it can only occur in a client(if a client is defined as the party that initiates the connection</p>
</li>
</ol>
<blockquote>
<p>场景：使用UDP在进程间socket通信，<code>sendto</code>发送消息时，返回错误，错误号为<code>111</code>.</p>
</blockquote>
<p>对端的socket没有进行接收所致。</p>
<h3 id="115-EINPROGRESS"><a href="#115-EINPROGRESS" class="headerlink" title="115: EINPROGRESS"></a>115: EINPROGRESS</h3><blockquote>
<p>The socket is <code>nonblocking</code> and the connection cannot be completed immediately. It is possible to <code>select(2)</code> or <code>poll(2)</code> for completion by selecting the socket for <code>writing</code>. After select(2) indicates writability, use getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to determine whether connect() completed successfully (SO_ERROR is zero) or unsuccessfully (SO_ERROR is one of the usual error codes listed here, explaining the reason for the failure).</p>
</blockquote>
<blockquote>
<p>From: <code>man connect</code></p>
</blockquote>
<ul>
<li>非阻塞的socket，connect调用后立即返回，连接过程还在执行</li>
</ul>
<blockquote>
<p>场景： TCP连接中进行<code>connect</code>错误后，返回值：<code>-1</code>，错误号：<code>115</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect_timeout</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr_in *addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> wait_seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">		activate_nonblock(fd);	<span class="comment">//设为非阻塞</span></span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">connect</span>(fd, (struct sockaddr*)addr, addrlen);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINPROGRESS) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">		fd_set write_fdset;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;write_fdset);</span><br><span class="line">		FD_SET(fd, &amp;write_fdset);</span><br><span class="line"></span><br><span class="line">		timeout.tv_sec = wait_seconds;</span><br><span class="line">		timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			ret = select(fd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;write_fdset, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">		&#125; <span class="keyword">while</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">			ret = <span class="number">-1</span>;</span><br><span class="line">			errno = ETIMEDOUT;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s:%d, select error[%d]:%s, ret=%d\n"</span>, __func__, __LINE__, errno, strerror(errno), ret);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s:%d, select error[%d]:%s, ret=%d\n"</span>, __func__, __LINE__, errno, strerror(errno), ret);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> err;</span><br><span class="line">			<span class="keyword">socklen_t</span> socklen = <span class="keyword">sizeof</span>(err);</span><br><span class="line">			ret = getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%s:%d, getsockopt error[%d]:%s, ret=%d\n"</span>, __func__, __LINE__, errno, strerror(errno), ret);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">				ret = <span class="number">0</span>; <span class="comment">//success</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				errno = err;</span><br><span class="line">				ret = <span class="number">-1</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%s:%d, getsockopt error[%d]:%s, ret=%d\n"</span>, __func__, __LINE__, errno, strerror(errno), ret);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (wait_seconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		deactivate_nonblock(fd);	<span class="comment">//设回阻塞</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">net_set_nonblocking</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags, res;</span><br><span class="line"></span><br><span class="line">    flags = fcntl(sock, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = fcntl(sock, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fcntl return err:%d!\n"</span>, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-EINTR"><a href="#4-EINTR" class="headerlink" title="4: EINTR"></a>4: EINTR</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    n = recv(new_fd, buff, <span class="number">500</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br></pre></td></tr></table></figure>
<h3 id="34-ERANGE"><a href="#34-ERANGE" class="headerlink" title="34: ERANGE"></a>34: ERANGE</h3><blockquote>
<p>#define    ERANGE        34    /<em> Math result not representable </em>/  结果无法表示</p>
</blockquote>
<p>在socket连接中，server端关闭了该连接</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>错误号</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发相关记录</title>
    <url>/post/2578.html</url>
    <content><![CDATA[<p>记录Android开发中遇到的一些方法和问题。</p>
<a id="more"></a>
<h2 id="remount-system分区可读可写"><a href="#remount-system分区可读可写" class="headerlink" title="remount system分区可读可写"></a>remount system分区可读可写</h2><ol>
<li><p>查看挂载点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat /proc/mounts</span><br><span class="line">rootfs / rootfs ro,relatime 0 0</span><br><span class="line">tmpfs /dev tmpfs rw,nosuid,relatime,mode=755 0 0</span><br><span class="line">devpts /dev/pts devpts rw,relatime,mode=600,ptmxmode=000 0 0</span><br><span class="line">proc /proc proc rw,relatime 0 0</span><br><span class="line">sysfs /sys sysfs rw,relatime 0 0</span><br><span class="line">debugfs /sys/kernel/debug debugfs rw,relatime 0 0</span><br><span class="line">tmpfs /mnt/asec tmpfs rw,relatime,mode=755,gid=1000 0 0</span><br><span class="line">tmpfs /mnt/obb tmpfs rw,relatime,mode=755,gid=1000 0 0</span><br><span class="line">tmpfs /storage/external_storage tmpfs rw,relatime,mode=775,uid=1000,gid=1023 0 0</span><br><span class="line">adb /dev/usb-ffs/adb functionfs rw,relatime 0 0</span><br><span class="line">/dev/block/system /system ext4 ro,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/block/data /data ext4 rw,nosuid,nodev,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/block/cache /cache ext4 rw,nosuid,nodev,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br><span class="line">/dev/block/zram0 /swap_zram0 ext2 rw,relatime,errors=continue 0 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新挂载system分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mount -o remount -rw /dev/block/system</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下去掉^M的方法</title>
    <url>/post/18189.html</url>
    <content><![CDATA[<p>在linux下去掉文件行尾的<code>^M</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat -A filename</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看到windows下的断元字符^M</p>
</blockquote>
<a id="more"></a>
<h2 id="dos2unix"><a href="#dos2unix" class="headerlink" title="dos2unix"></a>dos2unix</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dos2unix filename</span><br></pre></td></tr></table></figure>
<p>多文件处理<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls ./*.c | xargs dos2unix</span><br></pre></td></tr></table></figure></p>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/^M//g&apos; filename</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/\r//g&apos; filename</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：^M的输入方式是 <code>Ctrl + v</code> ，然后<code>Ctrl + M</code> </p>
</blockquote>
<h2 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h2><p>将两个命令合并成一个，并添加的vi的快捷键中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap dm :%s/\r\+$//e&lt;cr&gt;:set ff=unix&lt;cr&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>用法： 打开文件直接敲<code>dm</code>即可，最后保存</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核数据结构--基础宏</title>
    <url>/post/56380.html</url>
    <content><![CDATA[<p>在阅读内核源码时,存在一些基础的宏定义和函数,这里主要记录一下<code>offsetof</code>和<code>container_of</code></p>
<a id="more"></a>
<h2 id="offsetof"><a href="#offsetof" class="headerlink" title="offsetof"></a>offsetof</h2><p>获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER)  ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>From file:<a href="https://elixir.bootlin.com/linux/v4.4.1/source/include/linux/stddef.h" target="_blank" rel="noopener">include/linux/stddef.h</a></p>
</blockquote>
<ol>
<li><code>((TYPE *)0)</code>:将零转型为TYPE类型指针，即TYPE类型的指针的地址是0。</li>
<li><code>((TYPE *)0)-&gt;MEMBER</code>:访问结构中的数据成员。</li>
<li><code>&amp;(((TYPE *)0)-&gt;MEMBER)</code>:取出数据成员的地址。由于TYPE的地址是0，这里获取到的地址就是相对MEMBER在TYPE中的偏移。</li>
<li><code>(size_t)(&amp;(((TYPE*)0)-&gt;MEMBER))</code>: 结果转换类型。对于32位系统而言，size_t是unsigned int类型；对于64位系统而言，size_t是unsigned long类型。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gender_offset, id_offset, age_offset, name_offset;</span><br><span class="line"></span><br><span class="line">    gender_offset = offsetof(struct student, gender);</span><br><span class="line">    id_offset     = offsetof(struct student, id);</span><br><span class="line">    age_offset    = offsetof(struct student, age);</span><br><span class="line">    name_offset   = offsetof(struct student, name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gender_offset = %d\n"</span>, gender_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"id_offset = %d\n"</span>, id_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age_offset = %d\n"</span>, age_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name_offset = %d\n"</span>, name_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gender_offset = 0</span><br><span class="line">id_offset = 4</span><br><span class="line">age_offset = 8</span><br><span class="line">name_offset = 12</span><br></pre></td></tr></table></figure></p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/images/2018/11/list_offsetof.png" alt="list_offsetof"></p>
<p>TYPE是结构体，它代表”整体”；而MEMBER是成员，它是整体中的某一部分。</p>
<p>将offsetof看作一个数学问题来看待，问题就相当简单了：</p>
<blockquote>
<p>已知’整体’和该整体中’某一个部分’，而计算该部分在整体中的偏移。</p>
</blockquote>
<h2 id="container-of"><a href="#container-of" class="headerlink" title="container_of"></a>container_of</h2><p>根据”结构体(type)变量”中的”域成员变量(member)的指针(ptr)”来获取指向整个结构体变量的指针。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;          \</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);    \</span><br><span class="line">        (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>From file:<a href="https://elixir.bootlin.com/linux/v4.4.1/source/include/linux/kernel.h#L812" target="_blank" rel="noopener">include/linux/kernel.h</a></p>
</blockquote>
<ol>
<li><code>typeof(((type *)0)-&gt;member)</code>: 取出member成员的变量类型。</li>
<li><code>const typeof(((type *)0)-&gt;member) *__mptr = (ptr)</code>: 定义变量<code>__mptr</code>指针，并将ptr赋值给<code>__mptr</code>。经过这一步, <code>__mptr</code>为member数据类型的常量指针，其指向ptr所指向的地址。</li>
<li><code>(char *)__mptr</code>: 将<code>__mptr</code>转换为字节型指针。</li>
<li><code>offsetof(type,member))</code>: 就是获取”member成员”在”结构体type”中的位置偏移。</li>
<li><code>(char *)__mptr - offsetof(type,member))</code>: 就是用来获取”结构体type”的指针的起始地址（为char *型指针）。</li>
<li><code>(type *)((char *)__mptr - offsetof(type,member))</code>: 就是将”char <em>类型的结构体type的指针”转换为”type </em>类型的结构体type的指针”。</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据"结构体(type)变量"中的"域成员变量(member)的指针(ptr)"来获取指向整个结构体变量的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;          \</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);    \</span><br><span class="line">        (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">pstu</span>;</span></span><br><span class="line"></span><br><span class="line">    stu.gender = <span class="string">'1'</span>;</span><br><span class="line">    stu.id = <span class="number">9527</span>;</span><br><span class="line">    stu.age = <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu.name, <span class="string">"zhouxingxing"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据"id地址" 获取 "结构体的地址"。</span></span><br><span class="line">    pstu = container_of(&amp;stu.id, struct student, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据获取到的结构体student的地址，访问其它成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gender= %c\n"</span>, pstu-&gt;gender);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age= %d\n"</span>, pstu-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name= %s\n"</span>, pstu-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gender= 1</span><br><span class="line">age= 24</span><br><span class="line">name= zhouxingxing</span><br></pre></td></tr></table></figure></p>
<h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><p><img src="/images/2018/11/list_container_of.png" alt="list_container_of"></p>
<p>type是结构体，它代表”整体”；而member是成员，它是整体中的某一部分，而且member的地址是已知的。<br>将offsetof看作一个数学问题来看待，问题就相当简单了：</p>
<blockquote>
<p>已知’整体’和该整体中’某一个部分’，要根据该部分的地址，计算出整体的地址。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/skywang12345/p/3562146.html" target="_blank" rel="noopener">Linux内核中双向链表的经典实现</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核数据结构--链表</title>
    <url>/post/58180.html</url>
    <content><![CDATA[<p>链表操作接口：<a href="https://elixir.bootlin.com/linux/v4.4.1/source/include/linux/list.h" target="_blank" rel="noopener">include/linux/list.h</a></p>
<a id="more"></a>
<h2 id="应用层编程使用mylist-h"><a href="#应用层编程使用mylist-h" class="headerlink" title="应用层编程使用mylist.h"></a>应用层编程使用mylist.h</h2><blockquote>
<p><a href="https://raw.githubusercontent.com/Winddoing/CodeWheel/master/C/list/kernel_list/list.h" target="_blank" rel="noopener">mylist.h</a></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhimengzhe.com/linux/75966.html" target="_blank" rel="noopener">list_for_each_entry 和 list_for_each_entry_safe函数分析</a></li>
<li><a href="https://blog.csdn.net/u013904227/article/details/50931540" target="_blank" rel="noopener">list_head结构体的理解</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP之udhcpc</title>
    <url>/post/18609.html</url>
    <content><![CDATA[<blockquote>
<p>动态主机设置协议（英语：Dynamic Host Configuration Protocol，DHCP）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：</p>
<ul>
<li>用于内部网或网络服务供应商自动分配IP地址；</li>
<li>给用户用于内部网管理员作为对所有计算机作中央管理的手段。</li>
</ul>
</blockquote>
<p>DHCP从一个IP地址池中提供IP地址，该池有DHCP服务器数据库定义，称为scope。如果客户端接受这一地址，则它可在一个预定义的期限内使用该地址，称为<code>租约</code>。如果客户端无法从DHCP服务器获取IP地址，它就无法正常初始化TCP/IP。</p>
<p><strong>DHCP采用的C/S架构,客户端有<code>udhcpc</code></strong><br><a id="more"></a></p>
<h2 id="udhcpc"><a href="#udhcpc" class="headerlink" title="udhcpc"></a>udhcpc</h2><p>busybox中提供的简易的<code>udhcp client</code></p>
<p>文档:<a href="http://udhcp.busybox.net/README.udhcpc" target="_blank" rel="noopener">http://udhcp.busybox.net/README.udhcpc</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udhcpc -b -i eth0 -p /var/run/udhcpc.pid</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-b</code>:切换到后台指令</li>
<li><code>-i</code>:指定网络接口</li>
<li><code>-p</code>:守护进程ID存储在文件中</li>
<li><code>-s</code>:在DHCP的event中,执行脚本(default:/usr/share/udhcpc/default.script)</li>
</ul>
<h2 id="udhcpc执行脚本"><a href="#udhcpc执行脚本" class="headerlink" title="udhcpc执行脚本"></a>udhcpc执行脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">[ -z &quot;$1&quot; ] &amp;&amp; echo &quot;Error: should be called from udhcpc&quot; &amp;&amp; exit 1</span><br><span class="line"></span><br><span class="line">RESOLV_CONF=&quot;/etc/resolv.conf&quot;</span><br><span class="line">[ -n &quot;$broadcast&quot; ] &amp;&amp; BROADCAST=&quot;broadcast $broadcast&quot;</span><br><span class="line">[ -n &quot;$subnet&quot; ] &amp;&amp; NETMASK=&quot;netmask $subnet&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">        deconfig)</span><br><span class="line">                /sbin/ifconfig $interface 0.0.0.0</span><br><span class="line">                ;;</span><br><span class="line"></span><br><span class="line">        renew|bound)</span><br><span class="line">                /sbin/ifconfig $interface $ip $BROADCAST $NETMASK</span><br><span class="line"></span><br><span class="line">                if [ -n &quot;$router&quot; ] ; then</span><br><span class="line">                        echo &quot;deleting routers&quot;</span><br><span class="line">                        while route del default gw 0.0.0.0 dev $interface ; do</span><br><span class="line">                                :</span><br><span class="line">                        done</span><br><span class="line">                        for i in $router ; do</span><br><span class="line">                                route add default gw $i dev $interface</span><br><span class="line">                        done</span><br><span class="line">                fi</span><br><span class="line"></span><br><span class="line">                echo -n &gt; $RESOLV_CONF</span><br><span class="line">                [ -n &quot;$domain&quot; ] &amp;&amp; echo search $domain &gt;&gt; $RESOLV_CONF</span><br><span class="line">                for i in $dns ; do</span><br><span class="line">                        echo adding dns $i</span><br><span class="line">                        echo nameserver $i &gt;&gt; $RESOLV_CONF</span><br><span class="line">                done</span><br><span class="line">                ;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<h2 id="dhcpcd配置静态IP"><a href="#dhcpcd配置静态IP" class="headerlink" title="dhcpcd配置静态IP"></a>dhcpcd配置静态IP</h2><p>配置文件<code>/etc/dhcpcd.conf</code></p>
<p>追加IP配置信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface eth0</span><br><span class="line">static ip_address=172.16.xx.xx/24       #配置IP地址</span><br><span class="line">static routers=172.16.xx.xx             #网关</span><br><span class="line">static domain_name_servers=172.16.xx.xx #DNS</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wizardforcel.gitbooks.io/network-basic/content/30.html" target="_blank" rel="noopener">网络基本功（三十一）：细说DHCP</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>dhcp</category>
      </categories>
      <tags>
        <tag>dhcp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Anaconda环境搭建</title>
    <url>/post/65273.html</url>
    <content><![CDATA[<p><code>Anaconda</code>是Python的包管理器和环境管理器</p>
<p>优点:</p>
<ul>
<li>Anaconda附带了一大批常用数据科学包，它附带了conda、Python和 150 多个科学包及其依赖项</li>
<li>管理包. Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的, 包括安装、卸载和更新包</li>
<li>管理环境. 方便创建和使用不同python版本的虚拟环境</li>
</ul>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官网:<a href="https://www.anaconda.com/download/#linux" target="_blank" rel="noopener">https://www.anaconda.com/download/#linux</a></p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-5.3.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>在安装的过程中，会问你安装路径(home目录下)，直接回车选择默认。有个地方问你是否将anaconda安装路径加入到环境变量（.bashrc)中，输入yes，默认的是no</p>
<p>如果选择了默认需要手动将anaconda的路径添加到环境变量</p>
<ul>
<li>打开vi ~/.bashrc</li>
<li>添加anaconda的路径下的bin路径到<code>PATH</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:$HOME/.tools/x86:$HOME/anaconda3/bin/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>安装完成后,需要重启终端或者<code>source ~/.bashrc</code></strong></p>
<h3 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h3><p>which conda或conda –version<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$conda --version</span><br><span class="line">conda 4.5.11</span><br></pre></td></tr></table></figure></p>
<h2 id="使用命令–conda"><a href="#使用命令–conda" class="headerlink" title="使用命令–conda"></a>使用命令–conda</h2><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$conda -h</span><br><span class="line">usage: conda [-h] [-V] command ...</span><br><span class="line"></span><br><span class="line">conda is a tool for managing and deploying applications, environments and packages.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  command</span><br><span class="line">    clean        Remove unused packages and caches.</span><br><span class="line">    config       Modify configuration values in .condarc. This is modeled</span><br><span class="line">                 after the git config command. Writes to the user .condarc</span><br><span class="line">                 file (/home/xxx/.condarc) by default.</span><br><span class="line">    create       Create a new conda environment from a list of specified</span><br><span class="line">                 packages.</span><br><span class="line">    help         Displays a list of available conda commands and their help</span><br><span class="line">                 strings.</span><br><span class="line">    info         Display information about current conda install.</span><br><span class="line">    install      Installs a list of packages into a specified conda</span><br><span class="line">                 environment.</span><br><span class="line">    list         List linked packages in a conda environment.</span><br><span class="line">    package      Low-level conda package utility. (EXPERIMENTAL)</span><br><span class="line">    remove       Remove a list of packages from a specified conda environment.</span><br><span class="line">    uninstall    Alias for conda remove. See conda remove --help.</span><br><span class="line">    search       Search for packages and display associated information. The</span><br><span class="line">                 input is a MatchSpec, a query language for conda packages.</span><br><span class="line">                 See examples below.</span><br><span class="line">    update       Updates conda packages to the latest compatible version. This</span><br><span class="line">                 command accepts a list of package names and updates them to</span><br><span class="line">                 the latest versions that are compatible with all other</span><br><span class="line">                 packages in the environment. Conda attempts to install the</span><br><span class="line">                 newest versions of the requested packages. To accomplish</span><br><span class="line">                 this, it may update some packages that are already installed,</span><br><span class="line">                 or install additional packages. To prevent existing packages</span><br><span class="line">                 from updating, use the --no-update-deps option. This may</span><br><span class="line">                 force conda to install older versions of the requested</span><br><span class="line">                 packages, and it does not prevent additional dependency</span><br><span class="line">                 packages from being installed. If you wish to skip dependency</span><br><span class="line">                 checking altogether, use the &apos;--force&apos; option. This may</span><br><span class="line">                 result in an environment with incompatible packages, so this</span><br><span class="line">                 option must be used with great caution.</span><br><span class="line">    upgrade      Alias for conda update. See conda update --help.</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help     Show this help message and exit.</span><br><span class="line">  -V, --version  Show the conda version number and exit.</span><br><span class="line"></span><br><span class="line">conda commands available from other packages:</span><br><span class="line">  build</span><br><span class="line">  convert</span><br><span class="line">  develop</span><br><span class="line">  env</span><br><span class="line">  index</span><br><span class="line">  inspect</span><br><span class="line">  metapackage</span><br><span class="line">  render</span><br><span class="line">  server</span><br><span class="line">  skeleton</span><br></pre></td></tr></table></figure>
<h3 id="查看已安装的库"><a href="#查看已安装的库" class="headerlink" title="查看已安装的库"></a>查看已安装的库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$conda list</span><br></pre></td></tr></table></figure>
<h3 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$conda install numpy</span><br></pre></td></tr></table></figure>
<h3 id="更新库"><a href="#更新库" class="headerlink" title="更新库"></a>更新库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$conda update numpy</span><br></pre></td></tr></table></figure>
<h3 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h3><p>进入python环境使用<code>import numpy</code>进行验证,不报任何错误表示安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$python3.7</span><br><span class="line">Python 3.7.0 (default, Jun 28 2018, 13:15:42)</span><br><span class="line">[GCC 7.2.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Conda的环境管理"><a href="#Conda的环境管理" class="headerlink" title="Conda的环境管理"></a>Conda的环境管理</h2><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>Conda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。<br>若需要安装Python3.6，此时，我们需要做的操作如下：</p>
<ol>
<li><p>创建Python虚拟环境test，指定Python版本是3.6（不用管是3.6.x，conda会为我们自动寻找3.6.x中的最新版本）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n test python=3.6</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source activate test</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source deactivate zeronet</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove -n test --all</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟环境中安装额外的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install -n test [package]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/liaohuiqiang/p/9380417.html" target="_blank" rel="noopener">conda环境管理</a></li>
<li><a href="https://blog.csdn.net/z583636762/article/details/79166373" target="_blank" rel="noopener">conda命令：管理包、管理环境</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下shell基础--获取脚本路径</title>
    <url>/post/12156.html</url>
    <content><![CDATA[<p>在执行脚本时我们或多或少的都要知道当前所在的路径,或者脚本存放的路径,记录几个常用的获取<code>路径</code>的方法</p>
<a id="more"></a>
<h2 id="脚本路径"><a href="#脚本路径" class="headerlink" title="脚本路径"></a>脚本路径</h2><h3 id="cd-dirname-0-pwd"><a href="#cd-dirname-0-pwd" class="headerlink" title="$(cd dirname $0;pwd)"></a>$(cd <code>dirname $0</code>;pwd)</h3><blockquote>
<p>获取当前<code>脚本</code>所在的<code>绝对路径</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">basepath=$(cd `dirname $0`; pwd)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dirname $0</code> :取得当前执行脚本文件的父目录</li>
</ul>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><blockquote>
<p>获取当前<code>执行脚本</code>的所在的<code>绝对路径</code></p>
</blockquote>
<h3 id="readlink-f-dirname-0"><a href="#readlink-f-dirname-0" class="headerlink" title="$(readlink -f $(dirname $0))"></a>$(readlink -f $(dirname $0))</h3><blockquote>
<p>获取当前<code>脚本</code>所在的<code>相对路径`</code></p>
</blockquote>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote>
<p>xxx:主机名</p>
</blockquote>
<ul>
<li>测试脚本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">basepath1=`pwd`</span><br><span class="line">basepath2=$(cd `dirname $0`; pwd)</span><br><span class="line">basepath3=$(readlink -f $(dirname $0))</span><br><span class="line">basepath4=$(dirname $0)</span><br><span class="line">basepath5=$(dirname $(readlink -f $0))</span><br><span class="line"></span><br><span class="line">echo &quot;basepath1= $basepath1&quot;</span><br><span class="line">echo &quot;basepath2= $basepath2&quot;</span><br><span class="line">echo &quot;basepath3= $basepath3&quot;</span><br><span class="line">echo &quot;basepath4= $basepath4&quot;</span><br><span class="line">echo &quot;basepath5= $basepath5&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14:47 [xxx@xxx-pc]~/test</span><br><span class="line">=====&gt;$ls -l a.sh</span><br><span class="line">lrwxrwxrwx 1 xxx xxx 13 11月 24 14:42 a.sh -&gt; aa/bb/cc/a.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>执行脚本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14:48 [xxx@xxx-pc]~</span><br><span class="line">=====&gt;$./test/a.sh</span><br><span class="line">basepath1= /home/xxx</span><br><span class="line">basepath2= /home/xxx/test</span><br><span class="line">basepath3= /home/xxx/test</span><br><span class="line">basepath4= ./test</span><br><span class="line">basepath5= /home/xxx/test/aa/bb/cc</span><br></pre></td></tr></table></figure>
<h2 id="readlink"><a href="#readlink" class="headerlink" title="readlink"></a>readlink</h2><blockquote>
<p>用来找出符号链接所指向的位置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$readlink .vimrc</span><br><span class="line">/home/xxx/.work_env/vim/vimrc</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-f</code>: 递归跟随给出文件名的所有符号链接以标准化，除最后一个外所有组件必须存在。</li>
</ul>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下批量文件处理-字符串替换</title>
    <url>/post/63603.html</url>
    <content><![CDATA[<p><code>sed</code>进行处理多文件中的字符串替换,可以快速的修改函数名或者变量名.</p>
<a id="more"></a>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed [-nefri] [动作]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-n</code> ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</li>
<li><code>-e</code> ：直接在命令列模式上进行 sed 的动作编辑；</li>
<li><code>-f</code> ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</li>
<li><code>-r</code> ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</li>
<li><code>-i</code> ：直接修改读取的文件内容，而不是输出到终端。</li>
</ul>
<h2 id="单文件替换"><a href="#单文件替换" class="headerlink" title="单文件替换"></a>单文件替换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/sockhandle/sock/g&apos; aa.c</span><br></pre></td></tr></table></figure>
<h2 id="多文件替换"><a href="#多文件替换" class="headerlink" title="多文件替换"></a>多文件替换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;sockhandle&quot; . -rl | xargs sed -i &apos;s/sockhandle/sock/g&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-rl</code>: 列出文件内容符合指定的范本样式的文件名称</p>
<p><code>-rn</code>: 在显示符合范本样式的那一列之前，标示出该列的列数编号</p>
</blockquote>
]]></content>
      <categories>
        <category>shell</category>
        <category>字符串处理</category>
      </categories>
      <tags>
        <tag>linux shell</tag>
      </tags>
  </entry>
  <entry>
    <title>代码风格格式化--Astyle</title>
    <url>/post/62371.html</url>
    <content><![CDATA[<p><code>Astyle</code>是一个用来对C/C++代码进行格式化</p>
<blockquote>
<p>文档: <a href="http://astyle.sourceforge.net/astyle.html" target="_blank" rel="noopener">Artistic Style 3.1</a></p>
</blockquote>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sudo apt install astyle</span><br></pre></td></tr></table></figure>
<h2 id="预定风格"><a href="#预定风格" class="headerlink" title="预定风格"></a>预定风格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default brace style</span><br><span class="line">If no brace style is requested, the opening braces will not be</span><br><span class="line">changed and closing braces will be broken from the preceding line.</span><br><span class="line"></span><br><span class="line">--style=allman  OR  --style=bsd  OR  --style=break  OR  -A1</span><br><span class="line">Allman style formatting/indenting.</span><br><span class="line">Broken braces.</span><br><span class="line"></span><br><span class="line">--style=java  OR  --style=attach  OR  -A2</span><br><span class="line">Java style formatting/indenting.</span><br><span class="line">Attached braces.</span><br><span class="line"></span><br><span class="line">--style=kr  OR  --style=k&amp;r  OR  --style=k/r  OR  -A3</span><br><span class="line">Kernighan &amp; Ritchie style formatting/indenting.</span><br><span class="line">Linux braces.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">--style=gnu  OR  -A7</span><br><span class="line">GNU style formatting/indenting.</span><br><span class="line">Broken braces, indented blocks.</span><br><span class="line"></span><br><span class="line">--style=linux  OR  --style=knf  OR  -A8</span><br><span class="line">Linux style formatting/indenting.</span><br><span class="line">Linux braces, minimum conditional indent is one-half indent.</span><br><span class="line"></span><br><span class="line">--style=horstmann  OR  --style=run-in  OR  -A9</span><br><span class="line">Horstmann style formatting/indenting.</span><br><span class="line">Run-in braces, indented switches.</span><br><span class="line"></span><br><span class="line">--style=1tbs  OR  --style=otbs  OR  -A10</span><br><span class="line">One True Brace Style formatting/indenting.</span><br><span class="line">Linux braces, add braces to all conditionals.</span><br><span class="line"></span><br><span class="line">--style=google  OR  -A14</span><br><span class="line">Google style formatting/indenting.</span><br><span class="line">Attached braces, indented class modifiers.</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">astyle --style=linux -n ./*.c</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--style=linux</code> : linux风格缩进</li>
<li><code>-n</code> : 不保存备份</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;astyle --style=linux --indent=force-tab=4 --convert-tabs --pad-oper --unpad-paren --break-blocks=all --delete-empty-lines *.c *.h</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="递归格式化"><a href="#递归格式化" class="headerlink" title="递归格式化"></a>递归格式化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">astyle --style=linux --recursive *.c,*.h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>必须中间加<code>,</code></p>
</blockquote>
<h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><blockquote>
<p>在<code>--style=linux</code>的基础上修改,只做必要改动</p>
</blockquote>
<h3 id="缩进Tab"><a href="#缩进Tab" class="headerlink" title="缩进Tab"></a>缩进Tab</h3><p>默认tab是4个空格.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--indent=force-tab=#  OR  -T#</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优先采用空格缩进, 这样配置后同vim中的tab缩进配置4个空格相同,格式化后的代码相当于vim中的<code>gg=G</code></p>
</blockquote>
<h3 id="switch缩进"><a href="#switch缩进" class="headerlink" title="switch缩进"></a>switch缩进</h3><p>默认</p>
<h3 id="操作符两边加空格"><a href="#操作符两边加空格" class="headerlink" title="操作符两边加空格"></a>操作符两边加空格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--pad-oper  OR  -p</span><br></pre></td></tr></table></figure>
<h3 id="删除括号-两边多余空格"><a href="#删除括号-两边多余空格" class="headerlink" title="删除括号()两边多余空格"></a>删除括号()两边多余空格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--unpad-paren  OR  -U</span><br></pre></td></tr></table></figure>
<h3 id="空行分隔没有关系的块-类-标签-不包括函数块"><a href="#空行分隔没有关系的块-类-标签-不包括函数块" class="headerlink" title="空行分隔没有关系的块,类,标签(不包括函数块)"></a>空行分隔没有关系的块,类,标签(不包括函数块)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--break-blocks  OR  -f</span><br></pre></td></tr></table></figure>
<h3 id="空行分隔无关系的块-包括else-catch等"><a href="#空行分隔无关系的块-包括else-catch等" class="headerlink" title="空行分隔无关系的块,包括else catch等"></a>空行分隔无关系的块,包括else catch等</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--break-blocks=all  OR  -F</span><br></pre></td></tr></table></figure>
<h3 id="删除多余空行"><a href="#删除多余空行" class="headerlink" title="删除多余空行"></a>删除多余空行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--delete-empty-lines  OR  -x</span><br></pre></td></tr></table></figure>
<h3 id="Tab转换为空格"><a href="#Tab转换为空格" class="headerlink" title="Tab转换为空格"></a>Tab转换为空格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--convert-tabs  OR  -c</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/tfanalysis/articles/4874793.html" target="_blank" rel="noopener">Astyle编程语言格式化工具的中文说明</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>代码风格</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>码率,帧率,分辨率对视频画质的影响</title>
    <url>/post/60235.html</url>
    <content><![CDATA[<p>在这几天的调试中降低<code>码率</code>和<code>帧率</code>后,将会减少延时和花屏的情况,主要是提高了解码的速度,但是对画质的影响,主要在于什么地方?</p>
<ul>
<li>对帧率的修改,<code>60fps</code>降到<code>25fps</code>后,看到的显示效果没有变化,为什么?对用户体验的影响</li>
</ul>
<blockquote>
<p>用户体验: 只关系视频的画面质量,如果需要存储还需要关心视频文件的大小</p>
<ul>
<li>流畅度: 主要受视频帧率(FPS)的影响</li>
<li>清晰度: 单位面积的画面所承载的信息，在对视频进行评价是就是当FPS和分辨率固定时，考察视频的清晰度。码率</li>
<li>分辨率: 视频画面的大小</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h2><blockquote>
<p>码率:比特率，英文为<code>Bit Rate</code>，是指每秒传送的比特(bit)数</p>
</blockquote>
<h3 id="码率影响视频清晰度"><a href="#码率影响视频清晰度" class="headerlink" title="码率影响视频清晰度"></a>码率影响视频<code>清晰度</code></h3><p><img src="/images/2018/11/video_bit_rate.png" alt="video_bit_rate"></p>
<blockquote>
<p>当比特率越大，视频清晰度就越高。其影响存在边际效应递减现象，并且存在上限（视频原始数据的画质）。</p>
</blockquote>
<h3 id="码率决定了视频大小"><a href="#码率决定了视频大小" class="headerlink" title="码率决定了视频大小"></a>码率决定了视频<code>大小</code></h3><p>视频大小size和码率BitRate的关系：</p>
<p>size = $\dfrac{VideoDuration * BitRate}{8}$</p>
<h2 id="帧率—FPS"><a href="#帧率—FPS" class="headerlink" title="帧率—FPS"></a>帧率—FPS</h2><blockquote>
<p>FPS是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。FPS是测量用于保存、显示动态视频的信息数量。每秒钟帧数愈多，所显示的动作就会越流畅。</p>
<blockquote>
<p>在游戏过程中一般人不觉得卡顿的FPS频率大约是30Hz，想要达到流畅等级则需要60Hz。</p>
</blockquote>
</blockquote>
<ol>
<li><p><strong>帧率对视频画质没有影响</strong> 帧率和视频大小正相关。视频大小和FPS/GOP_SIZE存在一定的线性相关性。</p>
<blockquote>
<p>GOP_SIZE是ffmpeg中的一个编码参数，表示的每GOP_SIZE个帧存在一个关键帧。</p>
</blockquote>
</li>
<li><p>在显示<strong>“分辨率”不变</strong>的情况下，FPS越高，则对显卡的处理能力要求越高。</p>
</li>
</ol>
<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>分辨率对视频大小和画质有着非常重要的影响。</p>
<p>如果清晰度和流畅度不变，分辨与视频画质，大小正相关。但是前提条件是清晰度不变，单纯的增加分辨并不能带来更好的画质.</p>
<blockquote>
<p>结果显示，同等分辨率的前提下，显示屏幕越大，主观感受越差。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/leixiaohua1020/article/details/12856087" target="_blank" rel="noopener">视频质量，分辨率以及码率之间的关系</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频 帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>视频流基础知识1-PSI/SI</title>
    <url>/post/10069.html</url>
    <content><![CDATA[<p>在ts流转成es流的学习过程中,了解到PSI相关的基础知识在这里做一记录总结,方便以后查找和理解.</p>
<blockquote>
<p>在数据传输前打包成MPEG-2的TS(传输流)包,这些TS包如果没有引导信息,接收端的解码器将无法找到需要的码流信息,因此MPEG-2专门定义了<code>PSI</code>(节目信息),PSI的作用<strong>自动设置和引导解码器进行解码</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="PSI-SI关键词"><a href="#PSI-SI关键词" class="headerlink" title="PSI/SI关键词"></a>PSI/SI关键词</h2><table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">关键字</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">翻译</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">PSI</td>
<td style="text-align:center">Program Specific Information</td>
<td style="text-align:center">节目引导信息</td>
<td style="text-align:left">对单一码流的描述</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">SI</td>
<td style="text-align:center">Service Information</td>
<td style="text-align:center">业务信息</td>
<td style="text-align:left">对系统中所有码流的描述，包含了PSI（PSI+9张表）</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">TS包</td>
<td style="text-align:center">Transport Packet</td>
<td style="text-align:center">传输包</td>
<td style="text-align:left">数字视音频、图文数据打包成TS包</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">TS</td>
<td style="text-align:center">Transport Stream</td>
<td style="text-align:center">传输流（TS流）</td>
<td style="text-align:left">一个频道（多个节目及业务）的TS包复用后称TS流</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">PAT</td>
<td style="text-align:center">Program Association Table</td>
<td style="text-align:center">节目关联表</td>
<td style="text-align:left">将节目号码和节目映射表PID相关联，获取数据的开始</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">PMT</td>
<td style="text-align:center">Program Map Table</td>
<td style="text-align:center">节目映射表</td>
<td style="text-align:left">指定一个或多个节目的PID</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">CAT</td>
<td style="text-align:center">Conditional Access Table</td>
<td style="text-align:center">条件接收表</td>
<td style="text-align:left">将一个或多个专用EMM流分别与唯一的PID相关联</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">NIT</td>
<td style="text-align:center">Network Information Table</td>
<td style="text-align:center">网络信息表</td>
<td style="text-align:left">描述整个网络，如多少TS流、频点和调制方式等信息</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">SDT</td>
<td style="text-align:center">Service Description Table</td>
<td style="text-align:center"><strong>业务</strong>描述表</td>
<td style="text-align:left">包含业务数据（如业务名称、起始时间、持续时间等）</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">BAT</td>
<td style="text-align:center">Bouquet Association Table</td>
<td style="text-align:center">业务群关联表</td>
<td style="text-align:left">给出业务群的名称及其业务列表等信息</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">EIT</td>
<td style="text-align:center">Event Information Table</td>
<td style="text-align:center"><strong>事件</strong>信息表</td>
<td style="text-align:left">包含事件或节目相关数据，是生成EPG的主要表</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">RST</td>
<td style="text-align:center">Running Status Table</td>
<td style="text-align:center">运行状态表</td>
<td style="text-align:left">给出事件的状态（运行/非运行）</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">TDT</td>
<td style="text-align:center">Time&amp;Date Table</td>
<td style="text-align:center">时间和日期表</td>
<td style="text-align:left">给出当前事件和日期相关信息，更新频繁</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">TOT</td>
<td style="text-align:center">Time Offset Table</td>
<td style="text-align:center">时间偏移表</td>
<td style="text-align:left">给出了当前时间日期与本地时间偏移的信息</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">ST</td>
<td style="text-align:center">Stuffing Table</td>
<td style="text-align:center">填充表</td>
<td style="text-align:left">用于使现有的段无效，如在一个传输系统的边界</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">SIT</td>
<td style="text-align:center">Stuffing Information Table</td>
<td style="text-align:center">选择信息表</td>
<td style="text-align:left">仅用于码流片段中，如记录的一段码流，包含描述该码流片段业务信息段的地方</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">DIT</td>
<td style="text-align:center">Discontinuity Information Table</td>
<td style="text-align:center">间断信息表</td>
<td style="text-align:left">仅用于码流片段，如记录的一段码流中，它将插入到码流片段业务信息间断的地方</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><code>PAT</code>,<code>PMT</code>,<code>CAT</code>,<code>NIT</code>为<strong>PSI信息</strong>,由<strong>MPEG2标准</strong>定义,NIT是由<strong>SI标准</strong>规定</li>
<li><code>SDT</code>,<code>BAT</code>,<code>EIT</code>,<code>RST</code>,<code>TDT</code>,<code>TOT</code>,<code>ST</code>,<code>SIT</code>,<code>DIT</code>为<strong>SI信息</strong></li>
</ul>
</blockquote>
<h2 id="业务-Service-与事件-Event"><a href="#业务-Service-与事件-Event" class="headerlink" title="业务(Service)与事件(Event)"></a>业务(Service)与事件(Event)</h2><p><code>业务</code>就是指“频道”，<code>事件</code>就是“节目”.</p>
<blockquote>
<p>举个例子：CCTV1是一个频道，也就是我们所说的“业务（Service）”；《新闻联播》是一个节目，也就是我们所说的“事件(Event)”。</p>
</blockquote>
<h2 id="SI信息的构成"><a href="#SI信息的构成" class="headerlink" title="SI信息的构成"></a>SI信息的构成</h2><blockquote>
<p>SI信息内容是按照network(网络)→transport strem（传输流）→service（业务）→event（事件）的分层顺序描述</p>
</blockquote>
<p><img src="/images/2018/11/video_ts_si.png" alt="video_ts_SI"></p>
<p>为了能有效地从众多的数据包中组织起SI信息，而使用了很多的标识。有Network_id(网络标识)、 Original_network_id(原始网络标识)、Transport_stream_id(传输流标识)、Service id(业务标识)、eventid_id(事件标识)、Bouquet_id(业务群组标识)。</p>
<ul>
<li>一个网络信息由network_id来定位。</li>
<li>一个TS由network_id、Original_network_id、Transport_stream_id来定位，标明这个流在那个网络播发，它原属那个网络，并给它加上标识。</li>
<li>一个业务由network_id、Original_network_id、Transport_stream_id、service_id来定位，标明这个业务在那个网络播发，它原属那个网络和那个流，并给它加上标识。这体现在SDT表中。</li>
<li>一个事件由network_id、Original_network_id、Transport_stream_id、service_id、event_id来定位，标明这个事件在那个网络播发，它原属那个网络和那个流及那个业务，并给它加上标识。这体现在EIT表中。</li>
</ul>
<h3 id="SI和SI信息的各种表的PID"><a href="#SI和SI信息的各种表的PID" class="headerlink" title="SI和SI信息的各种表的PID"></a>SI和SI信息的各种表的PID</h3><table>
<thead>
<tr>
<th style="text-align:center">Table</th>
<th style="text-align:center">PID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PAT</td>
<td style="text-align:center">0x0000</td>
</tr>
<tr>
<td style="text-align:center">CAT</td>
<td style="text-align:center">0x0001</td>
</tr>
<tr>
<td style="text-align:center">TSDT</td>
<td style="text-align:center">0x0002</td>
</tr>
<tr>
<td style="text-align:center">NIT,ST</td>
<td style="text-align:center">0x0010</td>
</tr>
<tr>
<td style="text-align:center">SDT,BAT,ST</td>
<td style="text-align:center">0x0011</td>
</tr>
<tr>
<td style="text-align:center">EIT,ST</td>
<td style="text-align:center">0x0012</td>
</tr>
<tr>
<td style="text-align:center">RST,ST</td>
<td style="text-align:center">0x0013</td>
</tr>
<tr>
<td style="text-align:center">TDT,TOT,ST</td>
<td style="text-align:center">0x0014</td>
</tr>
<tr>
<td style="text-align:center">DIT</td>
<td style="text-align:center">0x001E</td>
</tr>
<tr>
<td style="text-align:center">SIT</td>
<td style="text-align:center">0x001F</td>
</tr>
</tbody>
</table>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><blockquote>
<p>表是组成SI信息的一种数据结构。</p>
</blockquote>
<p>由MPEG-2定义的TS里面，数据包携带了两类信息：</p>
<ul>
<li>一是音、视频等素材的数据，</li>
<li>二是PSI表。</li>
</ul>
<p>具有给定PID的数据包的有序排列就形成了TS 流。PSI表里的承载的内容主要是TS（本节目流）的描述参数。</p>
<p>由MPEG-2定义的PSI主要包含有三个表：<code>PAT</code>、<code>PMT</code>、<code>CAT</code>。每个表都可作为一个或多个TS包的净荷插入TS中传送。</p>
<p>一个TS数据包的净荷为188个字节，当一个PSI/SI表的字节长度大于184字节时，就要对这个表进行分割，形成段（section）来传送。分段机制主要是将一个数据表分割成多个数据段。在PSI/SI表到TS包的转换过程中，段起到了中介的作用。由于一个数据包只有188字节，而段的长度是可变的，EIT表的段限长4096字节，其余PSI/SI表的段限长为1024字节。因此，一个段要分成几部分插入到TS包的净荷中。<br><img src="/images/2018/11/video_ts_table.png" alt="video_ts_table"></p>
<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><ul>
<li>EPG(Electronic Program Guide) : 电子节目指南</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/kkdestiny/article/details/12993971" target="_blank" rel="noopener">【PSI/SI学习系列】2.PSI/SI深入学习1——预备知识</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_a57c156801014p57.html" target="_blank" rel="noopener">PSI/SI解析（各种id说明）</a></li>
<li>DVB-T Transport Stream :<a href="https://csie.ntut.edu.tw/labaspl/edu/MPEG2_TS(NCTU2)A.pdf" target="_blank" rel="noopener">https://csie.ntut.edu.tw/labaspl/edu/MPEG2_TS(NCTU2)A.pdf</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频 psi</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM--GCC内嵌汇编</title>
    <url>/post/4526.html</url>
    <content><![CDATA[<p>记录ARM平台中相关的汇编操作和总结</p>
<a id="more"></a>
<h2 id="空指令–nop"><a href="#空指令–nop" class="headerlink" title="空指令–nop"></a>空指令–nop</h2><p>NOP指令<code>不产生任何意义的操作</code>,只占用一个机器周期,可以用于简单的延时操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在C代码中可以通过前后使用<code>nop</code>定位反汇编后代码所在的位置.</p>
</blockquote>
<p>实际编程的用途:</p>
<ol>
<li>需要短暂延时</li>
<li>需要精确控制延时,如控制驱动器步进电机的延时</li>
<li>通过在写NOP指令处填写相应代码实现分支跳转或分支调用???</li>
<li>解密时用???</li>
<li>在控制系统中插入NOP指令防止系统飞程???</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/erazy0/article/details/6071281" target="_blank" rel="noopener">NOP 指令作用</a></li>
</ul>
]]></content>
      <categories>
        <category>arm</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM处理器寄存器和汇编指令</title>
    <url>/post/25025.html</url>
    <content><![CDATA[<p>ARM体系结构支持<code>7种</code>处理器模式，分别是：<code>用户</code>、<code>FIQ</code>、<code>IRQ</code>、<code>管理</code>、<code>中止（abort）</code>、<code>未定义</code>和<code>系统</code>模式。除了用户模式外，其余都称之为特权模式。除了用户和系统模式外，其余都称之为异常模式</p>
<a id="more"></a>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>ARM的寄存器分为两类, <code>普通寄存器</code>和<code>状态寄存器</code></p>
<p>普通寄存器总共16个，分别为R0-R15；状态寄存器共2个，分别为<code>CPSR</code>和<code>SPSR</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">寄存器(Reg)</th>
<th style="text-align:center">寄存器(APCS)</th>
<th style="text-align:left">作用域</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">R0</td>
<td style="text-align:center">a1</td>
<td style="text-align:left">所有7种模式</td>
<td style="text-align:left">工作寄存器</td>
</tr>
<tr>
<td style="text-align:center">R1</td>
<td style="text-align:center">a2</td>
<td style="text-align:left">所有7种模式</td>
<td style="text-align:left">..</td>
</tr>
<tr>
<td style="text-align:center">R2</td>
<td style="text-align:center">a3</td>
<td style="text-align:left">所有7种模式</td>
<td style="text-align:left">..</td>
</tr>
<tr>
<td style="text-align:center">R3</td>
<td style="text-align:center">a4</td>
<td style="text-align:left">所有7种模式</td>
<td style="text-align:left">..</td>
</tr>
<tr>
<td style="text-align:center">R4</td>
<td style="text-align:center">v1</td>
<td style="text-align:left">所有7种模式</td>
<td style="text-align:left">必须保护</td>
</tr>
<tr>
<td style="text-align:center">R5</td>
<td style="text-align:center">v2</td>
<td style="text-align:left">所有7种模式</td>
<td style="text-align:left">..</td>
</tr>
<tr>
<td style="text-align:center">R6</td>
<td style="text-align:center">v3</td>
<td style="text-align:left">所有7种模式</td>
<td style="text-align:left">..</td>
</tr>
<tr>
<td style="text-align:center">R7</td>
<td style="text-align:center">v4</td>
<td style="text-align:left">所有7种模式</td>
<td style="text-align:left">..</td>
</tr>
<tr>
<td style="text-align:center">R8</td>
<td style="text-align:center">v5</td>
<td style="text-align:left">除FIQ模式</td>
<td style="text-align:left">..</td>
</tr>
<tr>
<td style="text-align:center">R9</td>
<td style="text-align:center">v6</td>
<td style="text-align:left">除FIQ模式</td>
<td style="text-align:left">..</td>
</tr>
<tr>
<td style="text-align:center">R10</td>
<td style="text-align:center">sl</td>
<td style="text-align:left">除FIQ模式</td>
<td style="text-align:left">栈限制</td>
</tr>
<tr>
<td style="text-align:center">R11</td>
<td style="text-align:center">fp</td>
<td style="text-align:left">除FIQ模式</td>
<td style="text-align:left">帧指针</td>
</tr>
<tr>
<td style="text-align:center">R12</td>
<td style="text-align:center">ip</td>
<td style="text-align:left">除FIQ模式</td>
<td style="text-align:left">内部过程调用寄存器</td>
</tr>
<tr>
<td style="text-align:center">R13</td>
<td style="text-align:center">sp</td>
<td style="text-align:left">用户和系统模式</td>
<td style="text-align:left">栈指针</td>
</tr>
<tr>
<td style="text-align:center">R14</td>
<td style="text-align:center">lr</td>
<td style="text-align:left">用户和系统模式</td>
<td style="text-align:left">连接寄存器</td>
</tr>
<tr>
<td style="text-align:center">R15</td>
<td style="text-align:center">pc</td>
<td style="text-align:left">所有7种模式</td>
<td style="text-align:left">程序计数器</td>
</tr>
<tr>
<td style="text-align:center">CPSR</td>
<td style="text-align:center">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">SPSR</td>
<td style="text-align:center">-</td>
<td style="text-align:left">除用户和系统模式</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<ul>
<li><code>R13(sp)</code>: 每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。</li>
<li><code>R14(lr)</code>: 每种模式下r14都有自身版组，它有两个特殊功能。<ul>
<li>保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：</li>
<li>当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。</li>
</ul>
</li>
</ul>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>ARM处理器中通常将寄存器R13作为堆栈指针（SP）。ARM处理器针对不同的模式，共有<strong>6个堆栈指针SP</strong>, 其中用户模式和系统模式共用一个SP，每种异常模式都有各自专用的R13寄存器（SP）。它们通常指向各模式所对应的专用堆栈，也就是ARM处理器允许用户程序有六个不同的堆栈空间。这些堆栈指针分别为R13、R13_svc、R13_abt、R13_und、R13_irq、R13_fiq.</p>
<p><img src="/images/2018/12/arm_asm_reg_sp.png" alt="arm_asm_reg_sp"></p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="存储器访问指令"><a href="#存储器访问指令" class="headerlink" title="存储器访问指令"></a>存储器访问指令</h3><p>ARM 处理是加载/存储体系结构的典型的RISC处理器，对存储器的访问只能使用<code>加载</code>和<code>存储</code>指令实现。ARM 的加载/存储指令是可以实现字、半字、无符/有符字节操作；批量加载/存储指令可实现一条指令加载/存储多个寄存器的内容，大大提高效率；SWP指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等。</p>
<h4 id="LDR和STR"><a href="#LDR和STR" class="headerlink" title="LDR和STR"></a>LDR和STR</h4><p>加载/存储字和无符号字节指令。使用单一数据传送指令(STR 和LDR)来装载和存储单一字节或字的数据从/到内存。</p>
<ul>
<li><code>LDR</code> 指令用于从内存中读取数据放入寄存器中；</li>
<li><code>STR</code> 指令用于将寄存器中的数据保存到内存。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR&#123;cond&#125;&#123;T&#125; Rd,&lt;地址&gt;    ;加载指定地址上的数据(字)，放入Rd中</span><br><span class="line">STR&#123;cond&#125;&#123;T&#125; Rd,&lt;地址&gt;    ;存储数据(字)到指定地址的存储单元，要存储的数据在Rd中</span><br><span class="line">LDR&#123;cond&#125;B&#123;T&#125; Rd,&lt;地址&gt;   ;加载字节数据，放入Rd中，即Rd最低字节有效，高24位清零</span><br><span class="line">STR&#123;cond&#125;B&#123;T&#125; Rd,&lt;地址&gt;   ;存储字节数据，要存储的数据在Rd，最低字节有效</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中，T 为可选后缀，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下。T在用户模式下无效，不能与前索引偏移一起使用T</p>
</blockquote>
<ul>
<li><p>立即数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR R1,[R0,#0x12]   ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变)</span><br><span class="line">LDR R1,[R0,#-0x12]  ;将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变)</span><br><span class="line">LDR R1,[R0]         ;将R0 地址处的数据读出，保存到R1 中(零偏移)</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR R1,[R0,R2]      ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变)</span><br><span class="line">LDR R1,[R0,-R2]     ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变)</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄存器及移位常数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR R1,[R0,R2,LSL #2]   ;将R0+R2*4地址处的数据读出，保存到R1中（R0，R2的值不变）</span><br><span class="line">LDR R1,[R0,-R2,LSL #2]  ;将R0-R2*4地址处的数据计读出，保存到R1中(R0，R2的值不变)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h3><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h3 id="状态寄存器指令"><a href="#状态寄存器指令" class="headerlink" title="状态寄存器指令"></a>状态寄存器指令</h3><h3 id="ARM协处理器指令"><a href="#ARM协处理器指令" class="headerlink" title="ARM协处理器指令"></a>ARM协处理器指令</h3><h2 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h2><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b, c;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">3</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello c=%d!\n"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc hello.c -o hello --save-temp</span><br></pre></td></tr></table></figure></p>
<h3 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.arch armv7-a</span><br><span class="line">.eabi_attribute 28, 1</span><br><span class="line">.eabi_attribute 20, 1</span><br><span class="line">.eabi_attribute 21, 1</span><br><span class="line">.eabi_attribute 23, 3</span><br><span class="line">.eabi_attribute 24, 1</span><br><span class="line">.eabi_attribute 25, 1</span><br><span class="line">.eabi_attribute 26, 2</span><br><span class="line">.eabi_attribute 30, 6</span><br><span class="line">.eabi_attribute 34, 1</span><br><span class="line">.eabi_attribute 18, 4</span><br><span class="line">.file	&quot;hello.c&quot;</span><br><span class="line">.text</span><br><span class="line">.section	.rodata</span><br><span class="line">.align	2</span><br><span class="line">.LC0:</span><br><span class="line">.ascii	&quot;Hello c=%d!\012\000&quot;</span><br><span class="line">.text</span><br><span class="line">.align	1</span><br><span class="line">.global	main</span><br><span class="line">.syntax unified</span><br><span class="line">.thumb</span><br><span class="line">.thumb_func</span><br><span class="line">.fpu vfpv3-d16</span><br><span class="line">.type	main, %function</span><br><span class="line">main:</span><br><span class="line">@ args = 0, pretend = 0, frame = 24</span><br><span class="line">@ frame_needed = 1, uses_anonymous_args = 0</span><br><span class="line">push	&#123;r7, lr&#125;</span><br><span class="line">sub	sp, sp, #24</span><br><span class="line">add	r7, sp, #0</span><br><span class="line">str	r0, [r7, #4]</span><br><span class="line">str	r1, [r7]</span><br><span class="line">movs	r3, #1</span><br><span class="line">str	r3, [r7, #20]</span><br><span class="line">movs	r3, #3</span><br><span class="line">str	r3, [r7, #16]</span><br><span class="line">ldr	r2, [r7, #20]</span><br><span class="line">ldr	r3, [r7, #16]</span><br><span class="line">add	r3, r3, r2</span><br><span class="line">str	r3, [r7, #12]</span><br><span class="line">ldr	r1, [r7, #12]</span><br><span class="line">movw	r0, #:lower16:.LC0</span><br><span class="line">movt	r0, #:upper16:.LC0</span><br><span class="line">bl	printf</span><br><span class="line">movs	r3, #0</span><br><span class="line">mov	r0, r3</span><br><span class="line">adds	r7, r7, #24</span><br><span class="line">mov	sp, r7</span><br><span class="line">@ sp needed</span><br><span class="line">pop	&#123;r7, pc&#125;</span><br><span class="line">.size	main, .-main</span><br><span class="line">.ident	&quot;GCC: (Linaro GCC 7.3-2018.05) 7.3.1 20180425 [linaro-7.3-2018.05 revision d29120a424ecfbc167ef90065c0eeb7f91977701]&quot;</span><br><span class="line">.section	.note.GNU-stack,&quot;&quot;,%progbits</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@</code>: 单行注释</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/uestcbutcher/p/7244799.html" target="_blank" rel="noopener">ARM指令集详解</a></li>
<li><a href="https://blog.csdn.net/u013736724/article/details/53200539" target="_blank" rel="noopener">ARM汇编语言学习笔记（一）—ARM汇编的程序结构</a></li>
</ul>
]]></content>
      <categories>
        <category>arm</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下shell基础--软连接处理</title>
    <url>/post/55887.html</url>
    <content><![CDATA[<p>软连接的截取和定位</p>
<p>场景: 当前所执行的脚本是连接,获取其实际的路径(位置)</p>
<a id="more"></a>
<h2 id="判断软连接"><a href="#判断软连接" class="headerlink" title="判断软连接"></a>判断软连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ -h "a.sh" ]; then</span><br><span class="line">    echo "It's a soft connection"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-h</code>: 软连接</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PRG=$0</span><br><span class="line">ls=`ls -ld "$PRG"`</span><br><span class="line">link=`expr "$ls" : '.*-&gt; \(.*\)$'`</span><br><span class="line"></span><br><span class="line">echo "Current script PRG: $PRG"</span><br><span class="line">echo "Soft connection path link: $link"</span><br><span class="line"></span><br><span class="line">echo "Get the current path: `dirname "$PRG"`"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断软连接是否在当前目录下</span></span><br><span class="line">if expr "$link" : '/.*' &gt; /dev/null; then</span><br><span class="line">    PRG="$link"</span><br><span class="line">else</span><br><span class="line">    PRG="`dirname "$PRG"`/$link"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo "Soft connection path link: $link"</span><br><span class="line">echo "Actual script path PRG: $PRG"</span><br></pre></td></tr></table></figure>
<p>测试环境: 保存脚本到xx.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$mkdir -p aa/bb/cc</span><br><span class="line">$mv xx.sh aa/bb/cc</span><br><span class="line">$ln -s aa/bb/cc/xx.sh xx.sh</span><br><span class="line">$ls -ld xx.sh</span><br><span class="line">lrwxrwxrwx 1 xxx xxx 14 12月 21 16:57 xx.sh -&gt; aa/bb/cc/xx.sh</span><br><span class="line">$./xx.sh</span><br></pre></td></tr></table></figure>
<p>执行脚本:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$./xx.sh</span><br><span class="line">Current script PRG: ./xx.sh</span><br><span class="line">Soft connection path link: aa/bb/cc/xx.sh</span><br><span class="line">Get the current path: .</span><br><span class="line">Soft connection path link: aa/bb/cc/xx.sh</span><br><span class="line">Actual script path PRG: ./aa/bb/cc/xx.sh</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核工具--Sparse</title>
    <url>/post/22743.html</url>
    <content><![CDATA[<p>Sparse诞生于2004年，是由Linux之父开发的，目的就是提供一个静态检查代码的工具，从而减少Linux内核的隐患。起始，在Sparse之前已经有了一个不错的代码静态检查工具（SWAT），只不过这个工具不是免费软件，使用上有一些限制。所以Linus自己开发了一个静态检查工具。</p>
<blockquote>
<p>版本: linux4.4.166</p>
<p>参考文档:<a href="https://elixir.bootlin.com/linux/v4.4.166/source/Documentation/sparse.txt" target="_blank" rel="noopener">Documentation/sparse.txt</a></p>
</blockquote>
<a id="more"></a>
<p>Sparse通过gcc的扩展属性<code>__attribute__</code>以及自己定义的<code>__context__</code>来对代码进行静态检查。</p>
<blockquote>
<p><code>__xxx</code>双下划线开头的宏,表示编译器相关的一些属性设置</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CHECKER__</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __user     __attribute__((noderef, address_space(1)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __kernel   __attribute__((address_space(0)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __safe     __attribute__((safe))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __force    __attribute__((force))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __nocast   __attribute__((nocast))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __iomem    __attribute__((noderef, address_space(2)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __must_hold(x) __attribute__((context(x,1,1)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __acquires(x)  __attribute__((context(x,0,1)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __releases(x)  __attribute__((context(x,1,0)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __acquire(x)   __context__(x,1)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __release(x)   __context__(x,-1)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __cond_lock(x,c)   ((c) ? (&#123; __acquire(x); 1; &#125;) : 0)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __percpu   __attribute__((noderef, address_space(3)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __pmem     __attribute__((noderef, address_space(5)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSE_RCU_POINTER</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __rcu      __attribute__((noderef, address_space(4)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __rcu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> __chk_user_ptr(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> __user *);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> __chk_io_ptr(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include/linux/compiler.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CHECKER__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bitwise__ __attribute__((bitwise))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bitwise__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CHECK_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bitwise __bitwise__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bitwise</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: tools/include/linux/types.h</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">宏名称</th>
<th style="text-align:center">定义</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">__bitwise</td>
<td style="text-align:center"><code>__attribute__((bitwise))</code></td>
<td style="text-align:center">确保变量是相同的位方式(比如 bit-endian, little-endiandeng)</td>
</tr>
<tr>
<td style="text-align:center">__user</td>
<td style="text-align:center"><code>__attribute__((noderef, address_space(1)))</code></td>
<td style="text-align:center">指针地址必须在用户地址空间</td>
</tr>
<tr>
<td style="text-align:center">__kernel</td>
<td style="text-align:center"><code>__attribute__((noderef, address_space(0)))</code></td>
<td style="text-align:center">指针地址必须在内核地址空间</td>
</tr>
<tr>
<td style="text-align:center">__iomem</td>
<td style="text-align:center"><code>__attribute__((noderef, address_space(2)))</code></td>
<td style="text-align:center">指针地址必须在设备地址空间</td>
</tr>
<tr>
<td style="text-align:center">__safe</td>
<td style="text-align:center"><code>__attribute__((safe))</code></td>
<td style="text-align:center">变量可以为空</td>
</tr>
<tr>
<td style="text-align:center">__force</td>
<td style="text-align:center"><code>__attribute__((force))</code></td>
<td style="text-align:center">变量可以进行强制转换</td>
</tr>
<tr>
<td style="text-align:center">__nocast</td>
<td style="text-align:center"><code>__attribute__((nocast))</code></td>
<td style="text-align:center">参数类型与实际参数类型必须一致</td>
</tr>
<tr>
<td style="text-align:center">__acquires(x)</td>
<td style="text-align:center"><code>__attribute__((context(x, 0, 1)))</code></td>
<td style="text-align:center">参数x 在执行前引用计数必须是0,执行后,引用计数必须为1</td>
</tr>
<tr>
<td style="text-align:center">__releases(x)</td>
<td style="text-align:center"><code>__attribute__((context(x, 1, 0)))</code></td>
<td style="text-align:center">与__acquires(x)相反</td>
</tr>
<tr>
<td style="text-align:center">__acquire(x)</td>
<td style="text-align:center"><code>__context__(x, 1)</code></td>
<td style="text-align:center">参数x的引用计数+1</td>
</tr>
<tr>
<td style="text-align:center">__release(x)</td>
<td style="text-align:center"><code>__context__(x, 1)</code></td>
<td style="text-align:center">与__acquire(x)相反</td>
</tr>
<tr>
<td style="text-align:center">__cond_lock(x,c)</td>
<td style="text-align:center"><code>((c) ? ({ __acquire(x); 1; }) : 0)</code></td>
<td style="text-align:center">参数c 不为0时,引用计数 + 1, 并返回1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其中<code>__acquires(x)</code>和<code>__releases(x)</code>，<code>__acquire(x)</code>和<code>__release(x)</code>必须配对使用,都和<code>锁</code>有关，否则Sparse会发出警告</p>
</blockquote>
<h2 id="Sparse-在编译内核中的使用"><a href="#Sparse-在编译内核中的使用" class="headerlink" title="Sparse 在编译内核中的使用"></a>Sparse 在编译内核中的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make C=1 检查所有重新编译的代码</span><br><span class="line">make C=2 检查所有代码, 不管是不是被重新编译</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果进行<code>-Wbitwise</code>的检查,需要定义<code>#define __CHECK_ENDIAN__</code>,可以通过<code>CF</code>进行传参<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;  make C=2 CF=&quot;-D__CHECK_ENDIAN__&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">fb_open(struct inode *inode, struct file *file)</span><br><span class="line">__acquires(&amp;info-&gt;lock)</span><br><span class="line">__releases(&amp;info-&gt;lock)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译阶段检查锁,防止死锁.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/wang_yb/p/3575039.html" target="_blank" rel="noopener">内核工具 – Sparse 简介</a></li>
<li><a href="https://stackoverflow.com/questions/21018778/what-does-static-int-function-acquires-releases-mean" target="_blank" rel="noopener">what-does-static-int-function-acquires-releases-mean</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程状态-Z:僵尸进程产生的原因</title>
    <url>/post/5718.html</url>
    <content><![CDATA[<p><code>Z (zombie)</code>:僵死状态是一个比较特殊的状态。进程在退出的过程中，处于<code>TASK_DEAD</code>状态。</p>
<blockquote>
<p>在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps</span></span><br><span class="line">  PID USER       VSZ STAT COMMAND</span><br><span class="line">    1 root      3100 S    init</span><br><span class="line">    2 root         0 SW   [kthreadd]</span><br><span class="line">    3 root         0 SW   [ksoftirqd/0]</span><br><span class="line">    4 root         0 SW   [kworker/0:0]</span><br><span class="line">    5 root         0 SW&lt;  [kworker/0:0H]</span><br><span class="line">    6 root         0 SW   [kworker/u8:0]</span><br><span class="line">    ...</span><br><span class="line">    1380 root      0 Z    [view]     #僵尸进程</span><br><span class="line">    ...</span><br><span class="line">    1392 root   3104 S    -/bin/sh</span><br><span class="line">    1404 root      0 SW&lt;  [kworker/2:1H]</span><br><span class="line">    1429 root      0 SW&lt;  [kworker/0:1H]</span><br><span class="line">    1444 root      0 SW&lt;  [kworker/1:1H]</span><br></pre></td></tr></table></figure>
<ul>
<li>僵尸进程产生的原因???</li>
<li>如何确定根本原因???</li>
<li>如何避免???</li>
</ul>
<a id="more"></a>
<h2 id="僵尸进程产生的原因"><a href="#僵尸进程产生的原因" class="headerlink" title="僵尸进程产生的原因"></a>僵尸进程产生的原因</h2><blockquote>
<p><strong>僵尸进程</strong>: 是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源</p>
</blockquote>
<p>原因:</p>
<ol>
<li>子进程被直接杀死</li>
<li>子进程无法正常关闭</li>
</ol>
<p>场景:主进程创建的线程在进行数据搬运时,搬运数据的大小超过了放置数据buffer的大小,导致部分数据被污染,最终导致子线程在运行过程中出现段错误,将其直接杀死,没有等到父进程回收,而产生了僵尸进程.</p>
<h2 id="调试-amp-amp-Debug"><a href="#调试-amp-amp-Debug" class="headerlink" title="调试&amp;&amp;Debug"></a>调试&amp;&amp;Debug</h2><ul>
<li>查找子进程被杀死的原因,如,段错误可以重新定义段错误信号的处理打印部分信息.</li>
<li>排查显示fork和隐式fork,对子进程的操作.</li>
<li>子进程退出信号<code>signal(SIGCHLD,sig_child)</code>的自定义处理</li>
</ul>
<h2 id="设计时的预防"><a href="#设计时的预防" class="headerlink" title="设计时的预防"></a>设计时的预防</h2><ul>
<li><p>父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。</p>
<ul>
<li>执行wait（）或waitpid（）系统调用，则子进程在终止后会立即把它在进程表中的数据返回给父进程，此时系统会立即删除该进入点。在这种情形下就不会产生defunct进程。</li>
</ul>
</li>
<li><p>如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler。在子进程结束后，父进程会收到该信号，可以在handler中调用wait回收。</p>
</li>
<li><p>如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCLD, SIG_IGN）或signal（SIGCHLD, SIG_IGN）通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号</p>
</li>
<li><p>fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做</p>
</li>
</ul>
]]></content>
      <categories>
        <category>进程</category>
        <category>进程状态</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能测试工具---Lmbench</title>
    <url>/post/54953.html</url>
    <content><![CDATA[<p>Lmbench是一套简易，可移植的，符合ANSI/C标准为UNIX/POSIX而制定的微型测评工具。一般来说，它衡量两个关键特征：<code>反应时间</code>和<code>带宽</code>。Lmbench旨在使系统开发者深入了解关键操作的基础成本。</p>
<blockquote>
<p>测试包括文档读写、内存操作、进程创建销毁开销、网络等性能，测试方法简单</p>
<p>Lmbench: <a href="http://www.bitmover.com/lmbench/" target="_blank" rel="noopener">http://www.bitmover.com/lmbench</a></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">带宽测评(<code>bw_*</code>)</th>
<th style="text-align:center">&lt;命令&gt;</th>
<th style="text-align:center">反应时间测评（<code>lat_*</code>）</th>
<th style="text-align:center">&lt;命令&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读取缓存文件</td>
<td style="text-align:center">bw_file_rd</td>
<td style="text-align:center">上下文切换</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">拷贝内存</td>
<td style="text-align:center">bw_mem 1M cp</td>
<td style="text-align:center">网络： 连接的建立，管道，TCP，UDP和RPC hot potato</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">读内存</td>
<td style="text-align:center">bw_mem 1M rd</td>
<td style="text-align:center">文件系统的建立和删除</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">写内存</td>
<td style="text-align:center">bw_mem 1M wr</td>
<td style="text-align:center">进程创建</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">管道</td>
<td style="text-align:center">bw_pipe</td>
<td style="text-align:center">信号处理</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">TCP</td>
<td style="text-align:center">bw_tcp</td>
<td style="text-align:center">上层的系统调用</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">内存读入反应时间</td>
<td style="text-align:center">lat_mem_rd</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>man</code>获取详细信息</p>
</blockquote>
<a id="more"></a>
<p>移植方便可在buildroot配置</p>
<h2 id="mhz"><a href="#mhz" class="headerlink" title="mhz"></a>mhz</h2><p>计算处理时钟</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mhz</span></span><br><span class="line">1290 MHz, 0.7752 nanosec clock</span><br></pre></td></tr></table></figure>
<h2 id="tlb"><a href="#tlb" class="headerlink" title="tlb"></a>tlb</h2><p>获取TLB大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tlb</span></span><br><span class="line">tlb: 10 pages</span><br></pre></td></tr></table></figure>
<h2 id="line"><a href="#line" class="headerlink" title="line"></a>line</h2><p>Cache line大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> line</span></span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><p>测试内存带宽</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> stream</span></span><br><span class="line">STREAM copy latency: 4.98 nanoseconds</span><br><span class="line">STREAM copy bandwidth: 3213.50 MB/sec</span><br><span class="line">STREAM scale latency: 6.71 nanoseconds</span><br><span class="line">STREAM scale bandwidth: 2385.57 MB/sec</span><br><span class="line">STREAM add latency: 10.64 nanoseconds</span><br><span class="line">STREAM add bandwidth: 2256.06 MB/sec</span><br><span class="line">STREAM triad latency: 12.45 nanoseconds</span><br><span class="line">STREAM triad bandwidth: 1927.25 MB/sec</span><br></pre></td></tr></table></figure>
<h2 id="lmdd"><a href="#lmdd" class="headerlink" title="lmdd"></a>lmdd</h2><p>移动io进行性能和调试测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> time lmdd <span class="keyword">if</span>=/dev/urandom of=/tmp/xxx bs=1M count=10</span></span><br><span class="line">10.0000 MB in 1.7651 secs, 5.6653 MB/sec  #速度</span><br><span class="line">real    0m 1.77s</span><br><span class="line">user    0m 0.00s</span><br><span class="line">sys     0m 1.77s</span><br></pre></td></tr></table></figure>
<h2 id="测试示例"><a href="#测试示例" class="headerlink" title="测试示例"></a>测试示例</h2><h3 id="拷贝内存"><a href="#拷贝内存" class="headerlink" title="拷贝内存"></a>拷贝内存</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bw_mem 500M cp</span></span><br><span class="line">500.00 858.05   #500M测试数据，拷贝速度858.05MB/s</span><br></pre></td></tr></table></figure>
<h3 id="内存写入反应时间"><a href="#内存写入反应时间" class="headerlink" title="内存写入反应时间"></a>内存写入反应时间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lat_mem_rd 1M</span></span><br><span class="line">"stride=64     #步长，</span><br><span class="line">0.00049 2.343  #写入大小，反应时间纳秒（ns）</span><br><span class="line">0.00098 2.343</span><br><span class="line">0.00195 2.343</span><br><span class="line">0.00293 2.343</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>lmbench</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统应用层的内存申请--memory</title>
    <url>/post/9412.html</url>
    <content><![CDATA[<p>在linux系统编程中常见的内存申请方式和其特性，<code>malloc</code>，<code>calloc</code>, <code>realloc</code></p>
<a id="more"></a>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num_bytes)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>功能： 分配长度为num_bytes字节的内存块</li>
<li>返回值： 如果分配成功则返回指向被分配内存的指针(此存储区中的<code>初始值不确定</code>)，否则返回空指针NULL。</li>
</ul>
</blockquote>
<p>函数的工作机制</p>
<p>malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。</p>
<p>调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。</p>
<p>Linux Libc6采用的机制是在free的时候试图整合相邻的碎片，使其合并成为一个较大的free空间。</p>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">void *calloc(unsigned n,unsigned size)；</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>功能： 在内存的动态存储区中分配n个长度为size的内存空间，并初始化为<code>0</code></li>
<li>返回值： 函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。</li>
</ul>
</blockquote>
<h3 id="malloc的区别"><a href="#malloc的区别" class="headerlink" title="malloc的区别"></a>malloc的区别</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ansidecl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For systems with larger pointers than ints, this must be declared.  */</span></span><br><span class="line"><span class="function">PTR <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span> <span class="params">(PTR, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">PTR</span><br><span class="line"><span class="built_in">calloc</span> (<span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> elsize)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">register</span> PTR ptr;</span><br><span class="line">  <span class="keyword">if</span> (nelem == <span class="number">0</span> || elsize == <span class="number">0</span>)</span><br><span class="line">    nelem = elsize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  ptr = <span class="built_in">malloc</span> (nelem * elsize);</span><br><span class="line">  <span class="keyword">if</span> (ptr) bzero (ptr, nelem * elsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://code.woboq.org/gcc/libiberty/calloc.c.html" target="_blank" rel="noopener">https://code.woboq.org/gcc/libiberty/calloc.c.html</a></p>
</blockquote>
<p>只多做了初始化清零的操作<code>bzero</code></p>
<h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *mem_address, <span class="keyword">unsigned</span> <span class="keyword">int</span> newsize)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>功能： 先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域，同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。</li>
<li>返回值： 如果重新分配成功则返回指向被分配内存的指针，否则返回空指针NULL</li>
</ul>
</blockquote>
<p><strong>注意</strong>：这里原始内存中的数据还是保持不变的。当内存不再使用时，应使用free()函数将内存块释放。</p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu查询相关库的情况</title>
    <url>/post/31784.html</url>
    <content><![CDATA[<p>查询一个库的<code>位置</code></p>
<a id="more"></a>
<blockquote>
<p><strong>环境</strong>: Ubuntu 18.04.1 LTS</p>
<ul>
<li>测试库名: libmpfr</li>
</ul>
</blockquote>
<h2 id="库的相关描述"><a href="#库的相关描述" class="headerlink" title="库的相关描述"></a>库的相关描述</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$dpkg -l &quot;*库信息*&quot;</span><br></pre></td></tr></table></figure>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$dpkg -l &quot;*libmpfr*&quot;</span><br><span class="line">Desired=Unknown/Install/Remove/Purge/Hold</span><br><span class="line">| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend</span><br><span class="line">|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)</span><br><span class="line">||/ Name                                     Version                   Architecture              Description</span><br><span class="line">+++-========================================-=========================-=========================-======================================================================================</span><br><span class="line">ii  libmpfr6:amd64                           4.0.1-1                   amd64                     multiple precision floating-point computation</span><br></pre></td></tr></table></figure></p>
<h2 id="库的位置"><a href="#库的位置" class="headerlink" title="库的位置"></a>库的位置</h2><p>查询<code>libmpfr</code>的路径</p>
<h3 id="直接查找"><a href="#直接查找" class="headerlink" title="直接查找"></a>直接查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ldconfig -p | grep &quot;库信息&quot;</span><br></pre></td></tr></table></figure>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ldconfig -p | grep &quot;libmpfr&quot;</span><br><span class="line">	libmpfr.so.6 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libmpfr.so.6</span><br></pre></td></tr></table></figure></p>
<h3 id="间接查找"><a href="#间接查找" class="headerlink" title="间接查找"></a>间接查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -L &quot;库名称&quot;</span><br></pre></td></tr></table></figure>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$dpkg -L &quot;libmpfr6:amd64&quot;</span><br><span class="line">/.</span><br><span class="line">/usr</span><br><span class="line">/usr/lib</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmpfr.so.6.0.1</span><br><span class="line">/usr/share</span><br><span class="line">/usr/share/doc</span><br><span class="line">/usr/share/doc/libmpfr6</span><br><span class="line">/usr/share/doc/libmpfr6/AUTHORS</span><br><span class="line">/usr/share/doc/libmpfr6/BUGS</span><br><span class="line">/usr/share/doc/libmpfr6/NEWS.gz</span><br><span class="line">/usr/share/doc/libmpfr6/README</span><br><span class="line">/usr/share/doc/libmpfr6/TODO.gz</span><br><span class="line">/usr/share/doc/libmpfr6/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libmpfr6/copyright</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmpfr.so.6</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title>回顾2018的点滴</title>
    <url>/post/22139.html</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8-aarch64寄存器和指令集</title>
    <url>/post/7190.html</url>
    <content><![CDATA[<p><img src="/images/2019/02/armv8_a.png" alt="armv8-a"></p>
<a id="more"></a>
<h2 id="ARMv8-A处理器属性"><a href="#ARMv8-A处理器属性" class="headerlink" title="ARMv8-A处理器属性"></a>ARMv8-A处理器属性</h2><p><img src="/images/2019/02/armv8_a_properties.png" alt="armv8-a-properties"></p>
<blockquote>
<p>Rockchip RK3399 SoC integrates dual-core <code>Cortex-A72</code> and quad-core <code>Cortex-A53</code> with separate NEON coprocessor, and with ARM Mali-T864 GPU.</p>
</blockquote>
<h2 id="异常等级"><a href="#异常等级" class="headerlink" title="异常等级"></a>异常等级</h2><p>软件运行异常级别：</p>
<ul>
<li><code>EL0</code>： 普通用户应用程序</li>
<li><code>EL1</code>： 操作系统内核通常被描述为特权</li>
<li><code>EL2</code>： 管理程序</li>
<li><code>EL3</code>： 低级固件，包括安全监视器</li>
</ul>
<h2 id="ARMv8寄存器"><a href="#ARMv8寄存器" class="headerlink" title="ARMv8寄存器"></a>ARMv8寄存器</h2><p>AArch拥有<code>31</code>个通用寄存器，系统运行在64位状态下的时候名字叫<code>Xn</code>，运行在32位的时候就叫<code>Wn</code>.</p>
<p><img src="/images/2019/02/armv8_reg.png" alt="armv8-reg"></p>
<blockquote>
<p>32位W寄存器构成相应64位X寄存器的下半部分。 也就是说，W0<br>映射到X0的低位字，W1映射到X1的低位字。</p>
</blockquote>
<h3 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h3><p><img src="/images/2019/02/armv8特殊寄存器.png" alt="armv8特殊寄存器"></p>
<table>
<thead>
<tr>
<th style="text-align:center">Name</th>
<th style="text-align:center">Size</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WZR</td>
<td style="text-align:center">32bits</td>
<td style="text-align:center">Zero register</td>
</tr>
<tr>
<td style="text-align:center">XZR</td>
<td style="text-align:center">64bits</td>
<td style="text-align:center">Zero register</td>
</tr>
<tr>
<td style="text-align:center">WSP</td>
<td style="text-align:center">32bits</td>
<td style="text-align:center">Current stack pointer</td>
</tr>
<tr>
<td style="text-align:center">SP</td>
<td style="text-align:center">64bits</td>
<td style="text-align:center">Current stack pointer</td>
</tr>
<tr>
<td style="text-align:center">pC</td>
<td style="text-align:center">64bits</td>
<td style="text-align:center">Program counter</td>
</tr>
</tbody>
</table>
<h2 id="ARM-64位架构的ABI"><a href="#ARM-64位架构的ABI" class="headerlink" title="ARM 64位架构的ABI"></a>ARM 64位架构的ABI</h2><p>ARM体系结构的应用程序二进制接口（<code>ABI</code>， Application Binary Interface）指定了基本规则所有可执行的本机代码模块必须遵守，以便它们可以正常工作。</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器分为4组：</p>
<p><img src="/images/2019/02/armv8_register.png" alt="armv8-register"></p>
<ul>
<li><p>参数寄存器<code>（X0-X7）</code>： 用作临时寄存器或可以保存的调用者保存的寄存器变量函数内的中间值，调用其他函数之间的值（8个寄存器可用于传递参数）</p>
</li>
<li><p>来电保存的临时寄存器<code>（X9-X15）</code>： 如果调用者要求在任何这些寄存器中保留值调用另一个函数，调用者必须将受影响的寄存器保存在自己的堆栈中帧。 它们可以通过被调用的子程序进行修改，而无需保存并在返回调用者之前恢复它们。</p>
</li>
<li><p>被调用者保存的寄存器<code>（X19-X29）</code>： 这些寄存器保存在被调用者帧中。 它们可以被被调用者修改子程序，只要它们在返回之前保存并恢复。</p>
</li>
<li><p>特殊用途寄存器<code>（X8，X16-X18，X29，X30）</code>：</p>
<ul>
<li><code>X8</code>： 是间接结果寄存器,用于保存子程序返回地址，<code>尽量不使用</code></li>
<li><code>X16</code>和<code>X17</code>： 程序内调用临时寄存器</li>
<li><code>X18</code>： 平台寄存器，保留用于平台ABI，<code>尽量不使用</code></li>
<li><code>X29</code>： 帧指针寄存器（FP）</li>
<li><code>X30</code>： 链接寄存器（LR）</li>
<li><code>X31</code>： 堆栈指针寄存器SP或零寄存器ZXR</li>
</ul>
</li>
</ul>
<h3 id="NEON和浮点寄存器"><a href="#NEON和浮点寄存器" class="headerlink" title="NEON和浮点寄存器"></a>NEON和浮点寄存器</h3><p><img src="/images/2019/02/armv8_simd_reg.png" alt="armv8-simd-reg"></p>
<h2 id="A64指令集"><a href="#A64指令集" class="headerlink" title="A64指令集"></a>A64指令集</h2><h3 id="A64特点"><a href="#A64特点" class="headerlink" title="A64特点"></a>A64特点</h3><ul>
<li>移除了批量加载寄存器指令 LDM/STM, PUSH/POP, 使用STP/LDP 一对加载寄存器指令代替；</li>
<li>没有提供访问CPSR的单一寄存器，但是提供访问PSTATE的状态域寄存器；</li>
<li>A64没有协处理器的概念，没有协处理器指令MCR,MRC；</li>
<li>相比A32少了很多条件执行指令，只有条件跳转和少数数据处理这类指令才有条件执行.附件为条件指令码；</li>
</ul>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Opcode&gt;&#123;&lt;Cond&gt;&#125;&lt;S&gt;  &lt;Rd&gt;, &lt;Rn&gt; &#123;,&lt;Opcode2&gt;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>Opcode</code>：操作码，也就是助记符，说明指令需要执行的操作类型</li>
<li><code>Cond</code>：指令执行条件码，查看附件图；</li>
<li><code>S</code>：条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值</li>
<li><code>Rd/Xt</code>：目标寄存器，A32指令可以选择R0-R14,T32指令大部分只能选择RO-R7，A64指令可以选择X0-X30；</li>
<li><code>Rn/Xn</code>：第一个操作数的寄存器，和Rd一样，不同指令有不同要求；</li>
<li><code>Opcode2</code>：第二个操作数，可以是立即数，寄存器Rm和寄存器移位方式（Rm，#shit）；</li>
</ul>
</blockquote>
<h3 id="内存访问指令"><a href="#内存访问指令" class="headerlink" title="内存访问指令"></a>内存访问指令</h3><ul>
<li>加载指令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR Rt, &lt;addr&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li><code>LDRB</code> (8-bit, zero extended).</li>
<li><code>LDRSB</code> (8-bit, sign extended).</li>
<li><code>LDRH</code> (16-bit, zero extended).</li>
<li><code>LDRSH</code> (16-bit, sign extended).</li>
<li><code>LDRSW</code> (32-bit, sign extended).</li>
</ul>
</blockquote>
<p><img src="/images/2019/02/armv8加载指令的地址偏移.png" alt="armv8加载指令的地址偏移"></p>
<ul>
<li>存储指令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STR Rn, &lt;addr&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="/downloads/arm/DEN0024A_v8_architecture_PG.pdf">Programmer’s Guide for ARMv8-A</a>=</li>
</ul>
]]></content>
      <categories>
        <category>arm</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title> H264码流格式</title>
    <url>/post/35564.html</url>
    <content><![CDATA[<p>H264的两种码流格式，它们分别为：<code>字节流格式</code>和<code>RTP包格式</code>。</p>
<ul>
<li><code>字节流格式</code>: 默认的输出格式。它的基本数据单位为NAL单元，也即NALU。为了从字节流中提取出NALU，协议规定，在每个NALU的前面加上起始码：0x000001或0x00000001（0x代表十六进制）</li>
<li>RTP包格式: 一种数据传输格式,主要用于网络传送</li>
</ul>
<blockquote>
<p>字节流格式,由于它没有经过传输协议封装，所以也可以称之为<code>裸流</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">H264比特流 = Start_Code_Prefix + NALU + Start_Code_Prefix + NALU + ...</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="/images/2019/02/h264_struct.png" alt="H264_struct"></p>
<h2 id="起始码与NALU"><a href="#起始码与NALU" class="headerlink" title="起始码与NALU"></a>起始码与NALU</h2><blockquote>
<p>起始码（Start_Code_Prefix）: <code>0x00 00 01</code>或<code>0x00 00 00 01</code></p>
</blockquote>
<p>在两个起始码之间的数据，称为<code>NALU</code></p>
<h2 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h2><blockquote>
<p>NAL Unit: Network Abstract Layer Unit</p>
</blockquote>
<p>每个NAL单元包括一个原始字节序列负荷(RBSP, Raw Byte Sequence Payload)、一组对应于视频编码的NAL头信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NALU = NALU Header + RBSP</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>SODB</code>:最原始的编码数据，无任何附加数据。<ul>
<li><code>S</code>tring <code>O</code>f <code>D</code>ata <code>B</code>its</li>
</ul>
</li>
<li><code>RBSP</code>:在SODB的基础上增加了rbsp_stop_ont_bit(bit值为1)并用0按字节补位对齐。<ul>
<li>A NALU contains a <code>R</code>aw <code>B</code>yte <code>S</code>equence <code>P</code>ayload, a sequence of bytes containing syntax elements.</li>
</ul>
</li>
<li><code>EBSP</code>:(Encapsulation Byte Sequence Packets)在RBSP的基础上增加了防止伪起始码字节(0x03)。</li>
</ul>
</blockquote>
<h3 id="NALU-Header"><a href="#NALU-Header" class="headerlink" title="NALU Header"></a>NALU Header</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAL Header： forbidden_bit， nal_reference_bit（优先级）， nal_unit_type（类型）</span><br><span class="line">                  1bit            2bit                        5bit</span><br></pre></td></tr></table></figure>
<h2 id="SPS-Seq-Parameter-Set-–-序列参数集"><a href="#SPS-Seq-Parameter-Set-–-序列参数集" class="headerlink" title="SPS(Seq_Parameter_Set) – 序列参数集"></a>SPS(Seq_Parameter_Set) – 序列参数集</h2><blockquote>
<p>H.264码流<code>第一个</code>NALU是<code>SPS</code></p>
</blockquote>
<p>nal_unit_type = 7， 包含H.264的<code>profile_idc</code>和<code>level_idc</code>等信息.还有图像的宽高:<code>pic_width_in_mbs_minus1</code>、<code>pic_height_in_map_units_minus1</code></p>
<p>图像的宽和高，以宏块（16x16）为单位的值减1， 如果<code>pic_width_in_mbs_minus1 = 21</code>， 图像宽为（21+1）* 16 = 352</p>
<p>SPS即Sequence Paramater Set，又称作序列参数集。SPS中保存了一组<code>编码视频序列(Coded video sequence)</code>的全局参数。所谓的编码视频序列即原始视频的一帧一帧的像素数据经过编码之后的结构组成的序列。而每一帧的编码后数据所依赖的参数保存于图像参数集中。</p>
<h2 id="PPS-Pic-Parameter-Set-–-图像参数集"><a href="#PPS-Pic-Parameter-Set-–-图像参数集" class="headerlink" title="PPS(Pic_Parameter_Set) – 图像参数集"></a>PPS(Pic_Parameter_Set) – 图像参数集</h2><blockquote>
<p>H.264码流<code>第二个</code>NALU是<code>PPS</code></p>
</blockquote>
<p>nal_unit_type = 8</p>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>一个视频图像可编码成一个或更多个条带，每个条带包含整数个宏块（MB），即每个条带至少一个MB，最多时每个条带包含整个图像的宏块。总之，一幅图像中每个条带的宏块数不一定固定。设条带的目的是为了限制误码的扩散和传输，应使编码条带相互间是独立的。某个条带的预测不能以其它条带中的宏块为参考图像，这样某一条带中的预测误差才不会传播到其它条带中去。</p>
<h2 id="Tile"><a href="#Tile" class="headerlink" title="Tile"></a>Tile</h2><h2 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h2><p>在视频编码序列中，<code>GOP</code>即Group of picture（图像组），指<code>两个I帧之间的距离</code>，<code>Reference</code>（参考周期）指<code>两个P帧之间的距离</code>。一个I帧所占用的字节数大于一个P帧，一个P帧所占用的字节数大于一个B帧。</p>
<p><img src="/images/2020/12/h264_gop.png" alt="H264_GOP"></p>
<blockquote>
<p>GOP说白了就是两个<code>I帧</code>之间的间隔.比较说GOP为120,如果是720p60的话,那就是2s一次I帧</p>
</blockquote>
<h2 id="视频渐近刷新"><a href="#视频渐近刷新" class="headerlink" title="视频渐近刷新"></a>视频渐近刷新</h2><p>视频渐近刷新<code>GDR</code>(Gradual decoder refresh)是相对一帧完整刷新而来。传统IDR刷新的缺点是IDR帧大小相比图像质量相近的P帧更大，这样会对网络有冲击，导致网络抖动和拥塞。而GDR会带来更优的网络适应性。<br><code>GDR</code>是通过<code>P帧</code>内包括<code>I帧块</code>组的方法来实现渐近刷新。</p>
<p><img src="/images/2020/11/h264_gdr.png" alt="h264 GDR"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/wh8_2011/article/details/51163368" target="_blank" rel="noopener">H.264的Slice及Slice类型</a></li>
<li><a href="https://dev.tencent.com/u/Winddoing/p/blog_docs/git/raw/master/H.264官方中文版.pdf" target="_blank" rel="noopener">H.264官方中文版.pdf</a>–下载</li>
<li><a href="https://www.cnblogs.com/huxiaopeng/p/5653816.html" target="_blank" rel="noopener">TI的H264 SOC方案</a></li>
<li><a href="https://blog.csdn.net/xiaoyida11/article/details/52852398" target="_blank" rel="noopener">H264编码之GOP含义</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>h264</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下GBK文件编码批量转换UTF-8</title>
    <url>/post/38869.html</url>
    <content><![CDATA[<p>Windows默认是<code>GBK</code>编码格式，Linux默认是<code>UTF-8</code>的格式，不同格式之间的乱码处理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">enca -L zh_CN -x UTF-8 *.c</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="enca-–-文件编码"><a href="#enca-–-文件编码" class="headerlink" title="enca – 文件编码"></a>enca – 文件编码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">enca -h</span></span><br><span class="line">Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...</span><br><span class="line">        enconv [-L LANGUAGE] [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>
<p>用法：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> enca -L zh_CN file      检查文件的编码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> enca -L zh_CN -x UTF-8 file 将文件编码转换为<span class="string">"UTF-8"</span>编码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样</span></span><br></pre></td></tr></table></figure></p>
<h2 id="convmv-–-文件名编码"><a href="#convmv-–-文件名编码" class="headerlink" title="convmv – 文件名编码"></a>convmv – 文件名编码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> convmv -f 源编码 -t 新编码 [选项] 文件名</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>-r 递归处理子文件夹</li>
<li>–notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。</li>
<li>–list 显示所有支持的编码</li>
<li>–unescap 可以做一下转义，比如把%20变成空格</li>
</ul>
</blockquote>
<p>示例：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> convmv -f GBK -t UTF-8 --notest utf8 filename</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find default -<span class="built_in">type</span> f -<span class="built_in">exec</span> convmv -f GBK -t UTF-8 --notest utf8 &#123;&#125; -o utf/&#123;&#125; \;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>批量处理</p>
</blockquote>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>ADV7611硬件特性</title>
    <url>/post/29135.html</url>
    <content><![CDATA[<p><img src="/images/2019/03/adv7611_function_diagram.png" alt="adv7611_function_diagram"></p>
<blockquote>
<p>HDMI接收器,用于通过HDMI接口将输入的<code>视频信号</code>转换成<code>YUV</code>或<code>RGB</code>像素数据输出</p>
</blockquote>
<a id="more"></a>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>TMDS时钟频率： 165 MHz(最大值)</li>
<li>24位输出像素总线</li>
<li>可编程HDMI均衡器</li>
<li>HDMI端口支持5 V检测和热插拔<blockquote>
<p>具体见参考文档</p>
</blockquote>
</li>
</ul>
<h2 id="EDID"><a href="#EDID" class="headerlink" title="EDID"></a>EDID</h2><blockquote>
<ul>
<li>在视频模式中，PLCK不能超过165Mhz</li>
<li>EDID扩展的128bit，主要包含音频能力和可支持视频标准的640x480像素的描述信息<ul>
<li>主要目的为HDMI源提供音频能力信息（如声道，采样率等），和所支持的视频标准信息（如色彩空间YCbCr422等）</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="硬件连接逻辑"><a href="#硬件连接逻辑" class="headerlink" title="硬件连接逻辑"></a>硬件连接逻辑</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">|   LCD    |</span><br><span class="line">|  直接显示|</span><br><span class="line">+-^------^-+</span><br><span class="line">  |      |</span><br><span class="line">  | bus  |              +-----------+                +--------+</span><br><span class="line">+-+------+---+   bus    |           |    HDMI线      |        |</span><br><span class="line">| BT1120接口 +&lt;---------+  adv7611  +&lt;---------------+  HDMI  |</span><br><span class="line">+-+------+---+          |           |                |        |</span><br><span class="line">  | bus  |              +-----------+                +--------+</span><br><span class="line">  |      |</span><br><span class="line">+-v------v-+</span><br><span class="line">|  camera  |</span><br><span class="line">| 数据采集 |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CSI: CMOS Sensor Interface</p>
<ul>
<li>adv7611直接输出的是像素信息，<code>VS</code>，<code>HS</code>，<code>data[15~0]</code>，<code>PIXCLK</code></li>
</ul>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.analog.com/cn/products/adv7611.html#product-overview" target="_blank" rel="noopener">ADV7611官网资料</a></li>
<li><a href="https://www.tonylabs.com/downloads/datasheet/analog-devices-adv7611-datasheet" target="_blank" rel="noopener">Analog Devices ADV7611 数据手册</a></li>
<li><a href="https://www.analog.com/media/en/technical-documentation/user-guides/UG-180.pdf" target="_blank" rel="noopener">ADV7611 Reference Manual UG-180</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>HDMI</category>
      </categories>
      <tags>
        <tag>adv7611</tag>
        <tag>hdmi</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM64基本的汇编语法</title>
    <url>/post/5543.html</url>
    <content><![CDATA[<p>记录常用到的arm64汇编语法，参考<a href="https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/simd/arm64/jsimd_neon.S" target="_blank" rel="noopener">libjpeg-turbo</a></p>
<a id="more"></a>
<h2 id="常见语法"><a href="#常见语法" class="headerlink" title="常见语法"></a>常见语法</h2><table>
<thead>
<tr>
<th style="text-align:center">语法</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">备注/示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.req</code></td>
<td style="text-align:left">寄存器重命名</td>
<td style="text-align:left">DATA .req x0： DATA是寄存器x0的别名</td>
</tr>
<tr>
<td style="text-align:center"><code>.unreq</code></td>
<td style="text-align:left">取消重命名定义</td>
<td style="text-align:left">.unreq DATA</td>
</tr>
<tr>
<td style="text-align:center"><code>.balign</code></td>
<td style="text-align:left">字节对其</td>
<td style="text-align:left">.balign 16 ：十六字节对其</td>
</tr>
<tr>
<td style="text-align:center"><code>b</code></td>
<td style="text-align:left">跳转到标号处执行</td>
<td style="text-align:left">b   40 &lt;main+0x40&gt;</td>
</tr>
<tr>
<td style="text-align:center"><code>cmp</code></td>
<td style="text-align:left">比较</td>
<td style="text-align:left">cmp w0, #0x6e， 不会改变两个寄存器的值即两个寄存器不会变化，但是其结果会影响cpsr状态寄存器的标记值（nzcv）</td>
</tr>
<tr>
<td style="text-align:center"><code>b.le</code></td>
<td style="text-align:left">小于等于（less than or equal to），执行标号，否则不跳转</td>
<td style="text-align:left">b.le    24 &lt;main+0x24&gt;</td>
</tr>
<tr>
<td style="text-align:center"><code>b.ge</code></td>
<td style="text-align:left">大于等于（great than or equal to），执行标号，否则不跳转</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>b.gt</code></td>
<td style="text-align:left">大于（greater than），执行标号，否则不跳转</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>b.lt</code></td>
<td style="text-align:left">小于（less than），执行标号，否则不跳转</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>b.eq</code></td>
<td style="text-align:left">等于（equal to），执行标号，否则不跳转</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><code>b.hi</code></td>
<td style="text-align:left">无符号大于，执行标号，否则不跳转</td>
</tr>
</tbody>
</table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://sourceware.org/binutils/docs/as/" target="_blank" rel="noopener">GNU AS汇编器官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>arm</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDMI/DVI接口显示器热插拔原理（HPD）</title>
    <url>/post/57591.html</url>
    <content><![CDATA[<p><img src="/images/2019/03/hdmi_cable_link.png" alt="hdmi_cable_link"></p>
<blockquote>
<p>硬件接口， <code>HDMI(19Pin)/DVI（16 pin）</code>的功能是热插拔检测<code>（HPD）</code>，这个信号将作为主机系统是否对HDMI/DVI是否发送<code>TMDS</code>信号的依据</p>
</blockquote>
<a id="more"></a>
<p><img src="/images/2019/03/hdmi_and_vdi_interface.png" alt="hdmi_and_vdi_interface"></p>
<h2 id="HPD-Hot-Plug-Detection"><a href="#HPD-Hot-Plug-Detection" class="headerlink" title="HPD - (Hot Plug Detection)"></a>HPD - (Hot Plug Detection)</h2><p>HPD是从<code>显示器</code>输出送往<code>计算机主机</code>的一个检测信号.</p>
<p>作用：</p>
<blockquote>
<p>当显示器等数字显示器通过HDMI或DVI接口与计算机主机相连或断开连接时，计算机主机能够通过HDMI/DVI的HPD引脚检测出这一事件，并做出响应</p>
</blockquote>
<h2 id="热插拔时的信号变化"><a href="#热插拔时的信号变化" class="headerlink" title="热插拔时的信号变化"></a>热插拔时的信号变化</h2><ul>
<li>HDMI/DVI接口插入<ul>
<li>HPD: <code>low --&gt; high</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>主机上的显卡检测到HPD引脚被拉高（电压大于2V），主机认为此时显示设备已连接成功。主机中的显卡将发生一个信号，通过DDC读取显示器中的存储的EDID数据，通过读取到的EDID中显示器的工作模式范围与显卡相适应，则显卡将激活TMDS信号进行数据传输。</p>
</blockquote>
<ul>
<li>HDMI/DVI接口拔出<ul>
<li>HPD: <code>high --&gt; low</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>主机上的显卡检测到HPD引脚被拉低（电压小于0.8V），表示显示设备与主机断开连接。此时主机中的显卡也会发一个信号，通知显卡关闭TMDS信号的工作。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.fpga4fun.com/files/HDMI_Demystified_rev_1_02.pdf" target="_blank" rel="noopener">HDMI Demystified</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>hdmi</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Win10中Linux Ubuntu子系统的相关问题</title>
    <url>/post/41029.html</url>
    <content><![CDATA[<p>记录window10中Linux子系统使用的相关问题和常见错误。</p>
<a id="more"></a>
<h2 id="error-0x800703fa"><a href="#error-0x800703fa" class="headerlink" title="error: 0x800703fa"></a>error: 0x800703fa</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Installing, this may take a few minutes...</span><br><span class="line">WslRegisterDistribution failed with error: 0x800703fa</span><br><span class="line">Error: 0x800703fa ???????????????????????</span><br><span class="line"></span><br><span class="line">Press any key to continue...</span><br></pre></td></tr></table></figure>
<ul>
<li>解决方法：<blockquote>
<p>打开服务管理，重启<code>LxssManager</code>服务解决,并将其设置为<code>自动</code><br>路径：开始（右键）-&gt;计算机管理 -&gt; 服务和计算机程序 -&gt; 服务(LxssManager)</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>expect脚本交互操作——FIT升级FAT</title>
    <url>/post/20230.html</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><blockquote>
<p>脚本自动控制通过SSH自动登录到路由器，并执行相关命令进行自动升级</p>
</blockquote>
<p><strong> shell脚本无法完成这种交互，最终选择<code>expect</code>脚本进行操作</strong></p>
<a id="more"></a>
<h2 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h2><p>expect用于自动化地执行linux环境下的命令行交互任务，例如<code>scp</code>、<code>ssh</code>之类需要用户手动输入密码然后确认的任务</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install expect</span><br></pre></td></tr></table></figure>
<blockquote>
<p>操作系统：ubuntu18.04</p>
</blockquote>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>expect的实现核心是<code>spawn</code> <code>expect</code> <code>send</code> <code>set</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">spawn</td>
<td style="text-align:left">调用要执行的命令</td>
</tr>
<tr>
<td style="text-align:center">expect</td>
<td style="text-align:left">等待命令提示信息的出现，也就是捕获用户输入提示</td>
</tr>
<tr>
<td style="text-align:center">send</td>
<td style="text-align:left">发送要交互的值，替代用户手动输入内容</td>
</tr>
<tr>
<td style="text-align:center">set</td>
<td style="text-align:left">设置变量值</td>
</tr>
<tr>
<td style="text-align:center">interact</td>
<td style="text-align:left">执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。</td>
</tr>
<tr>
<td style="text-align:center">expect eof</td>
<td style="text-align:left">这个一定要加，与spawn对应表示捕获终端输出信息终止，类似于if….endif</td>
</tr>
</tbody>
</table>
<p>expect脚本必须以<code>interact</code>或<code>expect eof</code>结束，执行自动化任务通常<code>expect eof</code>就可以</p>
<p><strong>脚本第一行必须是<code>#!/usr/bin/expect</code>，第一行注释也不行，否则执行报错</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set timeout 5  //设置超时时间5秒</span><br><span class="line">set server [lindex $argv 0]  //传入的第一个参数</span><br><span class="line">set user [lindex $argv 1]</span><br><span class="line">set passwd [lindex $argv 2]</span><br><span class="line"></span><br><span class="line">spawn ssh -l $user $server   //执行ssh命令</span><br><span class="line"></span><br><span class="line">//如果匹配到了yes/no就发送yes，接着在匹配password，发送密码</span><br><span class="line">expect &#123;</span><br><span class="line">"*yes/no" &#123; send "yes\r"; exp_continue&#125;</span><br><span class="line">"*password:" &#123; send "$passwd\r" &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect *Last login*</span><br><span class="line"></span><br><span class="line">//执行完成后保持交互状态，把控制权交给控制台，就可以手工操作</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>
<ul>
<li>执行命令的超时时间可以设置<code>set timeout 5</code>,默认的超时时间是<code>10s</code>,如果设置为<code>-1</code>表示永不超时</li>
</ul>
<h2 id="示例–FIT升级FAT"><a href="#示例–FIT升级FAT" class="headerlink" title="示例–FIT升级FAT"></a>示例–FIT升级FAT</h2><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">netstat=$(ping -c1 169.254.1.1 |grep transmitted |awk '&#123;print $4&#125;')</span><br><span class="line">if [ "$netstat" -eq "0" ]; then</span><br><span class="line">    echo "      ***********************************"</span><br><span class="line">    echo "      * Network connection disconnected *"</span><br><span class="line">    echo "      ***********************************"</span><br><span class="line">    echo "Configuring a local network, IP: 169.254.1.100"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">ssh-keygen -f "$home/.ssh/known_hosts" -R "169.254.1.1"</span><br><span class="line"></span><br><span class="line">cat &gt; update.exp &lt;&lt; EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect -f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> timeout 10</span></span><br><span class="line">spawn ssh admin@169.254.1.1</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">	"*yes/no" &#123;</span><br><span class="line">		send "yes\r";</span><br><span class="line">		exp_continue</span><br><span class="line">	&#125;</span><br><span class="line">	"*password:" &#123;</span><br><span class="line">		send "admin@huawei.com\r"</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">   "&lt;Huawei&gt;" &#123;</span><br><span class="line">       send "system-view\r"</span><br><span class="line">       send "ap-mode-switch prepare\r"</span><br><span class="line">       send "ap-mode-switch check\r"</span><br><span class="line">       set timeout -1</span><br><span class="line">       send "ap-mode-switch tftp FatAP3010DN-V2_V200R008C10SPC500.bin 169.254.1.100\r"</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">   "Y/N" &#123;</span><br><span class="line">       set timeout 10</span><br><span class="line">       send "Y\r\n"</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod a+x update.exp</span><br><span class="line">./update.exp</span><br><span class="line">rm ./update.exp</span><br><span class="line"></span><br><span class="line">netstat=$(ping -c3 169.254.1.1 |grep transmitted |awk '&#123;print $4&#125;')</span><br><span class="line">while [ "$netstat" -ne "0" ]</span><br><span class="line">do</span><br><span class="line">    echo -n "#"</span><br><span class="line">    netstat=$(ping -c3 169.254.1.1 |grep transmitted |awk '&#123;print $4&#125;')</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "Firmware upgrade succeeded"</span><br><span class="line"></span><br><span class="line">echo ""</span><br><span class="line">echo "Device restart ..."</span><br><span class="line"></span><br><span class="line">netstat=$(ping -c3 169.254.1.1 |grep transmitted |awk '&#123;print $4&#125;')</span><br><span class="line">while [ "$netstat" -eq "0" ]</span><br><span class="line">do</span><br><span class="line">    echo -n "*"</span><br><span class="line">    netstat=$(ping -c3 169.254.1.1 |grep transmitted |awk '&#123;print $4&#125;')</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "Device restart succeeded"</span><br><span class="line">echo "over"</span><br><span class="line">echo "over"</span><br></pre></td></tr></table></figure>
<h3 id="expect脚本"><a href="#expect脚本" class="headerlink" title="expect脚本"></a>expect脚本</h3><ul>
<li>处理的交互流程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ssh admin@169.254.1.1</span><br><span class="line">The authenticity of host &apos;169.254.1.1 (169.254.1.1)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:ANKtrCYlGExlxhtgCoD1ZiOxflXyEsyvswS4fC5nzc8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &apos;169.254.1.1&apos; (RSA) to the list of known hosts.</span><br><span class="line">admin@169.254.1.1&apos;s password:</span><br><span class="line"></span><br><span class="line">Info: Current mode: Fit (managed by the AC).</span><br><span class="line">Info: You are advised to change the password to ensure security.</span><br><span class="line">&lt;Huawei&gt;system-view</span><br><span class="line">Enter system view, return user view with Ctrl+Z.</span><br><span class="line">[Huawei]ap-mode-switch prepare</span><br><span class="line">Info: Prepare is ok, Use ap-mode-switch command to switch to fat ap.</span><br><span class="line"></span><br><span class="line">[Huawei]ap-mode-switch check</span><br><span class="line">Info: Ap-mode-switch check ok.</span><br><span class="line"></span><br><span class="line">[Huawei]ap-mode-switch tftp FatAP3010DN-V2_V200R008C10SPC500.bin 169.254.1.100</span><br><span class="line">Info: Preparing to upgrade. Please wait a moment .............</span><br><span class="line">Warning: Do Not Power-off!</span><br><span class="line">......................................................................................................................................................................................................................................................................................................................</span><br><span class="line">Info: Upgrade upgrade-assistant-package succeeded.</span><br><span class="line"></span><br><span class="line">Warning: System will reboot, if you want to switch to upgrade-assistant-package.</span><br><span class="line">Are you sure to execute these operations ? [Y/N]:Y</span><br><span class="line">Info: system is rebooting ,please wait...</span><br></pre></td></tr></table></figure>
<ul>
<li>实现：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect -f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> timeout 10</span></span><br><span class="line">spawn ssh admin@169.254.1.1</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">    "*yes/no" &#123;</span><br><span class="line">		send "yes\r";</span><br><span class="line">		exp_continue</span><br><span class="line">	&#125;</span><br><span class="line">    "*password:" &#123;</span><br><span class="line">		send "admin@huawei.com\r"</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">   "&lt;Huawei&gt;" &#123;</span><br><span class="line">       send "system-view\r"</span><br><span class="line">       send "ap-mode-switch prepare\r"</span><br><span class="line">       send "ap-mode-switch check\r"</span><br><span class="line">       set timeout -1</span><br><span class="line">       send "ap-mode-switch tftp FatAP3010DN-V2_V200R008C10SPC500.bin 169.254.1.100\r"</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">   "Y/N" &#123;</span><br><span class="line">       set timeout 10</span><br><span class="line">       send "Y\r\n"</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/lixigang/articles/4849527.html" target="_blank" rel="noopener">Shell脚本学习之expect命令</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>expect</tag>
        <tag>ap</tag>
      </tags>
  </entry>
  <entry>
    <title>X86平台下的SIMD运算</title>
    <url>/post/50180.html</url>
    <content><![CDATA[<blockquote>
<p><code>SSE</code>的全称是 Sreaming SIMD Extensions， 它是一组Intel CPU指令，用于像信号处理、科学计算或者3D图形计算一样的应用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;mmintrin.h&gt;    //MMX  64bits</span><br><span class="line">#include &lt;xmmintrin.h&gt;   //SSE  128bits</span><br><span class="line">#include &lt;emmintrin.h&gt;   //SSE2</span><br><span class="line">#include &lt;immintrin.h&gt;   //AVX  256bits</span><br></pre></td></tr></table></figure>
<ul>
<li><code>immintrin.h</code>: (Intel(R) AVX compiler intrinsics  256bit)</li>
<li><code>emmintrin.h</code>: Principal header file for Intel(R) Pentium(R) 4 processor SSE2 intrinsics</li>
</ul>
<a id="more"></a>
<h2 id="XMM、SSE、AVX关系？？"><a href="#XMM、SSE、AVX关系？？" class="headerlink" title="XMM、SSE、AVX关系？？"></a>XMM、SSE、AVX关系？？</h2><ul>
<li><code>MMX</code>是由英特尔开发的一种SIMD多媒体指令集，共有57条指令。</li>
<li><code>SSE</code>(Sreaming SIMD Extensions)是继MMX的扩充指令集。SSE 指令集提供了 70 条新指令。</li>
<li><code>AVX</code>(Advanced Vector Extensions) 是Intel的SSE延伸架构，如IA16至IA32般的把暂存器XMM 128bit提升至YMM 256bit，以增加一倍的运算效率。</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__m64</code></td>
<td style="text-align:center">64位紧缩整数（MMX）</td>
<td style="text-align:center">一个MMX寄存器,表示封装了8个8bit,4个16bit,2个32bit,1个64bit的整数</td>
</tr>
<tr>
<td style="text-align:center"><code>__m128</code></td>
<td style="text-align:center">128位紧缩单精度（SSE）</td>
<td style="text-align:center">封装4个32bit的单精度浮点数</td>
</tr>
<tr>
<td style="text-align:center"><code>__m128d</code></td>
<td style="text-align:center">128位紧缩双精度（SSE2）</td>
<td style="text-align:center">封装2个64bit的双精度浮点数</td>
</tr>
<tr>
<td style="text-align:center"><code>__m128i</code></td>
<td style="text-align:center">128位紧缩整数（SSE2）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>__m256</code></td>
<td style="text-align:center">256位紧缩单精度（AVX）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>__m256d</code></td>
<td style="text-align:center">256位紧缩双精度（AVX）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>__m256i</code></td>
<td style="text-align:center">256位紧缩整数（AVX）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注</strong>： 紧缩整数包括了8位、16位、32位、64位的带符号和无符号整数。</p>
</blockquote>
<h2 id="SSE指令集"><a href="#SSE指令集" class="headerlink" title="SSE指令集"></a>SSE指令集</h2><ul>
<li>数据传输：<a href="http://www.tommesani.com/index.php/component/content/article/2-simd/59-sse-data-movement.html" target="_blank" rel="noopener">Data movement instructions</a></li>
<li>算术运算：<a href="http://tommesani.com/index.php/component/content/article/2-simd/46-sse-arithmetic.html" target="_blank" rel="noopener">Arithmetic instructions</a></li>
<li>倒数运算：<a href="http://www.tommesani.com/index.php/component/content/article/2-simd/61-sse-reciprocal.html" target="_blank" rel="noopener">Reciprocal instructions</a></li>
<li>比较运算：<a href="http://www.tommesani.com/index.php/component/content/article/2-simd/57-sse-comparison.html" target="_blank" rel="noopener">Comparison instructions</a></li>
<li>数据转换：<a href="http://www.tommesani.com/index.php/component/content/article/2-simd/58-sse-conversion.html" target="_blank" rel="noopener">Conversion instructions</a></li>
<li>逻辑运算：<a href="http://www.tommesani.com/index.php/component/content/article/2-simd/60-sse-logical.html" target="_blank" rel="noopener">Logical instructions</a></li>
<li>整数运算：<a href="http://tommesani.com/index.php/component/content/article/2-simd/36-sse-primer.html" target="_blank" rel="noopener">Additional SIMD integer instructions (SSE Primer)</a></li>
<li>字节乱排：<a href="http://www.tommesani.com/index.php/component/content/article/2-simd/62-sse-shuffle.html" target="_blank" rel="noopener">Shuffle instructions</a></li>
<li>状态管理：<a href="http://www.tommesani.com/index.php/component/content/article/2-simd/63-sse-state-management.html" target="_blank" rel="noopener">State Management instructions</a></li>
<li>缓存控制：<a href="http://www.tommesani.com/index.php/component/content/article/2-simd/56-sse-cacheability-control.html" target="_blank" rel="noopener">Cacheability Control instructions</a></li>
</ul>
<h2 id="指令函数"><a href="#指令函数" class="headerlink" title="指令函数"></a>指令函数</h2><blockquote>
<p><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#" target="_blank" rel="noopener">Intel intrinsic</a></p>
</blockquote>
<h2 id="操作码汇总表中的指令列"><a href="#操作码汇总表中的指令列" class="headerlink" title="操作码汇总表中的指令列"></a>操作码汇总表中的指令列</h2><ul>
<li><strong>mm</strong> — An MMX register. The 64-bit MMX registers are: MM0 through MM7.</li>
<li><strong>xmm</strong> — An XMM register. The 128-bit XMM registers are: XMM0 through XMM7; XMM8 through XMM15 are<br>available using REX.R in 64-bit mode.</li>
<li><strong>ymm</strong> — A YMM register. The 256-bit YMM registers are: YMM0 through YMM7; YMM8 through YMM15 are<br>available in 64-bit mode.</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/fengbingchun/article/details/18460199" target="_blank" rel="noopener">SSE2 Intrinsics各函数介绍</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-gccsimd" target="_blank" rel="noopener">GCC中SIMD指令的应用方法</a></li>
<li><a href="https://blog.csdn.net/u014713819/article/details/38433879" target="_blank" rel="noopener">mmintrin.h与MMX指令集 Intrinsics函数</a></li>
<li><a href="https://blog.csdn.net/tercel_zhang/article/details/80694573" target="_blank" rel="noopener">SIMD指令初学</a></li>
<li><a href="https://www.cnblogs.com/wangguchangqing/p/5466301.html" target="_blank" rel="noopener">SSE指令集学习：Compiler Intrinsic</a></li>
<li><a href="https://www.pediy.com/kssd/pediy10/78121.html" target="_blank" rel="noopener">深入浅出指令编码之四：指令核心</a></li>
<li><a href="https://www.cri.ensmp.fr/classement/doc/E-272.pdf" target="_blank" rel="noopener">An evaluation of the automatic generation of parallel X86 SIMD</a></li>
<li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf" target="_blank" rel="noopener">Intel® 64 and IA-32 ArchitecturesSoftware Developer’s Manual</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>性能</category>
      </categories>
      <tags>
        <tag>simd</tag>
      </tags>
  </entry>
  <entry>
    <title>[译]MCS locks and qspinlocks</title>
    <url>/post/12400.html</url>
    <content><![CDATA[<p>原文： <a href="https://lwn.net/Articles/590243/" target="_blank" rel="noopener">https://lwn.net/Articles/590243/</a></p>
<p>从概念上讲，自旋锁是一种简单的机制。 锁可以小到一位; 如果该位清零，则锁定可用。 想要获取锁的线程将尝试使用<code>原子比较交换指令</code>(atomic compare-and-swap instruction)设置该位，如果当时锁不可用则反复“旋转”。 多年来，自旋锁变得更加复杂; 排队自旋锁（<a href="https://lwn.net/Articles/267968/" target="_blank" rel="noopener">Ticket spinlocks</a>）在2008年增加了对该机制的公平性，并且2013年增加了更好的半虚拟化支持。</p>
<a id="more"></a>
<p>尽管每次尝试获取锁定都需要将包含该锁定的高速缓存行移动到本地CPU，但自旋锁仍然存在一个根本问题，除了简单的旋转锁定是痛苦的。 对于竞争锁，此<code>缓存弹跳</code>(cache-line bouncing)可能会显着损害性能。 因此，开发人员一直在努力减少自旋锁的缓存争用并不奇怪; 例如，尝试在2013年初为自旋锁添加自动退避(<a href="https://lwn.net/Articles/531254/" target="_blank" rel="noopener">an attempt to add automatic backoff</a>)是为了实现这一目标，但这项工作从未合并过。</p>
<h2 id="MCS-locks"><a href="#MCS-locks" class="headerlink" title="MCS locks"></a>MCS locks</h2><p>最近，Tim Chen根据一个名为“MCS锁”的原语组合了一种不同的方法。 通过将自旋锁扩展为每个CPU结构，MCS锁可以消除更简单锁所经历的大部分缓存弹跳，尤其是在竞争情况下。</p>
<p>MCS锁定由此结构的实例定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct mcs_spinlock &#123;</span><br><span class="line">  struct mcs_spinlock *next;</span><br><span class="line">	int locked; /* 1 if lock acquired */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/2019/04/msc_lock_struct.png" alt="msc_lock_struct"></p>
<p>当CPU出现获取此锁的愿望时，它将提供自己的<code>mcs_spinlock</code>结构。 使用无条件原子交换操作，它将自己的结构的地址存储在锁的<code>next</code>字段中，并将<code>locked</code>置为1，标记为以拿到，产生如下情况：<br><img src="/images/2019/04/msc_lock_taken.png" alt="msc_lock_taken"></p>
<p>原子交换将返回<code>next</code>指针的前面值。 由于该指针为空，因此获取CPU知道它已成功获取锁。 一旦完成，锁将是忙，但没有争用。 如果第二个CPU出现并尝试获取锁，它将以相同的方式启动，在主锁的<code>next</code>指针中存储指向其<code>mcs_spinlock</code>结构的指针：<br><img src="/images/2019/04/msc_lock_2.png" alt="msc_lock_2"></p>
<p>当第二个CPU在主锁上执行此原子交换时，它也将返回<code>next</code>字段的先前值(指向第一个CPU的mcs_spinlock结构的指针)。非NULL值则告诉第二个CPU锁是不可用，而特定指针的值表示谁在锁的前面。 第二个CPU将通过在CPU1的结构的<code>next</code>字段中存储指向其mcs_spinlock结构的指针来响应这种情况：<br><img src="/images/2019/04/msc_lock_3.png" alt="msc_lock_3"></p>
<p>请注意，在主锁上使用原子交换操作意味着只有CPU2可以具有指向CPU1的mcs_spinlock结构的指针。因此，在对该结构进行更改时不需要原子操作，但仍需要进行一些仔细的编程，以确保在正确的时间CPU1可以看到更改。</p>
<p>完成此分配后，CPU2将在其自己的mcs_spinlock结构中旋转锁定值，而不是主锁中的值。因此，它的旋转完全是CPU本地的，根本不会触及主锁。 随着对锁的争用增加，这个过程可以无限期地继续进行，每个CPU将自己置于已经存在的那些后面，并且每个CPU在其自己的锁副本上旋转。 因此，“主”锁中的指针始终指示等待CPU队列的尾部。</p>
<p>当CPU 1最终完成锁定时，它将对主锁执行比较和交换操作，尝试将下一个指针设置为NULL，假设此指针仍指向其自己的结构。 如果该操作成功，则永远不会争用锁定并完成作业。但是，如果某个其他CPU已经更改了该指针，如上所示，则compare-and-swap将失败。 在这种情况下，CPU1根本不会改变主锁; 相反，它将更改CPU2结构中的锁定值并从以下情况中移除自身：<br><img src="/images/2019/04/msc_lock_4.png" alt="msc_lock_4"></p>
<p>一旦锁的副本被更改，CPU2将脱离其旋转并成为锁的新所有者。</p>
<p>因此，MCS锁比常规自旋锁稍微复杂一些。但是，增加的复杂性消除了许多缓存行从竞争情况中反弹; 它也完全公平，按照CPU到达的顺序将锁传递给每个CPU。</p>
<h2 id="Qspinlocks"><a href="#Qspinlocks" class="headerlink" title="Qspinlocks"></a>Qspinlocks</h2><p>MCS锁用于实现互斥锁，但它们不会替换现有的排队自旋锁（ticket spinlocks）实现。 其中一个原因是占用内存大小：排队自旋锁适合单个32位字，而MCS锁不适合。 事实证明这很重要：自旋锁被嵌入到许多内核结构中，其中一些（特别是结构页面）不能容忍大小的增加。 如果要在整个内核中使用MCS锁定技术，则需要一些其他方法。</p>
<p>可能合并的那种方法的版本可以在Peter Zijlstra的<a href="https://lwn.net/Articles/590189/" target="_blank" rel="noopener">“qspinlock”补丁</a>系列中看到，而后者则基于Waiman Long的<a href="https://lwn.net/Articles/588426/" target="_blank" rel="noopener">实施</a>。 在此补丁集中，每个CPU在众所周知的位置获取四个<code>mcs_spinlock</code>结构的数组。 需要四种结构，因为CPU可能一次尝试获取多个自旋锁：想象如果在线程在锁上旋转时硬件中断进入会发生什么，并且中断处理程序试图锁定它自己的锁 ， 例如。 结构数组允许来自正常，软件中断，硬件中断和不可屏蔽中断上下文的锁定获取尝试保持分开。</p>
<p>32位<code>qspinlock</code>字段：</p>
<ul>
<li>函数的整数计数器，如上所述的<code>locked</code>字段</li>
<li>一个两位<code>index</code>字段，表示每个CPU<code>mcs_spinlock</code>数组中的哪个条目由列表尾部被使用</li>
<li>一个<code>pending</code>位</li>
<li>一个整数字段，用于保存指示队列尾部的CPU编号</li>
</ul>
<p>一个与每个CPU用于自转的值有关。 当下一个CPU获得锁时，它将自动上锁，而不是在每个CPU结构上自旋。 这样，当释放锁时，不需要操作每CPU结构的高速缓存行，从<del>等式</del>中移除一个高速缓存行未命中。 任何后续的CPU都会在它们自己的结构上自旋，直到它们到达队列的头部。</p>
<p><code>pending</code>位将该策略进一步扩展。如果CPU发现锁正忙但没有其他CPU正在等待，它将简单地设置挂起位而不打扰其自己的mcs_spinlock结构。第二个出现的CPU将看到挂起的位，开始构建队列的过程，并像往常一样旋转其锁定字段的本地副本。 服务员之间的缓存行反弹仍然被消除，但第一个服务员也能够避免与访问其自己的mcs_spinlock数组相关的缓存未命中代价。</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><ul>
<li><a href="/downloads/kernel/spinlock/mcs.pdf">spin lock(Ticket lock: A fair lock)</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
        <category>同步</category>
      </categories>
      <tags>
        <tag>spinlock</tag>
      </tags>
  </entry>
  <entry>
    <title>AVX VMOVDQA slower than two SSE MOVDQA?</title>
    <url>/post/40199.html</url>
    <content><![CDATA[<blockquote>
<p>转载于： <a href="https://stackoverflow.com/questions/13975546/avx-vmovdqa-slower-than-two-sse-movdqa" target="_blank" rel="noopener">https://stackoverflow.com/questions/13975546/avx-vmovdqa-slower-than-two-sse-movdqa</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>While I was working on my fast ADD loop (Speed up x64 assembler ADD loop), I was testing memory access with SSE and AVX instructions. To add I have to read two inputs and produce one output. So I wrote a dummy routine that reads two x64 values into registers and write one back to memory without doing any operation. This is of course useless, I only did it for benchmarking.</p>
<p>当我正在进行快速ADD循环（加速x64汇编ADD循环）时，我使用SSE和AVX指令测试内存访问。我必须读取两个输入并产生一个输出。 所以我编写了一个虚拟例程，它将两个x64值读入寄存器，然后将其写回存储器而不进行任何操作。 这当然没用，我只做了基准测试。</p>
<p>I use an unrolled loop that handles 64 bytes per loop. It is comprised of 8 blocks like this:</p>
<p>我使用一个展开的循环，每个循环处理64个字节。 它由8个块组成，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov rax, QWORD PTR [rdx+r11*8-64]</span><br><span class="line">mov r10, QWORD PTR [r8+r11*8-64]</span><br><span class="line">mov QWORD PTR [rcx+r11*8-64], rax</span><br></pre></td></tr></table></figure>
<p>Then I upgraded it to SSE2. Now I use 4 blocks like this:</p>
<p>然后我将其升级到SSE2。 现在我使用4个这样的块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movdqa xmm0, XMMWORD PTR [rdx+r11*8-64]</span><br><span class="line">movdqa xmm1, XMMWORD PTR [r8+r11*8-64]</span><br><span class="line">movdqa XMMWORD PTR [rcx+r11*8-64], xmm0</span><br></pre></td></tr></table></figure>
<p>And later on I used AVX (256 bit per register). I have 2 blocks like this:</p>
<p>后来我使用了AVX（每个寄存器256位）。 我有2个这样的块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vmovdqa ymm0, YMMWORD PTR [rdx+r11*8-64]</span><br><span class="line">vmovdqa ymm1, YMMWORD PTR [r8+r11*8-64]</span><br><span class="line">vmovdqa YMMWORD PTR [rcx+r11*8-64], ymm0</span><br></pre></td></tr></table></figure>
<p>So far, so not-so-extremely-spectacular. What is interesting is the benchmarking result: When I run the three different approaches on 1k+1k=1k 64-bit words (i.e. two times 8 kb of input and one time 8kb of output) I get strange results. Each of the following timings is for processing two times 64 bytes input into 64 bytes of output.</p>
<p>到目前为止，还不那么引人注目。 有趣的是基准测试结果：当我在1k + 1k = 1k 64位字（即两次8kb输入和一次8kb输出）上运行三种不同方法时，我得到奇怪的结果。 以下每个时序用于处理两次64字节输入到64字节输出。</p>
<ul>
<li>The x64 register method runs at about 15 cycles/64 bytes</li>
<li>x64寄存器方法以大约15个周期/ 64个字节运行</li>
<li>The SSE2 method runs at about 8.5 cycles/64 bytes</li>
<li>SSE2方法以大约8.5个周期/ 64个字节运行</li>
<li>The AVX method runs at about 9 cycles/64 bytes</li>
<li>AVX方法以大约9个周期/ 64个字节运行</li>
</ul>
<p>My question is: how come the AVX method is slower (though not a lot) than the SSE2 method? I expected it to be at least on par. Does using the YMM registers cost so much extra time? The memory was aligned (you get GPF’s otherwise).</p>
<p>我的问题是：为什么AVX方法比SSE2方法慢（虽然不是很多）？ 我预计它至少会与之相提并论。 使用YMM寄存器会花费多少额外的时间吗？ 内存已对齐（否则会获得GPF）。</p>
<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><p>On Sandybridge/Ivybridge, 256b AVX loads and stores are cracked into two 128b ops [as Peter Cordes notes, these aren’t quite µops, but it requires two cycles for the operation to clear the port] in the load/store execution units, so there’s no reason to expect the version using those instructions to be much faster.</p>
<p>在Sandybridge / Ivybridge上，256b AVX加载和存储被破解为两个128b操作[正如Peter Cordes所说，这些不是很好，但在加载/存储执行单元中需要两个周期来清除端口]， 因此没有理由期望使用这些指令的版本更快</p>
<p>Why is it slower? Two possibilities come to mind:</p>
<p>它为什么慢？ 我想到了两种可能性：</p>
<ul>
<li><p>for base + index + offset addressing, the latency of a 128b load is 6 cycles, whereas the latency of a 256b load is 7 cycles (Table 2-8 in the Intel Optimization Manual). Although your benchmark should be bound by thoughput and not latency, the longer latency means that the processor takes longer to recover from any hiccups (pipeline bubbles or prediction misses or interrupt servicing or …), which does have some impact.</p>
</li>
<li><p>对于基数+索引+偏移量寻址，128b负载的延迟为6个周期，而256b负载的延迟为7个周期（英特尔优化手册中的表2-8）。 尽管您的基准测试应该受到吞吐量而非延迟的限制，但延迟时间越长意味着处理器需要更长时间才能从任何暂停（流水线气泡或预测未命中或服务中断或……）中恢复，这确实会产生一些影响。</p>
</li>
<li><p>in 11.6.2 of the same document, Intel suggests that the penalty for cache line and page crossing may be larger for 256b loads than it is for 128b loads. If your loads are not all 32-byte aligned, this may also explain the slowdown you are seeing when using the 256b load/store operations:</p>
</li>
<li><p>在同一文档的11.6.2中，英特尔提示对256b的加载可能比128b的加载在缓存行和页面交叉方面更不利。 如果您的加载不是全部32字节对齐，这也可以解释您在使用256b加载/存储操作时看到的速度减慢：</p>
</li>
</ul>
<blockquote>
<p>Example 11-12 shows two implementations for SAXPY with unaligned addresses. Alternative 1 uses 32 byte loads and alternative 2 uses 16 byte loads. These code samples are executed with two source buffers, src1, src2, at 4 byte offset from 32- Byte alignment, and a destination buffer, DST, that is 32-Byte aligned. Using two 16- byte memory operations in lieu of 32-byte memory access performs faster.</p>
</blockquote>
<blockquote>
<p>例11-12显示了具有未对齐地址的SAXPY的两种实现。 备选1使用32字节加载，备选2使用16字节加载。 这些代码示例使用两个源缓冲区src1，src2执行，以32字节对齐的4字节偏移量和32字节对齐的目标缓冲区DST执行。 使用两个16字节内存操作代替32字节内存访问执行速度更快。</p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>性能</category>
      </categories>
      <tags>
        <tag>simd</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake</title>
    <url>/post/24934.html</url>
    <content><![CDATA[<p><code>cmake</code>使用技巧记录</p>
<a id="more"></a>
<h2 id="显示编译详细信息"><a href="#显示编译详细信息" class="headerlink" title="显示编译详细信息"></a>显示编译详细信息</h2><p>打印make进行编译过程中详细的gcc/g++参数信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make VERBOSE=1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在CMakeLists.txt中配置<code>set(CMAKE_VERBOSE_MAKEFILE ON)</code></p>
</blockquote>
<h2 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h2><ul>
<li>使用set命令，修改CMake文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用环境变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir Debug</span><br><span class="line">cd Debug</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br></pre></td></tr></table></figure>
<h2 id="常见常量"><a href="#常见常量" class="headerlink" title="常见常量"></a>常见常量</h2><h3 id="PROJECT-SOURCE-DIR与CMAKE-SOURCE-DIR"><a href="#PROJECT-SOURCE-DIR与CMAKE-SOURCE-DIR" class="headerlink" title="PROJECT_SOURCE_DIR与CMAKE_SOURCE_DIR"></a>PROJECT_SOURCE_DIR与CMAKE_SOURCE_DIR</h3><ul>
<li>这两个变量所指的路径是一样的，编译时的顶层路径</li>
<li>CMAKE_SOURCE_DIR确实引用了定义顶级CMakeLists.txt的文件夹。 但是，PROJECT_SOURCE_DIR引用包含最新<code>project()</code>命令的CMakeLists.txt文件夹。</li>
<li>CMAKE_SOURCE_DIR: 真对于“主”目录</li>
<li>PROJECT_SOURCE_DIR： 针对于“子”目录</li>
<li><a href="https://stackoverflow.com/questions/32028667/are-cmake-source-dir-and-project-source-dir-the-same-in-cmake#:~:text=CMAKE_SOURCE_DIR%20does%20indeed%20refer%20to%20the%20folder%20where,a%20subdirectory%20with%20its%20own%20project%20called%20Inner." target="_blank" rel="noopener">Are CMAKE_SOURCE_DIR and PROJECT_SOURCE_DIR the same in CMake?</a></li>
</ul>
<h3 id="PROJECT-BINARY-DIR与PROJECT-SOURCE-DIR"><a href="#PROJECT-BINARY-DIR与PROJECT-SOURCE-DIR" class="headerlink" title="PROJECT_BINARY_DIR与PROJECT_SOURCE_DIR"></a>PROJECT_BINARY_DIR与PROJECT_SOURCE_DIR</h3><ul>
<li>这两个变量所指路径也是一样的，都表示编译时生成的结果和中间文件存放位置</li>
<li>与上面类似</li>
</ul>
<h2 id="生成编译命令文件-compile-commands-json"><a href="#生成编译命令文件-compile-commands-json" class="headerlink" title="生成编译命令文件 - compile_commands.json"></a>生成编译命令文件 - compile_commands.json</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</span><br></pre></td></tr></table></figure></p>
<p>将在编译目录下生成<code>compile_commands.json</code>文件</p>
<h2 id="添加版本及git信息"><a href="#添加版本及git信息" class="headerlink" title="添加版本及git信息"></a>添加版本及git信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execute_process(</span><br><span class="line">    COMMAND git rev-parse --short HEAD</span><br><span class="line">    OUTPUT_VARIABLE COMMIT_HASH</span><br><span class="line">    OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">    ERROR_QUIET</span><br><span class="line">    WORKING_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">)</span><br><span class="line">add_definitions( -DCOMMIT_HASH=\&quot;$&#123;COMMIT_HASH&#125;\&quot;)</span><br><span class="line"></span><br><span class="line">execute_process(</span><br><span class="line">    COMMAND git symbolic-ref --short -q HEAD</span><br><span class="line">    OUTPUT_VARIABLE BRANCH_NAME</span><br><span class="line">    OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">    ERROR_QUIET</span><br><span class="line">    WORKING_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">)</span><br><span class="line">add_definitions( -DBRANCH_NAME=\&quot;$&#123;BRANCH_NAME&#125;\&quot;)</span><br><span class="line"></span><br><span class="line"># 当前编译时间</span><br><span class="line">string(TIMESTAMP COMPILE_TIME %Y%m%d_%H%M%S)</span><br></pre></td></tr></table></figure>
<h2 id="引入外部项目"><a href="#引入外部项目" class="headerlink" title="引入外部项目"></a>引入外部项目</h2><h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_subdirectory(xxx)</span><br></pre></td></tr></table></figure>
<h3 id="编译时下载项目并引入"><a href="#编译时下载项目并引入" class="headerlink" title="编译时下载项目并引入"></a>编译时下载项目并引入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include(ExternalProject)</span><br><span class="line"></span><br><span class="line">set(SPDLOG_ROOT $&#123;CMAKE_BINARY_DIR&#125;/thirdparty/SPDLOG)</span><br><span class="line">set(SPDLOG_GIT_TAG  v1.4.1)  # 指定版本</span><br><span class="line">set(SPDLOG_GIT_URL      https://github.com/gabime/spdlog.git)  # 指定git仓库地址</span><br><span class="line">set(SPDLOG_CONFIGURE    cd $&#123;SPDLOG_ROOT&#125;/src/SPDLOG &amp;&amp; cmake -D CMAKE_INSTALL_PREFIX=$&#123;SPDLOG_ROOT&#125; .)  # 指定配置指令（注意此处修改了安装目录，否则默认情况下回安装到系统目录）</span><br><span class="line">set(SPDLOG_MAKE         cd $&#123;SPDLOG_ROOT&#125;/src/SPDLOG &amp;&amp; make)  # 指定编译指令（需要覆盖默认指令，进入我们指定的SPDLOG_ROOT目录下）</span><br><span class="line">set(SPDLOG_INSTALL      cd $&#123;SPDLOG_ROOT&#125;/src/SPDLOG &amp;&amp; make install)  # 指定安装指令（需要覆盖默认指令，进入我们指定的SPDLOG_ROOT目录下）</span><br><span class="line"></span><br><span class="line">ExternalProject_Add(SPDLOG</span><br><span class="line">        PREFIX            $&#123;SPDLOG_ROOT&#125;</span><br><span class="line">        GIT_REPOSITORY    $&#123;SPDLOG_GIT_URL&#125;</span><br><span class="line">        GIT_TAG           $&#123;SPDLOG_GIT_TAG&#125;</span><br><span class="line">        CONFIGURE_COMMAND $&#123;SPDLOG_CONFIGURE&#125;</span><br><span class="line">        BUILD_COMMAND     $&#123;SPDLOG_MAKE&#125;</span><br><span class="line">        INSTALL_COMMAND   $&#123;SPDLOG_INSTALL&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 指定编译好的静态库文件的路径</span><br><span class="line">set(SPDLOG_LIB       $&#123;SPDLOG_ROOT&#125;/lib/spdlog/libspdlog.a)</span><br><span class="line"># 指定头文件所在的目录</span><br><span class="line">set(SPDLOG_INCLUDE_DIR   $&#123;SPDLOG_ROOT&#125;/include)</span><br></pre></td></tr></table></figure>
<h2 id="install命令"><a href="#install命令" class="headerlink" title="install命令"></a>install命令</h2><p>install用于指定在安装时运行的规则。它可以用来安装很多内容，可以包括目标二进制、动态库、静态库以及文件、目录、脚本等<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install(TARGETS &lt;target&gt;... [...])</span><br><span class="line">install(&#123;FILES | PROGRAMS&#125; &lt;file&gt;... [...])</span><br><span class="line">install(DIRECTORY &lt;dir&gt;... [...])</span><br><span class="line">install(SCRIPT &lt;file&gt; [...])</span><br><span class="line">install(CODE &lt;code&gt; [...])</span><br><span class="line">install(EXPORT &lt;export-name&gt; [...])</span><br></pre></td></tr></table></figure></p>
<h2 id="cpack打包"><a href="#cpack打包" class="headerlink" title="cpack打包"></a>cpack打包</h2><h3 id="打包rpm"><a href="#打包rpm" class="headerlink" title="打包rpm"></a>打包rpm</h3><ul>
<li>组件打包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpack_add_component</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置每个分组打包成一个 rpm 包</span><br><span class="line">set(CPACK_COMPONENTS_GROUPING ONE_PER_GROUP)</span><br><span class="line"># 设置支持 COMPONENT</span><br><span class="line">set(CPACK_RPM_COMPONENT_INSTALL ON)</span><br><span class="line"></span><br><span class="line">include(CPack)</span><br><span class="line"></span><br><span class="line"># 添加一个名为 AComponent 的 component</span><br><span class="line">cpack_add_component(AComponent</span><br><span class="line">    DISPLAY_NAME  &quot;A program&quot;</span><br><span class="line">    DESCRIPTION   &quot;The program for test&quot;</span><br><span class="line">    GROUP Aprogram)</span><br><span class="line"># 添加一个名为 BComponent 的 component</span><br><span class="line">cpack_add_component(BComponent</span><br><span class="line">    DISPLAY_NAME  &quot;B program&quot;</span><br><span class="line">    DESCRIPTION   &quot;The program for test&quot;</span><br><span class="line">    GROUP Bprogram)</span><br><span class="line"># 添加一个名为 Aprogram 的 group, 这个名字会作为 rpm 包名字的一部分</span><br><span class="line">cpack_add_component_group(Aprogram)</span><br><span class="line"># 添加一个名为 Bprogram 的 group</span><br><span class="line">cpack_add_component_group(Bprogram)</span><br><span class="line"></span><br><span class="line">set(CPACK_RPM_Aprogram_PACKAGE_SUMMARY &quot;Aprogram. Build: git-$&#123;BRANCH_NAME&#125;-$&#123;COMMIT_HASH&#125;&quot;)</span><br><span class="line">set(CPACK_RPM_Bprogram_PACKAGE_SUMMARY &quot;Bprogram. Build: git-$&#123;BRANCH_NAME&#125;-$&#123;COMMIT_HASH&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 组件Bprogram安装之后执行的脚本</span><br><span class="line">set(CPACK_RPM_Bprogram_POST_INSTALL_SCRIPT_FILE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/script/postinst.sh&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="安装前后的动作"><a href="#安装前后的动作" class="headerlink" title="安装前后的动作"></a>安装前后的动作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置安装前执行的脚本文件 preinst</span><br><span class="line">set(CPACK_RPM_PRE_INSTALL_SCRIPT_FILE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/preinst.sh&quot;)</span><br><span class="line"># 设置卸载前执行的脚本文件 prerm</span><br><span class="line">set(CPACK_RPM_PRE_UNINSTALL_SCRIPT_FILE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/prerm.sh&quot;)</span><br><span class="line"># 设置安装后执行的脚本文件 postinst</span><br><span class="line">set(CPACK_RPM_POST_INSTALL_SCRIPT_FILE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/postinst.sh&quot;)</span><br><span class="line"># 设置卸载后执行的脚本文件 postrm</span><br><span class="line">set(CPACK_RPM_POST_UNINSTALL_SCRIPT_FILE “$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/postrm.sh&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果执行脚本出现权限问题,不要使用chmod u+x来赋权限,最好使用chmod 0777</p>
</blockquote>
<h3 id="取消yum自动依赖关系"><a href="#取消yum自动依赖关系" class="headerlink" title="取消yum自动依赖关系"></a>取消yum自动依赖关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(CPACK_RPM_PACKAGE_AUTOREQPROV &quot; no&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>no</code>前面（或后面）需要<strong>添加空格</strong>才能使其工作。 cpack的RPM模块似乎有一个错误，这使得它不会让您将某些变量设置为短于3个字符的任何长度。</p>
</blockquote>
<p>参考：<a href="https://stackoverflow.com/questions/14658034/how-do-you-make-it-so-that-cpack-doesnt-add-required-libraries-to-an-rpm" target="_blank" rel="noopener">https://stackoverflow.com/questions/14658034/how-do-you-make-it-so-that-cpack-doesnt-add-required-libraries-to-an-rpm</a></p>
<p>手动设置必要软件依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(CPACK_RPM_PACKAGE_REQUIRES &quot;python &gt;= 2.5.0, cmake &gt;= 2.8&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="rpm包的安装"><a href="#rpm包的安装" class="headerlink" title="rpm包的安装"></a>rpm包的安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh --nodeps --replacefiles test.rpm</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>--nodeps</code>: 忽略依赖软件包</li>
<li><code>--replacefiles</code>: 替换包或文件 用于替换原有包，覆盖安装</li>
<li><code>--force</code>: 忽略冲突，强行安装</li>
<li><code>--test</code>: 测试安装，但不真正执行安装，即dry run模式</li>
</ul>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="安装rpm包时出现filesystem-3-2-25-el7-x86-64冲突"><a href="#安装rpm包时出现filesystem-3-2-25-el7-x86-64冲突" class="headerlink" title="安装rpm包时出现filesystem-3.2-25.el7.x86_64冲突"></a>安装rpm包时出现filesystem-3.2-25.el7.x86_64冲突</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file /home from install of example-1.0.0-1.x86_64 conflicts with file from package filesystem-3.2-25.el7.x86_64</span><br></pre></td></tr></table></figure>
<ul>
<li><p>原因：</p>
<ol>
<li>打包时存在新建目录</li>
<li>打包时将home目录也打包其中</li>
</ol>
</li>
<li><p>解决方法：</p>
<ol>
<li>针对第一种，最好不要新建目录，如果是必须的在安装时强制安装</li>
<li>针对第二种，添加如下配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION &quot;/home&quot;)</span><br><span class="line">list(APPEND CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION &quot;/home/xxx&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.w3cschool.cn/doc_cmake_3_8/cmake_3_8-module-cpackrpm.html" target="_blank" rel="noopener">CPackRPM</a></li>
<li><a href="https://blog.csdn.net/andrewgithub/article/details/108249065" target="_blank" rel="noopener">cmake的使用-if-else的逻辑流程详解</a></li>
<li><a href="https://blog.csdn.net/JCYAO_/article/details/115179015" target="_blank" rel="noopener">Cmake获取编译时间添加版本信息</a></li>
<li><a href="https://blog.csdn.net/qq_38410730/article/details/102837401" target="_blank" rel="noopener">【CMake】cmake的install指令</a></li>
<li><a href="https://blog.csdn.net/q345911572/article/details/105250633" target="_blank" rel="noopener">CMake 基本常用语法 CMakeLists.txt</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/102050750" target="_blank" rel="noopener">CMake之引入外部项目的三种方法</a></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU流水线</title>
    <url>/post/34653.html</url>
    <content><![CDATA[<p>链接：Pipelining（流水线） <a href="https://www.cnblogs.com/dragonir/p/6196602.html" target="_blank" rel="noopener">https://www.cnblogs.com/dragonir/p/6196602.html</a></p>
<a id="more"></a>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>X86---汇编&amp;内嵌汇编</title>
    <url>/post/1816.html</url>
    <content><![CDATA[<p>基本格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__ (</span><br><span class="line">    &quot;assembler template&quot;</span><br><span class="line">    : output operands                  /* optional */</span><br><span class="line">    : input operands                   /* optional */</span><br><span class="line">    : list of clobbered registers      /* optional */</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><blockquote>
<p><a href="https://www.felixcloutier.com/x86/index.html" target="_blank" rel="noopener">x86 and amd64 instruction reference</a></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">操作码</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">movdqa</td>
<td style="text-align:left">移动对齐的双四字(2*64)</td>
<td style="text-align:left">Move Aligned Packed Integer Values</td>
</tr>
<tr>
<td style="text-align:center">movdqu</td>
<td style="text-align:left">移动不对齐的双四字</td>
<td style="text-align:left">Move Unaligned Packed Integer Values</td>
</tr>
<tr>
<td style="text-align:center"><code>XMMWORD</code></td>
<td style="text-align:left">用于具有MMX和SSE（XMM）指令的128位多媒体操作数，<br> XMMWORD旨在表示与__m128相同的类型。</td>
<td style="text-align:left">movdqa   xmm0, xmmword ptr [ebx]</td>
</tr>
<tr>
<td style="text-align:center">punpcklwd</td>
<td style="text-align:left">打开低数据包装</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">punpckhwd</td>
<td style="text-align:left">打开高数据包装</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/whutzhou/articles/2638498.html" target="_blank" rel="noopener">【转】GCC 嵌入汇编代码</a></li>
<li><a href="http://blog.chinaunix.net/uid-21602837-id-1823631.html" target="_blank" rel="noopener">linux中X86的内联汇编</a></li>
<li><a href="http://www.egr.unlv.edu/~ed/assembly64.pdf" target="_blank" rel="noopener">x86-64 Assembly Language Programming with Ubuntu</a> —— Ed Jorgensen (PDF)</li>
<li><a href="https://en.wikibooks.org/wiki/X86_Assembly" target="_blank" rel="noopener">x86 Assembly</a> —— Wikibooks</li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>显示认证系统</title>
    <url>/post/48058.html</url>
    <content><![CDATA[<p>在图像数据通过无线网络或者有线网络，将S端采集的图像数据编码后，传送到R端进行解码显示。在编解码过程中我们使用的H264编码协议，此协议是一个开源的编解码协议。我们在进行数据传输时是在S端采集一帧数据后进行H264编码，发送到R端进行解码显示。在这个过程中如果数据的传输通道被别人截取，然后将其他图像数据的H264码流，发送至R端，那么R端同样也会对其进行解码显示，因为都是H264编码格式的码流。但是此时R端将显示不是我们期望的图像数据，如果图像数据存在恶意性，将造成不良影响。</p>
<a id="more"></a>
<p>图像显示认证系统，确保R端进行解码显示的数据，只能是S端发送的图像数据码流，保证其唯一性。其他的H264码流均不进行解码显示，避免传输通道被截取后，其他H264格式的图像数据码流被解码显示。</p>
<h2 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h2><p><img src="/images/2019/05/video_sc_display_start.png" alt="video_sc_display_start"></p>
<ol>
<li>S和R上电正常启动，并配对建立连接</li>
<li>启动加密模块，通过RSA加密算法生成公钥和私钥。<ul>
<li>私钥通过AES使用密码（MAC地址或机器码等）加密，增加破译难度，然后保存在S端的内存中（不能保存文件）</li>
<li>公钥通过与R建立TCP连接，发送给R端</li>
</ul>
</li>
</ol>
<h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><p><img src="/images/2019/05/video_sc_display_s.png" alt="video_sc_display_S"></p>
<ol>
<li>采集一帧图像数据，并进行H264编码，生成一帧码流</li>
<li>对该帧码流使用SHA128获取其摘要（数字签名），是保证该帧数据的唯一性的凭证</li>
<li>通过RSA加密算法使用私钥对获取的摘要进行加密</li>
<li>将加密后的摘要合并到码流的头部，并进行发送。</li>
</ol>
<h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><p><img src="/images/2019/05/video_sc_display_r.png" alt="video_sc_display_R"></p>
<ol>
<li>R端接收到一帧码流数据后，进行解析。将头部的摘要和实际码流分离。</li>
<li>将获取后的码流使用SHA128计算其摘要B（数字签名）</li>
<li>将获取后的摘要通过RSA使用公钥进行解密，得到摘要A</li>
<li>对比摘要A和摘要比，如果不相同，说明S端发送的数据被人篡改，将该帧丢弃；如果相同，说明该帧是S端发送的数据，正常进行显示。</li>
</ol>
<h2 id="选用RSA加密算法的原因"><a href="#选用RSA加密算法的原因" class="headerlink" title="选用RSA加密算法的原因"></a>选用RSA加密算法的原因</h2><p>RSA是非对称加密，在S端生成私钥和公钥后，只要对S端的私钥进行保存妥善保存即可，而发送给R端的公钥即使丢失对整个流程的安全性也不受影响。</p>
<h2 id="为什么不直接使用RSA加密数据而是加密摘要"><a href="#为什么不直接使用RSA加密数据而是加密摘要" class="headerlink" title="为什么不直接使用RSA加密数据而是加密摘要"></a>为什么不直接使用RSA加密数据而是加密摘要</h2><p>RSA加密算法的耗时时间随加密数据的增加而增加，加密摘要主要是摘要只有128bit，加解密耗时小，并且固定。</p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
      </tags>
  </entry>
  <entry>
    <title>关于WIFI的工作模式--AP MODE/STATION MODE/P2P MODE</title>
    <url>/post/49326.html</url>
    <content><![CDATA[<p>WiFi的共存模式：</p>
<ul>
<li>station mode + station mode</li>
<li>station mode + ap mode</li>
<li>station mode + p2p mode</li>
<li>p2p mode + ap mode</li>
</ul>
<a id="more"></a>
<h2 id="ap-mode"><a href="#ap-mode" class="headerlink" title="ap mode"></a>ap mode</h2><p><code>ap mode</code>通用应用在无线局域网成员设备（即客户端）的加入，即<code>网络下行</code>。它提供以无线方式组建无线局域网WLAN，相当际WLAN的中心设备。</p>
<h2 id="station-mode"><a href="#station-mode" class="headerlink" title="station mode"></a>station mode</h2><p><code>station mode</code>即工作站模式，可以理解为某个网格中的一个工作站即客户端。那当一个WIFI芯片提供这个功能时，它就可以连到另外的一个网络当中，如家用路由器。通常用于提供网络的数据<code>上行服务</code></p>
<h2 id="p2p-mode"><a href="#p2p-mode" class="headerlink" title="p2p mode"></a>p2p mode</h2><p><code>p2p mode</code>也为Wi-Fi Direct</p>
<p>Wi-Fi Direct是一种点对点连接技术，它可以在两台station之间直接建立tcp/ip链接，并不需要AP的参与；其中一台station会起到传统意义上的AP的作用，称为<code>Group Owner(GO)</code>,另外一台station则称为<code>Group Client(GC)</code>，像连接AP一样连接到GO。GO和GC不仅可以是一对一，也可以是一对多；比如，一台GO可以同时连接着多台GC</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/wirelessdisplay/article/details/53365377" target="_blank" rel="noopener">WIFI Direct/WIFI P2P</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>wifi</category>
      </categories>
      <tags>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理之NUMA与CPU</title>
    <url>/post/36923.html</url>
    <content><![CDATA[<p>NUMA与CPU之间的关系,如系统中有2个CPU（可以超过2个CPU）时， NUMA内存访问模型</p>
<p><img src="/images/2019/06/mmu_numa_cpu.png" alt="mmu_numa_cpu"></p>
<blockquote>
<p>平台：arm64<br>kernel：linux4.4</p>
</blockquote>
<a id="more"></a>
<h2 id="NUMA-Non-Uniform-Memory-Access"><a href="#NUMA-Non-Uniform-Memory-Access" class="headerlink" title="NUMA(Non Uniform Memory Access)"></a>NUMA(Non Uniform Memory Access)</h2><p>NUMA和SMP是两种CPU相关的硬件架构。在SMP架构里面，所有的CPU争用一个总线来访问所有内存，优点是资源共享，而缺点是总线争用激烈。随着PC服务器上的CPU数量变多（不仅仅是CPU核数），总线争用的弊端慢慢越来越明显，于是Intel在Nehalem CPU上推出了NUMA架构，而AMD也推出了基于相同架构的Opteron CPU。</p>
<p>NUMA最大的特点是引入了node和distance的概念。对于CPU和内存这两种最宝贵的硬件资源，NUMA用近乎严格的方式划分了所属的资源组（node），而每个资源组内的CPU和内存是几乎相等。资源组的数量取决于物理CPU的个数（现有的PC server大多数有两个物理CPU，每个CPU有4个核）；distance这个概念是用来定义各个node之间调用资源的开销，为资源调度优化算法提供数据支持。</p>
<p><img src="/images/2019/06/mmu_numa_intel_access.png" alt="mmu_numa_intel_access"></p>
<ul>
<li>查看NUMA相关情况<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#numactl  --show</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ARM64内存在管理相当于单个node"><a href="#ARM64内存在管理相当于单个node" class="headerlink" title="ARM64内存在管理相当于单个node"></a>ARM64内存在管理相当于单个node</h2><p><img src="/images/2019/06/mmu_one_node.png" alt="mmu_one_node"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On node 0 totalpages: 524288</span><br><span class="line">  DMA zone: 8192 pages used for memmap</span><br><span class="line">  DMA zone: 0 pages reserved</span><br><span class="line">  DMA zone: 524288 pages, LIFO batch:31</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内核启动部分打印</p>
</blockquote>
<h3 id="node的初始化"><a href="#node的初始化" class="headerlink" title="node的初始化"></a>node的初始化</h3><p>在内核启动时进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">  \-&gt;setup_arch //不同的CPU对node的使用不同</span><br><span class="line">      \-&gt;paging_init</span><br><span class="line">          \-&gt;bootmem_init</span><br><span class="line">              \-&gt;zone_sizes_init(arch/arm64/mm/minit.c)</span><br><span class="line">                  \-&gt;free_area_init_node(nid=0, ...)</span><br><span class="line">                    &#123;</span><br><span class="line">                       pg_data_t *pgdat = NODE_DATA(nid);</span><br><span class="line"></span><br><span class="line">                       calculate_node_totalpages(pgdat, start_pfn, end_pfn,</span><br><span class="line">                         zones_size, zholes_size);</span><br><span class="line">                       alloc_node_mem_map(pgdat);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="物理内存与node之间的关系"><a href="#物理内存与node之间的关系" class="headerlink" title="物理内存与node之间的关系"></a>物理内存与node之间的关系</h2><h2 id="numa编码"><a href="#numa编码" class="headerlink" title="numa编码"></a>numa编码</h2><p>将当前进程绑定到node0或node1,及在当前node上的CPU运行与申请内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_numa_node</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmask</span> *<span class="title">bit</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bit</span> = numa_bitmask_alloc(<span class="number">1</span>);</span><br><span class="line">    numa_bitmask_clearall(<span class="built_in">bit</span>);</span><br><span class="line">    numa_bitmask_setbit(<span class="built_in">bit</span>, node);</span><br><span class="line">    numa_bind(<span class="built_in">bit</span>); <span class="comment">//将当前任务及其子任务绑定到nodemask中指定的节点。它们只会在指定节点的CPU上运行，并且只能从它们分配内存。</span></span><br><span class="line">    numa_bitmask_free(<span class="built_in">bit</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>numa_bind()</code> binds the current task and its children to the nodes specified in nodemask. They will only run on the CPUs of the specified nodes and only be able to allocate memory from them. This function is equivalent to calling numa_run_on_node_mask(nodemask) followed by numa_set_membind(nodemask). If tasks should be bound to individual CPUs inside nodes consider using numa_node_to_cpus and the sched_setaffinity(2) syscall.</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/xueqiuqiu/articles/9282903.html" target="_blank" rel="noopener">NUMA的取舍与优化设置</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
        <category>mmu</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理——灰度化、二值化、反色、饱和度、对比度</title>
    <url>/post/25039.html</url>
    <content><![CDATA[<h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p>RGB色彩模式使用RGB模型为图像中每个像素的RGB分量分配一个0~255范围内的强度值。RGB图像仅仅使用三种颜色，R(red)、G(green)、B(blue)，就能够使它们依照不同的比例混合，在屏幕上呈现16777216(256 <em> 256 </em> 256)种颜色。</p>
<p>在电脑中，RGB的所谓“多少”就是指亮度，并使用整数来表示。通常情况下，RGB各有256级亮度，用数字表示为从0、1、2…直到255。</p>
<a id="more"></a>
<h2 id="ARGB"><a href="#ARGB" class="headerlink" title="ARGB"></a>ARGB</h2><p>一种色彩模式，也就是RGB色彩模式附加上Alpha（透明度）通道，常见于32位位图的存储结构。</p>
<p><code>ARGB</code>— Alpha,Red,Green,Blue.</p>
<h2 id="灰度化"><a href="#灰度化" class="headerlink" title="灰度化"></a>灰度化</h2><p>在RGB模型中，假设R=G=B时，则彩色表示一种灰度颜色，当中R=G=B的值叫灰度值，因此，灰度图像每一个像素仅仅需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255。一般有下面四种方法对彩色图像进行灰度化</p>
<h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><p>一幅图像包含目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，最经常使用的方法就是<strong>设定一个全局的阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。将大于T的像素群的像素值设定为白色（或者黑色），小于T的像素群的像素值设定为黑色（或者白色）。</strong></p>
<h2 id="反色"><a href="#反色" class="headerlink" title="反色"></a>反色</h2><p>反色的实际含义是将R、G、B值反转，若颜色的量化级别是256，则新图的R、G、B值为255减去原图的R、G、B值。</p>
<h2 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h2><p>所谓的饱和度，指的其实是色彩的纯度，纯度越高，表现越鲜明，纯度较低，表现则较黯淡，色饱和度表示光线的彩色深浅度或鲜艳度，取决于彩色中的白色光含量，白光含量越高，即彩色光含量就越低，色彩饱和度即越低，反之亦然。其数值为百分比，介于0-100% 之间。纯白光的色彩饱和度为0，而纯彩色光的饱和度则为100%。</p>
<h2 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h2><p>对比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围越大代表对比越大，差异范围越小代表对比越小，好的对比率120:1就可容易地显示生动、丰富的色彩，当对比率高达300:1时，便可支持各阶的颜色。但对比率遭受和亮度相同的困境，现今尚无一套有效又公正的标准来衡量对比率，所以最好的辨识方式还是依靠使用者眼睛。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/evsqiezi/article/details/7905436" target="_blank" rel="noopener">图像分析–灰度化,二值化,反色,饱和度，对比度</a></li>
<li><a href="https://github.com/KoffeinFlummi/armake" target="_blank" rel="noopener">C实现（PAA转换，二值化/快速化，PBO打包）</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>memset设置枚举（enum）数组--错误</title>
    <url>/post/50726.html</url>
    <content><![CDATA[<p>在最近的工作中，遇到了一个<code>memset</code>的问题，由于比较特殊在此记录一下。</p>
<p>需求：申请一个enum类型的数据，进行操作均正常，但是使用memset进行统一赋值时，数组各个元素均达不到预期效果。</p>
<p>如果枚举成员值是1，通过memset设置枚举类型数组内存值其结果将变为<code>0x01010101</code>,而不是<code>0x00000001</code></p>
<a id="more"></a>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> tst &#123;</span><br><span class="line">	a1 = <span class="number">0</span>,</span><br><span class="line">	a2,</span><br><span class="line">	a3 = <span class="number">5</span>,</span><br><span class="line">	a4,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">enum</span> tst* test = (<span class="keyword">enum</span> tst*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"test=%p, sizeof enum tst=%ld\n"</span>, test, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		test[i] = a2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"test[%d]=%d\n"</span>, i, test[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a1=%d, a2=%d, a3=%d, a4=%d\n"</span>, a1, a2, a3, a4);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d\n"</span>, __func__, __LINE__);</span><br><span class="line">	<span class="built_in">memset</span>(test, a1, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"test[%d]=%d 0x%08x\n"</span>, i, test[i], test[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d\n"</span>, __func__, __LINE__);</span><br><span class="line">	<span class="built_in">memset</span>(test, a2, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"test[%d]=%d 0x%08x\n"</span>, i, test[i], test[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d\n"</span>, __func__, __LINE__);</span><br><span class="line">	<span class="built_in">memset</span>(test, a3, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"test[%d]=%d 0x%08x\n"</span>, i, test[i], test[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d\n"</span>, __func__, __LINE__);</span><br><span class="line">	<span class="built_in">memset</span>(test, a4, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"test[%d]=%d 0x%08x\n"</span>, i, test[i], test[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(test);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test=0x7fffce4d3260, sizeof enum tst=4</span><br><span class="line">test[0]=1</span><br><span class="line">test[1]=1</span><br><span class="line">test[2]=1</span><br><span class="line">test[3]=1</span><br><span class="line">test[4]=1</span><br><span class="line">test[5]=1</span><br><span class="line">test[6]=1</span><br><span class="line">test[7]=1</span><br><span class="line">test[8]=1</span><br><span class="line">test[9]=1</span><br><span class="line">a1=0, a2=1, a3=5, a4=6</span><br><span class="line">===&gt; func: main, line: 37</span><br><span class="line">test[0]=0 0x00000000</span><br><span class="line">test[1]=0 0x00000000</span><br><span class="line">test[2]=0 0x00000000</span><br><span class="line">test[3]=0 0x00000000</span><br><span class="line">test[4]=0 0x00000000</span><br><span class="line">test[5]=0 0x00000000</span><br><span class="line">test[6]=0 0x00000000</span><br><span class="line">test[7]=0 0x00000000</span><br><span class="line">test[8]=0 0x00000000</span><br><span class="line">test[9]=0 0x00000000</span><br><span class="line">===&gt; func: main, line: 44</span><br><span class="line">test[0]=16843009 0x01010101</span><br><span class="line">test[1]=16843009 0x01010101</span><br><span class="line">test[2]=16843009 0x01010101</span><br><span class="line">test[3]=16843009 0x01010101</span><br><span class="line">test[4]=16843009 0x01010101</span><br><span class="line">test[5]=16843009 0x01010101</span><br><span class="line">test[6]=16843009 0x01010101</span><br><span class="line">test[7]=16843009 0x01010101</span><br><span class="line">test[8]=16843009 0x01010101</span><br><span class="line">test[9]=16843009 0x01010101</span><br><span class="line">===&gt; func: main, line: 51</span><br><span class="line">test[0]=84215045 0x05050505</span><br><span class="line">test[1]=84215045 0x05050505</span><br><span class="line">test[2]=84215045 0x05050505</span><br><span class="line">test[3]=84215045 0x05050505</span><br><span class="line">test[4]=84215045 0x05050505</span><br><span class="line">test[5]=84215045 0x05050505</span><br><span class="line">test[6]=84215045 0x05050505</span><br><span class="line">test[7]=84215045 0x05050505</span><br><span class="line">test[8]=84215045 0x05050505</span><br><span class="line">test[9]=84215045 0x05050505</span><br><span class="line">===&gt; func: main, line: 58</span><br><span class="line">test[0]=101058054 0x06060606</span><br><span class="line">test[1]=101058054 0x06060606</span><br><span class="line">test[2]=101058054 0x06060606</span><br><span class="line">test[3]=101058054 0x06060606</span><br><span class="line">test[4]=101058054 0x06060606</span><br><span class="line">test[5]=101058054 0x06060606</span><br><span class="line">test[6]=101058054 0x06060606</span><br><span class="line">test[7]=101058054 0x06060606</span><br><span class="line">test[8]=101058054 0x06060606</span><br><span class="line">test[9]=101058054 0x06060606</span><br></pre></td></tr></table></figure>
<ul>
<li>枚举类型的大小占<code>4字节</code></li>
<li><code>memset</code>后所有的内存值，将别设置为枚举成员的值的十六进制，但是只占1字节，其中4字节全部相同</li>
<li>测试如果枚举类型成员的值大于256（0x400），设置的内存值将是其底8位</li>
</ul>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *memset(void *s, int c, size_t n);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The memset() function fills the first n bytes of the memory area pointed to by s with the constant byte c.</p>
</blockquote>
<p>memset函数将内存的每个字节设置为第二个参数（在第二个参数被截断之后,因为是按照<code>字节</code>进行设置）。 由于枚举（通常）是int的大小，将得到错误的结果,它唯一有效的是枚举值为<code>0</code>.</p>
<p><strong><code>memset</code>设置内存值是以字节为单位处理，因此所设置的数值范围是<code>0~0xff</code></strong></p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>memset</tag>
      </tags>
  </entry>
  <entry>
    <title>USB中OTG功能的实现</title>
    <url>/post/1467.html</url>
    <content><![CDATA[<blockquote>
<p>usb otg(on-the-go)标准在完全兼容usb2.0标准的基础上，增添了电源管理（节省功耗）功能，它允许设备既可作为主机，也可作为外设操作（两用otg）。otg两用设备完全符合usb2.0标准，并可提供一定的主机检测能力，支持主机通令协议（hnp）和对话请求协议（srp）。在otg中，初始主机设备称为a设备，外设称为b设备。可用电缆的连接方式(id pin)来决定初始角色</p>
</blockquote>
<a id="more"></a>
<h2 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h2><p><img src="/images/2019/08/usb_otg_id_pin.png" alt="usb_otg_id_pin"></p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="中断传输"><a href="#中断传输" class="headerlink" title="中断传输"></a>中断传输</h3><blockquote>
<p>An interrupt transfer is complete when the endpoint does one of the following:</p>
<ul>
<li>Has transferred exactly the amount of data expected</li>
<li>Transfers a packet with a payload size less than <code>wMaxPacketSize</code> or transfers a zero-length packet</li>
</ul>
</blockquote>
<p>中断传输完成时，端点执行的操作：</p>
<ul>
<li>已传输完成预期的数据量</li>
<li>传输的有效数据负载小于wMaxPacketSize大小或者传输0长度的数据包（ZLP）</li>
</ul>
<p>在HID设置中对report描述符的传输使用中断传输（数据量小），如果wMaxPacketSize的值为64Byte（控制器可配），而此时该设备的report描述符大小也为64Byte，在数据发送完后需要发送一个ZLP，否则host端无法确定数据是否传输完成。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cl.cam.ac.uk/~atm26/ephemeral/rpi/dwc_otg/doc/html/main.html" target="_blank" rel="noopener">DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver Documentation</a></li>
<li><a href="https://www.cnblogs.com/LoongEmbedded/p/5298173.html" target="_blank" rel="noopener">USB OTG插入检测识别</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Virtio GPU</title>
    <url>/post/56420.html</url>
    <content><![CDATA[<blockquote>
<p>For containers in virtualized environments, they are working on accelerated OpenGL ES 2.0 support with that being the lowest common denominator for many mobile platforms. This virtual GPU access they are pursuing is making use of Red Hat’s work on Virgil3D as the Gallium3D-based solution for graphics pass-through to the host. Then for the kernel bits are VirtIO-GPU and on the host is the Virgl Renderer with QEMU.</p>
</blockquote>
<p><img src="/images/2019/08/virtio_gpu_qemu_layer.png" alt="virtio-gpu-qemu-layer"></p>
<a id="more"></a>
<h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><p>OpenGL, OpenGL ES, and OpenGL ES-SC API and Extension Registry</p>
<ul>
<li><a href="https://github.com/KhronosGroup/OpenGL-Registry/" target="_blank" rel="noopener">OpenGL-Registry</a></li>
</ul>
<h2 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h2><p><code>EGL</code>是图形渲染API（如OpenGL ES）与本地平台窗口系统的一层接口，保证了OpenGL ES的平台独立性。EGL提供了若干功能：创建rendering surface、创建graphics context、同步应用程序和本地平台渲染API、提供对显示设备的访问、提供对渲染配置的管理等。</p>
<p>egl是一个管理者的功能。包括管理所有的display ， context， surface，config。可能有很多的display ，每个display有很多的configs，这个display上可以创建很多的context和surface</p>
<ul>
<li><a href="https://www.khronos.org/registry/EGL/sdk/docs/man/" target="_blank" rel="noopener">EGL Reference Pages</a></li>
<li><a href="https://www.khronos.org/files/egl-1-4-quick-reference-card.pdf" target="_blank" rel="noopener">1EGL 1.4 API Quick Reference Card</a></li>
</ul>
<h2 id="GLX"><a href="#GLX" class="headerlink" title="GLX"></a>GLX</h2><p><code>GLX</code>是OpenGL Extension to the X Window System的缩写。它作为x的扩展，是x协议和X server的一部分，已经包含在X server的代码中了。GLX提供了X window system使用的OpenGL接口，允许通过x调用OpenGL库。OpenGL 在使用时，需要与一个实际的窗口系统关联起来。</p>
<h2 id="GLX、EGL与OpenGL-ES之间的关系？？"><a href="#GLX、EGL与OpenGL-ES之间的关系？？" class="headerlink" title="GLX、EGL与OpenGL ES之间的关系？？"></a>GLX、EGL与OpenGL ES之间的关系？？</h2><blockquote>
<p>一般EGL和OpenGL ES使用时都会先利用egl函数(egl开头)创建opengl本地环境，然后再利用opengl函数(gl开头)去画图。</p>
</blockquote>
<p><strong>EGL代替的是原先WGL/GLX那套context管理，跟图形API用的什么没关系</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EGLBoolean <span class="title">eglBindAPI</span><span class="params">( 	EGLenum api)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Parameters api:<br>   Specifies the client API to bind, one of <code>EGL_OPENGL_API</code>, <code>EGL_OPENGL_ES_API</code>, or <code>EGL_OPENVG_API</code>.</p>
</blockquote>
<h2 id="mesa"><a href="#mesa" class="headerlink" title="mesa"></a>mesa</h2><h3 id="Gallium"><a href="#Gallium" class="headerlink" title="Gallium"></a>Gallium</h3><ul>
<li><a href="https://gallium.readthedocs.io/en/latest/" target="_blank" rel="noopener">Gallium’s documentation</a></li>
<li><a href="https://dri.freedesktop.org/doxygen/gallium/index.html" target="_blank" rel="noopener">Gallium3D Documentation doxygen</a></li>
</ul>
<h2 id="DRI"><a href="#DRI" class="headerlink" title="DRI"></a>DRI</h2><ul>
<li><a href="https://www.x.org/wiki/Events/XDC2013/XDC2013EricAnholtDRIMegadrivers/xdc-2013-megadrivers.pdf" target="_blank" rel="noopener">DRI megadrivers</a></li>
</ul>
<h2 id="Virgil"><a href="#Virgil" class="headerlink" title="Virgil"></a>Virgil</h2><blockquote>
<p>Virgil is an effort to provide 3D acceleration using <code>Gallium3D</code> for QEMU+KVM virtual machine guests.</p>
</blockquote>
<ul>
<li><a href="https://www.phoronix.com/scan.php?page=search&amp;q=Virgil" target="_blank" rel="noopener">Virgil Linux News</a></li>
<li><a href="https://xdc2018.x.org/slides/Virgl_Presentation.pdf" target="_blank" rel="noopener">What’s new in the virtual world?(pdf)</a></li>
<li><a href="https://studiopixl.com/2018-07-12/vulkan-ize-virgl.html" target="_blank" rel="noopener">GSoC 2018 - Vulkan-ize Virglrenderer</a></li>
<li><a href="https://studiopixl.com/2017-08-27/3d-acceleration-using-virtio.html" target="_blank" rel="noopener">GSoC 2017 - 3D acceleration using VirtIOGPU</a></li>
</ul>
<h3 id="virgl-protocol"><a href="#virgl-protocol" class="headerlink" title="virgl_protocol"></a>virgl_protocol</h3><p>It is composed of several components:</p>
<ul>
<li>a MESA driver, on the guest, which generates <code>Virgl commands</code></li>
<li>a lib, on the host, which takes virgl commands and generated OpenGL calls from it.</li>
</ul>
<h2 id="GPU-Driver"><a href="#GPU-Driver" class="headerlink" title="GPU Driver"></a>GPU Driver</h2><h3 id="DRM"><a href="#DRM" class="headerlink" title="DRM"></a>DRM</h3><blockquote>
<p>he DRM core includes two memory managers, namely Translation Table Maps (TTM) and Graphics Execution Manager (GEM).</p>
</blockquote>
<ul>
<li><a href="https://blog.csdn.net/u012839187/article/details/89875800" target="_blank" rel="noopener">Linux GPU Driver Developer’s Guide</a></li>
<li><a href="http://ju.outofmemory.cn/entry/158909" target="_blank" rel="noopener">DRM memory management - 最好的GEM/TTM/PRIME解释</a></li>
</ul>
<h2 id="piglit"><a href="#piglit" class="headerlink" title="piglit"></a>piglit</h2><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><blockquote>
<p>OpenGL着色语言（OpenGL Shading Language）是用来在OpenGL中着色编程的语言，也即开发人员写的短小的自定义程序，他们是在图形卡的GPU （Graphic Processor Unit图形处理单元）上执行的，代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性。</p>
</blockquote>
<h2 id="X-org"><a href="#X-org" class="headerlink" title="X.org"></a>X.org</h2><p>2018年X.Org开发者大会相关文档和视频（网络原因视频看不了）</p>
<ul>
<li><a href="https://www.x.org/wiki/Events/XDC2018/" target="_blank" rel="noopener">https://www.x.org/wiki/Events/XDC2018/</a></li>
</ul>
<h2 id="graphics-pipeline"><a href="#graphics-pipeline" class="headerlink" title="graphics pipeline"></a>graphics pipeline</h2><p><img src="/images/2020/07/graphics_pipeline.png" alt="graphics_pipeline"></p>
<blockquote>
<p><a href="https://www.seas.upenn.edu/~cis565/LECTURES/Lecture2" target="_blank" rel="noopener">https://www.seas.upenn.edu/~cis565/LECTURES/Lecture2</a> New.pdf</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://gitlab.com/spice/win32/virtio-gpu-wddm-dod" target="_blank" rel="noopener">virtio-gpu-wddm-dod</a></li>
<li><a href="https://github.com/Keenuts/virtio-gpu-win-icd" target="_blank" rel="noopener">OpenGL ICD for Virtio-GPU Windows driver(Github)</a></li>
<li><a href="https://docs.oasis-open.org/virtio/virtio/v1.1/cs01/virtio-v1.1-cs01.html" target="_blank" rel="noopener">Virtual I/O Device (VIRTIO) Version 1.1</a></li>
<li><a href="https://studiopixl.com/2017-08-27/3d-acceleration-using-virtio.html" target="_blank" rel="noopener">GSoC 2017 - 3D acceleration using VirtIOGPU</a></li>
<li><a href="https://studiopixl.com/2018-07-12/vulkan-ize-virgl.html" target="_blank" rel="noopener">GSoC 2018 - Vulkan-ize Virglrenderer</a></li>
<li><a href="https://mesamatrix.net/" target="_blank" rel="noopener">The OpenGL vs Mesa matrix</a></li>
<li><a href="https://memcpy.io/virtualizing-gpu-access.html" target="_blank" rel="noopener">Virtualizing GPU Access</a></li>
<li><a href="https://www.kraxel.org/blog/" target="_blank" rel="noopener">kraxel’s news</a> — virgl and qemu</li>
<li><a href="https://blog.csdn.net/huang987246510/article/details/107729881" target="_blank" rel="noopener">VirtIO GPU基本原理</a></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>virtio</tag>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>ABRT</title>
    <url>/post/46984.html</url>
    <content><![CDATA[<p>ABRT (Automated Bug Reporting Tool) Daemon:</p>
<blockquote>
<p>ABRT is an application, included in Fedora Linux Distribution, that is used to report bugs in the software packages whenever crash occurs. Due to this, ABRT also helps in creation of core dump files. Multiple packages may be needed to run various features of ABRT daemon, and their listing is as follows.</p>
</blockquote>
<p>在linux调试程序，程序异常宕掉，没有core文件，很难定位问题。但是有了core文件就容易定位多了， 一般是可以通过在环境变量中设置<code>ulimit -c unlimited</code>。</p>
<p>但是现场实施人员有时会忘记设置这条命令， 因此可以通过设置linux的<code>abrt</code>服务来实现。</p>
<a id="more"></a>
<p>系统：CentOS7</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Product Signing (GPG) Keys:</span><br><span class="line"># https://access.redhat.com/security/team/key</span><br><span class="line">#</span><br><span class="line">OpenGPGCheck = no #捕获所有程序的崩溃信息</span><br><span class="line"></span><br><span class="line"># Blacklisted packages</span><br><span class="line">#</span><br><span class="line">BlackList = nspluginwrapper, valgrind, strace, mono-core</span><br><span class="line"></span><br><span class="line"># Process crashes in executables which do not belong to any package?</span><br><span class="line">#</span><br><span class="line">ProcessUnpackaged = yes #保存捕获程序异常的core文件</span><br><span class="line"></span><br><span class="line"># Blacklisted executable paths (shell patterns)</span><br><span class="line">#</span><br><span class="line">BlackListedPaths = /usr/share/doc/*, */example*, /usr/bin/nspluginviewer, /usr/lib/xulrunner-*/plugin-container</span><br><span class="line"></span><br><span class="line"># interpreters names</span><br><span class="line">Interpreters = python2, python2.7, python, python3, python3.3, perl, perl5.16.2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置文件： <code>/etc/abrt/abrt-action-save-package-data.conf</code></p>
</blockquote>
<blockquote>
<p>配置文件：<code>/etc/abrt/abrt.conf</code></p>
</blockquote>
<ul>
<li><p>配置参数<a href="https://docs.fedoraproject.org/en-US/Fedora/14/html/Deployment_Guide/configuring.html" target="_blank" rel="noopener">解析</a></p>
</li>
<li><p>重启服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service abrtd restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service abrtd status</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -a | grep core_pattern</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i 's/ProcessUnpackaged = no/ProcessUnpackaged = yes/g' /etc/abrt/abrt-action-save-package-data.conf&amp;&amp; service abrtd restart</span><br></pre></td></tr></table></figure>
<h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><h3 id="查看文件的包"><a href="#查看文件的包" class="headerlink" title="查看文件的包"></a>查看文件的包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abrt-cli list</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># abrt-cli list</span><br><span class="line">id 3c0df29571be38a595b2034cfa631d3e6b569d34</span><br><span class="line">reason:         Unable to handle kernel NULL pointer dereference at virtual address 00000000</span><br><span class="line">time:           2019年09月11日 星期三 20时26分26秒</span><br><span class="line">uid:            0 (root)</span><br><span class="line">count:          1</span><br><span class="line">Directory:      /var/spool/abrt/vmcore-127.0.0.1-2019-09-05-10:31:32</span><br><span class="line"></span><br><span class="line">The Autoreporting feature is disabled. Please consider enabling it by issuing</span><br><span class="line">&apos;abrt-auto-reporting enabled&apos; as a user with root privileges</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ls /var/spool/abrt/ccpp-2019-09-21-16:26:32-16439</span><br><span class="line">abrt_version  architecture  cmdline         coredump  dso_list  event_log   exploitable  hostname  last_occurrence  machineid  open_fds  os_release  proc_pid_status  reason    time  uid       uuid</span><br><span class="line">analyzer      cgroup        core_backtrace  count     environ   executable  global_pid   kernel    limits           maps       os_info   pid         pwd              runlevel  type  username  var_log_messages</span><br></pre></td></tr></table></figure>
<h3 id="删除文件包"><a href="#删除文件包" class="headerlink" title="删除文件包"></a>删除文件包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abrt-cli rm &lt;ccpp folder from list &gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># abrt-cli rm /var/spool/abrt/vmcore-127.0.0.1-2019-09-05-10:31:32</span><br><span class="line">rm &apos;/var/spool/abrt/vmcore-127.0.0.1-2019-09-05-10:31:32&apos;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-abrt" target="_blank" rel="noopener">Chapter 28. Automatic Bug Reporting Tool (ABRT)</a></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>dump</tag>
      </tags>
  </entry>
  <entry>
    <title>autotools自动编译---手动添加依赖库</title>
    <url>/post/31094.html</url>
    <content><![CDATA[<p><code>autotools</code>根据配置文件(configure.ac)自动生成<code>makefile</code></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./autogen.sh  #根据configure.ac生成configure与相关头文件</span><br><span class="line">./configure --prefix=$ALT_LOCAL --enable-debug</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="在现有应用中添加SDL的依赖"><a href="#在现有应用中添加SDL的依赖" class="headerlink" title="在现有应用中添加SDL的依赖"></a>在现有应用中添加SDL的依赖</h2><p>将gcc的编译参数<code>-lSDL2</code>,添加到<code>configure</code>生成的Makefile，并可以在配置阶段检测系统是否以安装SDL2相关库</p>
<h3 id="修改configure-ac"><a href="#修改configure-ac" class="headerlink" title="修改configure.ac"></a>修改configure.ac</h3><p>添加对SDL2库的检测<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PKG_CHECK_MODULES([SDL2], [sdl2])</span><br></pre></td></tr></table></figure></p>
<p>执行<code>autogen.sh</code>生成configure和config.log等，在<code>config.log</code>中将生成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SDL2_CFLAGS=&apos;-D_REENTRANT -I/usr/include/SDL2&apos;</span><br><span class="line">SDL2_LIBS=&apos;-lSDL2&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="编辑Makefile-am"><a href="#编辑Makefile-am" class="headerlink" title="编辑Makefile.am"></a>编辑Makefile.am</h3><p>修改需要链接SDL2的源码目录中的<code>Makefile.am</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AM_LDFLAGS = $(SDL2_LIBS)</span><br><span class="line">AM_CFLAGS = $(SDL2_CFLAGS)</span><br></pre></td></tr></table></figure></p>
<h2 id="make参数"><a href="#make参数" class="headerlink" title="make参数"></a>make参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j4 --trace</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--trace</code>: 打印gcc编译的详细数据</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/kongshuai19900505/article/details/79104442" target="_blank" rel="noopener">autotools自动编译系列之三—autogen.sh实例</a></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>autotools</tag>
        <tag>configure</tag>
        <tag>autogen</tag>
      </tags>
  </entry>
  <entry>
    <title>DRM</title>
    <url>/post/16573.html</url>
    <content><![CDATA[<p>显卡驱动相关：</p>
<a id="more"></a>
<h2 id="GEM-Graphics-Execution-Manager"><a href="#GEM-Graphics-Execution-Manager" class="headerlink" title="GEM (Graphics Execution Manager)"></a>GEM (Graphics Execution Manager)</h2><h2 id="TTM-Translation-Table-Manager"><a href="#TTM-Translation-Table-Manager" class="headerlink" title="TTM (Translation Table Manager)"></a>TTM (Translation Table Manager)</h2><blockquote>
<p> To this end, the TTM layer provides “fence” objects. A fence is a special operation which is placed into the GPU’s command FIFO. When the fence is executed, it raises a signal to indicate that all instructions enqueued before the fence have now been executed, and that the GPU will no longer be accessing any associated buffers. How the signaling works is very much dependent on the GPU; it could raise an interrupt or simply write a value to a special memory location. When a fence signals, any associated buffers are marked as no longer being referenced by the GPU, and any interested user-space processes are notified.<br><a href="https://lwn.net/Articles/257417/" target="_blank" rel="noopener">https://lwn.net/Articles/257417/</a></p>
</blockquote>
<p>TTM层提供“fence”对象。fence是一种特殊的操作，被放置在GPU的命令FIFO中。当执行fence时，它会发出一个信号，指示现已执行fence之前排队的所有指令，并且GPU将不再访问任何关联的缓冲区。信号的工作方式在很大程度上取决于GPU。它可能会引发中断，或者只是将值写入特殊的存储位置。当fenc发出信号时，所有关联的缓冲区都将标记为不再被GPU引用，并且会通知任何感兴趣的用户空间进程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.landley.net/kdocs/htmldocs/drm.html#drmIntroduction" target="_blank" rel="noopener">Linux DRM Developer’s Guide</a></li>
<li><a href="https://lwn.net/Articles/283793/" target="_blank" rel="noopener">GEM v. TTM</a></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>drm</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU page fault</title>
    <url>/post/793.html</url>
    <content><![CDATA[<p>尽管许多GPU都支持页面错误，但并非所有都支持。 一些GPU使用下列方式响应内存错误：</p>
<ul>
<li>位存储桶写入(bit-bucket writes)</li>
<li>读取模拟数据（如零）(reading simulated data (for example, zeros))</li>
<li>或仅挂起(by simply hanging)</li>
</ul>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[  712.873530] amdgpu 0001:01:00.0: GPU fault detected: 146 0x0218082c</span><br><span class="line">[  712.878462] pcieport 0001:00:00.0: AER: Multiple Corrected error received: id=0000</span><br><span class="line">[  712.878469] pcieport 0001:00:00.0: PCIe Bus Error: severity=Corrected, type=Physical Layer, id=0000(Receiver ID)</span><br><span class="line">[  712.878471] pcieport 0001:00:00.0:   device [1def:e006] error status/mask=00000001/00002000</span><br><span class="line">[  712.878472] pcieport 0001:00:00.0:    [ 0] Receiver Error         (First)</span><br><span class="line">[  712.912617] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101043</span><br><span class="line">[  712.920085] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0400802C</span><br><span class="line">[  712.927554] amdgpu 0001:01:00.0: VM fault (0x2c, vmid 2) at page 1052739, read from &apos;TC2&apos; (0x54433200) (8)</span><br><span class="line">[  712.937273] amdgpu 0001:01:00.0: GPU fault detected: 146 0x03403d0c</span><br><span class="line">[  712.943527] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101468</span><br><span class="line">[  712.950995] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0403D00C</span><br><span class="line">[  712.958463] amdgpu 0001:01:00.0: VM fault (0x0c, vmid 2) at page 1053800, read from &apos;SDM1&apos; (0x53444d31) (61)</span><br><span class="line">[  712.968329] amdgpu 0001:01:00.0: GPU fault detected: 146 0x03a0770c</span><br><span class="line">[  712.974582] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101474</span><br><span class="line">[  712.982050] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0A07700C</span><br><span class="line">[  712.989519] amdgpu 0001:01:00.0: VM fault (0x0c, vmid 5) at page 1053812, read from &apos;SDM0&apos; (0x53444d30) (119)</span><br></pre></td></tr></table></figure>
<h2 id="造成的现象"><a href="#造成的现象" class="headerlink" title="造成的现象"></a>造成的现象</h2><p>系统整体卡住，有时鼠标键盘无响应，但是可以通过ssh登录系统，并且测试无法kill掉xorg</p>
<h2 id="GPU页错误"><a href="#GPU页错误" class="headerlink" title="GPU页错误"></a>GPU页错误</h2><blockquote>
<p>A GPU page fault commonly occurs under one of these conditions. An application mistakenly executes work on the GPU that references a deleted object. This is one of the top reasons for an unexpected device removal. An application mistakenly executes work on the GPU that accesses an evicted resource, or a non-resident tile.</p>
</blockquote>
<p> GPU 页面错误通常在下列情况之一下发生：</p>
<ul>
<li>应用程序在 GPU 上错误地执行了应用已删除的对象的作业。 这是意外删除设备的主要原因之一。</li>
<li>应用程序错误地在 GPU 上执行了访问已逐出的资源或非驻留磁贴的作业。</li>
<li>着色器引用未初始化的或过时的描述符。</li>
<li>着色器索引超出根绑定末尾。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/use-dred" target="_blank" rel="noopener">Use DRED to diagnose GPU faults</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3d12/use-dred" target="_blank" rel="noopener">使用 DRED 诊断 GPU 错误</a></li>
<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=105251" target="_blank" rel="noopener">[Vega10] GPU lockup on boot: VMC page fault</a></li>
<li><a href="http://on-demand.gputechconf.com/gtc/2016/presentation/s6517-saman-ashkiani-gtc-multisplit.pdf" target="_blank" rel="noopener">GPU Multisplit</a></li>
<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=105733" target="_blank" rel="noopener">Bug 105733 - Amdgpu randomly hangs and only ssh works. Mouse cursor moves sometimes but does nothing. Keyboard stops working. </a></li>
<li><a href="http://ballmerpeak.web.elte.hu/devblog/debugging-mesa-and-the-linux-3d-graphics-stack.html" target="_blank" rel="noopener">Debugging mesa and the linux 3D graphics stack </a></li>
<li><a href="http://ballmerpeak.web.elte.hu/devblog/debugging-hyperz-and-fixing-a-radeon-drm-linux-kernel-module.html" target="_blank" rel="noopener">Debugging HyperZ and fixing a radeon drm linux kernel module </a></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux for ARM</title>
    <url>/post/35642.html</url>
    <content><![CDATA[<p>支持arm架构CPU的PC或服务器中linux相关系统或软件</p>
<a id="more"></a>
<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><h3 id="IOS镜像下载"><a href="#IOS镜像下载" class="headerlink" title="IOS镜像下载"></a>IOS镜像下载</h3><ul>
<li><a href="http://isoredirect.centos.org/altarch/7/isos/aarch64/" target="_blank" rel="noopener">http://isoredirect.centos.org/altarch/7/isos/aarch64/</a></li>
</ul>
<h3 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h3><ul>
<li><a href="http://mirror.centos.org/altarch/7/os/aarch64/Packages/" target="_blank" rel="noopener">http://mirror.centos.org/altarch/7/os/aarch64/Packages/</a></li>
</ul>
<h3 id="不同版本"><a href="#不同版本" class="headerlink" title="不同版本"></a>不同版本</h3><ul>
<li><a href="http://mirror.centos.org" target="_blank" rel="noopener">http://mirror.centos.org</a></li>
</ul>
<h2 id="Archlinux"><a href="#Archlinux" class="headerlink" title="Archlinux"></a>Archlinux</h2><blockquote>
<p>We build optimized packages for soft-float ARMv5te, hard-float ARMv6 and ARMv7, and ARMv8 AArch64 instruction sets to use each platform to its full potential.</p>
</blockquote>
<ul>
<li><a href="https://archlinuxarm.org/" target="_blank" rel="noopener">https://archlinuxarm.org/</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Kernel" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Kernel</a></li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>系统软件更新快，版本新</li>
</ul>
<h2 id="ubuntu-for-arm"><a href="#ubuntu-for-arm" class="headerlink" title="ubuntu for arm"></a>ubuntu for arm</h2><blockquote>
<p>配置清华源<code>ubuntu-ports</code></p>
</blockquote>
<h2 id="华为TaiShan服务器"><a href="#华为TaiShan服务器" class="headerlink" title="华为TaiShan服务器"></a>华为TaiShan服务器</h2><p>服务器MGMT网口，即BMC（iBMC/iMana）的默认IP地址与子网掩码如下：<br>默认IP地址：192.168.2.100<br>默认子网掩码：255.255.255.0</p>
<p>iBMC（iBMC/iMana）默认用户名和密码如下：<br>默认用户名：root<br>默认密码：Huawei12#$</p>
<p>定制后的固件中iBMC（iBMC/iMana）默认用户名和密码如下：<br>默认用户名：Administrator<br>默认密码：Huawei12#$ —&gt; Ziguang12#$</p>
<h2 id="Beyond-Linux®-From-Scratch-System-V-Edition"><a href="#Beyond-Linux®-From-Scratch-System-V-Edition" class="headerlink" title="Beyond Linux® From Scratch (System V Edition)"></a>Beyond Linux® From Scratch (System V Edition)</h2><ul>
<li><a href="http://www.linuxfromscratch.org/blfs/view/svn/index.html" target="_blank" rel="noopener">http://www.linuxfromscratch.org/blfs/view/svn/index.html</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/lsgxeva/p/10371276.html" target="_blank" rel="noopener">华为TaiShan 2280 ARM 服务器</a></li>
</ul>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中systemd的日志管理——journalctl</title>
    <url>/post/50280.html</url>
    <content><![CDATA[<p><code>Systemd</code>统一管理所有linux的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件<code>/etc/systemd/journald.conf</code></p>
<a id="more"></a>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p>配置文件：<code>/etc/systemd/journald.conf</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Journal]</span><br><span class="line">#Storage=auto</span><br><span class="line">#Compress=yes</span><br><span class="line">#Seal=yes</span><br><span class="line">#SplitMode=uid</span><br><span class="line">#SyncIntervalSec=5m</span><br><span class="line">#RateLimitIntervalSec=30s</span><br><span class="line">#RateLimitBurst=1000</span><br><span class="line">//指定journal所能使用的最高持久存储容量。</span><br><span class="line">#SystemMaxUse=</span><br><span class="line">//指定journal在添加新条目时需要保留的剩余空间。</span><br><span class="line">#SystemKeepFree=</span><br><span class="line">//控制单一journal文件大小，符合要求方可被转为持久存储。</span><br><span class="line">#SystemMaxFileSize=</span><br><span class="line">#SystemMaxFiles=100</span><br><span class="line">//指定易失性存储中的最大可用磁盘容量（/run文件系统之内）</span><br><span class="line">#RuntimeMaxUse=</span><br><span class="line">//指定向易失性存储内写入数据时为其它应用保留的空间量（/run文件系统之内）</span><br><span class="line">#RuntimeKeepFree=</span><br><span class="line">//指定单一journal文件可占用的最大易失性存储容量（/run文件系统之内）</span><br><span class="line">#RuntimeMaxFileSize=</span><br><span class="line">#RuntimeMaxFiles=100</span><br><span class="line">#MaxRetentionSec=</span><br><span class="line">#MaxFileSec=1month</span><br><span class="line">#ForwardToSyslog=yes</span><br><span class="line">#ForwardToKMsg=no</span><br><span class="line">#ForwardToConsole=no</span><br><span class="line">#ForwardToWall=yes</span><br><span class="line">#TTYPath=/dev/console</span><br><span class="line">#MaxLevelStore=debug</span><br><span class="line">#MaxLevelSyslog=debug</span><br><span class="line">#MaxLevelKMsg=notice</span><br><span class="line">#MaxLevelConsole=info</span><br><span class="line">#MaxLevelWall=emerg</span><br><span class="line">#LineMax=48K</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://www.freedesktop.org/software/systemd/man/journald.conf.html" target="_blank" rel="noopener">Journal service configuration files</a></li>
</ul>
<h3 id="把日志保存到文件中"><a href="#把日志保存到文件中" class="headerlink" title="把日志保存到文件中"></a>把日志保存到文件中</h3><ul>
<li><p>方法1： 创建目录<code>/var/log/journal</code>，然后重启日志服务<code>systemd-journald.service</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /var/log/journal</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2： 修改配置文件<code>/etc/systemd/journald.conf</code>，把<code>Storage=auto</code>改为<code>Storage=persistent</code>，并取消注释，然后重启日志服务<code>systemd-journald.service</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart systemd-journald</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl -h</span></span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">man journalctl</span></span><br></pre></td></tr></table></figure></p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="查看所有日志（默认情况下-，只保存本次启动的日志）"><a href="#查看所有日志（默认情况下-，只保存本次启动的日志）" class="headerlink" title="查看所有日志（默认情况下 ，只保存本次启动的日志）"></a>查看所有日志（默认情况下 ，只保存本次启动的日志）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl</span></span><br></pre></td></tr></table></figure>
<h3 id="查看当前最后一次启动后日志"><a href="#查看当前最后一次启动后日志" class="headerlink" title="查看当前最后一次启动后日志"></a>查看当前最后一次启动后日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl -xb</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-x</code>: 使用消息目录中的说明文本扩充日志行<br><code>-b</code>: 参数为空时，将显示当前引导的日志</p>
</blockquote>
<h3 id="查看内核日志（不显示应用日志）"><a href="#查看内核日志（不显示应用日志）" class="headerlink" title="查看内核日志（不显示应用日志）"></a>查看内核日志（不显示应用日志）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl -k</span></span><br></pre></td></tr></table></figure>
<h3 id="查看系统本次启动的日志"><a href="#查看系统本次启动的日志" class="headerlink" title="查看系统本次启动的日志"></a>查看系统本次启动的日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl -b</span></span><br></pre></td></tr></table></figure>
<h3 id="查看某次启动后的日志"><a href="#查看某次启动后的日志" class="headerlink" title="查看某次启动后的日志"></a>查看某次启动后的日志</h3><p>默认情况下<code>systemd-journald</code>服务只保存本次启动后的日志(重新启动后丢掉以前的日志)。此时<code>-b</code>选项是没啥用的。当我们把<code>systemd-journald</code>服务收集到的日志保存到文件中之后，就可以通过下面的命令查看系统的重启记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl --list-boots</span></span><br><span class="line">-82 672e675b37f74b72b2900c13743675e9 Mon 2019-03-18 11:11:20 CST—Fri 2019-03-22 09:17:58 CST</span><br><span class="line">-81 f857b21a80db4be3acfdf7d04247e4bd Fri 2019-03-22 09:18:44 CST—Fri 2019-03-22 18:13:10 CST</span><br><span class="line">-80 ee3d23ea84434be2b7d6a6353733e37c Sat 2019-03-23 11:23:40 CST—Sat 2019-03-23 13:28:06 CST</span><br></pre></td></tr></table></figure>
<p>通过<code>-b</code>选项来选择查看某次运行过程中的日志:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl -b -82</span></span><br><span class="line">或</span><br><span class="line"><span class="meta">$</span><span class="bash">journalctl -b 672e675b37f74b72b2900c13743675e9</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查看指定时间段的日志"><a href="#查看指定时间段的日志" class="headerlink" title="查看指定时间段的日志"></a>查看指定时间段的日志</h3><p>利用<code>--since</code>与<code>--until</code>选项设定时间段，二者分别负责指定给定时间之前与之后的日志记录。时间值可以使用多种格式，比如下面的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YYYY-MM-DD HH:MM:SS</span><br></pre></td></tr></table></figure>
<p>如果我们要查询2018年3月26日下午8:20之后的日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl --since <span class="string">"2018-03-26 20:20:00"</span></span></span><br></pre></td></tr></table></figure>
<h3 id="通过日志级别进行过滤"><a href="#通过日志级别进行过滤" class="headerlink" title="通过日志级别进行过滤"></a>通过日志级别进行过滤</h3><p>除了通过<code>PRIORITY=</code>的方式，还可以通过<code>-p</code>选项来过滤日志的级别。 可以指定的优先级如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">严重性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">emerg</td>
<td style="text-align:center">系统不可用</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">alert</td>
<td style="text-align:center">必须立即采取措施</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">crit</td>
<td style="text-align:center">严重状况</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">err</td>
<td style="text-align:center">非严重错误状况</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">warning</td>
<td style="text-align:center">警告状况</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">notice</td>
<td style="text-align:center">正常但重要的事件</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">info</td>
<td style="text-align:center">信息性事件</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">debug</td>
<td style="text-align:center">调试级别消息</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl -p err</span></span><br></pre></td></tr></table></figure>
<h3 id="实时更新日志"><a href="#实时更新日志" class="headerlink" title="实时更新日志"></a>实时更新日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl -f</span></span><br></pre></td></tr></table></figure>
<h3 id="按可执行文件的路径过滤"><a href="#按可执行文件的路径过滤" class="headerlink" title="按可执行文件的路径过滤"></a>按可执行文件的路径过滤</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl /bin/bash</span></span><br></pre></td></tr></table></figure>
<h3 id="查看指定应用日志"><a href="#查看指定应用日志" class="headerlink" title="查看指定应用日志"></a>查看指定应用日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl -t sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="查看指定进程的日志"><a href="#查看指定进程的日志" class="headerlink" title="查看指定进程的日志"></a>查看指定进程的日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl _PID=1234</span></span><br></pre></td></tr></table></figure>
<h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><h3 id="查看当前日志占用磁盘的空间的总大小"><a href="#查看当前日志占用磁盘的空间的总大小" class="headerlink" title="查看当前日志占用磁盘的空间的总大小"></a>查看当前日志占用磁盘的空间的总大小</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl --disk-usage</span></span><br><span class="line">Archived and active journals take up 3.9G in the file system.</span><br></pre></td></tr></table></figure>
<h3 id="指定日志文件最大空间"><a href="#指定日志文件最大空间" class="headerlink" title="指定日志文件最大空间"></a>指定日志文件最大空间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl --vacuum-size=1G</span></span><br></pre></td></tr></table></figure>
<h3 id="指定日志文件保存多久"><a href="#指定日志文件保存多久" class="headerlink" title="指定日志文件保存多久"></a>指定日志文件保存多久</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl --vacuum-time=1years</span></span><br></pre></td></tr></table></figure>
<h3 id="检查journal是否运行正常以及日志文件是否完整无损坏"><a href="#检查journal是否运行正常以及日志文件是否完整无损坏" class="headerlink" title="检查journal是否运行正常以及日志文件是否完整无损坏"></a>检查journal是否运行正常以及日志文件是否完整无损坏</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">journalctl --verify</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jinbuguo.com/systemd/journalctl.html" target="_blank" rel="noopener">journalctl 中文手册</a></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL测试</title>
    <url>/post/42765.html</url>
    <content><![CDATA[<p>OpenGL API相关测试：</p>
<a id="more"></a>
<h2 id="piglit"><a href="#piglit" class="headerlink" title="piglit"></a>piglit</h2><h2 id="WebGL-Test"><a href="#WebGL-Test" class="headerlink" title="WebGL Test"></a>WebGL Test</h2><ul>
<li><a href="https://www.khronos.org/registry/webgl/conformance-suites/1.0.3/webgl-conformance-tests.html" target="_blank" rel="noopener">https://www.khronos.org/registry/webgl/conformance-suites/1.0.3/webgl-conformance-tests.html</a></li>
<li><a href="https://www.khronos.org/registry/webgl/conformance-suites/2.0.0/webgl-conformance-tests.html" target="_blank" rel="noopener">https://www.khronos.org/registry/webgl/conformance-suites/2.0.0/webgl-conformance-tests.html</a></li>
</ul>
<h3 id="查看浏览器是否支持webgl的方法"><a href="#查看浏览器是否支持webgl的方法" class="headerlink" title="查看浏览器是否支持webgl的方法"></a>查看浏览器是否支持webgl的方法</h3><ul>
<li><a href="https://get.webgl.org/" target="_blank" rel="noopener">https://get.webgl.org/</a></li>
</ul>
<p><img src="/images/2019/09/webgl_supports.png" alt="webgl_supports"></p>
<h3 id="浏览器对WebGL版本的支持"><a href="#浏览器对WebGL版本的支持" class="headerlink" title="浏览器对WebGL版本的支持"></a>浏览器对WebGL版本的支持</h3><ul>
<li><a href="http://caniuse.com" target="_blank" rel="noopener">http://caniuse.com</a></li>
</ul>
<p><img src="/images/2019/09/webgl_version.png" alt="webgl_version"></p>
<blockquote>
<p>在页面搜索<code>WebGL</code>,查找<code>WebGL - 3D Canvas graphics</code></p>
</blockquote>
<ul>
<li>图中，绿色部分为完全实现 webgl 标准功能的版本，但有些厂商的实现并不一定如其所述那样完整，而有些并没那么稳定</li>
<li>当某一浏览器无法运行 webgl 应用时，应考虑，是否需要手动开启 webgl 功能，如 safari;</li>
<li>当某一浏览器无法打开本地的 webgl 应用时，应考虑，浏览器对本地资源出于安全考虑，对本地资源的访问是需要设置是否允许的，针对不浏览器设置方法不同，而像 firefox 默认是开启的；</li>
</ul>
<h3 id="检测浏览器支持的WebGL-Report"><a href="#检测浏览器支持的WebGL-Report" class="headerlink" title="检测浏览器支持的WebGL Report"></a>检测浏览器支持的WebGL Report</h3><ul>
<li><a href="https://webglreport.com/?v=2" target="_blank" rel="noopener">https://webglreport.com/?v=2</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>printk_ratelimit</title>
    <url>/post/59845.html</url>
    <content><![CDATA[<p>在Linux内核代码里当需要限制<code>printk</code>打印频率时会用到<code>__ratelimit</code>或<code>printk_ratelimit</code>（封装了__ratelimit）</p>
<a id="more"></a>
<p><code>printk_ratelimit</code>默认允许在<code>5s</code>内最多打印<code>10</code>条消息出来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat /proc/sys/kernel/printk_ratelimit</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">$</span><span class="bash">cat /proc/sys/kernel/printk_ratelimit_burst</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (printk_ratelimit()) &#123;</span><br><span class="line">    dev_err(adev-&gt;dev, <span class="string">"GPU fault detected: %d 0x%08x\n"</span>,</span><br><span class="line">        entry-&gt;src_id, entry-&gt;src_data[<span class="number">0</span>]);</span><br><span class="line">    dev_err(adev-&gt;dev, <span class="string">"  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\n"</span>,</span><br><span class="line">        addr);</span><br><span class="line">    dev_err(adev-&gt;dev, <span class="string">"  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\n"</span>,</span><br><span class="line">        status);</span><br><span class="line">    gmc_v8_0_vm_decode_fault(adev, status, addr, mc_client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/lkkey80/article/details/45190095" target="_blank" rel="noopener">限制printk打印频率函数printk_ratelimit</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>printk</tag>
      </tags>
  </entry>
  <entry>
    <title>rpc</title>
    <url>/post/62149.html</url>
    <content><![CDATA[<blockquote>
<p><code>RPC</code>是远程过程调用（Remote Procedure Call）的缩写形式。SAP系统RPC调用的原理其实很简单，有一些类似于三层构架的C/S系统，第三方的客户程序通过接口调用SAP内部的标准或自定义函数，获得函数返回的数据进行处理后显示或打印</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>Since the idea of <a href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">RPC</a>  goes back to 1976 and the first business use was by Xerox in 1981, I’m  not exactly sure what qualifies as a really old tutorial.</p>
</blockquote>
<blockquote>
<p>Here are a few resources you might find helpful.</p>
</blockquote>
<ul>
<li><a href="http://books.google.com/books?id=PN2hcRD29JUC&amp;dq=Power+Programming+with+RPC" target="_blank" rel="noopener">Power Programming with RPC</a> (1992)</li>
<li><a href="http://www.linuxjournal.com/article/2204" target="_blank" rel="noopener">Remote Procedure Calls | Linux Journal</a> (Oct 01, 1997)</li>
<li><a href="http://www.cs.cf.ac.uk/Dave/C/node33.html" target="_blank" rel="noopener">Remote Procedure Calls (RPC)</a> (1999)</li>
<li><a href="http://docs.freebsd.org/44doc/psd/23.rpc/paper.pdf" target="_blank" rel="noopener">Remote Procedure Call Programming Guide</a> (PDF link)</li>
<li><a href="http://linux.die.net/man/3/rpc" target="_blank" rel="noopener">rpc(3) - Linux man page</a></li>
</ul>
<h2 id="rpcgen"><a href="#rpcgen" class="headerlink" title="rpcgen"></a>rpcgen</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$rpcgen --version</span><br><span class="line">rpcgen (Ubuntu GLIBC 2.27-3ubuntu1) 2.27</span><br></pre></td></tr></table></figure>
<h2 id="rpcinfo"><a href="#rpcinfo" class="headerlink" title="rpcinfo"></a>rpcinfo</h2><blockquote>
<p>report RPC information</p>
</blockquote>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Cannot-register-service-RPC-Unable-to-receive-errno-Connection-refused"><a href="#Cannot-register-service-RPC-Unable-to-receive-errno-Connection-refused" class="headerlink" title="Cannot register service: RPC: Unable to receive; errno = Connection refused"></a>Cannot register service: RPC: Unable to receive; errno = Connection refused</h3><p><code>portmap</code>是为RPC程序服务的。每一个RPC server程序启动的时候要向portmap程序注册。这样portmap程序就知道这些RPC server监听在哪个端口。 而RPC client在发起连接向portmap发起查询，知道了想要查询的RPC server的监听端口后再去连接server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install portmap rpcbind</span><br><span class="line">sudo systemctl status portmap.service</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">find /usr/include/ -name <span class="string">"*.x"</span></span></span><br><span class="line">/usr/include/rpcsvc/key_prot.x</span><br><span class="line">/usr/include/rpcsvc/bootparam_prot.x</span><br><span class="line">/usr/include/rpcsvc/sm_inter.x</span><br><span class="line">/usr/include/rpcsvc/klm_prot.x</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program YPPASSWDPROG &#123;</span><br><span class="line">        version YPPASSWDVERS &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * Update my passwd entry</span><br><span class="line">                 */</span><br><span class="line">                int</span><br><span class="line">                YPPASSWDPROC_UPDATE(yppasswd) = 1;</span><br><span class="line">        &#125; = 1;</span><br><span class="line">&#125; = 100009;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct passwd &#123;</span><br><span class="line">        string pw_name&lt;&gt;;       /* username */</span><br><span class="line">        string pw_passwd&lt;&gt;;     /* encrypted password */</span><br><span class="line">        int pw_uid;             /* user id */</span><br><span class="line">        int pw_gid;             /* group id */</span><br><span class="line">        string pw_gecos&lt;&gt;;      /* in real life name */</span><br><span class="line">        string pw_dir&lt;&gt;;        /* home directory */</span><br><span class="line">        string pw_shell&lt;&gt;;      /* default shell */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct yppasswd &#123;</span><br><span class="line">        string oldpass&lt;&gt;;       /* unencrypted old password */</span><br><span class="line">        passwd newpw;           /* new passwd entry */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://unix.stackexchange.com/questions/344015/what-are-the-x-files-in-usr-include" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/344015/what-are-the-x-files-in-usr-include</a></p>
</blockquote>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://www.linuxjournal.com/article/2204" target="_blank" rel="noopener">Remote Procedure Calls</a></li>
<li><a href="https://stackoverflow.com/questions/2526227/c-c-rpc-tutorial-for-linux" target="_blank" rel="noopener">C/C++ RPC Tutorial for Linux [closed]</a></li>
<li><a href="https://blog.csdn.net/iw1210/article/details/41051779" target="_blank" rel="noopener">Linux下C语言RPC（远程过程调用）编程实例</a></li>
<li><a href="https://docs.freebsd.org/44doc/psd/22.rpcgen/paper.pdf" target="_blank" rel="noopener">rpcgen Programming Guide</a></li>
<li><a href="https://www.cprogramming.com/tutorial/rpc/remote_procedure_call_start.html" target="_blank" rel="noopener">Writing Remote Procedural Calls (RPCs) in C</a></li>
<li><a href="https://stackoverflow.com/questions/28822436/passing-character-pointers-from-client-to-server-in-rpcgen" target="_blank" rel="noopener">Passing character pointers from client to server in RPCGen</a></li>
<li><a href="http://neo.dmcs.pl/rso/du/onc-rpc3.html" target="_blank" rel="noopener">Writing RPC Applications with the rpcgen Protocol Compiler</a></li>
</ul>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>升级Centos7系统内核版本（for arm64）</title>
    <url>/post/51885.html</url>
    <content><![CDATA[<p>升级CentOS7中的内核版本：</p>
<a id="more"></a>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="认证错误"><a href="#认证错误" class="headerlink" title="认证错误"></a>认证错误</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target `certs/centos.pem&apos;, needed by `certs/x509_certificate_list&apos;.  Stop</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注释掉<code>.config</code>中的相关配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG_SYSTEM_TRUSTED_KEYS=&quot;certs/centos.pem&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://unix.stackexchange.com/questions/293642/attempting-to-compile-any-kernel-yields-a-certification-error/294116" target="_blank" rel="noopener">Attempting to compile any kernel yields a certification error</a></p>
</li>
<li><a href="https://www.kernel.org/doc/html/v5.3-rc8/admin-guide/module-signing.html" target="_blank" rel="noopener">Kernel module signing facility</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://lists.debian.org/debian-kernel/2016/04/msg00579.html" target="_blank" rel="noopener">Bug#823107: marked as done (linux: make deb-pkg fails: No rule to make target ‘debian/certs/benh@debian.org.cert.pem’)</a></li>
<li><a href="https://blog.ziki.cn/post/compile-kernel/" target="_blank" rel="noopener">https://blog.ziki.cn/post/compile-kernel/</a></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>meson构建系统</title>
    <url>/post/28042.html</url>
    <content><![CDATA[<p>转载：<a href="https://stackoverflow.com/questions/5837764/autotools-vs-cmake-for-both-windows-and-linux-compilation" target="_blank" rel="noopener">https://stackoverflow.com/questions/5837764/autotools-vs-cmake-for-both-windows-and-linux-compilation</a></p>
<a id="more"></a>
<p><strong>Meson</strong></p>
<p>Pros:</p>
<ul>
<li>The DSL does not get in the way at all. In fact, it is very nice and familiar, based in python.</li>
<li>Well-thought cross compilation support.</li>
<li>The objects are all strongly typed: you cannot make string  substitution mistakes easily, since objects are entities such as  ‘depencency’, ‘include directory’, etc.</li>
<li>It is very obviuos how to add a module for one of your tools.</li>
<li>Cross-compilation seems more straightforward to use.</li>
<li>Really well-thought. The designer and main writer of Meson knows what  he talks about very well when designing a build system.</li>
<li>Very, very fast, especially in incremental builds.</li>
<li>The documentation is 10 times better that what you can find in cmake. Go visit <a href="http://mesonbuild.com" target="_blank" rel="noopener">http://mesonbuild.com</a> and you will find tutorial, howtos and a good reference. It is not perfect but it is really discoverable.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Not as mature as CMake, though, I consider it already fully usable for C++.</li>
<li>Not so many modules available, though, gnome, qt and the common ones are already there.</li>
<li>Project generators: seems VS generator is not working that well as of now. CMake project generators are far more mature.</li>
<li>Has a python3 + ninja dependency.</li>
</ul>
<p><strong>Cmake</strong></p>
<p>Pros:</p>
<ul>
<li>Generates projects for many different IDEs. This is a <em>very</em> nice feature for teams.</li>
<li>Plays well with windows tools, unlike autotools.</li>
<li>Mature, almost de-facto standard.</li>
<li>Microsoft is working on CMake integration for Visual Studio.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It does not follow any well known standard or guidelines.</li>
<li>No uninstall target.</li>
<li>The DSL is weird, when you start to do comparisons and such, and the  strings vs list thing or escape chars, you will make many mistakes, I  am pretty sure.</li>
<li>Cross compilation sucks.</li>
</ul>
<p><strong>Autotools</strong></p>
<p>Pros:</p>
<ul>
<li>Most powerful system for cross-compilation, IMHO.</li>
<li>The generated scripts don’t need anything else than make, a shell and, if you need it to build, a compiler.</li>
<li>The command-line is really nice and consistent.</li>
<li>A standard in unix world, lots of docs.</li>
<li>Really powerful command-line: changing directories of installation, uninstall, renaming binaries…</li>
<li>If you target unix, packaging sources with this tool is really convenient.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It won’t play well with microsoft tools. A real showstopper.</li>
<li>The learning curve is… well… But actually I can say that CMake was not that easy either.</li>
<li>The use of recursive make is pervasive in legacy projects. Automake <a href="https://autotools.io/automake/nonrecursive.html" target="_blank" rel="noopener">supports non-recursive builds</a>, but it’s not a very widely used approach.</li>
</ul>
<p>About the learning curve, there are two very good sources to learn from:</p>
<ul>
<li>The website <a href="https://www.flameeyes.eu/autotools-mythbuster/" target="_blank" rel="noopener">here</a></li>
<li>The book <a href="http://www.nostarch.com/autotools.htm" target="_blank" rel="noopener">here</a></li>
</ul>
<p>The first source will get you up and running faster. The book is a more in-depth discussion.</p>
<p>From Scons, waf and tup, Scons and tup are more like make. Waf is  more like CMake and the autotools. I tried waf instead of cmake at  first. I think it is overengineered in the sense that it has a full OOP  API. The scripts didn’t look short at all and it was really confusing  for me the working directory stuff and related things. At the end, I  found that autotools and CMake are a better choice. My favourite from  these 3 build systems is tup.</p>
<p><strong>Tup</strong></p>
<p>Pros</p>
<ul>
<li>Really correct.</li>
<li><strong>Insanely fast</strong>. You should try it to believe it.</li>
<li>The scripting language relies on a very easy idea that can be understood in 10 minutes.</li>
</ul>
<p>Cons</p>
<ul>
<li>It does not have a full-featured config framework.</li>
<li>I couldn’t find the way to make targets such as <code>doc</code>,  since  they generate files I don’t know of and they must be listed in the  output before being generated, or at least, that’s my conclusion for  now. This was a really annoying limitation, if it is, since I am not  sure.</li>
</ul>
<p>All in all, the only things I am considering right now for new  projects is are Cmake and Meson. When I have a chance I will try tup  also, but it lacks the config framework, which means that it makes  things more complex when you need all of that stuff. On the other hand,  it is really fast.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mesonbuild.com/Comparisons.html" target="_blank" rel="noopener">Comparing Meson with other build systems</a></li>
<li><a href="https://mesonbuild.com/Simple-comparison.html" target="_blank" rel="noopener">A simple comparison for meson</a></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>meson</tag>
        <tag>build</tag>
      </tags>
  </entry>
  <entry>
    <title>glxinfo之Video Memory大小</title>
    <url>/post/18632.html</url>
    <content><![CDATA[<p>mesa中的显存大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">glxinfo -B</span></span><br><span class="line">name of display: :0</span><br><span class="line">display: :0  screen: 0</span><br><span class="line">direct rendering: Yes</span><br><span class="line">Extended renderer info (GLX_MESA_query_renderer):</span><br><span class="line">    Vendor: X.Org (0x1002)</span><br><span class="line">    Device: AMD OLAND (DRM 2.50.0, 5.3.8-050308-generic, LLVM 8.0.0) (0x6611)</span><br><span class="line">    Version: 19.1.6</span><br><span class="line">    Accelerated: yes</span><br><span class="line">    Video memory: 1024MB &lt;----------- 显存</span><br><span class="line">    Unified memory: no</span><br><span class="line">    Preferred profile: core (0x1)</span><br><span class="line">    Max core profile version: 4.5</span><br><span class="line">    Max compat profile version: 4.5</span><br><span class="line">    Max GLES1 profile version: 1.1</span><br><span class="line">    Max GLES[23] profile version: 3.2</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="glxinfo"><a href="#glxinfo" class="headerlink" title="glxinfo"></a>glxinfo</h2><p>源码文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://gitlab.freedesktop.org/mesa/demos.git</span><br></pre></td></tr></table></figure></p>
<p>获取显存大小：<code>queryInteger(GLX_RENDERER_VIDEO_MEMORY_MESA, v)</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queryInteger(GLX_RENDERER_ACCELERATED_MESA, v);</span><br><span class="line">printf(&quot;    Accelerated: %s\n&quot;, *v ? &quot;yes&quot; : &quot;no&quot;);</span><br><span class="line">queryInteger(GLX_RENDERER_VIDEO_MEMORY_MESA, v);</span><br><span class="line">printf(&quot;    Video memory: %dMB\n&quot;, *v);</span><br><span class="line">queryInteger(GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA, v);</span><br><span class="line">printf(&quot;    Unified memory: %s\n&quot;, *v ? &quot;yes&quot; : &quot;no&quot;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>file: glxinfo.c</p>
</blockquote>
<h2 id="mesa"><a href="#mesa" class="headerlink" title="mesa"></a>mesa</h2><p>queryInteger在mesa中的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glXQueryCurrentRendererIntegerMESA</span><br><span class="line">  \-&gt;__glXQueryRendererInteger --- GLX_RENDERER_VIDEO_MEMORY_MESA</span><br><span class="line">    -&gt; psc-&gt;vtable-&gt;query_renderer_integer()</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<ul>
<li>dri3<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">glx_screen_vtable</span> <span class="title">dri3_screen_vtable</span> = &#123;</span></span><br><span class="line">   .create_context         = dri3_create_context,</span><br><span class="line">   .create_context_attribs = dri3_create_context_attribs,</span><br><span class="line">   .query_renderer_integer = dri3_query_renderer_integer,</span><br><span class="line">   .query_renderer_string  = dri3_query_renderer_string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dri3_query_renderer_integer</span><br><span class="line"> \-&gt; dri2_convert_glx_query_renderer_attribs</span><br><span class="line">    \/</span><br><span class="line">  dri_attribute = __DRI2_RENDERER_VIDEO_MEMORY &lt;--GLX_RENDERER_VIDEO_MEMORY_MESA</span><br><span class="line"> \-&gt;psc-&gt;rendererQuery-&gt;queryInteger((psc-&gt;driScreen, dri_attribute, value)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> __DRI2rendererQueryExtension dri2RendererQueryExtension = &#123;</span><br><span class="line">    .base = &#123; __DRI2_RENDERER_QUERY, <span class="number">1</span> &#125;,</span><br><span class="line"></span><br><span class="line">    .queryInteger         = dri2_query_renderer_integer,</span><br><span class="line">    .queryString          = dri2_query_renderer_string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>fire: src/gallium/state_trackers/dri/dri_query_renderer.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dri2_query_renderer_integer</span><br><span class="line"> \-&gt; __DRI2_RENDERER_VIDEO_MEMORY</span><br><span class="line">   &gt; screen-&gt;base.screen-&gt;get_param(screen-&gt;base.screen, PIPE_CAP_VIDEO_MEMORY)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>get_param</code>接口是<code>struct pipe_screen</code>提供给驱动的接口，需要各个驱动自己实现。</li>
</ul>
<h3 id="virgl"><a href="#virgl" class="headerlink" title="virgl"></a>virgl</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_screen</span> *</span></span><br><span class="line"><span class="class"><span class="title">virgl_create_screen</span>(<span class="title">struct</span> <span class="title">virgl_winsys</span> *<span class="title">vws</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">virgl_screen</span> *<span class="title">screen</span> = <span class="title">CALLOC_STRUCT</span>(<span class="title">virgl_screen</span>);</span></span><br><span class="line"></span><br><span class="line">   screen-&gt;base.get_name = virgl_get_name;</span><br><span class="line">   screen-&gt;base.get_vendor = virgl_get_vendor;</span><br><span class="line">   screen-&gt;base.get_param = virgl_get_param;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virgl_get_param &lt;- PIPE_CAP_VIDEO_MEMORY</span><br><span class="line">\-&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">      case PIPE_CAP_VIDEO_MEMORY:</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>在virgl中没有实现显存接口，默认为0，无法通过glxinfo获取</strong></p>
</blockquote>
<p>在virgl中的部分其他参数是获取host端的参数，通过<code>struct virgl_winsys</code>结构体中的<code>get_caps</code>接口。</p>
<ul>
<li>drm： <code>DRM_IOCTL_VIRTGPU_GET_CAPS</code></li>
<li>vtest： <code>VCMD_GET_CAPS</code>+<code>VCMD_GET_CAPS2</code></li>
</ul>
<h3 id="radeonsi"><a href="#radeonsi" class="headerlink" title="radeonsi"></a>radeonsi</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">si_init_screen_get_functions</span><span class="params">(struct si_screen *sscreen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sscreen-&gt;b.get_name = si_get_name;</span><br><span class="line">  sscreen-&gt;b.get_vendor = si_get_vendor;</span><br><span class="line">  sscreen-&gt;b.get_device_vendor = si_get_device_vendor;</span><br><span class="line">  sscreen-&gt;b.get_param = si_get_param;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)</span><br><span class="line">&#123;</span><br><span class="line">  switch (param) &#123;</span><br><span class="line">    case PIPE_CAP_VIDEO_MEMORY:</span><br><span class="line">      return sscreen-&gt;info.vram_size &gt;&gt; 20;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Radeon驱动中通过<code>drmCommandWriteRead</code>接口获取<code>DRM_RADEON_GEM_INFO</code>中的配置参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Get GEM info. */</span><br><span class="line">retval = drmCommandWriteRead(ws-&gt;fd, DRM_RADEON_GEM_INFO,</span><br><span class="line">        &amp;gem_info, sizeof(gem_info));</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>glxinfo</tag>
        <tag>显存</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习</title>
    <url>/post/36394.html</url>
    <content><![CDATA[<p>OpenGL中的概念与数据渲染流程：<br><img src="/images/2019/11/opengl_pipeline.png" alt="opengl_pipeline"></p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="OpenGL-Context"><a href="#OpenGL-Context" class="headerlink" title="OpenGL Context"></a>OpenGL Context</h3><p>OpenGL上下文代表许多东西。上下文存储与此OpenGL实例关联的所有状态。它表示未绘制到帧缓冲区对象时渲染命令将绘制到的（潜在可见）默认帧缓冲区。将上下文视为拥有所有OpenGL的对象；当上下文被销毁时，OpenGL被销毁。</p>
<blockquote>
<p>In order for any OpenGL commands to work, a context must be current; all OpenGL commands affect the state of whichever context is current. The current context is a thread-local variable, so a single process can have several threads, each of which has its own current context. However, <strong>a single context cannot be current in multiple threads at the same time.</strong><br><a href="https://www.khronos.org/opengl/wiki/OpenGL_Context" target="_blank" rel="noopener">Khronos wiki</a></p>
</blockquote>
<h2 id="OpenGL渲染管线"><a href="#OpenGL渲染管线" class="headerlink" title="OpenGL渲染管线"></a>OpenGL渲染管线</h2><p><img src="/images/2019/11/gl_block_diagram.png" alt="gl_block_diagram"></p>
<p><img src="/images/2019/11/opengl_ops.png" alt="opengl_ops"></p>
<p><img src="/images/2019/11/opengl_render_pipeline.png" alt="OpenGL_render_pipeline"></p>
<ul>
<li>顶点着色</li>
<li>细分着色</li>
<li>几何着色</li>
<li>图元装配<ul>
<li>将顶点与相关的几何图元之间组织起来，准备下一步的剪切和光栅化</li>
</ul>
</li>
<li>剪切<ul>
<li>顶点可能会落到视口（viewport）之外，此时与顶点相关的图元会进行改动，保证像素不会在视口之外绘制，这个过叫剪切，全部由OpenGL自动完成</li>
</ul>
</li>
<li>光栅化<ul>
<li>更新后的图元传递到光栅化单元，生成片元。光栅化的工作是判断某一部分几何体（点，线或者三角形）所覆盖的屏幕空间</li>
</ul>
</li>
<li>片元着色<ul>
<li>通过着色器计算片元的最终颜色</li>
</ul>
</li>
<li>逐片元操作<ul>
<li>使用深度测试（depth test 或者称为z缓存）和模板测试（stencil test）的方式来决定一个片元是否是可见的</li>
</ul>
</li>
</ul>
<p><strong>顶点着色（包括细分和几何着色）决定了一个图元应该位于屏幕的什么位置；片元着色使用这些信息决定某个片元的颜色应该是什么</strong></p>
<h2 id="OpenGL可编程管线"><a href="#OpenGL可编程管线" class="headerlink" title="OpenGL可编程管线"></a>OpenGL可编程管线</h2><p>OpenGL 4.5版本的图形管线有4个阶段，还有1个通用计算阶段。</p>
<ol>
<li>顶点着色阶段（vertex shader stage）</li>
<li>细分着色阶段（tessellation shader stage）<ul>
<li>细分控制着色器（tessellation control shader）</li>
<li>细分赋值着色器（tessellation evaluation shader）</li>
</ul>
</li>
<li>几何着色阶段（geometry shader stage）</li>
<li>片元着色阶段（fragment shader stage）</li>
<li>计算着色阶段（compute shader stage）</li>
</ol>
<h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><h3 id="细分控制着色器（Tessellation-Control-Shader）"><a href="#细分控制着色器（Tessellation-Control-Shader）" class="headerlink" title="细分控制着色器（Tessellation Control Shader）"></a>细分控制着色器（Tessellation Control Shader）</h3><h3 id="细分赋值着色器（Tessellation-Evaluation-Shader）"><a href="#细分赋值着色器（Tessellation-Evaluation-Shader）" class="headerlink" title="细分赋值着色器（Tessellation Evaluation Shader）"></a>细分赋值着色器（Tessellation Evaluation Shader）</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.songho.ca/opengl" target="_blank" rel="noopener">OpenGL</a></li>
<li><a href="https://studiopixl.com/2017-05-13/linux-graphic-stack-an-overview" target="_blank" rel="noopener">Linux graphic stack</a></li>
<li><a href="https://www.cnblogs.com/opencascade/p/4604734.html" target="_blank" rel="noopener">A Simple OpenGL Shader Example</a></li>
<li><a href="http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-2-the-first-triangle/" target="_blank" rel="noopener">opengl tutorial 教程</a></li>
<li><a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">Learn OpenGL【中】</a></li>
<li><a href="https://learnopengl.com/" target="_blank" rel="noopener">Learn OpenGL【英】</a></li>
<li><a href="https://www.scss.tcd.ie/Michael.Manzke/CS7055/Lab2/SuperBible.4th.Ed.Ch8-9.pdf" target="_blank" rel="noopener">CHAPTER8 Texture Mapping: The Basics</a></li>
<li><a href="https://www.khronos.org/registry/OpenGL/specs/gl/glx1.4.pdf" target="_blank" rel="noopener">OpenGLR©Graphics with the X Window System (Version 1.4)</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL纹理——Cubemap Texture</title>
    <url>/post/43690.html</url>
    <content><![CDATA[<blockquote>
<p>A Cubemap Texture is a texture, where each mipmap level consists of six 2D images which must be square. The 6 images represent the faces of a cube. The texture coordinate used to access a cubemap is a 3D direction vector which represents a direction from the center of the cube to the value to be accessed.<br><a href="https://www.khronos.org/opengl/wiki/Cubemap_Texture" target="_blank" rel="noopener">https://www.khronos.org/opengl/wiki/Cubemap_Texture</a></p>
</blockquote>
<a id="more"></a>
<h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mesa: User error: GL_INVALID_ENUM in glSamplerParameteri(pname=GL_TEXTURE_CUBE_MAP_SEAMLESS)</span><br></pre></td></tr></table></figure>
<ul>
<li>错误打印<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> INVALID_PNAME:</span><br><span class="line">_mesa_error(ctx, GL_INVALID_ENUM, <span class="string">"glSamplerParameteri(pname=%s)\n"</span>,</span><br><span class="line">        _mesa_enum_to_string(pname));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>mesa:src/mesa/main/samplerobj.c</p>
</blockquote>
<ul>
<li>错误函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glSamplerParameteri(state-&gt;ids[i], GL_TEXTURE_CUBE_MAP_SEAMLESS, templ-&gt;seamless_cube_map);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="GL-TEXTURE-CUBE-MAP-SEAMLESS"><a href="#GL-TEXTURE-CUBE-MAP-SEAMLESS" class="headerlink" title="GL_TEXTURE_CUBE_MAP_SEAMLESS"></a>GL_TEXTURE_CUBE_MAP_SEAMLESS</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);</span><br></pre></td></tr></table></figure>
<p>立方体贴图的边界利用相邻面线性差值,消除立方体边缘的缝隙</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/06%20Cubemaps/" target="_blank" rel="noopener">立方体贴图(Cubemap)</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>内核版本升级——ubuntu18.04</title>
    <url>/post/15332.html</url>
    <content><![CDATA[<p>linux内核升级笔记：</p>
<a id="more"></a>
<h2 id="内核升级"><a href="#内核升级" class="headerlink" title="内核升级"></a>内核升级</h2><ul>
<li>HWE<blockquote>
<p><a href="https://www.sysgeek.cn/ubuntu-1804-install-linux-kernel-50/" target="_blank" rel="noopener">https://www.sysgeek.cn/ubuntu-1804-install-linux-kernel-50/</a></p>
</blockquote>
</li>
</ul>
<p>Ubuntu 18.04.2 版本包含一个新的「硬件启用堆栈」，即 HWE，该堆栈由较新的Linux Kernel、X.org 图形服务器和图形驱动程序等组成。然而毕竟 LTS 长期支持版本主打的是稳定性，用户不一定希望经常有新内核更新，所以 HWE 不会自动安装到现有系统上，以确保不会破坏任何内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install --install-recommends linux-generic-hwe-18.04 xserver-xorg-hwe-18.04</span><br></pre></td></tr></table></figure>
<ul>
<li>手动升级</li>
</ul>
<blockquote>
<p><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/" target="_blank" rel="noopener">https://kernel.ubuntu.com/~kernel-ppa/mainline/</a></p>
</blockquote>
<p>升级脚本：<a href="https://raw.githubusercontent.com/Winddoing/work_env/master/tools/auto-install/upgrade_latest_kernel.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/Winddoing/work_env/master/tools/auto-install/upgrade_latest_kernel.sh</a></p>
<ul>
<li>ubuntu HWE 支持</li>
</ul>
<blockquote>
<ol>
<li>获取5.3.0内核版本 sudo apt list | grep linux-generic*</li>
<li>能够获取到5.3.0版本之后直接安装 sudo apt install linux-generic-hwe-18.04-edge</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt list | grep linux-generic*</span></span><br><span class="line"></span><br><span class="line">WARNING: apt does not have a stable CLI interface. Use with caution in scripts.</span><br><span class="line"></span><br><span class="line">linux-generic/bionic-updates,bionic-security,now 4.15.0.70.72 amd64 [installed]</span><br><span class="line">linux-generic-hwe-16.04/bionic-updates,bionic-security 4.15.0.70.72 amd64</span><br><span class="line">linux-generic-hwe-16.04-edge/bionic-updates,bionic-security 4.15.0.70.72 amd64</span><br><span class="line">linux-generic-hwe-18.04/bionic-updates,bionic-security 5.0.0.36.94 amd64</span><br><span class="line">linux-generic-hwe-18.04-edge/bionic-updates,bionic-security,now 5.3.0.23.90 amd64 [installed]</span><br><span class="line"></span><br><span class="line">sudo apt install linux-generic-hwe-18.04-edge</span><br></pre></td></tr></table></figure>
<p>更新grub启动配置文件：<code>/boot/grub/grub.cfg</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果系统没有该命令通过<code>sudo apt install grub-efi-amd64 grub-efi-amd64-bin</code>安装</p>
</blockquote>
<ul>
<li>下载当前内核源码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get source linux-image-$(uname -r)</span><br></pre></td></tr></table></figure>
<h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><ul>
<li><p>文本模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>图形模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="源码编译升级"><a href="#源码编译升级" class="headerlink" title="源码编译升级"></a>源码编译升级</h2><blockquote>
<p>系统：ubuntu18.04</p>
</blockquote>
<ul>
<li><p>依赖软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译升级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -v /boot/config-$(uname -r) .config</span><br><span class="line">sh -c 'yes "" | make oldconfig'</span><br><span class="line">make -j4</span><br><span class="line">sudo make modules_install</span><br><span class="line">sudo make install</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>重启时选择最新安装内核启动，通过<code>uname -a</code>确定内核升级是否成功</p>
</blockquote>
<h2 id="列出系统中的所有已安装内核"><a href="#列出系统中的所有已安装内核" class="headerlink" title="列出系统中的所有已安装内核"></a>列出系统中的所有已安装内核</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg --get-selections|grep linux</span><br><span class="line">sudo dpkg --list | grep linux-image</span><br><span class="line">sudo dpkg --list | grep linux-headers</span><br></pre></td></tr></table></figure>
<h2 id="删除不要的内核镜像"><a href="#删除不要的内核镜像" class="headerlink" title="删除不要的内核镜像"></a>删除不要的内核镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge linux-headers-3.13.0-24-generic</span><br><span class="line">sudo apt-get purge linux-image-3.13.0-24-generic</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>anbox_build_for_android</title>
    <url>/post/22129.html</url>
    <content><![CDATA[<p>Anbox 是 “Android in a box” 的缩写。Anbox 是一个基于<code>容器</code>的方法，可以在普通的GNU/Linux系统上启动完整的Android系统。</p>
<blockquote>
<p><a href="https://github.com/anbox/anbox/blob/master/docs/build-android.md" target="_blank" rel="noopener">https://github.com/anbox/anbox/blob/master/docs/build-android.md</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Anbox"><a href="#Anbox" class="headerlink" title="Anbox"></a>Anbox</h2><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>ubuntu18.04 for ARM64<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: ISO C forbids conversion of object pointer to function pointer type [-Werror=pedantic]</span><br><span class="line">   func = (getauxval_func_t*)dlsym(libc_handle, &quot;getauxval&quot;);</span><br><span class="line">             ^</span><br><span class="line">cc1: all warnings being treated as errors</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/31526876/casting-when-using-dlsym" target="_blank" rel="noopener">https://stackoverflow.com/questions/31526876/casting-when-using-dlsym</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-set(C_AND_CXX_WARNINGS &quot;-pedantic -Wall -Wextra&quot;)</span><br><span class="line">+set(C_AND_CXX_WARNINGS &quot;-Wextra&quot;)</span><br></pre></td></tr></table></figure>
<p>删除掉<code>-Wall</code>和<code>-pedantic</code>这两个编译选项，可以正常编译</p>
<ul>
<li><code>-Wall</code>：</li>
<li><code>-pedantic</code>:</li>
</ul>
<h2 id="anbox-modules-binder-ashmem"><a href="#anbox-modules-binder-ashmem" class="headerlink" title="anbox-modules: binder ashmem"></a>anbox-modules: binder ashmem</h2><h3 id="编译binder"><a href="#编译binder" class="headerlink" title="编译binder"></a>编译binder</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@server:# dkms install kernel/binder</span><br><span class="line">Error! DKMS tree already contains: anbox-binder-1</span><br><span class="line">You cannot add the same module/version combo more than once.</span><br><span class="line">root@server:# dkms remove anbox-binder/1 --all</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line">Deleting module version: 1</span><br><span class="line">completely from the DKMS tree.</span><br><span class="line">------------------------------</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>
<h2 id="Android-for-anbox"><a href="#Android-for-anbox" class="headerlink" title="Android-for-anbox"></a>Android-for-anbox</h2><h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo</span><br><span class="line">chmod +x repo</span><br><span class="line">export REPO_URL=&apos;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&apos;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repo init -u https://github.com/anbox/platform_manifests.git -b anbox --depth=1</span><br><span class="line">repo sync -j4</span><br><span class="line">while [ $? -ne 0 ]</span><br><span class="line">do</span><br><span class="line">    repo sync -j4</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<blockquote>
<p>全部代码下载完成后总大小：144G， .repo的大小：125G</p>
</blockquote>
<p>在进行repo sync之前使用清华的源替代谷歌源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;remote  name=&quot;aosp&quot;</span><br><span class="line">         revision=&quot;refs/tags/android-7.1.1_r13&quot;</span><br><span class="line">-           fetch=&quot;https://android.googlesource.com/&quot; /&gt;</span><br><span class="line">+           fetch=&quot;https://aosp.tuna.tsinghua.edu.cn/&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;default revision=&quot;refs/tags/android-7.1.1_r13&quot;</span><br><span class="line">         remote=&quot;aosp&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>From: .repo/manifests/default.xml</p>
</blockquote>
<h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LC_ALL=C</span><br><span class="line">source build/envsetup.sh</span><br><span class="line">lunch anbox_x86_64-userdebug</span><br><span class="line">make -j3</span><br></pre></td></tr></table></figure>
<h3 id="Error-1"><a href="#Error-1" class="headerlink" title="Error"></a>Error</h3><h4 id="aidl-language-l"><a href="#aidl-language-l" class="headerlink" title="aidl_language_l"></a>aidl_language_l</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ninja: Entering directory `.&apos;</span><br><span class="line">[  0% 33/48163] Lex: aidl &lt;= system/tools/aidl/aidl_language_l.ll</span><br><span class="line">FAILED: /bin/bash -c &quot;prebuilts/misc/linux-x86/flex/flex-2.5.39 -oout/host/linux-x86/obj/STATIC_LIBRARIES/libaidl-common_intermediates/aidl_language_l.cpp system/tools/aidl/aidl_language_l.ll&quot;</span><br><span class="line">flex-2.5.39: loadlocale.c:130:_nl_intern_locale_data: ?? &apos;cnt &lt; (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))&apos; ???</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">[  0% 33/48163] JarJar: out/target/common/obj/JAVA_LIBRARIES/bouncycastle_intermediates/classes-jarjar.jar</span><br><span class="line">ninja: build stopped: subcommand failed.</span><br><span class="line">build/core/ninja.mk:148: recipe for target &apos;ninja_wrapper&apos; failed</span><br><span class="line">make: *** [ninja_wrapper] Error 1</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LC_ALL=C</span><br></pre></td></tr></table></figure>
<h4 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 30% 14248/46548] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/with-local/classes.dex</span><br><span class="line">FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/with-local/classes.dex.rsp</span><br><span class="line">Out of memory error (version 1.2-rc4 &apos;Carnac&apos; (298900 f95d7bdecfceb327f9d201a1348397ed8a843843 by android-jack-team@google.com)).</span><br><span class="line">GC overhead limit exceeded.</span><br><span class="line">Try increasing heap size with java option &apos;-Xmx&lt;size&gt;&apos;.</span><br><span class="line">Warning: This may have produced partial or corrupted output.</span><br><span class="line">[ 30% 14248/46548] host C++: libartd &lt;= art/runtime/native/java_lang_ref_FinalizerReference.cc</span><br><span class="line">ninja: build stopped: subcommand failed.</span><br><span class="line">build/core/ninja.mk:148: recipe for target &apos;ninja_wrapper&apos; failed</span><br><span class="line">make: *** [ninja_wrapper] Error 1&gt;</span><br></pre></td></tr></table></figure>
<p>错误日志里边列出了问题并且已经给出了解决方案 - 增加Java虚拟机的<code>-Xmx&lt;size&gt;</code>，即设置一个较大的堆内存上限</p>
<ul>
<li>修改Jack的配置文件<code>prebuilts/sdk/tools/jack-admin</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JACK_SERVER_COMMAND=&quot;java -XX:MaxJavaStackTraceDepth=-1 -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</span><br></pre></td></tr></table></figure>
<p>修改内存：<code>-Xmx4096m</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JACK_SERVER_COMMAND=&quot;java -XX:MaxJavaStackTraceDepth=-1 -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -Xmx4096m -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>重启jack-admin服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./prebuilts/sdk/tools/jack-admin stop-server</span><br><span class="line">./prebuilts/sdk/tools/jack-admin start-server</span><br></pre></td></tr></table></figure>
<h2 id="anbox-images"><a href="#anbox-images" class="headerlink" title="anbox-images"></a>anbox-images</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd $HOME/anbox-work/anbox</span><br><span class="line">$ scripts/create-package.sh \</span><br><span class="line">    $PWD/../out/target/product/x86_64/ramdisk.img \</span><br><span class="line">    $PWD/../out/target/product/x86_64/system.img</span><br></pre></td></tr></table></figure>
<h2 id="anbox-modules"><a href="#anbox-modules" class="headerlink" title="anbox-modules"></a>anbox-modules</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/anbox/anbox-modules.git</span><br></pre></td></tr></table></figure>
<p>在anbox-modules安装完成后，需要对系统进行reboot，否则无法生成<code>/dev/binder</code>节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo modprobe binder_linux num_devices=9</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多容器编译生成binder节点，<code>/dev/binder[0-9]</code></p>
</blockquote>
<h2 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Anbox Container Manager</span><br><span class="line">After=network.target</span><br><span class="line">Wants=network.target</span><br><span class="line">ConditionPathExists=/home/xxx/work1/android-for-anbox/anbox/android.img</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=/sbin/modprobe ashmem_linux</span><br><span class="line">ExecStartPre=/sbin/modprobe binder_linux</span><br><span class="line">ExecStart=/usr/local/bin/anbox container-manager --daemon --privileged --data-path=/home/xxx/work1/android-for-anbox/anbox-data/ --android-image=/home/xxx/work1/android-for-anbox/anbox/android.img --use-rootfs-overlay</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>服务配置文件： <code>/lib/systemd/system/anbox-container-manager.service</code>或<code>/etc/systemd/system/anbox-container-manager.service</code></li>
<li><code>anbox-data</code>为空目录，具体内容容器启动后生成。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start anbox-container-manager</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anbox launch --package=org.anbox.appmgr --component=org.anbox.appmgr.AppViewActivity</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl | grep &quot;anbox&quot;</span><br><span class="line"></span><br><span class="line">anbox system-info</span><br></pre></td></tr></table></figure>
<h3 id="设置anbox服务自动运行"><a href="#设置anbox服务自动运行" class="headerlink" title="设置anbox服务自动运行"></a>设置anbox服务自动运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable anbox-container-manager.service</span><br></pre></td></tr></table></figure>
<h2 id="手动启动"><a href="#手动启动" class="headerlink" title="手动启动"></a>手动启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo anbox container-manager --privileged --data-path=/home/xxx/work1/android-for-anbox/anbox-data/ --android-image=/home/xxx/work1/android-for-anbox/anbox/android.img</span><br></pre></td></tr></table></figure>
<h2 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmcli con add type bridge ifname anbox0 -- connection.id anbox-net ipv4.method shared ipv4.addresses 192.168.250.1/24</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/liangtianmeng/article/details/89522092" target="_blank" rel="noopener">解决Out of memory error (version 1.2-rc4 ‘Carnac’ (298900 … by android-jack-team@google.com)).</a></li>
<li><a href="https://magazine.odroid.com/article/linux-gaming-anbox-android-in-a-box/" target="_blank" rel="noopener">Linux Gaming: Anbox - Android In A Box</a></li>
<li><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=176820" target="_blank" rel="noopener">安卓运行环境Anbox安装/编译说明（20190426)</a></li>
<li><a href="https://www.jianshu.com/p/77e51c6475fc" target="_blank" rel="noopener">运行 Anbox</a></li>
<li><a href="https://portal-www-software.obs.cn-north-1.myhuaweicloud.com/%E8%BD%AF%E4%BB%B6/%E5%9F%BA%E4%BA%8E%E9%B2%B2%E9%B9%8F916%E7%9A%84robox%E5%AE%89%E5%8D%93%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA%E6%8C%87%E5%AF%BC%E4%B9%A6.docx" target="_blank" rel="noopener">robox安卓容器环境搭建指导书</a></li>
</ul>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>anbox</tag>
      </tags>
  </entry>
  <entry>
    <title>Android and Linux</title>
    <url>/post/38002.html</url>
    <content><![CDATA[<p>Android相关笔记</p>
<a id="more"></a>
<h2 id="Linux-kernel"><a href="#Linux-kernel" class="headerlink" title="Linux kernel"></a>Linux kernel</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">git <span class="built_in">clone</span> https://android.googlesource.com/kernel/goldfish.git</span></span><br></pre></td></tr></table></figure>
<p>更改<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">清华源</a>下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">git <span class="built_in">clone</span> https://aosp.tuna.tsinghua.edu.cn/kernel/goldfish.git</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Energy Aware Scheduling</title>
    <url>/post/58199.html</url>
    <content><![CDATA[<p><code>Energy Aware Scheduling(EAS)</code>,EAS调度器的设计目标是在保证系统性能的前提下尽可能地降低功耗。</p>
<ul>
<li>EAS调度器，在Android 7.x之后开始使用???</li>
<li>内核版本:Arm posts v10 of ‘<a href="https://lore.kernel.org/patchwork/cover/1020432/" target="_blank" rel="noopener">Energy Aware Scheduling</a>‘ - merged into Linux-5.0</li>
</ul>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.linaro.org/blog/energy-aware-scheduling-eas-progress-update/" target="_blank" rel="noopener">Energy Aware Scheduling (EAS) progress update</a></li>
<li><a href="https://developer.arm.com/tools-and-software/open-source-software/linux-kernel/energy-aware-scheduling" target="_blank" rel="noopener">Energy Aware Scheduling (EAS)</a></li>
<li><a href="https://blog.csdn.net/rikeyone/article/details/88342382" target="_blank" rel="noopener">HMP调度器和EAS调度器</a></li>
<li><a href="https://blog.csdn.net/pwl999/article/details/78817906" target="_blank" rel="noopener">Linux schedule 5、EAS(Energy-Aware Scheduling)</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>sched</tag>
      </tags>
  </entry>
  <entry>
    <title>GBM for EGL (Linux)</title>
    <url>/post/62365.html</url>
    <content><![CDATA[<blockquote>
<p>Mesa GBM (<code>Generic Buffer Manager</code>) basically provides a EGL native window type (just like Wayland and X11), so one could obtain a real EGL surface and create render target buffers. With that then, GL can be used to render into these buffers, which will be shown to the display by queuing a page flip via KMS/DRM API.</p>
</blockquote>
<p>用户应用程序直接对内存进行管理，通过EGL可以获取真实的EGL表面并创建渲染目标缓冲区</p>
<p><code>gbm</code>（通用缓冲区管理），它提供了一种为Mesa绑定的图形渲染分配缓冲区的机制。GBM旨在被当做一个本地平台为了工作在DRM上的EGL或者openwfd。它创建的句柄可用于初始化EGL和创建渲染目标缓冲区。</p>
<a id="more"></a>
<h2 id="MESA-platform-gbm"><a href="#MESA-platform-gbm" class="headerlink" title="MESA_platform_gbm"></a>MESA_platform_gbm</h2><blockquote>
<p>This extension defines how to create EGL resources from native GBM resources using the functions defined by EGL_EXT_platform_base. (GBM is a <code>Generic Buffer Manager</code> for Linux).</p>
</blockquote>
<h2 id="离屏渲染–简单示例"><a href="#离屏渲染–简单示例" class="headerlink" title="离屏渲染–简单示例"></a>离屏渲染–简单示例</h2><blockquote>
<p><a href="https://github.com/elima/gpu-playground/tree/master/render-nodes-minimal" target="_blank" rel="noopener">https://github.com/elima/gpu-playground/tree/master/render-nodes-minimal</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;EGL/egl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;EGL/eglext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLES3/gl31.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gbm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* a dummy compute shader that does nothing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPUTE_SHADER_SRC <span class="meta-string">"          \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#version 310 es\n                                                       \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                                                                        \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;       \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                                                                        \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void main(void) &#123;                                                       \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">   /* awesome compute code here */                                      \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;                                                                       \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">main (<span class="keyword">int32_t</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">bool</span> res;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int32_t</span> fd = <span class="built_in">open</span> (<span class="string">"/dev/dri/renderD128"</span>, O_RDWR);</span><br><span class="line">   assert (fd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">gbm_device</span> *<span class="title">gbm</span> = <span class="title">gbm_create_device</span> (<span class="title">fd</span>);</span></span><br><span class="line">   assert (gbm != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* setup EGL from the GBM device */</span></span><br><span class="line">   EGLDisplay egl_dpy = eglGetPlatformDisplay (EGL_PLATFORM_GBM_MESA, gbm, <span class="literal">NULL</span>);</span><br><span class="line">   assert (egl_dpy != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   res = eglInitialize (egl_dpy, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">   assert (res);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *egl_extension_st = eglQueryString (egl_dpy, EGL_EXTENSIONS);</span><br><span class="line">   assert (<span class="built_in">strstr</span> (egl_extension_st, <span class="string">"EGL_KHR_create_context"</span>) != <span class="literal">NULL</span>);</span><br><span class="line">   assert (<span class="built_in">strstr</span> (egl_extension_st, <span class="string">"EGL_KHR_surfaceless_context"</span>) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">const</span> EGLint config_attribs[] = &#123;</span><br><span class="line">      EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT_KHR,</span><br><span class="line">      EGL_NONE</span><br><span class="line">   &#125;;</span><br><span class="line">   EGLConfig cfg;</span><br><span class="line">   EGLint count;</span><br><span class="line"></span><br><span class="line">   res = eglChooseConfig (egl_dpy, config_attribs, &amp;cfg, <span class="number">1</span>, &amp;count);</span><br><span class="line">   assert (res);</span><br><span class="line"></span><br><span class="line">   res = eglBindAPI (EGL_OPENGL_ES_API);</span><br><span class="line">   assert (res);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">const</span> EGLint attribs[] = &#123;</span><br><span class="line">      EGL_CONTEXT_CLIENT_VERSION, <span class="number">3</span>,</span><br><span class="line">      EGL_NONE</span><br><span class="line">   &#125;;</span><br><span class="line">   EGLContext core_ctx = eglCreateContext (egl_dpy,</span><br><span class="line">                                           cfg,</span><br><span class="line">                                           EGL_NO_CONTEXT,</span><br><span class="line">                                           attribs);</span><br><span class="line">   assert (core_ctx != EGL_NO_CONTEXT);</span><br><span class="line"></span><br><span class="line">   res = eglMakeCurrent (egl_dpy, EGL_NO_SURFACE, EGL_NO_SURFACE, core_ctx);</span><br><span class="line">   assert (res);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* print some compute limits (not strictly necessary) */</span></span><br><span class="line">   GLint work_group_count[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      glGetIntegeri_v (GL_MAX_COMPUTE_WORK_GROUP_COUNT,</span><br><span class="line">                       i,</span><br><span class="line">                       &amp;work_group_count[i]);</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">"GL_MAX_COMPUTE_WORK_GROUP_COUNT: %d, %d, %d\n"</span>,</span><br><span class="line">           work_group_count[<span class="number">0</span>],</span><br><span class="line">           work_group_count[<span class="number">1</span>],</span><br><span class="line">           work_group_count[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">   GLint work_group_size[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      glGetIntegeri_v (GL_MAX_COMPUTE_WORK_GROUP_SIZE, i, &amp;work_group_size[i]);</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">"GL_MAX_COMPUTE_WORK_GROUP_SIZE: %d, %d, %d\n"</span>,</span><br><span class="line">           work_group_size[<span class="number">0</span>],</span><br><span class="line">           work_group_size[<span class="number">1</span>],</span><br><span class="line">           work_group_size[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">   GLint max_invocations;</span><br><span class="line">   glGetIntegerv (GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS, &amp;max_invocations);</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">"GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS: %d\n"</span>, max_invocations);</span><br><span class="line"></span><br><span class="line">   GLint mem_size;</span><br><span class="line">   glGetIntegerv (GL_MAX_COMPUTE_SHARED_MEMORY_SIZE, &amp;mem_size);</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">"GL_MAX_COMPUTE_SHARED_MEMORY_SIZE: %d\n"</span>, mem_size);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* setup a compute shader */</span></span><br><span class="line">   GLuint compute_shader = glCreateShader (GL_COMPUTE_SHADER);</span><br><span class="line"></span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *shader_source = COMPUTE_SHADER_SRC;</span><br><span class="line"></span><br><span class="line">   glShaderSource (compute_shader, <span class="number">1</span>, &amp;shader_source, <span class="literal">NULL</span>);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   glCompileShader (compute_shader);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   GLuint shader_program = glCreateProgram ();</span><br><span class="line"></span><br><span class="line">   glAttachShader (shader_program, compute_shader);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   glLinkProgram (shader_program);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   glDeleteShader (compute_shader);</span><br><span class="line"></span><br><span class="line">   glUseProgram (shader_program);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* dispatch computation */</span></span><br><span class="line">   glDispatchCompute (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">"Compute shader dispatched and finished successfully\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* free stuff */</span></span><br><span class="line">   glDeleteProgram (shader_program);</span><br><span class="line">   eglDestroyContext (egl_dpy, core_ctx);</span><br><span class="line">   eglTerminate (egl_dpy);</span><br><span class="line">   gbm_device_destroy (gbm);</span><br><span class="line">   <span class="built_in">close</span> (fd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc main.c `pkg-config --libs --cflags egl gbm gl`</span><br></pre></td></tr></table></figure>
<p>主要分4部分：</p>
<ul>
<li>从渲染节点创建GBM设备</li>
<li>设置（无表面的）EGL / OpenGL-ES上下文</li>
<li>创建一个计算着色器程序</li>
<li>调度计算着色器</li>
</ul>
<h2 id="GBM-EGL-OPENGL-render"><a href="#GBM-EGL-OPENGL-render" class="headerlink" title="GBM+EGL+OPENGL+render"></a>GBM+EGL+OPENGL+render</h2><p>利用GBM进行图像的离屏渲染</p>
<blockquote>
<p><a href="https://raw.githubusercontent.com/Winddoing/CodeWheel/master/egl/egl_gbm_render.c" target="_blank" rel="noopener">https://raw.githubusercontent.com/Winddoing/CodeWheel/master/egl/egl_gbm_render.c</a></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.khronos.org/registry/EGL/extensions/MESA/EGL_MESA_platform_gbm.txt" target="_blank" rel="noopener">MESA_platform_gbm</a></li>
<li><a href="https://github.com/eyelash/tutorials/blob/master/drm-gbm.c" target="_blank" rel="noopener">drm gbm demo</a></li>
<li><a href="https://stackoverflow.com/questions/20816844/egldisplay-on-gbm" target="_blank" rel="noopener">EGLDisplay on GBM</a></li>
<li><a href="https://blogs.igalia.com/elima/2016/10/06/example-run-an-opengl-es-compute-shader-on-a-drm-render-node/" target="_blank" rel="noopener">Example: Run a headless OpenGL (ES) compute shader via DRM render-nodes</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>EGL</category>
      </categories>
      <tags>
        <tag>gbm</tag>
        <tag>egl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能测试工具---sysbench</title>
    <url>/post/37666.html</url>
    <content><![CDATA[<p>Linux环境下的性能测试：</p>
<a id="more"></a>
<h2 id="sysbench"><a href="#sysbench" class="headerlink" title="sysbench"></a>sysbench</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install sysbench</span><br></pre></td></tr></table></figure>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/akopytov/sysbench.git</span><br></pre></td></tr></table></figure>
<h3 id="CPU测试"><a href="#CPU测试" class="headerlink" title="CPU测试"></a>CPU测试</h3><p>CPU的性能测试通常有：</p>
<ol>
<li>质数计算；</li>
<li>圆周率计算.</li>
</ol>
<p>cpu测试主要是进行<code>质数加法</code>运算, 找指定范围内最大质数<strong>时间越短，性能越好</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysbench cpu run</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysbench cpu --cpu-max-prime=100000 --num-threads=`grep "processor" /proc/cpuinfo | sort -u | wc -l` run</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mpstat -P ALL 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>间隔1s，打印当前所有CPU核的使用情况</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sysbench cpu run</span></span><br><span class="line">sysbench 1.0.11 (using system LuaJIT 2.1.0-beta3)</span><br><span class="line"></span><br><span class="line">Running the test with following options:</span><br><span class="line">Number of threads: 1  #指定线程数为1</span><br><span class="line">Initializing random number generator from current time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Prime numbers limit: 10000 #每个线程产生的素数上限均为10000个</span><br><span class="line"></span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">CPU speed:</span><br><span class="line">    events per second:  1181.65 #所有线程每秒完成的event次数</span><br><span class="line"></span><br><span class="line">General statistics:</span><br><span class="line">    total time:                          10.0007s #总消耗时间</span><br><span class="line">    total number of events:              11819    #event次数</span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         min:                                  0.78</span><br><span class="line">         avg:                                  0.85</span><br><span class="line">         max:                                  4.57</span><br><span class="line">         95th percentile:                      0.99</span><br><span class="line">         sum:                               9996.65</span><br><span class="line"></span><br><span class="line">Threads fairness:</span><br><span class="line">    events (avg/stddev):           11819.0000/0.00</span><br><span class="line">    execution time (avg/stddev):   9.9967/0.00</span><br></pre></td></tr></table></figure>
<h2 id="圆周率测试"><a href="#圆周率测试" class="headerlink" title="圆周率测试"></a>圆周率测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time echo "scale=5000;4*a(1)"|bc -l -q</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>sysbench</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL调试——apitrace</title>
    <url>/post/65255.html</url>
    <content><![CDATA[<p><code>apitrace</code>是一套用于调试OpenGL应用程序和驱动程序的工具，其中包括用于生成应用程序进行的所有OpenGL调用的跟踪的工具以及用于在程序执行期间重放这些跟踪并检查渲染和OpenGL状态的工具。</p>
<a id="more"></a>
<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><blockquote>
<p><a href="http://apitrace.github.io" target="_blank" rel="noopener">http://apitrace.github.io</a></p>
</blockquote>
<p>源码下载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/janesma/apitrace.git</span><br></pre></td></tr></table></figure></p>
<p>ubuntu安装:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install apitrace apitrace-gui</span><br></pre></td></tr></table></figure></p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="命令行-——-apitrace"><a href="#命令行-——-apitrace" class="headerlink" title="命令行 —— apitrace"></a>命令行 —— apitrace</h3><ul>
<li>全部抓取<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$apitrace trace glxgears</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>生成glxgears.trace文件</p>
<ul>
<li><p>webgl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./apitrace trace --api gl /usr/bin/chromium-browser https://webglsamples.org/aquarium/aquarium.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>重现解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./apitrace replay --pgpu --pcpu --ppd chromium-browser.trace &gt; chromium-browser.retrace</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># call no gpu_start gpu_dura cpu_start cpu_dura vsize_start vsize_dura rss_start rss_dura pixels program name</span><br><span class="line">call 741 0 0 15358963 4741 0 0 0 0 -1 0 glViewport</span><br><span class="line">call 742 0 0 15389926 2370 0 0 0 0 -1 0 glScissor</span><br><span class="line">call 2903 0 0 125774519 8000 0 0 0 0 -1 0 glViewport</span><br><span class="line">call 2904 0 0 125802222 6223 0 0 0 0 -1 0 glScissor</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="图形-——-qapitrace"><a href="#图形-——-qapitrace" class="headerlink" title="图形 —— qapitrace"></a>图形 —— qapitrace</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$qapitrace</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$qapitrace chromium-browser.trace</span><br></pre></td></tr></table></figure>
<h4 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h4><p>选中工具栏Trace下的<code>Profile</code>功能，会执行与replay相同的动作，并将结果更直观的展示出来</p>
<p><img src="/images/2019/12/qapistrace_profile.png" alt="qapistrace-profile"></p>
<blockquote>
<p>将鼠标放到某个函数上会出现提示信息，双击会在主窗口中显示当前函数</p>
</blockquote>
<p>界面说明：</p>
<ul>
<li>第一部分<ul>
<li><code>Frames</code>: 帧号</li>
<li><code>CPU</code>: 处理器端的执行顺序和时长（用宽度表示）</li>
<li><code>GPU</code>: 显卡draw函数的执行顺序和时长</li>
<li><code>编号n</code>: 第n个shader的执行情况</li>
</ul>
</li>
<li>第二部分<ul>
<li><code>GPU</code>、<code>CPU</code>的执行时长（高度）</li>
</ul>
</li>
<li>第三部分<ul>
<li><code>Program</code>: shader的执行情况,左边编号与第一部分相对应</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.x.org/wiki/Events/XDC2016/Program/trukhin_apitrace.pdf" target="_blank" rel="noopener">Apitrace OpenGL profiling view</a></li>
<li><a href="https://blog.simbot.net/index.php/2017/12/09/apitrace/" target="_blank" rel="noopener">使用apitrace分析OpenGL程序性能</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>系统启动引导修复</title>
    <url>/post/15947.html</url>
    <content><![CDATA[<p>在对磁盘分区进行增删以后导致整个系统的磁盘序号错误，会造成系统无法正常启动的现象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: unknown filesystem</span><br><span class="line">Entering rescue mode ...</span><br><span class="line">grub rescue&gt; _</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ls</code>可以看到磁盘分区</p>
</blockquote>
<a id="more"></a>
<h2 id="grub-rescue修复"><a href="#grub-rescue修复" class="headerlink" title="grub rescue修复"></a>grub rescue修复</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grub rescue&gt;ls</span><br><span class="line">grub rescue&gt;set</span><br></pre></td></tr></table></figure></p>
<p>查找ubuntu的boot分区所在磁盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grub rescue&gt;ls (hd0,msdos1)</span><br></pre></td></tr></table></figure>
<p>如果</p>
<h2 id="ubuntu18-04引导修复"><a href="#ubuntu18-04引导修复" class="headerlink" title="ubuntu18.04引导修复"></a>ubuntu18.04引导修复</h2><p>修复工具：<code>boot-repair</code></p>
<p>通过ubuntu的U盘安装进入试用模式，并进行联网</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y boot-repair</span><br><span class="line">boot-repair</span><br></pre></td></tr></table></figure>
<p>根据提示选择yes，直到修复成功。</p>
<h2 id="window引导修复"><a href="#window引导修复" class="headerlink" title="window引导修复"></a>window引导修复</h2><p>通过window PE进行一键修复</p>
<p>修复工具：<code>easyBCD</code></p>
<blockquote>
<p>无法修复ubuntu18.04的引导</p>
</blockquote>
<h2 id="ubuntu-终端乱码"><a href="#ubuntu-终端乱码" class="headerlink" title="ubuntu 终端乱码"></a>ubuntu 终端乱码</h2><blockquote>
<p>改成全英文环境来解决乱码</p>
</blockquote>
<p>在<code>/var/lib/locales/supported.d/en</code>中添加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br></pre></td></tr></table></figure></p>
<p>保存，并执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo locale-gen</span><br></pre></td></tr></table></figure></p>
<p>修改<code>/etc/default/locale</code>中的<code>LANG</code>和<code>LANGUAGE</code>，并重启系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">LANGUAGE=&quot;en_US:en&quot;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/mengfanrong/p/3751185.html" target="_blank" rel="noopener">“error : unknown filesystem”的解决的方法</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>引导</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd原理与使用</title>
    <url>/post/14807.html</url>
    <content><![CDATA[<p><code>Systemd</code>（系统管理守护进程）的主要目的就是减少系统引导时间和计算开销。</p>
<a id="more"></a>
<p>Systemd 的核心是一个叫单元unit的概念，它是一些存有关于<code>服务service</code>（在运行在后台的程序）、<code>设备</code>、<code>挂载点</code>、和操作系统其他方面信息的配置文件。Systemd 的其中一个目标就是简化这些事物之间的相互作用，因此如果你有程序需要在某个挂载点被创建或某个设备被接入后开始运行，Systemd 可以让这一切正常运作起来变得相当容易。</p>
<p><img src="/images/2020/02/systemd_unit.png" alt="systemd_unit"></p>
<p>Systemd中的所有操作都是通过<code>systemctl</code>交互控制</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">systemctl list-unit-files</td>
<td style="text-align:center">列出系统上的所有单元</td>
</tr>
<tr>
<td style="text-align:center">systemctl list-unit-files –type=service</td>
<td style="text-align:center">限制输出列表只包含服务</td>
</tr>
<tr>
<td style="text-align:center">systemctl status ssh.service</td>
<td style="text-align:center">查看服务的状态</td>
</tr>
<tr>
<td style="text-align:center">systemctl stop ssh.service</td>
<td style="text-align:center">停止服务</td>
</tr>
<tr>
<td style="text-align:center">systemctl start ssh.service</td>
<td style="text-align:center">开启服务</td>
</tr>
<tr>
<td style="text-align:center">systemctl enable ssh.service</td>
<td style="text-align:center">设置开机自启</td>
</tr>
<tr>
<td style="text-align:center">systemctl disable ssh.service</td>
<td style="text-align:center">禁止开机自启</td>
</tr>
</tbody>
</table>
<p><code>systemctl list-units --type=target</code>命令可以获取当前正在使用的运行目标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$systemctl list-units --type=target</span><br><span class="line">UNIT                   LOAD   ACTIVE SUB    DESCRIPTION</span><br><span class="line">basic.target           loaded active active Basic System</span><br><span class="line">cryptsetup.target      loaded active active Encrypted Volumes</span><br><span class="line">getty.target           loaded active active Login Prompts</span><br><span class="line">graphical.target       loaded active active Graphical Interface</span><br><span class="line">local-fs-pre.target    loaded active active Local File Systems (Pre)</span><br><span class="line">local-fs.target        loaded active active Local File Systems</span><br><span class="line">multi-user.target      loaded active active Multi-User System</span><br><span class="line">network-online.target  loaded active active Network is Online</span><br><span class="line">network.target         loaded active active Network</span><br><span class="line">nss-user-lookup.target loaded active active User and Group Name Lookups</span><br><span class="line">paths.target           loaded active active Paths</span><br><span class="line">remote-fs.target       loaded active active Remote File Systems</span><br><span class="line">slices.target          loaded active active Slices</span><br><span class="line">sockets.target         loaded active active Sockets</span><br><span class="line">sound.target           loaded active active Sound Card</span><br><span class="line">swap.target            loaded active active Swap</span><br><span class="line">sysinit.target         loaded active active System Initialization</span><br><span class="line">time-sync.target       loaded active active System Time Synchronized</span><br><span class="line">timers.target          loaded active active Timers</span><br><span class="line"></span><br><span class="line">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class="line">ACTIVE = The high-level unit activation state, i.e. generalization of SUB.</span><br><span class="line">SUB    = The low-level unit activation state, values depend on unit type.</span><br><span class="line"></span><br><span class="line">19 loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class="line">To show all installed unit files use &apos;systemctl list-unit-files&apos;.</span><br></pre></td></tr></table></figure>
<h2 id="Systemd-目录"><a href="#Systemd-目录" class="headerlink" title="Systemd 目录"></a>Systemd 目录</h2><ul>
<li><code>/etc/systemd/system</code>：系统或用户自定义的配置文件</li>
<li><code>/run/systemd/system</code>：软件运行时生成的配置文件</li>
<li><code>/usr/lib/systemd/system</code>：系统或第三方软件安装时添加的配置文件。<ul>
<li>CentOS：Unit 文件指向该目录</li>
<li>Ubuntu：被移到了<code>/lib/systemd/system</code></li>
</ul>
</li>
</ul>
<p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录</p>
<h2 id="system配置文件"><a href="#system配置文件" class="headerlink" title="system配置文件"></a>system配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Anbox Container Manager</span><br><span class="line">After=network.target</span><br><span class="line">Wants=network.target</span><br><span class="line">ConditionPathExists=/home/xxx/work1/android-for-anbox/android_x86.img</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=/sbin/modprobe ashmem_linux</span><br><span class="line">ExecStartPre=/sbin/modprobe binder_linux</span><br><span class="line">ExecStart=/usr/local/bin/anbox container-manager --daemon --privileged --data-path=/home/xxx/work1/android-for-anbox/anbox-data/ --android-image=/home/xxx/work1/android-for-anbox/android_x86.img --use-rootfs-overlay</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Unit</code>和<code>Install</code>段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式</li>
<li><code>Service</code> 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法</li>
</ul>
<h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Description</td>
<td style="text-align:center">描述这个 Unit 文件的信息</td>
</tr>
<tr>
<td style="text-align:center">Requires</td>
<td style="text-align:center">依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止</td>
</tr>
<tr>
<td style="text-align:center">After</td>
<td style="text-align:center">与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务</td>
</tr>
<tr>
<td style="text-align:center">Want</td>
<td style="text-align:center">与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功</td>
</tr>
<tr>
<td style="text-align:center">ConditionPathExists</td>
<td style="text-align:center">是指定在服务启动时检查指定文件的存在状态。如果指定的绝对路径名不存在，这个条件的结果就是失败。如果绝对路径的带有!前缀，则条件反转，即只有路径不存在时服务才启动。</td>
</tr>
</tbody>
</table>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ExecStartPre</td>
<td style="text-align:center">指定在ExecStart之前用户自定义执行的脚本</td>
</tr>
<tr>
<td style="text-align:center">ExecStart</td>
<td style="text-align:center">指定启动单元的命令或者脚本</td>
</tr>
</tbody>
</table>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WantedBy</td>
<td style="text-align:center">和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://man.linuxde.net/systemctl" target="_blank" rel="noopener">systemctl命令</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1516125" target="_blank" rel="noopener">可能是史上最全面易懂的 Systemd 服务管理教程</a><a href="https://winddoing.github.io/downloads/linux/systemd.pdf"></a></li>
<li><a href="https://www.cnblogs.com/zhouhbing/p/4021635.html" target="_blank" rel="noopener">systemd服务内容详解</a></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>win10家庭版设置软件安装密码——本地组策略编辑器</title>
    <url>/post/40085.html</url>
    <content><![CDATA[<p>win10版本：<code>家庭版</code><br>操作系统版本：<code>18363.592</code></p>
<blockquote>
<p>设置软件安装密码</p>
</blockquote>
<a id="more"></a>
<h2 id="本地组策略编辑器"><a href="#本地组策略编辑器" class="headerlink" title="本地组策略编辑器"></a>本地组策略编辑器</h2><p>设置方法通过<code>gpedit.msc</code>本地组策略，但是win10家庭版中找不到gpedit.msc，需要手动添加网上找的脚本（测试有效）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line">dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt</span><br><span class="line">dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt</span><br><span class="line">for /f %%i in (&apos;findstr /i . List.txt 2^&gt;nul&apos;) do dism /online /norestart /add-package:&quot;C:\Windows\servicing\Packages\%%i&quot;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>win10专业版默认自带本地组策略编辑器</p>
</blockquote>
<h2 id="设置软件安装策略"><a href="#设置软件安装策略" class="headerlink" title="设置软件安装策略"></a>设置软件安装策略</h2><p><img src="/images/2020/02/win10_gpdeit.png" alt="win10_gpdeit"></p>
<p>双击打开一个用户帐户控制：<code>管理审批模式下管理员的提升提示行为</code> 属性窗口，下拉菜单中点击【提示凭据】</p>
<h2 id="禁止系统软件安装"><a href="#禁止系统软件安装" class="headerlink" title="禁止系统软件安装"></a>禁止系统软件安装</h2><blockquote>
<p>本地组策略编辑器（gpedit.msc） -&gt; 计算机配置 -&gt; 管理模板 -&gt; Window组件 -&gt; Window Installer -&gt; 禁止用户安装 -&gt; （已启用）</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本目录规范——XDG</title>
    <url>/post/ef694e1f.html</url>
    <content><![CDATA[<p><code>XDG</code> Base Directory Specification</p>
<blockquote>
<p>该规范定义了一套指向应用程序的环境变量，这些变量指明的就是这些程序应该存储的基准目录。而变量的具体值取决于用户，若用户未指定，将由程序本身指向一个默认目录，该默认目录也应该遵从标准，而不是用户主目录。</p>
</blockquote>
<a id="more"></a>
<h2 id="环境变量清单：用户层面变量（User-Level-Variables）"><a href="#环境变量清单：用户层面变量（User-Level-Variables）" class="headerlink" title="环境变量清单：用户层面变量（User-Level Variables）"></a>环境变量清单：用户层面变量（User-Level Variables）</h2><h3 id="XDG-DATA-HOME"><a href="#XDG-DATA-HOME" class="headerlink" title="$XDG_DATA_HOME"></a><code>$XDG_DATA_HOME</code></h3><p><code>$XDG_DATA_HOME</code> 定义了应存储用户特定的数据文件的基准目录。默认值是 <code>$HOME/.local/share</code>。</p>
<p>使用场景：</p>
<ul>
<li>用户下载的插件；</li>
<li>程序产生的数据库；</li>
<li>用户输入历史、书签、邮件等。</li>
</ul>
<h3 id="XDG-CONFIG-HOME"><a href="#XDG-CONFIG-HOME" class="headerlink" title="$XDG_CONFIG_HOME"></a><code>$XDG_CONFIG_HOME</code></h3><p><code>$XDG_CONFIG_HOME</code> 定义了应存储用户特定的配置文件的基准目录。默认值是 <code>$HOME/.config</code>。</p>
<p>使用场景：</p>
<ul>
<li>用户配置。</li>
</ul>
<blockquote>
<p>一般来说，这个地方可以在程序初始化的时候存储一个默认的配置文件供加载和修改。</p>
</blockquote>
<h3 id="XDG-CACHE-HOME"><a href="#XDG-CACHE-HOME" class="headerlink" title="$XDG_CACHE_HOME"></a><code>$XDG_CACHE_HOME</code></h3><p><code>$XDG_CACHE_HOME</code> 定义了应存储用户特定的非重要性数据文件的基准目录。默认值是 <code>$HOME/.cache</code>。</p>
<p>使用场景：</p>
<ul>
<li>缓存的缩略图、歌曲文件、视频文件等。</li>
</ul>
<blockquote>
<p>程序应该做到哪怕这个目录被用户删了也能正常运行。</p>
</blockquote>
<h3 id="XDG-RUNTIME-DIR"><a href="#XDG-RUNTIME-DIR" class="headerlink" title="$XDG_RUNTIME_DIR"></a><code>$XDG_RUNTIME_DIR</code></h3><p><code>$XDG_RUNTIME_DIR</code> 定义了应存储用户特定的非重要性运行时文件和一些其他文件对象。</p>
<p>使用场景：</p>
<ul>
<li>套接字 (socket)、命名管道 (named pipes) 等。</li>
</ul>
<blockquote>
<p>该目录必须由用户拥有，并且该用户必须是唯一具有读写访问权限的。 目录的 Unix 访问模式必须是 <code>0700</code>。</p>
</blockquote>
<h2 id="环境变量清单：系统层面变量（System-Level-Variables）"><a href="#环境变量清单：系统层面变量（System-Level-Variables）" class="headerlink" title="环境变量清单：系统层面变量（System-Level Variables）"></a>环境变量清单：系统层面变量（System-Level Variables）</h2><h3 id="XDG-CONFIG-DIRS"><a href="#XDG-CONFIG-DIRS" class="headerlink" title="$XDG_CONFIG_DIRS"></a><code>$XDG_CONFIG_DIRS</code></h3><p><code>$XDG_CONFIG_DIRS</code> 定义了一套按照偏好顺序的基准目录集，用来搜索除了 <code>$XDG_CONFIG_HOME</code> 目录之外的配置文件。该目录中的文件夹应该用冒号（<code>:</code>）隔开。默认值是 <code>/etc/xdg</code>。</p>
<p>使用场景：</p>
<ul>
<li>可以被用户特定的配置文件所覆盖的系统层面的配置文件。</li>
</ul>
<blockquote>
<p>一般来说，应用程序安装的时候可以加载配置文件到这个目录。</p>
</blockquote>
<h3 id="XDG-DATA-DIRS"><a href="#XDG-DATA-DIRS" class="headerlink" title="$XDG_DATA_DIRS"></a><code>$XDG_DATA_DIRS</code></h3><p><code>$XDG_DATA_DIRS</code> 定义了一套按照偏好顺序的基准目录集，用来搜索除了 <code>$XDG_DATA_HOME</code> 目录之外的数据文件。该目录中的文件夹应该用冒号（<code>:</code>）隔开。默认值是 <code>/usr/local/share/:/usr/share/</code>。</p>
<p>使用场景：</p>
<ul>
<li>可以被所有用户使用的插件或者主题。</li>
</ul>
<blockquote>
<p>一般来说，应用程序安装的时候可以加载插件、主题等文件到这个目录。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html" target="_blank" rel="noopener">XDG Base Directory Specification</a></li>
<li><a href="https://songkeys.github.io/posts/xdc-spec/" target="_blank" rel="noopener">消灭泛滥的点文件：XDG 基准目录规范</a></li>
</ul>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>xdg</tag>
      </tags>
  </entry>
  <entry>
    <title>Android模拟器</title>
    <url>/post/40058.html</url>
    <content><![CDATA[<p>Android模拟器开发和调试应用肯定比使用真机方便</p>
<a id="more"></a>
<h2 id="模拟器源码下载"><a href="#模拟器源码下载" class="headerlink" title="模拟器源码下载"></a>模拟器源码下载</h2><p>Android 模拟器源码的下载与 Android AOSP 源码库的下载过程类似。</p>
<p>模拟器的分支：在 <a href="https://android.googlesource.com/platform/manifest/+refs" target="_blank" rel="noopener">https://android.googlesource.com/platform/manifest/+refs</a> 可以看到所有可以指定的分支，包括 Android 分支和模拟器分支，其中模拟器分支主要有如下这些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emu-1.4-release</span><br><span class="line">emu-1.5-release</span><br><span class="line">emu-2.0-release</span><br><span class="line">emu-2.2-release</span><br><span class="line">emu-2.3-release</span><br><span class="line">emu-2.4-arc</span><br><span class="line">emu-2.4-release</span><br><span class="line">emu-2.5-release</span><br><span class="line">emu-2.6-release</span><br><span class="line">emu-2.7-release</span><br><span class="line">emu-2.8-release</span><br><span class="line">emu-29.0-release</span><br><span class="line">emu-3.0-release</span><br><span class="line">emu-3.1-release</span><br><span class="line">emu-gn-dev</span><br><span class="line">emu-master-dev</span><br><span class="line">emu-master-qemu</span><br><span class="line">emu-master-qemu-release</span><br></pre></td></tr></table></figure>
<p>下载最新模拟器代码：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo init -u https://android.googlesource.com/platform/manifest -b emu-master-dev</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在国内可以使用清华源更快下载:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b emu-master-dev</span></span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd external/qemu/android/</span><br><span class="line">./rebuild.sh --no-tests</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>--no-tests</code>: 告诉编译系统，编译完成之后不要执行测试程序，以节省时间，提高效率</li>
</ul>
</blockquote>
<h2 id="Android-Hardware-OpenGLES-emulation-design-overview"><a href="#Android-Hardware-OpenGLES-emulation-design-overview" class="headerlink" title="Android Hardware OpenGLES emulation design overview"></a>Android Hardware OpenGLES emulation design overview</h2><blockquote>
<p>path: <code>external/qemu/android/android-emugl/DESIGN</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_________            __________          __________</span><br><span class="line">|         |          |          |        |          |</span><br><span class="line">|EMULATION|          |EMULATION |        |EMULATION |     GUEST</span><br><span class="line">|   EGL   |          | GLES 1.1 |        | GLES 2.0 |     SYSTEM</span><br><span class="line">|_________|          |__________|        |__________|     LIBRARIES</span><br><span class="line">    ^                    ^                    ^</span><br><span class="line">    |                    |                    |</span><br><span class="line">- - | - - - - - - - - -  | - - - - - - - - -  | - - - - -</span><br><span class="line">    |                    |                    |</span><br><span class="line">____v____________________v____________________v____      GUEST</span><br><span class="line">|                                                   |     KERNEL</span><br><span class="line">|                       QEMU PIPE                   |</span><br><span class="line">|___________________________________________________|</span><br><span class="line">                        ^</span><br><span class="line">                        |</span><br><span class="line"> - - - - - - - - - - - -|- - - - - - - - - - - - - - - -</span><br><span class="line">                        |</span><br><span class="line">                        |    PROTOCOL BYTE STREAM</span><br><span class="line">                   _____v_____</span><br><span class="line">                  |           |</span><br><span class="line">                  |  EMULATOR |</span><br><span class="line">                  |___________|</span><br><span class="line">                        ^</span><br><span class="line">                        |   UNMODIFIED PROTOCOL BYTE STREAM</span><br><span class="line">                   _____v_____</span><br><span class="line">                  |           |</span><br><span class="line">                  |  RENDERER |</span><br><span class="line">                  |___________|</span><br><span class="line">                      ^ ^  ^</span><br><span class="line">                      | |  |</span><br><span class="line">    +-----------------+ |  +-----------------+</span><br><span class="line">    |                   |                    |</span><br><span class="line">____v____            ___v______          ____v_____</span><br><span class="line">|         |          |          |        |          |</span><br><span class="line">|TRANSLATOR          |TRANSLATOR|        |TRANSLATOR|     HOST</span><br><span class="line">|   EGL   |          | GLES 1.1 |        | GLES 2.0 |     TRANSLATOR</span><br><span class="line">|_________|          |__________|        |__________|     LIBRARIES</span><br><span class="line">    ^                    ^                    ^</span><br><span class="line">    |                    |                    |</span><br><span class="line">- - | - - - - - - - - -  | - - - - - - - - -  | - - - - -</span><br><span class="line">    |                    |                    |</span><br><span class="line">____v____            ____v_____          _____v____      HOST</span><br><span class="line">|         |          |          |        |          |     SYSTEM</span><br><span class="line">|   GLX   |          |  GL 2.0  |        |  GL 2.0  |     LIBRARIES</span><br><span class="line">|_________|          |__________|        |__________|</span><br><span class="line"></span><br><span class="line">(NOTE: &apos;GLX&apos; is for Linux only, replace &apos;AGL&apos; on OS X, and &apos;WGL&apos; on Windows).</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL之Sync Object</title>
    <url>/post/8528.html</url>
    <content><![CDATA[<blockquote>
<p><em>Sync Objects</em> are objects that are used to synchronize the activity between the GPU and the application. <code>glFinish</code> is a start to synchronization, but sync objects allow for much finer grained control.</p>
<ul>
<li><a href="https://www.khronos.org/opengl/wiki/Sync_Object" target="_blank" rel="noopener">https://www.khronos.org/opengl/wiki/Sync_Object</a></li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">GLsync</span> *<span class="title">GLsync</span>;</span></span><br></pre></td></tr></table></figure>
<p><code>GLsync</code>同步对象永远不会绑定到上下文，也不会像普通GL对象一样封装状态。 这些不是OpenGL对象。</p>
<p>有一个通用的glDeleteSync函数可删除任何类型的同步对象。</p>
<h2 id="图像渲染"><a href="#图像渲染" class="headerlink" title="图像渲染"></a>图像渲染</h2><p>egl为opengl的执行创建了一个上下文Context。这时Context中绑定了一个默认的Framebuffer。后续所有的渲染都是在这个framebuffer上进行的。</p>
<p>当我们调用<code>drawcall</code>来绘制一组三维物体的时候，实际上这个<code>drawcall</code>并没有立即执行，或者说并不保证立即执行了，gl库的实现也可能只是制作了一个命令队列，往这个命令队列里填加了一些命令，当你调用下一条opengl函数时，上一个函数会没有被执行，它还在排队。也就是说普通的opengl函数是异步的。</p>
<p>所有的opengl函数都是异步的肯定是不行的，有些时候我们必须保证某个函数返回时，它及它之前的函数都真正被执行了。也就是说要有一些不普通的函数，它们是同步的。比如说<code>glFinish</code>，当这个函数返回时，gl库会保证之前的命令全部都执行完毕了。</p>
<p>还有<code>glFlush</code>，gl库会立即把队列里的所有命令提交给显卡去执行一轮。<br>在glFlush和glFinsh之后的函数调用，都会落在下一轮渲染管线执行中了。</p>
<blockquote>
<p><code>drawcall</code>的标志很简单，一个<code>glDrawXXX</code>函数调用就是一个drawcall的结束标志。</p>
</blockquote>
<h2 id="同步——Synchronization"><a href="#同步——Synchronization" class="headerlink" title="同步——Synchronization"></a>同步——Synchronization</h2><p>同步对象的目的是使CPU与GPU的动作同步。为此，同步对象具有当前状态的概念。同步对象的状态可以发信号或不发信号。此状态代表GPU的某种状态，具体取决于同步对象的特定类型及其使用方式。这类似于使用互斥在线程之间同步行为的方式。当发出互斥信号时，它允许正在等待它的其他线程激活。</p>
<ul>
<li><p>要阻塞所有CPU操作，直到发出同步对象信号为止</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> <span class="title">glClientWaitSync</span><span class="params">(GLsync sync, GLbitfield flags, GLuint64 timeout)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指示GL服务器阻塞，直到发出指定的同步对象信号为止</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glWaitSync</span><span class="params">(GLsync sync, GLbitfield flags, GLuint64 timeout)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h2><h3 id="glFenceSync"><a href="#glFenceSync" class="headerlink" title="glFenceSync"></a>glFenceSync</h3><blockquote>
<p><code>glFenceSync</code> — create a new sync object and insert it into the GL command stream</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">GLsync <span class="title">glFenceSync</span><span class="params">(GLenum condition,</span></span></span><br><span class="line"><span class="function"><span class="params">  	             GLbitfield flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>glFenceSync创建一个新的fence同步对象，将fence命令插入GL命令流并将其与该同步对象相关联，并返回与该同步对象相对应的非零名称。</p>
<p>当fence命令满足了同步对象的指定条件时，GL将向该同步对象发出信号，从而使所有在同步中阻塞的glWaitSync和glClientWaitSync命令解除阻塞。 glFenceSync或关联的fence命令的执行不会影响其他任何状态。</p>
<p>条件必须为GL_SYNC_GPU_COMMANDS_COMPLETE。通过完成与同步对象相对应的fence命令以及同一命令流中的所有先前命令，可以满足此条件。在完全实现这些命令对GL客户端和服务器状态以及帧缓冲区的所有影响之前，不会发信号通知同步对象。请注意，一旦更改了相应同步对象的状态，便会完成fence命令，但是直到fence命令完成后，等待该同步对象的命令才可能被释放。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">GLsync sync = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">glWaitSync(sync, <span class="number">0</span>, GL_TIMEOUT_IGNORED);</span><br><span class="line">glDeleteSync(sync);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.khronos.org/opengl/wiki/Sync_Object" target="_blank" rel="noopener">Sync Object</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>Xvfb —— 虚拟X server</title>
    <url>/post/64072.html</url>
    <content><![CDATA[<blockquote>
<p>Xvfb − virtual framebuffer X server for X Version 11</p>
</blockquote>
<p><code>Xvfb</code>是一个X server，主要用于在没有显示设备的主机上，进行拥有图形界面程序的运行。比如自动化测试</p>
<blockquote>
<p>Xvfb is an X server that can run on machines with no display hardware and no physical input devices. It emulates a dumb framebuffer using virtual memory.</p>
</blockquote>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install xvfb</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Xvfb -ac :3 -screen 0 1280x1024x24 &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">export DISPLAY=:3</span><br></pre></td></tr></table></figure>
<h2 id="VNC测试"><a href="#VNC测试" class="headerlink" title="VNC测试"></a>VNC测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x11vnc -display :3 -N -forever -shared -reopen -passwd 123456 -desktop 1 -bg -q</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The VNC desktop is:      xxx-pc:3</span><br><span class="line">PORT=5903</span><br></pre></td></tr></table></figure></p>
<p>由于是本地测试，通过<code>remmina</code>登录VNC<code>127.0.0.1:5903</code>，将获取到<code>DISPLAY=:3</code>窗口的所有屏幕输出。比如此时在终端执行glxgears，将在vnc远端获取到图像。</p>
<p>测试脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">killall x11vnc</span><br><span class="line">killall glxgears</span><br><span class="line"></span><br><span class="line">Xvfb -ac :3 -screen 0 1280x1024x24 &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">export DISPLAY=:3</span><br><span class="line"></span><br><span class="line">x11vnc -display :3 -N -forever -shared -reopen -passwd 123456 -desktop 1 -bg -q</span><br><span class="line">echo "Password: 123456"</span><br><span class="line"></span><br><span class="line">glxgears &amp;</span><br></pre></td></tr></table></figure>
<p>VNC登录：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vncviewer 127.0.0.1:5903</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>xvfb</tag>
        <tag>x11</tag>
      </tags>
  </entry>
  <entry>
    <title>Zink for OpenGL</title>
    <url>/post/27461.html</url>
    <content><![CDATA[<p><code>Zink</code>是Gallium 3D的驱动程序，主要是在vulkan上实现OpenGL API接口</p>
<blockquote>
<p>Zink is a Gallium driver that translate gallium API calls into Vulkan calls</p>
</blockquote>
<p><img src="/images/2020/03/mesa_gallium_zink.png" alt="mesa_gallium_zink"></p>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://xdc2019.x.org/event/5/contributions/329/attachments/433/687/XDC2019-Zink-slide-deck.pdf" target="_blank" rel="noopener">Zink: OpenGL on Vulkan</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>zink</tag>
        <tag>mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透——cpolar</title>
    <url>/post/28389.html</url>
    <content><![CDATA[<p><code>cpolar</code>工具从家庭或本地网络外部访问内网设备，比如树莓派、群晖等。</p>
<a id="more"></a>
<h2 id="cpolar"><a href="#cpolar" class="headerlink" title="cpolar"></a>cpolar</h2><p>cpolar是一种安全的隧道服务，可以在任何地方在线提供您的设备。 隧道是一种在两台计算机之间通过互联网等公共网络建立专线的方法。 当您在两台计算机之间设置隧道时，它应该是安全且私有的，并且能够通过网络障碍，如端口阻塞路由器和防火墙。 这是一个方便的服务，允许您在安全的无线网络或防火墙后面将请求从公共互联网连接到本地计算机。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.cpolar.com/static/downloads/cpolar-stable-linux-amd64.zip</span><br><span class="line"></span><br><span class="line">unzip cpolar-stable-linux-amd64.zip</span><br></pre></td></tr></table></figure>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>在<a href="https://dashboard.cpolar.com" target="_blank" rel="noopener">cpolar官网</a>注册账户，以获取authtoken密钥。使用免费版本，您每次希望建立远程连接并与远程用户共享地址时，都必须从本地生成主机地址。</p>
<ul>
<li>本地添加token认证</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cpolar authtoken  &lt;yourauthtoken&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行一次认证，它就会存储在配置文件中<code>/home/user/.cpolar/cpolar.yml</code></p>
</blockquote>
<h2 id="SSH穿透"><a href="#SSH穿透" class="headerlink" title="SSH穿透"></a>SSH穿透</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cpolar tcp 22</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpolar by @bestexpresser</span><br><span class="line"></span><br><span class="line">Tunnel Status                 online</span><br><span class="line">Account                       xxx (Plan: Free)</span><br><span class="line">Version                       2.62/2.58</span><br><span class="line">Web Interface                 127.0.0.1:4040</span><br><span class="line">Forwarding                    tcp://1.tcp.cpolar.io:1111 -&gt; tcp://127.0.0.1:22</span><br><span class="line"># Conn                        0</span><br><span class="line">Avg Conn Time                 0.00ms</span><br></pre></td></tr></table></figure>
<h3 id="远程连接访问"><a href="#远程连接访问" class="headerlink" title="远程连接访问"></a>远程连接访问</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -p &lt;cpolar公网端口号&gt;  &lt;用户名@1.tcp.cpolar.io&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -p 1111 username@1.tcp.cpolar.io</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>cpolar</tag>
      </tags>
  </entry>
  <entry>
    <title>网络配置</title>
    <url>/post/18692.html</url>
    <content><![CDATA[<p>Linux系统中的相关网络配置问题</p>
<a id="more"></a>
<h2 id="网线不识别，网卡灯不亮"><a href="#网线不识别，网卡灯不亮" class="headerlink" title="网线不识别，网卡灯不亮"></a>网线不识别，网卡灯不亮</h2><blockquote>
<p>关闭网卡的自动协商功能，手动配置网卡速度和工作模式</p>
</blockquote>
<p>解决命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ethtool -s enahisic2i0 autoneg off speed 100 duplex full</span><br></pre></td></tr></table></figure></p>
<h3 id="ethtool"><a href="#ethtool" class="headerlink" title="ethtool"></a>ethtool</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ethtool [-s] ethX [speed 10|100|1000] [duplex half|full] [autoneg on|off] [port tp|aui|bnc|mii] [phyad N]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-s</code>: 修改网卡的部分配置，包括网卡速度、单工/全双工模式、mac地址等</li>
<li><code>autoneg on|off</code>: 设置网口是否自协商</li>
<li><code>duplex half|full</code>: 设置网口半/全双工</li>
<li><code>speed 10|100|1000</code>: 设置网口速率10/100/1000M</li>
</ul>
<h2 id="netplan配置"><a href="#netplan配置" class="headerlink" title="netplan配置"></a>netplan配置</h2><p><img src="/images/2020/03/network_netplan.png" alt="network_netplan"></p>
<h3 id="图形界面网络管理配置"><a href="#图形界面网络管理配置" class="headerlink" title="图形界面网络管理配置"></a>图形界面网络管理配置</h3><p><code>NetworkManager</code>主要用于在桌面系统上管理网络设备。如果您使用<code>NetworkManager</code>作为网络设备管理的系统守护程序，将会使用 NetworkManager 的图形程序来管理网络接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"># For more information, see netplan(5).</span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br></pre></td></tr></table></figure>
<blockquote>
<p>File: /etc/netplan/01-netcfg.yaml</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan generate</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247484080&amp;idx=1&amp;sn=3c5ca66a2dc63c285ca6d2db39f7e553&amp;mpshare=1&amp;scene=23&amp;srcid=0613Bf6KoICw4XVpI9CZzkGE%23rd" target="_blank" rel="noopener">YAML语言教程</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>C与C++混合编译</title>
    <url>/post/74f3b3c3.html</url>
    <content><![CDATA[<p>在C代码中引用C++编译的库时，编译错误处理</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&apos;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&apos;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&apos;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&apos;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&apos;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&apos;</span><br><span class="line">undefined reference to `__cxa_free_exception&apos;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&apos;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&apos;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&apos;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&apos;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&apos;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链接时的错误信息</p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="编译器版本不兼容"><a href="#编译器版本不兼容" class="headerlink" title="编译器版本不兼容"></a>编译器版本不兼容</h3><p>添加编译选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-D_GLIBCXX_USE_CXX11_ABI=1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>cmake: <code>add_definitions(-D_GLIBCXX_USE_CXX11_ABI=1)</code></p>
</blockquote>
<h3 id="未引用C-库"><a href="#未引用C-库" class="headerlink" title="未引用C++库"></a>未引用C++库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-lstdc++</span><br></pre></td></tr></table></figure>
<blockquote>
<p>camke: <code>target_link_libraries(exe_target stdc++)</code></p>
</blockquote>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>编译</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>meson编译规则</title>
    <url>/post/434f8def.html</url>
    <content><![CDATA[<p>在meson编译的项目中添加修改编译规则</p>
<a id="more"></a>
<h2 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h2><p>添加OpenGL依赖库示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libgl_dep = dependency(&apos;GL&apos;)</span><br><span class="line"></span><br><span class="line">test_sources = [</span><br><span class="line">   &apos;test.c&apos;,</span><br><span class="line">   &apos;test.h&apos;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">test = executable(</span><br><span class="line">   &apos;test.out&apos;,</span><br><span class="line">   test_sources,</span><br><span class="line">   dependencies : [libsdl_dep, libgl_dep],</span><br><span class="line">   install : true</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="Built-in-options"><a href="#Built-in-options" class="headerlink" title="Built-in options"></a>Built-in options</h2><blockquote>
<p><a href="https://mesonbuild.com/Builtin-options.html" target="_blank" rel="noopener">https://mesonbuild.com/Builtin-options.html</a></p>
</blockquote>
<ul>
<li><code>b_vscrt</code>: 为工程在window下通过mesa使用MSVC进行编译,如<code>-Db_vscrt=mtd</code></li>
</ul>
<h3 id="Base-options"><a href="#Base-options" class="headerlink" title="Base options"></a>Base options</h3><table>
<thead>
<tr>
<th>Option</th>
<th>Default value</th>
<th>Possible values</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>b_vscrt</td>
<td>from_buildtype</td>
<td>none, md, mdd, mt, mtd, from_buildtype</td>
<td>VS runtime library to use (since 0.48.0)</td>
</tr>
</tbody>
</table>
<h2 id="Native-file-properties"><a href="#Native-file-properties" class="headerlink" title="Native file properties"></a>Native file properties</h2><blockquote>
<p>As of Meson 0.54.0, the <code>--native-file nativefile.ini</code> can contain:</p>
<ul>
<li>binaries</li>
<li>paths</li>
<li>properties</li>
</ul>
</blockquote>
<ul>
<li><a href="https://mesonbuild.com/Release-notes-for-0-54-0.html#page-description" target="_blank" rel="noopener">https://mesonbuild.com/Release-notes-for-0-54-0.html#page-description</a></li>
<li><a href="https://mesonbuild.com/Contributing.html#page-description" target="_blank" rel="noopener">https://mesonbuild.com/Contributing.html#page-description</a></li>
</ul>
<p>本机文件属性,这里主要是指定meson在配置阶段加载本机的文件路径.用到它是因为本机的llvm存在多个版本,meson配置阶段总是加载最高版本的llvm-config-10,而我想用相对低版本(llvm-config-8),通过meson<a href="https://mesonbuild.com" target="_blank" rel="noopener">手册</a>可以通过<code>--native-file nativefile.ini</code>进行指定</p>
<p>版本大于<code>0.54.0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ls -lsh /usr/bin/llvm-config-10</span></span><br><span class="line">0 lrwxrwxrwx 1 root root 30 4月  20 13:12 /usr/bin/llvm-config-10 -&gt; ../lib/llvm-10/bin/llvm-config</span><br><span class="line"><span class="meta">$</span><span class="bash">ls -lsh /usr/bin/llvm-config-8</span></span><br><span class="line">0 lrwxrwxrwx 1 root root 29 3月  19 16:50 /usr/bin/llvm-config-8 -&gt; ../lib/llvm-8/bin/llvm-config</span><br><span class="line"><span class="meta">$</span><span class="bash">ls -lsh /usr/bin/llvm-config-7</span></span><br><span class="line">0 lrwxrwxrwx 1 root root 29 3月  23 18:59 /usr/bin/llvm-config-7 -&gt; ../lib/llvm-7/bin/llvm-config</span><br></pre></td></tr></table></figure>
<p>~使用软链接修改<code>llvm-config</code>的路径测试,配置是依旧加载<code>llvm-config-10</code>,软连接方式不行~</p>
<h3 id="nativefile-ini"><a href="#nativefile-ini" class="headerlink" title="nativefile.ini"></a>nativefile.ini</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[binaries]</span><br><span class="line">llvm-config = &apos;/usr/lib/llvm-8/bin/llvm-config&apos;</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">meson builddir/ --native-file nativefile.ini</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>meson</tag>
        <tag>build</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos源码编译安装gcc</title>
    <url>/post/bb09b834.html</url>
    <content><![CDATA[<p>升级centos中默认的gcc版本</p>
<a id="more"></a>
<h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y gcc gcc-c++ gcc-gnat libgcc libgcc.i686 glibc-devel bison flex texinfo build-essential</span><br></pre></td></tr></table></figure>
<h2 id="下载gcc源码"><a href="#下载gcc源码" class="headerlink" title="下载gcc源码"></a>下载gcc源码</h2><blockquote>
<p>最新的gcc版本：<a href="http://ftp.gnu.org/gnu/gcc" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/gcc</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-8.2.0/gcc-8.2.0.tar.xz</span><br><span class="line">tar -xJvf gcc-8.2.0.tar.xz</span><br></pre></td></tr></table></figure>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><h3 id="下载编译依赖库"><a href="#下载编译依赖库" class="headerlink" title="下载编译依赖库"></a>下载编译依赖库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd gcc-8.2.0</span><br><span class="line">./contrib/download_prerequisites</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要等一段时间，下载并解压完成，无需手动编译，下面编译时会自动编译安装</p>
</blockquote>
<h3 id="编译安装-1"><a href="#编译安装-1" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd gcc-8.2.0</span><br><span class="line">./configure --prefix=/usr/local/gcc-8.2.0</span><br><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="指定运行库"><a href="#指定运行库" class="headerlink" title="指定运行库"></a>指定运行库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/ld.so.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"></span><br><span class="line">/usr/local/gcc-8.2.0/lib</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更新运行库文件的缓存：<code>ldconfig -v</code></p>
</blockquote>
<h2 id="scl软件集"><a href="#scl软件集" class="headerlink" title="scl软件集"></a>scl软件集</h2><h3 id="安装scl源"><a href="#安装scl源" class="headerlink" title="安装scl源"></a>安装scl源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br></pre></td></tr></table></figure>
<h3 id="列出scl有哪些可用软件"><a href="#列出scl有哪些可用软件" class="headerlink" title="列出scl有哪些可用软件"></a>列出scl有哪些可用软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list all --enablerepo='centos-sclo-rh'</span><br></pre></td></tr></table></figure>
<h3 id="安装gcc8"><a href="#安装gcc8" class="headerlink" title="安装gcc8"></a>安装gcc8</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install devtoolset-8-gcc.x86_64</span><br></pre></td></tr></table></figure>
<h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scl enable devtoolset-4 bash</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/444169a3721a" target="_blank" rel="noopener">Centos7.5下源码编译安装gcc-8.2.0</a></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 搭建 Nextcloud</title>
    <url>/post/efa23dc6.html</url>
    <content><![CDATA[<p>系统：ubuntu18.04</p>
<p>搭建个人网盘</p>
<a id="more"></a>
<h2 id="Docker环境"><a href="#Docker环境" class="headerlink" title="Docker环境"></a>Docker环境</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol>
<li><p>添加可信任的 GPG 公钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 GPG 公钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-key fingerprint 0EBFCD88</span><br><span class="line"><span class="meta">$</span><span class="bash">apt-key fingerprint 0EBFCD88</span></span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">     9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加镜像源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu  $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 Docker-CE 及其依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y docker-ce</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>
<h3 id="Docker-镜像加速器"><a href="#Docker-镜像加速器" class="headerlink" title="Docker 镜像加速器"></a>Docker 镜像加速器</h3><ol>
<li><p>添加网易云 Docker 镜像加速器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s https://hub-mirror.c.163.com/</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 Docker 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 Docker 是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="安装-docker-compose-工具"><a href="#安装-docker-compose-工具" class="headerlink" title="安装 docker-compose 工具"></a>安装 docker-compose 工具</h2><p>docker-compose 是一个由 Docker 官方提供的管理工具，适合一个应用需要多个容器配合统一管理，进一步简化应用部署、应用升级步骤。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y python3 python3-pip</span><br><span class="line">sudo pip3 install docker-compose</span><br></pre></td></tr></table></figure>
<p>在安装<code>docker-compose</code>时，由于网络原因下载可能会总超时，可以使用该脚本安装直到成功<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip3 install docker-compose</span><br><span class="line">while [ $? != 0 ]; do</span><br><span class="line">    sleep 3</span><br><span class="line">    sudo pip3 install docker-compose</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<h3 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h3><p>进入<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">https://github.com/docker/compose/releases</a> 查看最新版本，选择当前版本为<code>1.25.5</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` -o docker-compose</span><br><span class="line">chmod +x docker-compose</span><br></pre></td></tr></table></figure>
<p>查看是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./docker-compose --version</span><br></pre></td></tr></table></figure>
<h2 id="安装nextcloud"><a href="#安装nextcloud" class="headerlink" title="安装nextcloud"></a>安装nextcloud</h2><ol>
<li>编写docker-compose.yml文件<br>docker-compose 的管理主要依赖于一个名为 docker-compose.yml 的 yaml 文件来进行管理，当然这个文件也可以以任何别的名称并以<code>-f filename</code>的方式来启用，但必须是符合yaml格式和Docker官方定义的字段和方式。</li>
</ol>
<ol start="2">
<li>启动容器<br>以下命令即可开始拉取所需容器的镜像文件并根据<code>docker-compose.yml</code>文件配置好本地文件夹挂载和端口映射。（由于需要拉取镜像，可能需要等一段时间，与当前网络环境相关。）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./docker–compose up –d</span><br></pre></td></tr></table></figure>
<p>查看容器是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>应用初始化配置</li>
</ol>
<p>访问 http://<ip 地址> 设置管理员用户名和密码（比如 admin 和 <a href="mailto:admin@nextcloud.com" target="_blank" rel="noopener">admin@nextcloud.com</a> ），数据目录默认即可，数据库信息填写如 docker-composer.yml 中所示，数据库主机名填 db （配置文件中的数据库应用名）</ip></p>
<ol start="4">
<li>更新应用至最新版</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull nextcloud</span><br><span class="line">sudo ./docker-compose down &amp;&amp; sudo ./docker-compose up -d</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://tsov.net/home/view/2077/" target="_blank" rel="noopener">Nginx配合docker安装nextcloud</a></li>
<li><a href="https://blog.csdn.net/weixin_36851500/article/details/90409195" target="_blank" rel="noopener">Docker 搭建 Nextcloud</a></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下硬盘检查</title>
    <url>/post/f6f2a529.html</url>
    <content><![CDATA[<p>通过<code>hdparm</code>、<code>smartctl</code>、<code>badblocks</code>等命令，获取硬盘详细信息和测试硬盘读取速度等</p>
<a id="more"></a>
<h2 id="hdparm"><a href="#hdparm" class="headerlink" title="hdparm"></a>hdparm</h2><blockquote>
<p>可检测，显示与设定IDE或SCSI硬盘的参数</p>
</blockquote>
<p><img src="/images/2020/05/tool_hdparm_cmd.png" alt="tool_hdparm_cmd"><br><strong>hdparm的改变的配置是个临时的状态，下次启动Linux系统的时候hdparm的配置将会消失，如果需要必须加入开机启动脚本<code></code></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo hdparm  /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> multcount     = 16 (on)</span><br><span class="line"> IO_support    =  1 (32-bit)</span><br><span class="line"> readonly      =  0 (off)</span><br><span class="line"> readahead     = 256 (on)</span><br><span class="line"> geometry      = 121601/255/63, sectors = 1953525168, start = 0</span><br></pre></td></tr></table></figure>
<h3 id="测试读取速度"><a href="#测试读取速度" class="headerlink" title="测试读取速度"></a>测试读取速度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo hdparm -tT /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> Timing cached reads:   9084 MB in  1.99 seconds = 4560.73 MB/sec</span><br><span class="line"> Timing buffered disk reads: 418 MB in  3.01 seconds = 139.02 MB/sec</span><br></pre></td></tr></table></figure>
<h3 id="检测硬盘的电源管理模式"><a href="#检测硬盘的电源管理模式" class="headerlink" title="检测硬盘的电源管理模式"></a>检测硬盘的电源管理模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo hdparm -C /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> drive state is:  active/idle</span><br></pre></td></tr></table></figure>
<h3 id="进入省电模式"><a href="#进入省电模式" class="headerlink" title="进入省电模式"></a>进入省电模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo hdparm -Y /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> issuing sleep command</span><br></pre></td></tr></table></figure>
<h3 id="设置硬盘省电策略"><a href="#设置硬盘省电策略" class="headerlink" title="设置硬盘省电策略"></a>设置硬盘省电策略</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo hdparm -S 60 /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> setting standby to 60 (5 minutes)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在无数据访问后，5分钟硬盘自动停转进入休眠模式</p>
</blockquote>
<p><strong><code>0</code>表示“超时已禁用”：设备不会自动进入待机模式。从1到240指定5秒的倍数，产生5秒到20分钟的超时。</strong></p>
<h2 id="smartctl"><a href="#smartctl" class="headerlink" title="smartctl"></a>smartctl</h2><blockquote>
<p><code>SMART</code>是一种磁盘自我分析检测技术</p>
</blockquote>
<h3 id="获取硬盘详细信息"><a href="#获取硬盘详细信息" class="headerlink" title="获取硬盘详细信息"></a>获取硬盘详细信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo smartctl -i /dev/sdb</span></span><br><span class="line">smartctl 7.1 2019-12-30 r5022 [x86_64-linux-5.4.0-31-generic] (local build)</span><br><span class="line">Copyright (C) 2002-19, Bruce Allen, Christian Franke, www.smartmontools.org</span><br><span class="line"></span><br><span class="line">=== START OF INFORMATION SECTION ===</span><br><span class="line">Device Model:     TOSHIBA MQ04ABF100</span><br><span class="line">Serial Number:    30IAP8ZKT</span><br><span class="line">LU WWN Device Id: 5 000039 9e26062ca</span><br><span class="line">Firmware Version: JU002U</span><br><span class="line">User Capacity:    1,000,204,886,016 bytes [1.00 TB]</span><br><span class="line">Sector Sizes:     512 bytes logical, 4096 bytes physical</span><br><span class="line">Rotation Rate:    5400 rpm</span><br><span class="line">Form Factor:      2.5 inches</span><br><span class="line">Device is:        Not in smartctl database [for details use: -P showall]</span><br><span class="line">ATA Version is:   ACS-3 T13/2161-D revision 5</span><br><span class="line">SATA Version is:  SATA 3.3, 3.0 Gb/s (current: 3.0 Gb/s)</span><br><span class="line">Local Time is:    Sat May 23 23:36:34 2020 CST</span><br><span class="line">SMART support is: Available - device has SMART capability.</span><br><span class="line">SMART support is: Enabled</span><br></pre></td></tr></table></figure>
<h2 id="badblocks"><a href="#badblocks" class="headerlink" title="badblocks"></a>badblocks</h2><blockquote>
<p>检查磁盘装置中损坏的区块</p>
</blockquote>
<h3 id="坏道检查"><a href="#坏道检查" class="headerlink" title="坏道检查"></a>坏道检查</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo badblocks -s -v /dev/sdb</span></span><br><span class="line">Checking blocks 0 to 976762583</span><br><span class="line">Checking for bad blocks (read-only test): done</span><br><span class="line">Pass completed, 0 bad blocks found. (0/0/0 errors)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-s</code>: 在检查时显示进度</li>
<li><code>-v</code>: 执行时显示详细的信息</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>硬盘</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Multiseat System</title>
    <url>/post/1458b897.html</url>
    <content><![CDATA[<p><code>Multiseat system</code>: 可以由多个用户同时共享一个PC的大部分资源使用，比如独立的鼠标键盘、显示器</p>
<blockquote>
<p>Multiseat主要是硬件，然后才是软件配置</p>
</blockquote>
<p>在每个使用<code>Xorg</code>的Linux中，即使您不想安装多座linux系统，也总是有一个席位。 该座位名为“seat0”，您无法重命名。</p>
<a id="more"></a>
<h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><ul>
<li>创建一个seat；</li>
<li>删除座位seat；</li>
<li>为seat分配资源；</li>
<li>查看分配给特定seat的资源。</li>
</ul>
<blockquote>
<p>规则，seat名称必须以<code>seat-</code>作为前缀</p>
</blockquote>
<p><strong>无论在任何情况下都遇到麻烦，如果遇到麻烦，您总是可以通过以下简单的单个命令将所有设备重新分配给seat0</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl flush-devices</span><br></pre></td></tr></table></figure>
<h3 id="列出当前seat"><a href="#列出当前seat" class="headerlink" title="列出当前seat"></a>列出当前seat</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl list-seats</span><br></pre></td></tr></table></figure>
<h3 id="创建seat并分配资源"><a href="#创建seat并分配资源" class="headerlink" title="创建seat并分配资源"></a>创建seat并分配资源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl attach seat-[name] /sys/devices/pci0000:00/0000:00:06.0/0000:02:00.0/drm/card1</span><br></pre></td></tr></table></figure>
<ul>
<li>给已经存在的seat,添加资源,比如其他的设备外设</li>
</ul>
<h3 id="查看seat状态"><a href="#查看seat状态" class="headerlink" title="查看seat状态"></a>查看seat状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl seat-status seat0</span><br></pre></td></tr></table></figure>
<h2 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h2><p>多设备并且固定时,可以通过udev批量添加, 在<code>/etc/udev/rules.d</code>目录下根据udev规则添加seat配置文件</p>
<h3 id="添加udev规则"><a href="#添加udev规则" class="headerlink" title="添加udev规则"></a>添加udev规则</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat 72-seat-*</span></span><br><span class="line">SUBSYSTEM=="pci", DEVPATH=="/devices/pci0000:00/0000:00:02.2/0000:03:00.0", TAG+="seat-1", TAG+="master-of-seat", ENV&#123;ID_AUTOSEAT&#125;="1", ENV&#123;ID_SEAT&#125;="seat-1"</span><br><span class="line">SUBSYSTEM=="pci", DEVPATH=="/devices/pci0000:00/0000:00:03.0/0000:04:00.0", TAG+="seat-2", TAG+="master-of-seat", ENV&#123;ID_AUTOSEAT&#125;="1", ENV&#123;ID_SEAT&#125;="seat-2"</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DEVPATH</code>指设置地址,通过<code>loginctl seat-status seat0</code>获取</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> loginctl seat-status seat0 | grep <span class="string">"drm:card"</span> -A4</span></span><br><span class="line">		  │ drm:card1</span><br><span class="line">		  ├─/sys/device...0:00/0000:00:02.2/0000:03:00.0/drm/renderD128</span><br><span class="line">		  │ drm:renderD128</span><br><span class="line">		  ├─/sys/device...0000:00/0000:00:02.2/0000:03:00.1/sound/card0</span><br><span class="line">		  │ sound:card0</span><br><span class="line">--</span><br><span class="line">		  │ drm:card2</span><br><span class="line">		  ├─/sys/device...0:00/0000:00:03.0/0000:04:00.0/drm/renderD129</span><br><span class="line">		  │ drm:renderD129</span><br><span class="line">		  ├─/sys/device...0000:00/0000:00:03.0/0000:04:00.1/sound/card1</span><br><span class="line">		  │ sound:card1</span><br></pre></td></tr></table></figure>
<h3 id="生成seats分组"><a href="#生成seats分组" class="headerlink" title="生成seats分组"></a>生成seats分组</h3><blockquote>
<p>udevadm - udev management tool</p>
</blockquote>
<p><code>udevadm</code>是一个udev的管理工具，可以用来监视和控制udev运行时的行为，请求内核事件，管理事件队列，以及提供简单的调试机制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo udevadm trigger</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从内核请求events事件,主要用于重放coldplug事件信息.(相当于模拟一次重启后的设置加载)<br><code>coldplug</code>:内核在启动时已经检测到了系统的硬件设备，并把硬件设备信息通过sysfs内核虚拟文件系统导出。udev扫描sysfs文件系统，根据硬件设备信息生成热插拔（hotplug）事件，udev再读取这些事件，生成对应的硬件设备文件。由于没有实际的硬件插拔动作，所以这一过程被称为coldplug。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl list-seats</span><br><span class="line">SEAT</span><br><span class="line">seat-1</span><br><span class="line">seat-2</span><br><span class="line">seat0</span><br><span class="line"></span><br><span class="line">3 seats listed.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时可能无法生成seats分组,需要将本机的所有设备重新分配到seat0,重启设备后重新通过<code>udevadm trigger</code>生成分组<br><strong>注意</strong>: 通过<code>loginctl flush-devices</code>重置到seat0之前,需要备份我们在<code>/etc/udev/rules.d</code>目录下,编辑的udev文件,否则重置时将自动删除</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.freedesktop.org/wiki/Software/systemd/multiseat/" target="_blank" rel="noopener">multiseat</a></li>
<li><a href="https://www.x.org/wiki/Development/Documentation/Multiseat/" target="_blank" rel="noopener">Multiseat</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Xorg_multiseat" target="_blank" rel="noopener">Xorg multiseat</a></li>
<li><a href="https://samuloop.github.io/linux/multiseat.html#create_seat" target="_blank" rel="noopener">How to configure a Multiseat system</a></li>
<li><a href="https://unix.stackexchange.com/questions/87169/autostart-all-lightdm-seats-and-show-one-as-default" target="_blank" rel="noopener">Autostart all LightDM seats and show one as default</a></li>
<li><a href="https://unix.stackexchange.com/questions/167709/debugging-multiseat-how-to-run-two-x-server-layouts-together-without-display-ma" target="_blank" rel="noopener">Debugging multiseat: How to run two X server layouts together without display manager?</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>x11</tag>
        <tag>seat</tag>
      </tags>
  </entry>
  <entry>
    <title>pcieport报错分析--网络间隔断掉</title>
    <url>/post/7a90000d.html</url>
    <content><![CDATA[<p>有线网络间隔断开,查看系统日志pcie端口存在错误打印</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel: pcieport 0000:00:1c.0: AER: Multiple Corrected error received: 0000:00:1c.0</span><br><span class="line">kernel: pcieport 0000:00:1c.0: AER: PCIe Bus Error: severity=Corrected, type=Data Link Layer, (Transmitter ID)</span><br><span class="line">kernel: pcieport 0000:00:1c.0: AER:   device [8086:a115] error status/mask=00001000/00002000</span><br><span class="line">kernel: pcieport 0000:00:1c.0: AER:    [12] Timeout</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p>在错误信息中指出PCIE总线<code>0000:00:1c.0</code>的设备<code>[8086:a115]</code>存在错误</p>
<h2 id="确定出错设备"><a href="#确定出错设备" class="headerlink" title="确定出错设备"></a>确定出错设备</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">lspci -nn | grep <span class="string">"8086:a115"</span></span></span><br><span class="line">00:1c.0 PCI bridge [0604]: Intel Corporation 100 Series/C230 Series Chipset Family PCI Express Root Port #6 [8086:a115] (rev f1)</span><br></pre></td></tr></table></figure>
<p>获取出错总线的具体信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">lspci -s 00:1c.0 -v</span></span><br><span class="line">00:1c.0 PCI bridge: Intel Corporation 100 Series/C230 Series Chipset Family PCI Express Root Port #6 (rev f1) (prog-if 00 [Normal decode])</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 121</span><br><span class="line">	Bus: primary=00, secondary=02, subordinate=02, sec-latency=0</span><br><span class="line">	I/O behind bridge: 0000d000-0000dfff [size=4K]</span><br><span class="line">	Memory behind bridge: dfd00000-dfdfffff [size=1M]</span><br><span class="line">	Prefetchable memory behind bridge: 00000000d0000000-00000000d00fffff [size=1M]</span><br><span class="line">	Capabilities: &lt;access denied&gt;</span><br><span class="line">	Kernel driver in use: pcieport</span><br></pre></td></tr></table></figure>
<h2 id="跟踪端口"><a href="#跟踪端口" class="headerlink" title="跟踪端口"></a>跟踪端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">lspci -t</span></span><br><span class="line">-[0000:00]-+-00.0</span><br><span class="line">           +-01.0-[01]--+-00.0</span><br><span class="line">           |            \-00.1</span><br><span class="line">           +-14.0</span><br><span class="line">           +-16.0</span><br><span class="line">           +-17.0</span><br><span class="line">           +-1c.0-[02]----00.0</span><br><span class="line">           +-1f.0</span><br><span class="line">           +-1f.2</span><br><span class="line">           +-1f.3</span><br><span class="line">           \-1f.4</span><br></pre></td></tr></table></figure>
<p>pci的树状接口图，这里可以看到<code>1c.0</code>接到<code>02</code>设备</p>
<h2 id="查找设备"><a href="#查找设备" class="headerlink" title="查找设备"></a>查找设备</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$lspci -nn | grep "02"</span><br><span class="line">02:00.0 Ethernet controller [0200]: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller [10ec:8168] (rev 0c)</span><br></pre></td></tr></table></figure>
<p>出错设备应该是网卡,设备型号<code>RTL8111/8168/8411</code></p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>其实类型的错误都可以分析为cpu寻址错误，<br>部分类型设备可以通过在grub.cfg里面给引导内核时添加参数<code>pci=nocer</code>, <code>pci=nomsi</code>之类解决，<br>实际上在正式运行的系统里面不应该有此错误，因为理论上驱动都是经测试正常的<br>那我们就只能得出一个结论，驱动不适合此设备</p>
<blockquote>
<p>一般情况下得先确认设备驱动是否合适</p>
</blockquote>
<h2 id="查看网卡驱动"><a href="#查看网卡驱动" class="headerlink" title="查看网卡驱动"></a>查看网卡驱动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo lshw -C network</span></span><br><span class="line">  *-network</span><br><span class="line">       description: Ethernet interface</span><br><span class="line">       product: RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller</span><br><span class="line">       vendor: Realtek Semiconductor Co., Ltd.</span><br><span class="line">       physical id: 0</span><br><span class="line">       bus info: pci@0000:02:00.0</span><br><span class="line">       logical name: enp2s0</span><br><span class="line">       version: 0c</span><br><span class="line">       serial: c8:5b:76:dc:a4:80</span><br><span class="line">       size: 1Gbit/s</span><br><span class="line">       capacity: 1Gbit/s</span><br><span class="line">       width: 64 bits</span><br><span class="line">       clock: 33MHz</span><br><span class="line">       capabilities: pm msi pciexpress msix vpd bus_master cap_list ethernet physical tp 10bt 10bt-fd 100bt 100bt-fd 1000bt-fd autonegotiation</span><br><span class="line">       configuration: autonegotiation=on broadcast=yes driver=r8168 driverversion=8.048.02-NAPI duplex=full ip=172.16.200.52 latency=0 link=yes multicast=yes port=twisted pair speed=1Gbit/s</span><br><span class="line">       resources: irq:124 ioport:d000(size=256) memory:dfd00000-dfd00fff memory:d0000000-d0003fff</span><br></pre></td></tr></table></figure>
<p><strong>网卡驱动为<code>r8168</code>,但是网卡设备是<code>RTL8111/8168/8411</code>,出现的错误应该是设备驱动不匹配造成的</strong></p>
<h2 id="更换网卡驱动"><a href="#更换网卡驱动" class="headerlink" title="更换网卡驱动"></a>更换网卡驱动</h2><h3 id="apt安装"><a href="#apt安装" class="headerlink" title="apt安装"></a>apt安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install r8168-dkms</span><br></pre></td></tr></table></figure>
<h3 id="源码手动安装"><a href="#源码手动安装" class="headerlink" title="源码手动安装"></a>源码手动安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://codeload.github.com/mtorromeo/r8168/tar.gz/8.048.02</span><br><span class="line">tar zxvf r8168-8.048.02.tar.gz &amp;&amp; r8168-8.048.02</span><br><span class="line">sudo ./autorun.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更新完设备驱动后,网络连接正常,系统日志不再出现pcie错误打印</p>
</blockquote>
<h2 id="r8169驱动模块加入黑名单"><a href="#r8169驱动模块加入黑名单" class="headerlink" title="r8169驱动模块加入黑名单"></a>r8169驱动模块加入黑名单</h2><p>在<code>/etc/modprobe.d/</code>下添加文件<code>blacklist-r8169.conf</code>内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist r8169</span><br></pre></td></tr></table></figure>
<ul>
<li><p>备份当前initrd文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /boot/initrd.img-`uname -r` /boot/initrd.img-`uname -r`.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新生成initrd文件,根据<code>/etc/modprobe.d/</code>下的文件规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>网卡</tag>
        <tag>网络</tag>
        <tag>pcie</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu kvm参数配置解析</title>
    <url>/post/d2c5077b.html</url>
    <content><![CDATA[<p>Qemu参数配置</p>
<blockquote>
<p><a href="https://www.qemu.org/docs/master/system/index.html#" target="_blank" rel="noopener">QEMU System Emulation User’s Guide</a></p>
</blockquote>
<a id="more"></a>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-netdev user,id=mynet,hostfwd=tcp::550-:5555</span><br><span class="line">或</span><br><span class="line">-netdev user,id=n0,hostfwd=::1020-:20,hostfwd=::1021-:21 #多端口映射,使用逗号分割</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport</code>将进入到主机端口的TCP或者UDP连接转发到客户机的某个地址和端口</p>
</blockquote>
<p>这种方法可以在主机的qemu进程监听一个端口，主机可通过这个端口与客户机对应的端口通讯,相当于将客户机的端口映射到主机端.</p>
<h2 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h2><h3 id="声卡"><a href="#声卡" class="headerlink" title="声卡"></a>声卡</h3><p>qemu支持的声卡类型<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">qemu-system-x86_64 -soundhw <span class="built_in">help</span></span></span><br><span class="line">Valid sound card names (comma separated):</span><br><span class="line">sb16        Creative Sound Blaster 16</span><br><span class="line">es1370      ENSONIQ AudioPCI ES1370</span><br><span class="line">ac97        Intel 82801AA AC97 Audio</span><br><span class="line">adlib       Yamaha YM3812 (OPL2)</span><br><span class="line">gus         Gravis Ultrasound GF1</span><br><span class="line">cs4231a     CS4231A</span><br><span class="line">hda         Intel HD Audio</span><br><span class="line">pcspk       PC speaker</span><br><span class="line"></span><br><span class="line">-soundhw all will enable all of the above</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>-soundhw</code> option is now available for all targets that have a PCI bus.</p>
</blockquote>
<ul>
<li>PCI声卡:<code>ac97</code>,<code>hda</code>,<code>es1370</code></li>
</ul>
<h3 id="虚拟GPU"><a href="#虚拟GPU" class="headerlink" title="虚拟GPU"></a>虚拟GPU</h3><p>详细的配置参数<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">qemu-system-x86_64 -device <span class="built_in">help</span> | grep gpu</span></span><br><span class="line">name "vhost-user-gpu", bus virtio-bus</span><br><span class="line">name "vhost-user-gpu-pci", bus PCI</span><br><span class="line">name "virtio-gpu-device", bus virtio-bus</span><br><span class="line">name "virtio-gpu-pci", bus PCI, alias "virtio-gpu"</span><br><span class="line"><span class="meta">$</span><span class="bash">qemu-system-x86_64 -device virtio-gpu-device,<span class="built_in">help</span></span></span><br><span class="line">virtio-gpu-device options:</span><br><span class="line">  indirect_desc=&lt;bool&gt;   - on/off</span><br><span class="line">  yres=&lt;uint32&gt;</span><br><span class="line">  iommu_platform=&lt;bool&gt;  - on/off</span><br><span class="line">  stats=&lt;bool&gt;           - on/off</span><br><span class="line">  event_idx=&lt;bool&gt;       - on/off</span><br><span class="line">  edid=&lt;bool&gt;            - on/off</span><br><span class="line">  any_layout=&lt;bool&gt;      - on/off</span><br><span class="line">  max_hostmem=&lt;size&gt;</span><br><span class="line">  notify_on_empty=&lt;bool&gt; - on/off</span><br><span class="line">  use-started=&lt;bool&gt;</span><br><span class="line">  packed=&lt;bool&gt;          - on/off</span><br><span class="line">  virgl=&lt;bool&gt;           - on/off</span><br><span class="line">  max_outputs=&lt;uint32&gt;</span><br><span class="line">  xres=&lt;uint32&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/wangyezi19930928/article/details/53156057" target="_blank" rel="noopener">qemu-kvm 参数设置（多屏显示、图像压缩、声音压缩、USB重定向、添加agent）</a></li>
<li><a href="https://qemu.weilnetz.de/doc/qemu-doc.html" target="_blank" rel="noopener">QEMU version 4.2.0 User Documentation</a></li>
<li><a href="http://blog.leanote.com/post/7wlnk13/%E5%88%9B%E5%BB%BAKVM%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">qemu-system-x86_64命令总结</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>kvm</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>WiFi配置——ubuntu20.04 server</title>
    <url>/post/9cb9cc51.html</url>
    <content><![CDATA[<p>前段时间发现之前给老家买的mini主机很久没用了，拿来加了个无线网卡和硬盘通过nextcloud搭建一个私人网盘备份一些文件，在家里也方便手机共享。在wifi的配置时踩过一些坑，在这里简单记录下。</p>
<a id="more"></a>
<p>在ubuntu18.04中就发现使用<code>netplan</code>进行网络配置，WiFi同样可以通过netplan的简单配置实现上网，不需要我们在配置wpa_supplicant</p>
<p>netplan配置文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/netplan/00-installer-config.yaml</span><br><span class="line"># This is the network config written by &apos;subiquity&apos;</span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  ethernets:</span><br><span class="line">    enp2s0:</span><br><span class="line">      dhcp4: true</span><br><span class="line">      dhcp6: true</span><br><span class="line">  wifis:</span><br><span class="line">    wlp3s0:</span><br><span class="line">      dhcp4: false</span><br><span class="line">      dhcp6: true</span><br><span class="line">      optional: true</span><br><span class="line">      addresses: [192.168.1.38/24]</span><br><span class="line">      gateway4: 192.168.1.1</span><br><span class="line">      nameservers:</span><br><span class="line">          addresses: [8.8.8.8]</span><br><span class="line">      access-points:</span><br><span class="line">          &quot;ChinaNet-xxx&quot;:</span><br><span class="line">              password: &quot;xxxxx&quot;</span><br></pre></td></tr></table></figure></p>
<p>常用的命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netplan generate</span><br><span class="line">netplan apply</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li><code>generate</code>: 从<code>/etc/netplan/*.yaml</code>生成特定于后端的配置文件</li>
<li><code>apply</code>: 应用配置(以便生效),在每一次修改完配置文件后需要执行，使配置生效</li>
</ul>
</blockquote>
<p>配置完成执行以上两个命令后，系统可以正常上网，但是在系统重启后存在两个问题。</p>
<ol>
<li>系统重启时间过长，两分钟多</li>
<li>重启后，无线网卡可以正常配置IPv4地址，但是IPv6地址没有配置成功（nextcloud通过docker安装，局域网访问需要IPv6地址配置成功）</li>
</ol>
<h2 id="优化开机时间"><a href="#优化开机时间" class="headerlink" title="优化开机时间"></a>优化开机时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">systemd-analyze</span></span><br><span class="line">Startup finished in 2.582s (firmware) + 4.843s (loader) + 5.075s (kernel) + 2min 15.951s (userspace) = 2min 28.453s</span><br><span class="line">graphical.target reached after 2min 14.410s in userspace</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">systemd-analyze blame</span></span><br><span class="line">2min 213ms systemd-networkd-wait-online.service</span><br><span class="line">    7.145s docker.service</span><br></pre></td></tr></table></figure>
<p>耗时最多的是<code>systemd-networkd-wait-online.service</code>服务其超时后才退出，主要用于检查网络配置是否成功，便于后面其他依赖于网络的服务启动，直接禁掉最省事，网络连接也不会受影响。但是<code>netdata</code>的服务启动会受影响导致失败，因此不能直接mark掉。</p>
<p>通过对系统log的分析这里主要原因是，检查网络连接失败最后导致的超时，网络链接失败是由于该主机有两张网卡（有线网卡，无线网卡），但是我没有使用，导致检查超时。由于后期可能会用到有线网卡，不打算有线网卡的检查过滤掉，同时为了方便只能牺牲一些开机时间，将该服务的超时时间重新配置为30s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=30</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: /lib/systemd/system/systemd-networkd-wait-online.service</p>
</blockquote>
<h2 id="配置IPv6网络"><a href="#配置IPv6网络" class="headerlink" title="配置IPv6网络"></a>配置IPv6网络</h2><p>通过系统启动日志，发现网络配置存在异常，可能是导致IPv6网络配置失败的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">May 24 22:36:39 ubuntu NetworkManager[874]: &lt;warn&gt;  [1590330999.7653] device (wlp3s0): re-acquiring supplicant interface (#1).</span><br><span class="line">May 24 22:36:39 ubuntu systemd-networkd[816]: wlp3s0: Lost carrier</span><br><span class="line">May 24 22:36:39 ubuntu systemd-networkd[816]: wlp3s0: Gained carrier</span><br><span class="line">May 24 22:36:39 ubuntu systemd[1]: NetworkManager-dispatcher.service: Succeeded.</span><br><span class="line">May 24 22:36:39 ubuntu wpa_supplicant[897]: ctrl_iface exists and seems to be in use - cannot override it</span><br><span class="line">May 24 22:36:39 ubuntu wpa_supplicant[897]: Delete &apos;/run/wpa_supplicant/wlp3s0&apos; manually if it is not used anymore</span><br><span class="line">May 24 22:36:39 ubuntu wpa_supplicant[897]: Failed to initialize control interface &apos;/run/wpa_supplicant&apos;.</span><br><span class="line">                                            You may have another wpa_supplicant process already running or the file was</span><br><span class="line">                                            left by an unclean termination of wpa_supplicant in which case you will need</span><br><span class="line">                                            to manually remove this file before starting wpa_supplicant again.</span><br><span class="line">May 24 22:36:39 ubuntu systemd-networkd[816]: wlp3s0: Lost carrier</span><br><span class="line">May 24 22:36:39 ubuntu systemd-networkd[816]: wlp3s0: Gained carrier</span><br><span class="line">May 24 22:36:39 ubuntu wpa_supplicant[897]: nl80211: deinit ifname=wlp3s0 disabled_11b_rates=0</span><br><span class="line">May 24 22:36:39 ubuntu NetworkManager[874]: &lt;error&gt; [1590330999.9224] sup-iface[0x558f502f31f0,wlp3s0]: error adding interface: wpa_supplicant</span><br><span class="line">couldn&apos;t grab this interface.</span><br><span class="line">May 24 22:36:39 ubuntu NetworkManager[874]: &lt;info&gt;  [1590330999.9225] device (wlp3s0): supplicant interface state: starting -&gt; down</span><br><span class="line">May 24 22:36:42 ubuntu snapd[891]: stateengine.go:150: state ensure error: decode new commands catalog: net/http: request canceled (Client.</span><br><span class="line">Timeout exceeded while reading body)</span><br><span class="line">May 24 22:36:49 ubuntu NetworkManager[874]: &lt;warn&gt;  [1590331009.7629] device (wlp3s0): re-acquiring supplicant interface (#2).</span><br><span class="line">May 24 22:36:49 ubuntu systemd-networkd[816]: wlp3s0: Lost carrier</span><br><span class="line">May 24 22:36:49 ubuntu systemd-networkd[816]: wlp3s0: Gained carrier</span><br><span class="line">May 24 22:36:49 ubuntu wpa_supplicant[897]: ctrl_iface exists and seems to be in use - cannot override it</span><br><span class="line">May 24 22:36:49 ubuntu wpa_supplicant[897]: Delete &apos;/run/wpa_supplicant/wlp3s0&apos; manually if it is not used anymore</span><br><span class="line">May 24 22:36:49 ubuntu wpa_supplicant[897]: Failed to initialize control interface &apos;/run/wpa_supplicant&apos;.</span><br><span class="line">                                            You may have another wpa_supplicant process already running or the file was</span><br><span class="line">                                            left by an unclean termination of wpa_supplicant in which case you will need</span><br><span class="line">                                            to manually remove this file before starting wpa_supplicant again.</span><br><span class="line">May 24 22:36:49 ubuntu systemd-networkd[816]: wlp3s0: Lost carrier</span><br><span class="line">May 24 22:36:49 ubuntu systemd-networkd[816]: wlp3s0: Gained carrier</span><br></pre></td></tr></table></figure>
<p>在系统的启动日志里，WiFi的配置被进行了两次，在第一次配置中日志显示ipv6地址获取成功，可能是第二次失败导致ipv6地址无法获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">May 26 23:00:43 ubuntu wpa_supplicant[663]: Successfully initialized wpa_supplicant</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">May 26 23:00:48 ubuntu wpa_supplicant[1002]: Successfully initialized wpa_supplicant</span><br></pre></td></tr></table></figure>
<p>在这里无线网络被配置两次是由于系统启动时两个网络配置的服务（<code>NetworkManager.service</code>，<code>network-manager.service</code>）都被启动了，我们禁掉<code>NetworkManager.service</code>服务重启后网络配置正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl disable NetworkManager.service</span><br></pre></td></tr></table></figure>
<h2 id="netplan的配置"><a href="#netplan的配置" class="headerlink" title="netplan的配置"></a>netplan的配置</h2><blockquote>
<p><code>NetworkManager</code>主要用于在桌面系统上管理网络设备。如果您使用<code>NetworkManager</code>作为网络设备管理的系统守护程序，将会使用 NetworkManager 的图形程序来管理网络接口。</p>
<ul>
<li><a href="https://winddoing.github.io/post/18692.html">网络配置</a></li>
</ul>
</blockquote>
<p>在netplan的配置文件中有一个<code>renderer</code>字段将其指定为<code>networkd</code>，或许也可以解决上面的问题，没有进行验证，不过netplan手册说其是默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">renderer (scalar)</span><br><span class="line">       Use  the  given  networking backend for this definition.  Currently supported are networkd and NetworkManager.  This property can be</span><br><span class="line">       specified globally in networks:, for a device type (in e.  g.  ethernets:) or for a particular device definition.  Default  is  net‐</span><br><span class="line">       workd.</span><br><span class="line"></span><br><span class="line">       The renderer property has one additional acceptable value for vlan objects (i.  e.  defined in vlans:): sriov.  If a vlan is defined</span><br><span class="line">       with the sriov renderer for an SR-IOV Virtual Function interface, this causes netplan to set up  a  hardware  VLAN  filter  for  it.</span><br><span class="line">       There can be only one defined per VF.</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://xzclip.cn/tech-records/systemd-networkd-wait-online-stuck-boot-ubuntu-1804/" target="_blank" rel="noopener">systemd-networkd-wait-online拖慢Ubuntu 18.04云主机开机的排查手记</a></li>
<li><a href="https://blog.csdn.net/doushi/article/details/104062482" target="_blank" rel="noopener">ubuntu命令行配置wifi，不使用NetworkManager和netplan</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>wifi</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>Travis CI的部署与发布</title>
    <url>/post/768dddf0.html</url>
    <content><![CDATA[<p>由于国内对一些资源的限制，在无法翻墙的情况下，借助于Travis CI的部署发布功能进行代码的编译，将最终的二进制文件发布后下载使用。<br>比如编译<a href="https://github.com/aisouard/libwebrtc" target="_blank" rel="noopener">libwebrtc</a>，生产静态库和一些头文件，供本地开发使用。</p>
<a id="more"></a>
<h2 id="The-Job-Lifecycle"><a href="#The-Job-Lifecycle" class="headerlink" title="The Job Lifecycle #"></a>The Job Lifecycle <a href="https://docs.travis-ci.com/user/job-lifecycle#the-job-lifecycle" target="_blank" rel="noopener">#</a></h2><p>Each <em>job</em> is a sequence of <a href="https://docs.travis-ci.com/for-beginners/#builds-jobs-stages-and-phases" target="_blank" rel="noopener">phases</a>. The <em>main phases</em> are:</p>
<ol>
<li><code>install</code> - install any dependencies required</li>
<li><code>script</code> - run the build script</li>
</ol>
<p>Travis CI can run custom commands in the phases:</p>
<ol>
<li><code>before_install</code> - before the install phase</li>
<li><code>before_script</code> - before the script phase</li>
<li><code>after_script</code> - after the script phase.</li>
<li><code>after_success</code> - when the build <em>succeeds</em> (e.g. building documentation), the result is in <code>TRAVIS_TEST_RESULT</code> environment variable</li>
<li><code>after_failure</code> - when the build <em>fails</em> (e.g. uploading log files), the result is in <code>TRAVIS_TEST_RESULT</code> environment variable</li>
</ol>
<p>There are three optional <em>deployment phases</em>.</p>
<p>The complete sequence of phases of a job is the lifecycle. The steps are:</p>
<ol>
<li>OPTIONAL Install <a href="https://docs.travis-ci.com/user/installing-dependencies/#installing-packages-with-the-apt-addon" target="_blank" rel="noopener"><code>apt addons</code></a></li>
<li>OPTIONAL Install <a href="https://docs.travis-ci.com/user/caching" target="_blank" rel="noopener"><code>cache components</code></a></li>
<li><code>before_install</code></li>
<li><code>install</code></li>
<li><code>before_script</code></li>
<li><code>script</code></li>
<li>OPTIONAL <code>before_cache</code> (if and only if caching is effective)</li>
<li><code>after_success</code> or <code>after_failure</code></li>
<li>OPTIONAL <code>before_deploy</code> (if and only if deployment is active)</li>
<li>OPTIONAL <code>deploy</code></li>
<li>OPTIONAL <code>after_deploy</code> (if and only if deployment is active)</li>
<li><code>after_script</code></li>
</ol>
<blockquote>
<p>A <em>build</em> can be composed of many jobs.</p>
</blockquote>
<h2 id="Travis-CI关键字"><a href="#Travis-CI关键字" class="headerlink" title="Travis CI关键字"></a>Travis CI关键字</h2><table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>dist</code></td>
<td style="text-align:center">指定系统版本,dist: bionic(ubuntu18.04)</td>
</tr>
</tbody>
</table>
<h2 id="添加python"><a href="#添加python" class="headerlink" title="添加python"></a>添加python</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python:</span><br><span class="line">   - &quot;3.6&quot;</span><br></pre></td></tr></table></figure>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  provider: releases</span><br><span class="line">  api_key: $GITHUB_TOKEN</span><br><span class="line">  file_glob: true</span><br><span class="line">  file: &quot;$&#123;TRAVIS_ARTIFACTS&#125;&quot;</span><br><span class="line">  skip_cleanup: true</span><br><span class="line">  on:</span><br><span class="line">    tags: true</span><br><span class="line">    repo: Winddoing/libwebrtc</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://raw.githubusercontent.com/Winddoing/libwebrtc/mydev/.travis.yml" target="_blank" rel="noopener">https://raw.githubusercontent.com/Winddoing/libwebrtc/mydev/.travis.yml</a></p>
</blockquote>
<ul>
<li><code>GITHUB_TOKEN</code>: setting-&gt;Developer settings-&gt;Personal access tokens:Generate new token</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.travis-ci.com/user/tutorial/" target="_blank" rel="noopener">Travis CI Tutorial</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>travis-ci</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Graphics driver for Linux</title>
    <url>/post/2caf5a45.html</url>
    <content><![CDATA[<p>Graphics driver for Linux</p>
<a id="more"></a>
<h2 id="NVIDIA-for-Centos7"><a href="#NVIDIA-for-Centos7" class="headerlink" title="NVIDIA for Centos7"></a>NVIDIA for Centos7</h2><blockquote>
<p>为centos7安装<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">NVIDIA</a>驱动程序</p>
</blockquote>
<h3 id="屏蔽系统自带的Nouveau显卡驱动"><a href="#屏蔽系统自带的Nouveau显卡驱动" class="headerlink" title="屏蔽系统自带的Nouveau显卡驱动"></a>屏蔽系统自带的Nouveau显卡驱动</h3><ol>
<li>通过vim编辑器更改配置文件，按照以下内容进行修改</li>
</ol>
<blockquote>
<p>vim /lib/modprobe.d/dist-blacklist.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist nouveau               #添加此行</span><br><span class="line">options nouveau modeset=0       #添加此行</span><br><span class="line"># blacklist nvidiafb            #将nvidiafb的这一行注释掉</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>重建 initramfs image</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 备份</span><br><span class="line"># mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak</span><br><span class="line"></span><br><span class="line"># 重建</span><br><span class="line"># dracut /boot/initramfs-$(uname -r).img $(uname -r)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>重启系统确认nouveau驱动没有被加载</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改系统运行级别为纯文本模式</span><br><span class="line"># systemctl set-default multi-user.target</span><br><span class="line"></span><br><span class="line"># 重启系统</span><br><span class="line"># reboot</span><br><span class="line"></span><br><span class="line"># 系统重启完成后，在纯文本模式下使用root用户登录进系统</span><br><span class="line"></span><br><span class="line"># 查看nouveau显卡驱动是否已经被禁用，若此命令执行完之后没有输出相关信息，则说明已经被禁用</span><br><span class="line"># lsmod | grep nouveau</span><br></pre></td></tr></table></figure>
<h3 id="安装NVIDIA驱动"><a href="#安装NVIDIA驱动" class="headerlink" title="安装NVIDIA驱动"></a>安装NVIDIA驱动</h3><p>设置下载的驱动文件可执行权限后,直接运行,安装过程中，选择accept；如果提示是否编译DKMS模块，选择yes（方便以后升级系统内核）；如果提示要修改xorg.conf，选择yes</p>
<p>在安装完后使用<code>nvidia-smi</code>测试查看显卡状态,并通过<code>startx</code>确认是否可以启动xorg进入桌面,有时可能需要在生成的<code>xorg.conf</code>中配置显卡驱动的PCI总线地址(注意:地址以十进制表示,需要将lspci的十六进制转换为十进制)</p>
<ul>
<li>修改系统运行级别为图形模式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>显卡</tag>
      </tags>
  </entry>
  <entry>
    <title>emacs操作快捷键</title>
    <url>/post/6c6f22c4.html</url>
    <content><![CDATA[<p>在无意中看到这张emacs快捷键图片,在这里保存一下,说不定啥时候在想尝试一下emacs了可以直接查找.</p>
<a id="more"></a>
<p><img src="/images/2020/07/emacs.png" alt="emacs"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>mesa调试——运行时函数栈的打印</title>
    <url>/post/1987c89c.html</url>
    <content><![CDATA[<p>阅读mesa代码时，追踪一些函数的调用关系，但是由于mesa的编译选项的不同导致一些函数调用流程存在差异。在编译的配置选项中发现了<code>-Dlibunwind=true</code>，mesa应该提供了函数调用栈打印的接口，接口如下：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">debug_stack_frame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LIBUNWIND</span></span><br><span class="line">   <span class="keyword">unw_word_t</span> start_ip;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> off;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *procname;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">void</span> *function;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">debug_backtrace_capture(struct debug_stack_frame *backtrace,</span><br><span class="line">                        <span class="keyword">unsigned</span> start_frame,</span><br><span class="line">                        <span class="keyword">unsigned</span> nr_frames);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">debug_backtrace_dump(<span class="keyword">const</span> struct debug_stack_frame *backtrace,</span><br><span class="line">                     <span class="keyword">unsigned</span> nr_frames);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">debug_backtrace_print(FILE *f,</span><br><span class="line">                      <span class="keyword">const</span> struct debug_stack_frame *backtrace,</span><br><span class="line">                      <span class="keyword">unsigned</span> nr_frames);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: src/gallium/auxiliary/util/u_debug_stack.h</p>
</blockquote>
<h2 id="添加函数栈打印接口"><a href="#添加函数栈打印接口" class="headerlink" title="添加函数栈打印接口"></a>添加函数栈打印接口</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/src/gallium/drivers/virgl/virgl_context.c</span></span><br><span class="line"><span class="comment">+++ b/src/gallium/drivers/virgl/virgl_context.c</span></span><br><span class="line">@@ -1471,6 +1471,9 @@ struct pipe_context *virgl_context_create(struct pipe_screen *pscreen,</span><br><span class="line">       return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   debug_backtrace_capture(vctx-&gt;create_backtrace, 1, VIRGL_DEBUG_CREATE_BACKTRACE);</span></span><br><span class="line"><span class="addition">+   debug_backtrace_dump(vctx-&gt;create_backtrace, VIRGL_DEBUG_CREATE_BACKTRACE);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">    vctx-&gt;base.destroy = virgl_context_destroy;</span><br><span class="line">    vctx-&gt;base.create_surface = virgl_create_surface;</span><br><span class="line">    vctx-&gt;base.surface_destroy = virgl_surface_destroy;</span><br><span class="line">diff --git a/src/gallium/drivers/virgl/virgl_context.h b/src/gallium/drivers/virgl/virgl_context.h</span><br><span class="line">index 8ea3e1e2f6e..1dbfd41573e 100644</span><br><span class="line"><span class="comment">--- a/src/gallium/drivers/virgl/virgl_context.h</span></span><br><span class="line"><span class="comment">+++ b/src/gallium/drivers/virgl/virgl_context.h</span></span><br><span class="line"><span class="meta">@@ -31,6 +31,8 @@</span></span><br><span class="line"> #include "virgl_staging_mgr.h"</span><br><span class="line"> #include "virgl_transfer_queue.h"</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include "util/u_debug_stack.h"</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> struct pipe_screen;</span><br><span class="line"> struct tgsi_token;</span><br><span class="line"> struct u_upload_mgr;</span><br><span class="line">@@ -66,11 +68,15 @@ struct virgl_shader_binding_state &#123;</span><br><span class="line">    uint32_t image_enabled_mask;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="addition">+#define VIRGL_DEBUG_CREATE_BACKTRACE 15</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> struct virgl_context &#123;</span><br><span class="line">    struct pipe_context base;</span><br><span class="line">    struct virgl_cmd_buf *cbuf;</span><br><span class="line">    unsigned cbuf_initial_cdw;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   struct debug_stack_frame create_backtrace[VIRGL_DEBUG_CREATE_BACKTRACE];</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">    struct virgl_shader_binding_state shader_bindings[PIPE_SHADER_TYPES];</span><br><span class="line">    struct pipe_shader_buffer atomic_buffers[PIPE_MAX_HW_ATOMIC_BUFFERS];</span><br><span class="line">    uint32_t atomic_buffer_enabled_mask;</span><br></pre></td></tr></table></figure>
<p>这是是想获取<code>virgl_context_create</code>函数的调用栈，因此将<code>debug_backtrace_capture</code>和<code>debug_backtrace_dump</code>接口加在了同一个位置，其实<code>debug_backtrace_dump</code>接口也可以加到后续调用的函数中</p>
<p><strong>注</strong>：目前我在window系统中使用这些接口无法打印函数栈信息</p>
<ul>
<li>函数调用栈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0xe20b5) (st_api_create_context+0x22a) [0x7f4bb8a000b5]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0xd07c6) (dri_create_context+0x477) [0x7f4bb89ee7c6]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x85c327) (driCreateContextAttribs+0x499) [0x7f4bb917a327]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x85c3be) (driCreateNewContextForAPI+0x59) [0x7f4bb917a3be]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x85c414) (driCreateNewContext+0x3c) [0x7f4bb917a414]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x47828) (drisw_create_context+0x137) [0x7f4bb9f9a828]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x492b9) (CreateContext+0xbd) [0x7f4bb9f9c2b9]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x49788) (glXCreateContext+0x13f) [0x7f4bb9f9c788]</span><br><span class="line">glxgears(+0x416f) (?+0x27f) [0x55b7c388816f]</span><br><span class="line">glxgears(+0x257f) (?+0x16f) [0x55b7c388657f]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x270b3) (__libc_start_main+0xf3) [0x7f4bb9ad80b3]</span><br><span class="line">glxgears(+0x2f0a) (?+0x2a) [0x55b7c3886f0a]</span><br></pre></td></tr></table></figure>
<h2 id="SwapBuffer接口调用"><a href="#SwapBuffer接口调用" class="headerlink" title="SwapBuffer接口调用"></a>SwapBuffer接口调用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func: virgl_flush_eq, line: 922</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x951a57) (virgl_flush_from_st+0x3e) [0x7f19f19f6a57]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0xfbf26) (st_flush+0x4a) [0x7f19f11a0f26]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0xfc03d) (st_glFlush+0x42) [0x7f19f11a103d]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x1aeb37) (_mesa_flush+0x96) [0x7f19f1253b37]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x1aec65) (_mesa_Flush+0x56) [0x7f19f1253c65]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x47f08) (driswSwapBuffers+0x3f) [0x7f19f2721f08]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x4a1e9) (glXSwapBuffers+0x9d) [0x7f19f27241e9]</span><br><span class="line">   ./glxgears(+0x2dfd) (main+0x61d) [0x564f11c10dfd]</span><br><span class="line">   /lib/x86_64-linux-gnu/libc.so.6(+0x270b3) (__libc_start_main+0xf3) [0x7f19f225f0b3]</span><br><span class="line">   ./glxgears(+0x330e) (_start+0x2e) [0x564f11c1130e]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>mesa</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>gpu</tag>
        <tag>opengl</tag>
        <tag>mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>My TiddlyWiki</title>
    <url>/post/8982b524.html</url>
    <content><![CDATA[<p>Tiddlywiki 的使用方法很简单，先打开 <a href="http://tiddlywiki.com" target="_blank" rel="noopener">http://tiddlywiki.com</a> 点击「Download Empty」下载一个空文档。然后在浏览器中打开这个文档，之后就可以进行修改标题、输入文字、插入图片和链接等等操作</p>
<a id="more"></a>
<h2 id="本地搭建"><a href="#本地搭建" class="headerlink" title="本地搭建"></a>本地搭建</h2><p>本地搭建可以作为简单个人笔记,随手记录一些想法,这里可以使用docker进行搭建不用进行烦琐的配置.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:Winddoing/tiddlyWiki.git</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://hub.docker.com/r/nicolaw/tiddlywiki" target="_blank" rel="noopener">Docker–nicolaw/tiddlywiki</a></li>
<li><a href="http://blog.dimpurr.com/tiddly-wiki/" target="_blank" rel="noopener">使用 TiddlyWiki 打造轻便个人 Wiki 知识库</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>scoop for window</title>
    <url>/post/5c8794fe.html</url>
    <content><![CDATA[<p>Window下的包管理工具,便于开发环境的搭建和软件安装</p>
<a id="more"></a>
<p>系统版本：<code>window10 2004</code></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装scoop或者choco都需要powershell的支持</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启脚本权限</span></span><br><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-scope</span> CurrentUser</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">iwr <span class="literal">-useb</span> get.scoop.sh | iex</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"><span class="built_in">Invoke-Expression</span> (<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">'https://get.scoop.sh'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不使用VPNscoop的安装由于下载慢而中断导致失败，那么必须先删除<code>C:\Users\scoop</code>文件夹(默认路径可自定义)，再执行以上命令安装。</p>
</blockquote>
<ul>
<li><p>指定安装路径(指定SCOOP的路径到环境变量)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[environment]::setEnvironmentVariable(&apos;SCOOP&apos;,&apos;C:\Scoop&apos;,&apos;User&apos;)</span><br><span class="line">$env:SCOOP=&apos;C:\Scoop&apos;</span><br><span class="line">iex (new-object net.webclient).downloadstring(&apos;https://get.scoop.sh&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加官网扩展支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoop bucket add extras</span><br><span class="line">scoop bucket add versions</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://github.com/lukesampson/scoop-extras" target="_blank" rel="noopener">https://github.com/lukesampson/scoop-extras</a></p>
</blockquote>
</li>
</ul>
<h2 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: scoop &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Some useful commands are:</span><br><span class="line"></span><br><span class="line">alias       管理 scoop 别名</span><br><span class="line">bucket      管理 Scoop buckets</span><br><span class="line">cache       显示/清理下载缓存</span><br><span class="line">checkup     检查可能存在的问题</span><br><span class="line">cleanup     移除旧版本清理应用</span><br><span class="line">config      获取或设置配置值</span><br><span class="line">create      创建一个自定义的app manifest</span><br><span class="line">depends     列出一个app的依赖关系</span><br><span class="line">export      导出（可导入的）已安装应用程序列表</span><br><span class="line">help        显示一个命令的帮助</span><br><span class="line">home        打开一个app 的主页</span><br><span class="line">info        显示一个app的相关信息</span><br><span class="line">install     安装 apps</span><br><span class="line">list        列出已安装的 apps</span><br><span class="line">prefix      返回指定应用程序的路径</span><br><span class="line">reset       重置应用程序以解决冲突</span><br><span class="line">search      搜索可用应用</span><br><span class="line">status      显示状态并检查新的应用程序版本</span><br><span class="line">uninstall   卸载 app</span><br><span class="line">update      更新 apps 和更新 Scoop</span><br><span class="line">virustotal  在virustotal.com上查找应用程序的哈希</span><br><span class="line">which       找到一个shim/可执行文件（类似于Linux上的which）</span><br></pre></td></tr></table></figure>
<h2 id="Scoop示例"><a href="#Scoop示例" class="headerlink" title="Scoop示例"></a>Scoop示例</h2><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoop install python27 python</span><br><span class="line">python --version # -&gt; Python 3.6.2</span><br><span class="line"></span><br><span class="line"># switch to python 2.7.x</span><br><span class="line">scoop reset python27</span><br><span class="line">python --version # -&gt; Python 2.7.13</span><br><span class="line"></span><br><span class="line"># switch back (to 3.x)</span><br><span class="line">scoop reset python</span><br><span class="line">python --version # -&gt; Python 3.6.2</span><br></pre></td></tr></table></figure>
<h3 id="导出安装软件列表"><a href="#导出安装软件列表" class="headerlink" title="导出安装软件列表"></a>导出安装软件列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoop export &gt; app_list.txt</span><br></pre></td></tr></table></figure>
<h3 id="更新所有安装软件"><a href="#更新所有安装软件" class="headerlink" title="更新所有安装软件"></a>更新所有安装软件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoop update * &amp;&amp; scoop cleanup *</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://scoop.sh/" target="_blank" rel="noopener">Scoop</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>scoop</tag>
      </tags>
  </entry>
  <entry>
    <title>window下的包管理工具</title>
    <url>/post/f9f0e3bd.html</url>
    <content><![CDATA[<p>在window10中微软开发了<code>winget</code>包管理工具,但是由于时间问题可以安装的软件包比较少,以后可能会好些.</p>
<p>除了<code>winget</code>,还有一些第三方包管理工具,比较好的有<code>choco</code>和<code>scoop</code>,但是由于scoop的仓库依赖github,可能有时由于网络的原因导致无法安装使用,如果网络正常可以参考<a href="https://winddoing.github.io/post/5c8794fe.html">scoop</a>使用起来有点像ubuntu下的apt-get,还挺好用.如果网络不能用,使用<code>choco</code>虽然慢点但是还能下载安装,同样简化了软件的安装.</p>
<a id="more"></a>
<h2 id="winget"><a href="#winget" class="headerlink" title="winget"></a>winget</h2><p>暂时没有使用过,以后可能也不会使用了呵呵呵</p>
<h2 id="choco"><a href="#choco" class="headerlink" title="choco"></a>choco</h2><ul>
<li>官网: <a href="https://chocolatey.org" target="_blank" rel="noopener">https://chocolatey.org</a></li>
</ul>
<p>通过<code>CMD</code>进行安装,需要<code>管理员</code>权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">choco --help</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以安装的软件包:<a href="https://chocolatey.org/packages" target="_blank" rel="noopener">https://chocolatey.org/packages</a></p>
</blockquote>
<h3 id="本地已安装软件"><a href="#本地已安装软件" class="headerlink" title="本地已安装软件"></a>本地已安装软件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">choco list -lo</span><br></pre></td></tr></table></figure>
<h2 id="scoop"><a href="#scoop" class="headerlink" title="scoop"></a>scoop</h2><blockquote>
<p><a href="https://winddoing.github.io/post/5c8794fe.html">scoop for window</a></p>
</blockquote>
<h2 id="系统激活"><a href="#系统激活" class="headerlink" title="系统激活"></a>系统激活</h2><p>bat脚本,自动激活<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>window10测试有效</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>scoop</tag>
        <tag>choco</tag>
      </tags>
  </entry>
  <entry>
    <title>vs与gcc编译器之间的差别</title>
    <url>/post/2f341d0b.html</url>
    <content><![CDATA[<p>最近在做一些移植的工作时，相同的代码使用gcc编译全部正常。但是在windows下使用VS2019进行编译时，出现一些语法错误，主要有下面几种：</p>
<a id="more"></a>
<h2 id="“void-”-unknown-size"><a href="#“void-”-unknown-size" class="headerlink" title="“void *”: unknown size"></a>“void *”: unknown size</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">void</span> *arr, <span class="keyword">size_t</span> n, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">memcpy</span>(arr+(i*<span class="built_in">size</span>), swp,  <span class="built_in">size</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>void *</code>执行指针算术运算，因为void没有定义大小，进行偏移操作无法确定偏移的单位，因此出现错误提示</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>((<span class="keyword">char</span>*)arr+(i*<span class="built_in">size</span>), swp,  <span class="built_in">size</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：这种修改解决了编译报错的问题，但是与gcc的编译不兼容</p>
<h2 id="small关键字"><a href="#small关键字" class="headerlink" title="small关键字"></a>small关键字</h2><blockquote>
<p>在编译的代码中定义了<code>small</code>变量名，但是其在VS中属于一个关键字,是<code>char</code>类型的别名</p>
</blockquote>
<p>在头文件<code>#include &lt;windows.h&gt;</code>中包含的<code>&lt;rpcndr.h&gt;</code>头文件中定义了<code>small</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> small char</span></span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<ol>
<li>将<code>samll</code>的定义去掉：<code>#undef small</code></li>
<li>修改代码<code>small</code>变量名</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://stackoverflow.com/questions/21165891/is-small-a-keyword-in-c" target="_blank" rel="noopener">Is “small” a keyword in c?</a></li>
<li><a href="https://stackoverflow.com/questions/5874215/what-is-rpcndr-h" target="_blank" rel="noopener">What is RpcNdr.h</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>vs</tag>
      </tags>
  </entry>
  <entry>
    <title>SElinux与文件属性权限</title>
    <url>/post/38ee39e7.html</url>
    <content><![CDATA[<p>文件属性与权限的相关记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test ~]# ls -lsh /dir-path</span><br><span class="line">8.9M -rw-r--r--. 1 root root 8.9M 9月</span><br><span class="line"> 66M -rw-r--r--. 1 root root  66M 9月</span><br><span class="line">1.8M -rw-r--r--. 1 root root 1.8M 9月</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在文件的属性权限后面出现了一个小点<code>.</code>, 这是在SElinux开启的情况下创建的文件所有，表示文件带有“SELinux的安全上下文”。</p>
</blockquote>
<a id="more"></a>
<p>传统的Linux系统中，默认权限是对文件或目录的所有者、所属组和其他人的读、写和执行权限进行控制，这种控制方式称为<code>自主访问控制（DAC）</code>方式；而在 SELinux 中，采用的是<code>强制访问控制（MAC）</code>系统，也就是控制一个进程对具体文件系统上面的文件或目录是否拥有访问权限，而判断进程是否可以访问文件或目录的依据，取决于 SELinux 中设定的很多策略规则</p>
<ul>
<li>开启了SELinux功能的Linux系统就会有这个点。</li>
<li>这个点表示文件带有“SELinux的安全上下文”。</li>
<li>关闭SELinux，新创建的文件就不会再有这个点了。</li>
<li>但是，以前创建的文件本来有这个点的还会显示这个点（虽然SELinux不起作用了）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ll</span></span><br><span class="line">-rwxr-xr--  root root    #没有selinux上下文，没有ACL</span><br><span class="line">-rwx--xr-x+ root root    #只有ACL，没有selinux上下文</span><br><span class="line">-rw-r--r--. root root    #只有selinux上下文，没有ACL</span><br><span class="line">-rwxrwxr--+ root root    #有selinux上下文，有ACL</span><br></pre></td></tr></table></figure>
<h2 id="关闭SElinux——永久"><a href="#关闭SElinux——永久" class="headerlink" title="关闭SElinux——永久"></a>关闭SElinux——永久</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/selinux</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>
<h3 id="在线关闭selinux——临时"><a href="#在线关闭selinux——临时" class="headerlink" title="在线关闭selinux——临时"></a>在线关闭selinux——临时</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sestatus</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getenforce</span><br></pre></td></tr></table></figure>
<p>SElinux的状态分为以下三种：</p>
<ul>
<li><code>Enforcing</code>    （1）   强制模式</li>
<li><code>Permissive</code>   （0）   警告模式<ul>
<li><code>Disabled</code>          关闭模式</li>
</ul>
</li>
</ul>
<h2 id="SELinux权限"><a href="#SELinux权限" class="headerlink" title="SELinux权限"></a>SELinux权限</h2><ul>
<li><code>ls -Z</code>: 可以查看文件所拥有的SELinux权限的具体信息</li>
<li><code>chcon</code>: 手动修改文件的SELinux安全上下文</li>
<li><code>restorecon</code>: 恢复为默认的SELinux权限类型</li>
<li><code>semanage</code>: 查询/修改/增加/删除文件的默认SELinux权限类型</li>
</ul>
<h2 id="SELinux安全上下文"><a href="#SELinux安全上下文" class="headerlink" title="SELinux安全上下文"></a>SELinux安全上下文</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ls -Zd tmp/</span></span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:unlabeled_t:s0 tmp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目录</p>
</blockquote>
<p>安全上下文使用<code>:</code>分隔为5字段，只是最后一个“类别”字段是可选的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system_u：object_r：httpd_sys_content_t：s0：[类别]</span><br><span class="line">#身份字段：角色：类型：灵敏度：[类别]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>unconfined_u</code>: (身份字段)一个普通的标签，该标签表示不受SELinux的限制（没有约束）</li>
<li><code>object_r</code>:（角色字段）这里代表该数据目录（文件）</li>
<li><code>unlabeled_t</code>: （类型字段）无效的标签，该文件被创建是没有有效的SELinux上下文进行关联，因此在某些应用读写该文件时将无法操作。需要给其一个有效的<code>type</code>,一般与读写的应用类型一样</li>
<li><code>s0</code>:（灵敏度）</li>
</ul>
<h3 id="身份字段（user"><a href="#身份字段（user" class="headerlink" title="身份字段（user)"></a>身份字段（user)</h3><p>用于标识该数据被哪个身份所拥有，相当于权限中的用户身份。这个字段并没有特别的作用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# seinfo -u</span><br><span class="line">Users：9</span><br><span class="line">sysadm_u</span><br><span class="line">system_u</span><br><span class="line">xguest_u</span><br><span class="line">root</span><br><span class="line">guest_u</span><br><span class="line">staff_u</span><br><span class="line">user_u</span><br><span class="line">unconfined_u</span><br><span class="line">git_shell_u</span><br></pre></td></tr></table></figure>
<h3 id="角色（role）"><a href="#角色（role）" class="headerlink" title="角色（role）"></a>角色（role）</h3><p>主要用来表示此数据是进程还是文件或目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# seinfo -r</span><br><span class="line">Roles：12</span><br><span class="line">guest_r</span><br><span class="line">staff_r</span><br><span class="line">user_r</span><br><span class="line">git_shell_r</span><br><span class="line">logadm_r</span><br><span class="line">object_r</span><br><span class="line">sysadm_r</span><br><span class="line">system_r</span><br><span class="line">webadm_r</span><br><span class="line">xguest_r</span><br><span class="line">nx_server_r</span><br><span class="line">unconfined_r</span><br></pre></td></tr></table></figure>
<ul>
<li><code>object_r</code>：代表该数据是文件或目录，这里的<code>_r</code>代表 role。</li>
<li><code>system_r</code>：代表该数据是进程，这里的<code>_r</code>代表 role。</li>
</ul>
<h3 id="类型（type）"><a href="#类型（type）" class="headerlink" title="类型（type）"></a>类型（type）</h3><p>类型字段是安全上下文中最重要的字段，进程是否可以访问文件，主要就是看进程的安全上下文类型字段是否和文件的安全上下文类型字段相匹配，如果匹配则可以访问</p>
<blockquote>
<p><strong>注意</strong>:类型字段在文件或目录的安全上下文中被称作类型（type），但是在进程的安全上下文中被称作域（domain）。也就是说，在主体（Subject）的安全上下文中，这个字段被称为域；在目标（Object）的安全上下文中，这个字段被称为类型。域和类型需要匹配（进程的类型要和文件的类型相匹配），才能正确访问。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# seinfo -t | more</span><br><span class="line">Types：3488</span><br><span class="line"><span class="meta">#</span><span class="bash">共有3488个类型</span></span><br><span class="line">bluetooth_conf_t</span><br><span class="line">cmirrord_exec_t</span><br><span class="line">foghorn_exec_t</span><br><span class="line">jacorb_port_t</span><br><span class="line">sosreport_t</span><br><span class="line">etc_runtime_t</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="灵敏度"><a href="#灵敏度" class="headerlink" title="灵敏度"></a>灵敏度</h3><p>灵敏度一般是用<code>s0</code>、<code>s1</code>、<code>s2</code>来命名的，数字代表灵敏度的分级。数值越大，代表灵敏度越高</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>类别字段不是必须有的，所以我们使用 ls 和 ps 命令查询的时候并没有看到类别字段</p>
<h2 id="修改SELinux上下文——type"><a href="#修改SELinux上下文——type" class="headerlink" title="修改SELinux上下文——type"></a>修改SELinux上下文——type</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chcon -R -t public_content_t /var/ftp</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chcon -R -t bin_t tmp/</span><br></pre></td></tr></table></figure>
<h2 id="删除SELinux上下文"><a href="#删除SELinux上下文" class="headerlink" title="删除SELinux上下文"></a>删除SELinux上下文</h2><blockquote>
<p><code>setfacl -b</code> will remove the ACL on a file. <code>setfattr -x security.selinux</code> will remove the SELinux file context, but you will probably have to boot with SELinux completely disabled.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setfattr -x security.selinux tmp/test.txt</span><br></pre></td></tr></table></figure>
<p>批量处理：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find tmp/ -exec setfattr -h -x security.selinux &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/davidshen/p/8145946.html" target="_blank" rel="noopener">linux初学者-SElinux篇</a></li>
<li><a href="https://www.cnblogs.com/xiaoyanger/p/7264151.html" target="_blank" rel="noopener">Linux文件权限属性后面有个点</a></li>
<li><a href="http://c.biancheng.net/view/1149.html" target="_blank" rel="noopener">SELinux安全上下文查看方法（超详细）</a></li>
<li><a href="https://stackoverflow.com/questions/58444157/unconfined-t-vs-unlabeled-t-in-selinux" target="_blank" rel="noopener">unconfined_t vs unlabeled_t in SELinux</a></li>
<li><a href="https://superuser.com/questions/191903/how-do-i-remove-any-selinux-context-or-acl" target="_blank" rel="noopener">How do I remove any SELinux context or ACL?</a></li>
</ul>
]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>权限</tag>
        <tag>selinux</tag>
      </tags>
  </entry>
  <entry>
    <title>C与YAML的解析</title>
    <url>/post/865ecfcc.html</url>
    <content><![CDATA[<p><code>YAML</code>是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言），但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。</p>
<p>YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态</p>
<p>适用场景:</p>
<ul>
<li>脚本语言</li>
<li>序列化</li>
<li>配置文件</li>
</ul>
<a id="more"></a>
<p>C语言解析库:<a href="https://pyyaml.org/wiki/LibYAML" target="_blank" rel="noopener">https://pyyaml.org/wiki/LibYAML</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/yaml/libyaml</span><br></pre></td></tr></table></figure>
<h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><ul>
<li>ubuntu<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install libyaml-dev</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># config/public.yaml</span><br><span class="line"></span><br><span class="line">title   : Finex 2011</span><br><span class="line">img_url : /finex/html/img/</span><br><span class="line">css_url : /finex/html/style/</span><br><span class="line">js_url  : /finex/html/js/</span><br><span class="line"></span><br><span class="line">template_dir: html/templ/</span><br><span class="line"></span><br><span class="line">default_act : idx    # used for invalid/missing act=</span><br><span class="line"></span><br><span class="line">pages:</span><br><span class="line">  - act   : idx</span><br><span class="line">    title : Welcome</span><br><span class="line">    html  : public/welcome.phtml</span><br><span class="line">  - act   : reg</span><br><span class="line">    title : Register</span><br><span class="line">    html  : public/register.phtml</span><br><span class="line">  - act   : log</span><br><span class="line">    title : Log in</span><br><span class="line">    html  : public/login.phtml</span><br><span class="line">  - act   : out</span><br><span class="line">    title : Log out</span><br><span class="line">    html  : public/logout.phtml</span><br></pre></td></tr></table></figure>
<h3 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;yaml.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fh = fopen(<span class="string">"public.yaml"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">yaml_parser_t</span> parser;</span><br><span class="line">    <span class="keyword">yaml_token_t</span>  token;   <span class="comment">/* new variable */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize parser */</span></span><br><span class="line">    <span class="keyword">if</span>(!yaml_parser_initialize(&amp;parser))</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Failed to initialize parser!\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">if</span>(fh == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Failed to open file!\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set input file */</span></span><br><span class="line">    yaml_parser_set_input_file(&amp;parser, fh);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BEGIN new code */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        yaml_parser_scan(&amp;parser, &amp;token);</span><br><span class="line">        <span class="keyword">switch</span>(token.type)&#123;</span><br><span class="line">        <span class="comment">/* Stream start/end */</span></span><br><span class="line">        <span class="keyword">case</span> YAML_STREAM_START_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"STREAM START"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_STREAM_END_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"STREAM END"</span>);   <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Token types (read before actual token) */</span></span><br><span class="line">        <span class="keyword">case</span> YAML_KEY_TOKEN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(Key token)   "</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_VALUE_TOKEN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(Value token) "</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Block delimeters */</span></span><br><span class="line">        <span class="keyword">case</span> YAML_BLOCK_SEQUENCE_START_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"&lt;b&gt;Start Block (Sequence)&lt;/b&gt;"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_BLOCK_ENTRY_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"&lt;b&gt;Start Block (Entry)&lt;/b&gt;"</span>);    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_BLOCK_END_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"&lt;b&gt;End block&lt;/b&gt;"</span>);              <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Data */</span></span><br><span class="line">        <span class="keyword">case</span> YAML_BLOCK_MAPPING_START_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"[Block mapping]"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_SCALAR_TOKEN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"scalar %s \n"</span>, token.data.scalar.value); <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Others */</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Got token of type %d\n"</span>, token.type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(token.type != YAML_STREAM_END_TOKEN)</span><br><span class="line">            yaml_token_delete(&amp;token);</span><br><span class="line">    &#125; <span class="keyword">while</span>(token.type != YAML_STREAM_END_TOKEN);</span><br><span class="line">    yaml_token_delete(&amp;token);</span><br><span class="line">    <span class="comment">/* END new code */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup */</span></span><br><span class="line">    yaml_parser_delete(&amp;parser);</span><br><span class="line">    fclose(fh);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析结果"><a href="#解析结果" class="headerlink" title="解析结果"></a>解析结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">STREAM START</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Finex 2011</span><br><span class="line">(Key token)   scalar img_url</span><br><span class="line">(Value token) scalar /finex/html/img/</span><br><span class="line">(Key token)   scalar css_url</span><br><span class="line">(Value token) scalar /finex/html/style/</span><br><span class="line">(Key token)   scalar js_url</span><br><span class="line">(Value token) scalar /finex/html/js/</span><br><span class="line">(Key token)   scalar template_dir</span><br><span class="line">(Value token) scalar html/templ/</span><br><span class="line">(Key token)   scalar default_act</span><br><span class="line">(Value token) scalar idx</span><br><span class="line">(Key token)   scalar pages</span><br><span class="line">(Value token) &lt;b&gt;Start Block (Sequence)&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Start Block (Entry)&lt;/b&gt;</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar act</span><br><span class="line">(Value token) scalar idx</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Welcome</span><br><span class="line">(Key token)   scalar html</span><br><span class="line">(Value token) scalar public/welcome.phtml</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Start Block (Entry)&lt;/b&gt;</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar act</span><br><span class="line">(Value token) scalar reg</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Register</span><br><span class="line">(Key token)   scalar html</span><br><span class="line">(Value token) scalar public/register.phtml</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Start Block (Entry)&lt;/b&gt;</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar act</span><br><span class="line">(Value token) scalar log</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Log in</span><br><span class="line">(Key token)   scalar html</span><br><span class="line">(Value token) scalar public/login.phtml</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Start Block (Entry)&lt;/b&gt;</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar act</span><br><span class="line">(Value token) scalar out</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Log out</span><br><span class="line">(Key token)   scalar html</span><br><span class="line">(Value token) scalar public/logout.phtml</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">STREAM END</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/vc66vcc/article/details/79497466" target="_blank" rel="noopener">YAML C语言范例</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yaml</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt源码分析——virsh</title>
    <url>/post/dec26e6d.html</url>
    <content><![CDATA[<p>libvirt是用来管理虚拟机或虚拟化功能的软件集合，主要包括：<code>libvirt API</code>，<code>libvirtd进程</code>和<code>virsh</code>工具集三部分。最初的目的是为不同的hypervisor提供统一的管理接口</p>
<blockquote>
<p><code>libvirt</code>是将最底层的直接在shell中输入命令来完成的操作进行了抽象封装，给应用程序开发人员提供了统一的，易用的接口。</p>
</blockquote>
<a id="more"></a>
<p>libvirt版本：<code>libvirt-4.9.0</code></p>
<h2 id="libvirt层次体系结构"><a href="#libvirt层次体系结构" class="headerlink" title="libvirt层次体系结构"></a>libvirt层次体系结构</h2><p><img src="/images/2020/09/libviry_api.png" alt="libviry_api"></p>
<p>参照上图，来理一下通过virsh命令或接口创建虚拟机实例的代码执行路径：</p>
<ol>
<li>virsh命令或API接口c创建虚拟机 —— 接口层<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virsh create vm.xml 或者 virDomainPtr virDomainCreateXML (virConnectPtr conn, const char * xmlDesc, unsigned int flags)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>file: src/libvirt-domain.c</p>
</blockquote>
<ol start="2">
<li><p>调用libvirt提供的统一接口 —— 抽象驱动层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conn-&gt;driver-&gt;domainCreateXML(conn, xmlDesc, flags);  //此处的domainCreateXML即抽象的统一接口，这里并不需要关心底层的driver是kvm，还是xen</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用底层的相应虚拟化技术的接口 —— 具体驱动层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">domainCreateXML = qemuDomainCreateXML; //如果driver=qemu，那么此处即调用的qemu注册到抽象驱动层上的函数qemuDomainCreateXML</span><br></pre></td></tr></table></figure>
</li>
<li><p>拼装shell命令，并执行</p>
</li>
</ol>
<h3 id="抽象驱动层"><a href="#抽象驱动层" class="headerlink" title="抽象驱动层"></a>抽象驱动层</h3><p>目前，libvirt以下几种类型的抽象驱动，每一种类型的驱动代表某以功能模块的抽象封装：</p>
<ul>
<li>虚拟化驱动(virDriverPtr)</li>
<li>虚拟网络驱动(virNetworkDriverPtr)</li>
<li>物理网卡驱(virInterfaceDriverPtr)</li>
<li>存储驱动(virStorageDriverPtr)</li>
<li>监控驱动(virDeviceMonitorPtr)</li>
<li>安全驱动(virSecretDriverPtr)</li>
<li>过滤驱动(virNWFilterDriverPtr)</li>
<li>状态驱动(virStateDriverPtr)</li>
</ul>
<h3 id="virsh-start-vm-name"><a href="#virsh-start-vm-name" class="headerlink" title="virsh start vm-name"></a>virsh start vm-name</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virsh start vm-name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启动一个虚拟机</p>
</blockquote>
<h2 id="daemon进程（libvirtd-）"><a href="#daemon进程（libvirtd-）" class="headerlink" title="daemon进程（libvirtd ）"></a>daemon进程（libvirtd ）</h2><p>该后台进程主要实现以下功能：</p>
<ol>
<li>远程代理<br>   所有remote client发送来的命令，由该进程监测执行</li>
<li>本地环境初始化<br>   libvirt服务的启停，用户connection的响应等</li>
<li>根据环境注册各种Driver（qemu, xen, storage…）的实现<br>  不同虚拟化技术以Driver的形式实现，由于libvirt对外提供的是统一的接口，所以各个Driver就是实现这些接口， 即将Driver注册到libvirt中</li>
</ol>
<h2 id="virsh-API调用"><a href="#virsh-API调用" class="headerlink" title="virsh API调用"></a>virsh API调用</h2><blockquote>
<p>将libvirt API封装，以Command Line Interface提供的对外接口</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">virsh define /path-vm-xml/vm_name.xml</span></span><br><span class="line"><span class="meta">$</span><span class="bash">virst start vm-name</span></span><br></pre></td></tr></table></figure>
<p>virsh命令与代码结构之间的关系：</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>对应vshCmdDef变量</th>
<th>对应virsh命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>virsh-domain-monitor.c</td>
<td>domMonitoringCmds</td>
<td>virsh XX(虚拟机监控)</td>
</tr>
<tr>
<td>virsh-domain.c</td>
<td>domManagementCmds</td>
<td>virsh XX(虚拟机操作)</td>
</tr>
<tr>
<td>virsh-host.c</td>
<td>hostAndHypervisorCmds</td>
<td>virsh XX(虚拟机配置)</td>
</tr>
<tr>
<td>virsh-interface.c</td>
<td>ifaceCmds</td>
<td>virsh iface-XX</td>
</tr>
<tr>
<td>virsh-network.c</td>
<td>networkCmds</td>
<td>virsh net-XX</td>
</tr>
<tr>
<td>virsh-nodedev.c</td>
<td>nodedevCmds</td>
<td>virsh net-XX</td>
</tr>
<tr>
<td>virsh-nwfilter.c</td>
<td>nwfilterCmds</td>
<td>virsh nwfilter-XX</td>
</tr>
<tr>
<td>virsh-pool.c</td>
<td>storagePoolCmds</td>
<td>virsh pool-XX</td>
</tr>
<tr>
<td>virsh-secret.c</td>
<td>secretCmds</td>
<td>virsh secret-XX</td>
</tr>
<tr>
<td>virsh-snapshot.c</td>
<td>snapshotCmds</td>
<td>virsh snapshot-XX</td>
</tr>
<tr>
<td>virsh-volume.c</td>
<td>storageVolCmds</td>
<td>virsh vol-XX</td>
</tr>
</tbody>
</table>
<p>有了上面的表格我们就能够根据使用的<strong>virsh命令</strong>找到对应文件的对应<strong>vshCmdDef变量</strong>，在virsh中相关命令实现与具体API的调用文件相对于<code>tools/virsh-domain.c</code> &lt;=&gt; <code>src/libvirt-domain.c</code></p>
<blockquote>
<p>一个<code>vshCmdDef</code>结构对应一个<code>virsh</code>命令，其中<code>vshCmdOptDef</code>定义了命令的参数，<code>vshCmdInfo</code>定义了命令的帮助信息，<code>bool (*handler) (vshControl *, const vshCmd *)</code>定义了命令的处理函数。</p>
</blockquote>
<h3 id="domManagementCmds"><a href="#domManagementCmds" class="headerlink" title="domManagementCmds"></a>domManagementCmds</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vshCmdDef domManagementCmds[] = &#123;</span><br><span class="line">    &#123;.name = <span class="string">"attach-device"</span>,</span><br><span class="line">     .handler = cmdAttachDevice,</span><br><span class="line">     .opts = opts_attach_device,</span><br><span class="line">     .info = info_attach_device,</span><br><span class="line">     .flags = <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    &#123;.name = <span class="string">"start"</span>,</span><br><span class="line">     .handler = cmdStart,</span><br><span class="line">     .opts = opts_start,</span><br><span class="line">     .info = info_start,</span><br><span class="line">     .flags = <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: tools/virsh-domain.c</p>
</blockquote>
<p>启动虚拟机的主要工作：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virst start vm-name</span><br></pre></td></tr></table></figure></p>
<p>start命令的处理流程是<code>cmdStart</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span></span><br><span class="line">cmdStart(vshControl *ctl, <span class="keyword">const</span> vshCmd *cmd)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((nfds ?</span><br><span class="line">         virDomainCreateWithFiles(dom, nfds, fds, flags) :</span><br><span class="line">         virDomainCreateWithFlags(dom, flags)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> started;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>virDomainCreateWithFiles</code>: 启动已定义的域。如果调用成功，则域将从已定义的域池移动到正在运行的域池</li>
<li><code>virDomainCreateWithFlags</code>: 启动已定义的域。如果调用成功，则域将从已定义的域池移动到正在运行的域池</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virDomainCreateWithFiles</span><br><span class="line">  \-&gt; conn-&gt;driver-&gt;domainCreateWithFiles</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virDomainCreateWithFlags</span><br><span class="line">  \-&gt; conn-&gt;driver-&gt;domainCreateWithFlags</span><br><span class="line">      \-&gt; qemuDomainCreateWithFlags</span><br><span class="line">        \-&gt; qemuProcessStart</span><br><span class="line">          \-&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: src/qemu/qemu_driver.c</p>
</blockquote>
<h2 id="libvirt-for-qemu"><a href="#libvirt-for-qemu" class="headerlink" title="libvirt for qemu"></a>libvirt for qemu</h2><p>由于libvirt是将最底层需要执行的shell命令进行了抽象封装，供上层应用使用。因此在其封装的借口中必须存在一个<code>shell运行环境</code></p>
<ul>
<li>底层qemu的命令何时被创建？</li>
<li>底层shell环境的搭建？</li>
<li>如何执行的该命令？</li>
</ul>
<h2 id="配置QEMU环境变量与参数"><a href="#配置QEMU环境变量与参数" class="headerlink" title="配置QEMU环境变量与参数"></a>配置QEMU环境变量与参数</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">'kvm'</span> <span class="attr">xmlns:qemu</span>=<span class="string">'http://libvirt.org/schemas/domain/qemu/1.0'</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">'-newarg'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:env</span> <span class="attr">name</span>=<span class="string">'QEMU_ENV'</span> <span class="attr">value</span>=<span class="string">'VAL'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">qemu:commandline</span> <span class="attr">xmlns:qemu</span>=<span class="string">'http://libvirt.org/schemas/domain/qemu/1.0'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">'ARGUMENT'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在xml配置文件中必须指定<code>&lt;domain type=&#39;kvm&#39; xmlns:qemu=&#39;http://libvirt.org/schemas/domain/qemu/1.0&#39;&gt;</code>,因为默认的<code>&lt;domain type=&#39;kvm&#39;&gt;</code>不支持<code>qemu:commandline</code>的标签</p>
<ul>
<li><a href="https://libvirt.org/drvqemu.html#qemucommand" target="_blank" rel="noopener">https://libvirt.org/drvqemu.html#qemucommand</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.chinaunix.net/uid-26133817-id-4909216.html" target="_blank" rel="noopener">libvirt架构及源码分析</a></li>
<li><a href="https://computingforgeeks.com/virsh-commands-cheatsheet/" target="_blank" rel="noopener">virsh commands cheatsheet to manage KVM guest virtual machines</a></li>
<li><a href="http://blog.vmsplice.net/2011/04/how-to-pass-qemu-command-line-options.html" target="_blank" rel="noopener">How to pass QEMU command-line options through libvirt</a></li>
<li><a href="https://wiki.libvirt.org/page/QEMUSwitchToLibvirt#-s_2" target="_blank" rel="noopener">QEMUSwitchToLibvirt(-s)</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
        <category>libvirt</category>
      </categories>
      <tags>
        <tag>virsh</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt透传qemu参数</title>
    <url>/post/549bb2ea.html</url>
    <content><![CDATA[<p>在使用virsh通过libvirt接口创建虚拟机时，存在一些qemu的启动参数或者系统环境变量而libvirt接口不支持，因此需要将参数直接透传到qemu的启动命令。</p>
<p>新创建的每一个虚拟机都有一个<code>xml配置文件</code>，用来定义该虚拟机的配置，因此可以直接在该xml文件中利用<code>qemu:commandline</code>标记添加需要透传的<code>参数</code>或<code>环境变量</code></p>
<a id="more"></a>
<h2 id="编辑XML文件"><a href="#编辑XML文件" class="headerlink" title="编辑XML文件"></a>编辑XML文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">'kvm'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>QEMUGuest1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uuid</span>&gt;</span>c7a5fdbd-edaf-9455-926a-d65c16db1809<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">commandline</span> <span class="attr">xmlns</span>=<span class="string">"http://libvirt.org/schemas/domain/qemu/1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">'-newarg'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">'parameter'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:env</span> <span class="attr">name</span>=<span class="string">'ID'</span> <span class="attr">value</span>=<span class="string">'wibble'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:env</span> <span class="attr">name</span>=<span class="string">'BAR'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="virt-xml"><a href="#virt-xml" class="headerlink" title="virt-xml"></a>virt-xml</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">virt-xml <span class="variable">$DOMAIN</span> --edit --confirm --qemu-commandline <span class="string">'-newarg parameter'</span></span></span><br></pre></td></tr></table></figure>
<h2 id="libvirt函数接口添加"><a href="#libvirt函数接口添加" class="headerlink" title="libvirt函数接口添加"></a>libvirt函数接口添加</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.libvirt.org/kbase/qemu-passthrough-security.html" target="_blank" rel="noopener">QEMU command-line passthrough</a></li>
<li><a href="http://blog.vmsplice.net/2011/04/how-to-pass-qemu-command-line-options.html" target="_blank" rel="noopener"></a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
        <category>libvirt</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下性能分析---bootchart</title>
    <url>/post/5f89ded7.html</url>
    <content><![CDATA[<blockquote>
<p><code>BootChart</code>是一个用于linux启动过程性能分析的开源软件工具，它可以在内核装载后就开始运行，记录各个程序启动占用的时间、CPU以及硬盘读写，直到系统启动完成为止。进入系统后，bootchart可以将启动时记录下的内容生成多种格式（PNG，SVG或者EPS）的图形报表，以便分析。</p>
</blockquote>
<a id="more"></a>
<h1 id="一般应用运行分析"><a href="#一般应用运行分析" class="headerlink" title="一般应用运行分析"></a>一般应用运行分析</h1><h2 id="用perf录制系统的sched情况"><a href="#用perf录制系统的sched情况" class="headerlink" title="用perf录制系统的sched情况"></a>用perf录制系统的sched情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo perf <span class="built_in">sched</span> record -a</span></span><br><span class="line">^C[ perf record: Woken up 5 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 11.284 MB perf.data (87520 samples) ]</span><br></pre></td></tr></table></figure>
<h2 id="生成timechart"><a href="#生成timechart" class="headerlink" title="生成timechart"></a>生成timechart</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo perf timechart</span></span><br><span class="line">Written 24.6 seconds of trace to output.svg.</span><br></pre></td></tr></table></figure>
<p>使用Firefox浏览器查看生成结果：</p>
<p><img src="/images/2020/09/bootchart_sample.png" alt="bootchart_sample"></p>
<h1 id="系统启动时间的分析"><a href="#系统启动时间的分析" class="headerlink" title="系统启动时间的分析"></a>系统启动时间的分析</h1><h2 id="bootchart"><a href="#bootchart" class="headerlink" title="bootchart"></a>bootchart</h2><p><strong>ubuntu20.04中不适用，不过使用<code>systemd-analyze</code>可以查看开机时间和耗时部分</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install bootchart pybootchartgui</span><br></pre></td></tr></table></figure>
<blockquote>
<p>~在ubuntu20.04系统安装后(其他系统安装也可)，下次系统启动时生成一个系统启动时的各个组件启动所花的时间的记录的图表，此图表位于:<code>/var/log/bootchart</code>文件夹下。默认格式为.png格式~</p>
</blockquote>
<h2 id="initcall-debug内核启动图"><a href="#initcall-debug内核启动图" class="headerlink" title="initcall_debug内核启动图"></a>initcall_debug内核启动图</h2><p>这个方法多用于嵌入式系统中，在内核命令行中添加<code>initcall_debug</code>参数，可以在<code>dmesg</code>日志中打印出每个函数调用的时间点</p>
<ol>
<li>将<code>dmesg</code>的日志保存到<code>boot.log</code>中</li>
<li>运行内核源码中自带的<code>scripts/bootgraph.pl</code>脚本生成启动图(矢量图)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scripts/bootgraph.pl boot.log &gt; boot.svg</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>bootchart</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下性能分析---kernelshark</title>
    <url>/post/321101fe.html</url>
    <content><![CDATA[<p>Kernelshark作为trace-cmd的前端，借助图形化，灵活的filter，缩放功能，能更有效的帮助分析，高效的得到结果。它包含Ftrace以进行内部Linux内核跟踪，以分析内核中正在发生的事情。</p>
<blockquote>
<p><code>trace-cmd</code>是设置读取<code>ftrace</code>的命令行工具，<code>kernelshark</code>既可以记录数据，也可以图形化分析结果。</p>
</blockquote>
<a id="more"></a>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install trace-cmd kernelshark</span><br></pre></td></tr></table></figure>
<h2 id="trace-cmd"><a href="#trace-cmd" class="headerlink" title="trace-cmd"></a>trace-cmd</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://git.kernel.org/pub/scm/linux/kernel/git/rostedt/trace-cmd.git</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="跟踪系统进程切换"><a href="#跟踪系统进程切换" class="headerlink" title="跟踪系统进程切换"></a>跟踪系统进程切换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo trace-cmd record -e <span class="string">'sched_wakeup*'</span> -e sched_switch -e <span class="string">'sched_migrate*'</span></span></span><br><span class="line">Hit Ctrl^C to stop recording</span><br><span class="line">^C</span><br><span class="line">CPU0 data recorded at offset=0x6ea000</span><br><span class="line">    2752512 bytes in size</span><br><span class="line">CPU1 data recorded at offset=0x98a000</span><br><span class="line">    2891776 bytes in size</span><br><span class="line">CPU2 data recorded at offset=0xc4c000</span><br><span class="line">    2756608 bytes in size</span><br><span class="line">CPU3 data recorded at offset=0xeed000</span><br><span class="line">    2805760 bytes in size</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>CTRL+c</code>停止记录并保存到trace.dat中</p>
</blockquote>
<h2 id="kernelshark来打开录制的点"><a href="#kernelshark来打开录制的点" class="headerlink" title="kernelshark来打开录制的点"></a>kernelshark来打开录制的点</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kernelshark trace.dat</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>方便查看某一个进程在某一个时刻在做什么，在哪个CPU核上运行，其他的CPU核在干什么</p>
</blockquote>
<p><img src="/images/2020/09/kernel_shark_sample.png" alt="kernel_shark_sample"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>kernelshark</tag>
      </tags>
  </entry>
  <entry>
    <title>Qemu虚拟机pci设备透传——网卡</title>
    <url>/post/b3396e6f.html</url>
    <content><![CDATA[<p>在qemu虚拟机中为了提高网络的性能，将本地host端的多余网卡透传到虚拟机中使用。</p>
<p>设备的透传需要主机支持<code>Intel(VT-d)</code>或<code>AMD (IOMMU)</code>硬件虚拟化加速技术</p>
<a id="more"></a>
<p><img src="/images/2020/09/qemu_net_passthrough.png" alt="qemu_net_passthrough"></p>
<h2 id="查看是否开启IOMMU"><a href="#查看是否开启IOMMU" class="headerlink" title="查看是否开启IOMMU"></a>查看是否开启IOMMU</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg | grep -e DMAR -e IOMMU</span><br></pre></td></tr></table></figure>
<h3 id="开启IOMMU功能"><a href="#开启IOMMU功能" class="headerlink" title="开启IOMMU功能"></a>开启IOMMU功能</h3><blockquote>
<p>操作系统：Centos7,cpu: Intel(R) Xeon(R)</p>
</blockquote>
<p>编辑<code>/boot/efi/EFI/centos/grub.cfg</code>文件，在系统启动内核的选项<code>linuxefi</code>中追加<code>intel_iommu=on</code></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;       linuxefi /vmlinuz-3.10.0-1127.18.2.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=en_US.UTF-8 intel_iommu=on</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt;       linuxefi /vmlinuz-3.10.0-1127.18.2.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>
<p>系统重启后，查看支持IOMMU的设备：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> find /sys/kernel/iommu_groups/ -<span class="built_in">type</span> l</span></span><br><span class="line">/sys/kernel/iommu_groups/0/devices/0000:00:00.0</span><br><span class="line">/sys/kernel/iommu_groups/1/devices/0000:00:04.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="查看BIOS是否开启intel-vt-x-vt-d"><a href="#查看BIOS是否开启intel-vt-x-vt-d" class="headerlink" title="查看BIOS是否开启intel-vt-x/vt-d"></a>查看BIOS是否开启intel-vt-x/vt-d</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep vmx</span><br></pre></td></tr></table></figure>
<p>如果没有开启需要在BOIS中使能<code>intel-vt-x/vt-d</code></p>
<h2 id="选择绑定网卡"><a href="#选择绑定网卡" class="headerlink" title="选择绑定网卡"></a>选择绑定网卡</h2><p>通过<code>ifconfig ethx down/up</code>开关相应的网络节点，获取相应的pci地址，该地址可以通过<code>dmesg</code>查看判断</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> dmesg -c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ifconfig p1p1 down</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dmesg</span></span><br><span class="line">[27244.804247] ixgbe 0000:3b:00.0: removed PHC on p1p1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>p1p1</code>端口对应网卡的pci地址：0000:3b:00.0</p>
</blockquote>
<h2 id="加载vfio驱动"><a href="#加载vfio驱动" class="headerlink" title="加载vfio驱动"></a>加载vfio驱动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe vfio</span><br><span class="line">modprobe vfio-pci</span><br></pre></td></tr></table></figure>
<h2 id="网卡透传"><a href="#网卡透传" class="headerlink" title="网卡透传"></a>网卡透传</h2><h3 id="Host端解绑网卡"><a href="#Host端解绑网卡" class="headerlink" title="Host端解绑网卡"></a>Host端解绑网卡</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "0000:3b:00.0" &gt; /sys/bus/pci/devices/0000\:3b\:00.0/driver/unbind</span><br></pre></td></tr></table></figure>
<p>注意在解绑网卡是需要将该网卡下的所有端口设备全部解绑，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /sys/bus/pci/devices/0000\:18\:00.0/iommu_group/devices/</span><br><span class="line">0000:18:00.0  0000:18:00.1</span><br></pre></td></tr></table></figure>
<p>需要将<code>0000:18:00.0</code>，<code>0000:18:00.1</code>全部进行解绑</p>
<h3 id="生成vfio设备"><a href="#生成vfio设备" class="headerlink" title="生成vfio设备"></a>生成vfio设备</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lspci -s 0000:3b:00.0 -n</span></span><br><span class="line">3b:00.0 0200: 8086:154d (rev 01)</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"8086 154d"</span> &gt; /sys/bus/pci/drivers/vfio-pci/new_id</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>/dev/vfio/</code>下面会有个以阿拉伯数字命名的文件，对应vfio设备组</p>
</blockquote>
<h3 id="绑定vfio总线驱动"><a href="#绑定vfio总线驱动" class="headerlink" title="绑定vfio总线驱动"></a>绑定vfio总线驱动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "0000:3b:00.0" &gt; /sys/bus/pci/drivers/vfio-pci/bind</span><br></pre></td></tr></table></figure>
<h2 id="虚拟机参数"><a href="#虚拟机参数" class="headerlink" title="虚拟机参数"></a>虚拟机参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-device vfio-pci,host=0000:3b:00.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在qemu的启动参数中添加上面参数，该物理网卡将被透传到虚拟机中。</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在进行网卡的透传过程中，出现以下错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-09-23T10:16:51.707664Z qemu-system-x86_64: -device vfio-pci,host=0000:3b:00.0,id=hostdev0,bus=pci.0,addr=0xa: vfio 0000:3b:00.0: group 25 is not viable</span><br><span class="line">Please ensure all devices within the iommu_group are bound to their vfio bus driver.</span><br></pre></td></tr></table></figure></p>
<p>该错误的原因：在进行网卡透传时，以上提到的pci地址（0000:3b:00.0）其实为一张物理网卡的一个端口地址，一般的网卡都是两个端口，而此时只绑定了一个端口，需要将两个端口设备都进行解绑并绑定到vfio总线驱动上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls /sys/bus/pci/devices/0000\:18\:00.0/iommu_group/devices/</span></span><br><span class="line">0000:18:00.0  0000:18:00.1</span><br></pre></td></tr></table></figure>
<h2 id="脚本处理"><a href="#脚本处理" class="headerlink" title="脚本处理"></a>脚本处理</h2><p>为了以后处理方便将host端的配置进行脚本处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> -x</span></span><br><span class="line"></span><br><span class="line">PCI_ADDR="18:00.1"</span><br><span class="line"></span><br><span class="line">modprobe vfio</span><br><span class="line">modprobe vfio-pci</span><br><span class="line">lsmod | grep vfio</span><br><span class="line"></span><br><span class="line">lspci -s $PCI_ADDR -n  #em2</span><br><span class="line"></span><br><span class="line">device_id=`lspci -s $PCI_ADDR -n | awk '&#123;print $3&#125;'`</span><br><span class="line">device_id=$&#123;device_id/:/ &#125; #去除：号</span><br><span class="line">echo "PCI: $PCI_ADDR, Device ID:$device_id"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">生成vfio设备</span></span><br><span class="line">echo "$device_id" &gt; /sys/bus/pci/drivers/vfio-pci/new_id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">pci设备绑定vfio总线驱动（解绑--绑定）</span></span><br><span class="line">pci_device=/sys/bus/pci/devices/0000:$PCI_ADDR/iommu_group/devices/</span><br><span class="line">pci_device=`echo $pci_device | sed 's/:/\\:/g'` #添加转移符，echo打印不出来</span><br><span class="line"><span class="meta">#</span><span class="bash">ls <span class="variable">$pci_device</span></span></span><br><span class="line">for dev in `ls $pci_device`</span><br><span class="line">do</span><br><span class="line">    echo "---dev:$dev"</span><br><span class="line">    _pci_dev_unbind="/sys/bus/pci/devices/$dev/driver/unbind"</span><br><span class="line">    _pci_dev_unbind=`echo $_pci_dev_unbind | sed 's/:/\\:/g'`</span><br><span class="line">    #ls $_pci_dev_unbind</span><br><span class="line">    echo "$dev" &gt; $_pci_dev_unbind</span><br><span class="line">    echo "$dev" &gt; /sys/bus/pci/drivers/vfio-pci/bind</span><br><span class="line">    lspci -s $dev -k</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">ls /dev/vfio/</span><br></pre></td></tr></table></figure>
<h2 id="virsh命令解除绑定"><a href="#virsh命令解除绑定" class="headerlink" title="virsh命令解除绑定"></a>virsh命令解除绑定</h2><blockquote>
<p>Host端的设备解除绑定（就是不被host系统所管理使用）后，通过给guest系统使用前的必备操作</p>
</blockquote>
<ul>
<li><p>列出设备ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> virsh nodedev-list | grep pci   | grep 18</span></span><br><span class="line">pci_0000_18_00_0</span><br><span class="line">pci_0000_18_00_1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前使用的驱动程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> virsh nodedev-dumpxml pci_0000_18_00_0</span></span><br><span class="line">&lt;device&gt;</span><br><span class="line">  &lt;name&gt;pci_0000_18_00_0&lt;/name&gt;</span><br><span class="line">  &lt;path&gt;/sys/devices/pci0000:17/0000:17:03.0/0000:18:00.0&lt;/path&gt;</span><br><span class="line">  &lt;parent&gt;pci_0000_17_03_0&lt;/parent&gt;</span><br><span class="line">  &lt;driver&gt;</span><br><span class="line">    &lt;name&gt;vfio-pci&lt;/name&gt;</span><br><span class="line">  &lt;/driver&gt;</span><br><span class="line">  &lt;capability type='pci'&gt;</span><br><span class="line">    &lt;domain&gt;0&lt;/domain&gt;</span><br><span class="line">    &lt;bus&gt;24&lt;/bus&gt;</span><br><span class="line">    &lt;slot&gt;0&lt;/slot&gt;</span><br><span class="line">    &lt;function&gt;0&lt;/function&gt;</span><br><span class="line">    &lt;product id='0x165f'&gt;NetXtreme BCM5720 2-port Gigabit Ethernet PCIe&lt;/product&gt;</span><br><span class="line">    &lt;vendor id='0x14e4'&gt;Broadcom Inc. and subsidiaries&lt;/vendor&gt;</span><br><span class="line">    &lt;iommuGroup number='26'&gt;</span><br><span class="line">      &lt;address domain='0x0000' bus='0x18' slot='0x00' function='0x0'/&gt;</span><br><span class="line">      &lt;address domain='0x0000' bus='0x18' slot='0x00' function='0x1'/&gt;</span><br><span class="line">    &lt;/iommuGroup&gt;</span><br><span class="line">    &lt;numa node='0'/&gt;</span><br><span class="line">    &lt;pci-express&gt;</span><br><span class="line">      &lt;link validity='cap' port='0' speed='5' width='2'/&gt;</span><br><span class="line">      &lt;link validity='sta' speed='5' width='1'/&gt;</span><br><span class="line">    &lt;/pci-express&gt;</span><br><span class="line">  &lt;/capability&gt;</span><br><span class="line">&lt;/device&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这是设备手动解除绑定后dump出的详细信息，如果没有解除绑定数据可能不同</p>
</blockquote>
<ul>
<li>解绑当前设备<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> virsh nodedev-detach pci_0000_18_00_0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> virsh nodedev-detach pci_0000_18_00_1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.kernel.org/doc/Documentation/vfio.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vfio.txt</a></li>
<li><a href="https://wiki.archlinux.org/index.php/PCI_passthrough_via_OVMF" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/PCI_passthrough_via_OVMF</a></li>
<li><a href="https://blog.csdn.net/gerrylee93/article/details/106477055" target="_blank" rel="noopener">KVM网卡透传</a></li>
<li><a href="https://www.cnblogs.com/xia-dong/p/11542771.html" target="_blank" rel="noopener">Qemu 虚拟机网卡透传（PCI Pass Through）</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>网卡</tag>
        <tag>pci</tag>
      </tags>
  </entry>
  <entry>
    <title>WebVirtMgr for Qemu</title>
    <url>/post/32f26c86.html</url>
    <content><![CDATA[<p><code>WebVirtMgr</code>采用几乎纯Python开发，其前端是基于Python的Django，后端是基于Libvirt的Python接口，将日常kvm的管理操作变的更加的可视化。</p>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://retspen.github.io/" target="_blank" rel="noopener">WebVirtMgr</a></li>
<li><a href="https://github.com/retspen/webvirtmgr" target="_blank" rel="noopener">github-webvirtmgr</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/49120559" target="_blank" rel="noopener">KVM 虚拟化环境搭建 - WebVirtMgr</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
        <category>libvirt</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>libvirt</tag>
        <tag>webvirtmgr</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机配置</title>
    <url>/post/e0896859.html</url>
    <content><![CDATA[<p>交换机配置相关信息：</p>
<a id="more"></a>
<h1 id="二层交换机"><a href="#二层交换机" class="headerlink" title="二层交换机"></a>二层交换机</h1><p>二层交换机属<code>数据链路层</code>设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些<code>MAC地址</code>与对应的<code>端口</code>记录在自己内部的一个地址表中。</p>
<h2 id="二层接口模式"><a href="#二层接口模式" class="headerlink" title="二层接口模式"></a>二层接口模式</h2><p>交换机每一个端口可以配置为以下二层模式</p>
<ul>
<li>Access 模式:只接收没有 VLAN 标记的数据包,带有 VLAN 标记的数据包会被丢弃。接收到的数据包会自动标记为端口的 VLAN 信息,只能属于1个VLAN。通常用于服务器和交换机之间的链接。</li>
<li>Trunk 模式:接收和发送带有 VLAN 标记的数据包,没有 VLAN 标记的数据包将被丢弃。这个模式可以配置多个 VLAN ID。</li>
<li>Hybrid 模式:带有 VLAN 标记和没有 VLAN 标记的数据包均可以被接收, 同时传送多个VLAN的包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show interfaces switchport</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">Interface         Mode           Access vlan          Allowed vlans</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">Eth1/1            access         1</span><br><span class="line">Eth1/2            access         1</span><br><span class="line">Eth1/3            access         1</span><br><span class="line">Eth1/4            access         1</span><br><span class="line">Eth1/5            access         1</span><br><span class="line">Eth1/6            access         1</span><br><span class="line">Eth1/7            access         1</span><br><span class="line">Eth1/8            access         1</span><br><span class="line">Eth1/9            access         1</span><br><span class="line">Eth1/10           access         1</span><br><span class="line">Eth1/11           access         1</span><br></pre></td></tr></table></figure>
<h1 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h1><p>三层交换技术就是将路由技术与交换技术合二为一的技术。在对第一个数据流进行路由后，它将会产生一个<code>MAC地址</code>与<code>IP地址</code>的映射表，当同样的数据流再次通过时，将根据此表直接从二层通过而不是再次路由，从而消除了路由器进行路由选择而造成网络的延迟，提高了数据包转发的效率。</p>
<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><h2 id="端口速度配置"><a href="#端口速度配置" class="headerlink" title="端口速度配置"></a>端口速度配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master] &gt; enable</span><br><span class="line">master] # configure terminal</span><br><span class="line">master] (config) # interface ethernet 1/6 speed 10G force</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置第6个端口的速率为10G</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>交换机</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7内核编译及RPM包的制作</title>
    <url>/post/cb2d9d77.html</url>
    <content><![CDATA[<p>特定内核的编译安装</p>
<a id="more"></a>
<h2 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y groups install "Development Tools"</span><br><span class="line">yum install ncurses-devel make gcc bc openssl-devel</span><br><span class="line"></span><br><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.14.105.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf linux-4.14.105.tar.gz</span><br><span class="line"></span><br><span class="line">cp /boot/config-`uname -r` ./linux-4.14.105/.config</span><br><span class="line"></span><br><span class="line">cd linux-4.14.105</span><br><span class="line"></span><br><span class="line">make menuconfig  #进入后直接保存保存配置</span><br><span class="line">make oldconfig</span><br><span class="line"></span><br><span class="line">make kernelversion</span><br><span class="line">make INSTALL_MOD_STRIP=1 all -j32</span><br><span class="line"></span><br><span class="line">make INSTALL_MOD_STRIP=1 modules_install</span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -lh /lib/modules</span></span><br><span class="line"></span><br><span class="line">make INSTALL_MOD_STRIP=1 install</span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -lh /boot</span></span><br></pre></td></tr></table></figure>
<p>通过以上命令可以完成内核的编译。</p>
<blockquote>
<p>Use the INSTALL_MOD_STRIP option for removing debugging symbols:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make INSTALL_MOD_STRIP=1 modules_install</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="打包——RPM"><a href="#打包——RPM" class="headerlink" title="打包——RPM"></a>打包——RPM</h2><p>在源码编译的基础上进行rpm包的制作，主要是利用在源码编译阶段生成对内核的配置<code>.config</code>文件后，不进行安装而是直接打包。</p>
<p>安装rpm包制作工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install rpm-build</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make rpm-pkg -j32</span><br></pre></td></tr></table></figure>
<p>编译完成在<code>~/rpmbuild/RPMS/x86_64/</code>目录下生成rpm安装包：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -lh ~/rpmbuild/RPMS/x86_64/</span><br><span class="line">-rw-r--r-- 1 root root 515M 10月 10 06:28 /root/rpmbuild/RPMS/x86_64/kernel-4.14.105-1.x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 135M 10月 10 06:30 /root/rpmbuild/RPMS/x86_64/kernel-devel-4.14.105-1.x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 1.2M 10月 10 06:28 /root/rpmbuild/RPMS/x86_64/kernel-headers-4.14.105-1.x86_64.rpm</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>为啥rpm包这么大，官方rpm包一般五六十兆大小？？？</p>
<blockquote>
<p>主要是编译生成的<code>ko</code>文件增大所致，应该包含了debug信息和符号表<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make INSTALL_MOD_STRIP=1 rpm-pkg</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -iUv ~/rpmbuild/RPMS/x86_64/kernel-*.rpm</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install ~/rpmbuild/RPMS/x86_64/kernel-*.rpm</span><br></pre></td></tr></table></figure></p>
<h2 id="内核编译命令"><a href="#内核编译命令" class="headerlink" title="内核编译命令"></a>内核编译命令</h2><p>编译内核生成<code>centos rpm</code>或<code>ubuntu deb</code>包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make rpm          #生成带源码的RPM包</span><br><span class="line">make rpm-pkg      #生成带源码的RPM包,同上</span><br><span class="line">make binrpm-pkg   #生成包含内核和驱动的RMP包</span><br><span class="line">make deb-pkg      #生成带源码的debian包</span><br><span class="line">make bindeb-pkg   #生成包含内核和驱动的debian包</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>rpm-pkg</code>: 每次编译前会先clean,重复编译会很慢</p>
</blockquote>
<p>linux内核<code>make help</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel packaging:</span><br><span class="line">  rpm-pkg             - Build both source and binary RPM kernel packages</span><br><span class="line">  binrpm-pkg          - Build only the binary kernel RPM package</span><br><span class="line">  deb-pkg             - Build both source and binary deb kernel packages</span><br><span class="line">  bindeb-pkg          - Build only the binary kernel deb package</span><br><span class="line">  tar-pkg             - Build the kernel as an uncompressed tarball</span><br><span class="line">  targz-pkg           - Build the kernel as a gzip compressed tarball</span><br><span class="line">  tarbz2-pkg          - Build the kernel as a bzip2 compressed tarball</span><br><span class="line">  tarxz-pkg           - Build the kernel as a xz compressed tarball</span><br><span class="line">  perf-tar-src-pkg    - Build perf-4.14.105.tar source tarball</span><br><span class="line">  perf-targz-src-pkg  - Build perf-4.14.105.tar.gz source tarball</span><br><span class="line">  perf-tarbz2-src-pkg - Build perf-4.14.105.tar.bz2 source tarball</span><br><span class="line">  perf-tarxz-src-pkg  - Build perf-4.14.105.tar.xz source tarball</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make clean            #删除编译中间文件，但是保留配置</span><br><span class="line">make mrproper         #删除包括配置文件的所有构建文件</span><br><span class="line">make distclean        #执行mrproper所做的一切，并删除备份文件</span><br><span class="line"></span><br><span class="line">make menuconfig       #文本图形方式配置内核</span><br><span class="line">make oldconfig        #基于当前的.config文件提示更新内核</span><br><span class="line">make defconfig        #生成默认的内核配置</span><br><span class="line">make allmodconfig     #所有的可选的选项构建成模块</span><br><span class="line">make allyesconfig     #生成全部选择是内核配置</span><br><span class="line">make noconfig         #生成全部选择否的内核配置</span><br><span class="line"></span><br><span class="line">make all              #构建所有目标</span><br><span class="line">make bzImage          #构建内核映像</span><br><span class="line">make modules          #构建所有驱动</span><br><span class="line">make dir/             #构建指定目录</span><br><span class="line">make dir/file.[s|o|i] #构建指定文件</span><br><span class="line">make dir/file.ko      #构建指定驱动</span><br><span class="line"></span><br><span class="line">make install          #安装内核</span><br><span class="line">make modules_install  #安装驱动</span><br><span class="line"></span><br><span class="line">make xmldocs          #生成xml文档</span><br><span class="line">make pdfdocs          #生成pdf文档</span><br><span class="line">maek htmldocs         #生成html文档</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wiki.centos.org/zh/HowTos/I_need_the_Kernel_Source" target="_blank" rel="noopener">我需要内核的源代码</a></li>
<li><a href="https://wiki.centos.org/zh/HowTos/Custom_Kernel" target="_blank" rel="noopener">我需要创建一个自设的内核</a></li>
<li><a href="http://www.owlriver.com/tips/non-root/" target="_blank" rel="noopener">Building Source RPM as non-root under CentOS*</a></li>
<li><a href="https://www.cnblogs.com/wangjq19920210/p/10819541.html" target="_blank" rel="noopener">kernel 4.18.18 rpm 制作</a></li>
<li><a href="https://blog.csdn.net/csujiangyu/article/details/84718750" target="_blank" rel="noopener">Linux kernel编译指南</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>centos</tag>
        <tag>rpm</tag>
      </tags>
  </entry>
  <entry>
    <title>CRTC for drm</title>
    <url>/post/e15c0180.html</url>
    <content><![CDATA[<p><code>DRM</code>是linux下的图形渲染架构(Direct Render Manager),具体的说是显卡驱动的一种架构，为了给上层应用提供操作接口。而显卡，最基本的功能就是把用户的绘图渲染后输出到显示屏上，DRM主要是为了在软件层面实现这一目标。这里主要就包括两部分，<code>硬件设备</code>、<code>软件模块</code></p>
<p><img src="/images/2020/10/drm.png" alt="drm"></p>
<blockquote>
<p><code>CRTC</code>主要负责从Framebuffer中读出待显示的图像，并按照相应的格式输出给Encoder</p>
</blockquote>
<p><code>CRTC</code>是阴极射线显像管上下文（Cathode Ray Tube Context）,作用是读取当前Framebuffer的像素数据并借助于PLL电路从其生成视频模式定时信号。</p>
<a id="more"></a>
<p><img src="/images/2020/10/drm_layer.png" alt="drm_layer"></p>
<p>DRM中<code>CRTC</code>模块主要的作用：</p>
<ul>
<li>配置适合显示器的分辨率（kernel）并输出相应时序（hardware logic）</li>
<li>扫描framebuffer送显到一个或多个显示设备中</li>
<li>更新framebuffer</li>
</ul>
<p>CRTC模块产生vbank信号进行场同步刷新</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://elinux.org/images/7/71/Elce11_dae.pdf" target="_blank" rel="noopener">DRM Driver Development For Embedded Systems</a></li>
<li><a href="https://blog.csdn.net/dearsq/article/details/78394388" target="_blank" rel="noopener">Linux DRM（二）基本概念和特性</a></li>
<li><a href="https://blog.csdn.net/boyemachao/article/details/83576684" target="_blank" rel="noopener">linux drm 架构及linux drm 架构 之代码分析</a></li>
<li><a href="https://blog.csdn.net/hexiaolong2009/article/details/105961192" target="_blank" rel="noopener">关于 DRM 中 DUMB 和 PRIME 名字的由来</a></li>
<li><a href="https://blog.csdn.net/hexiaolong2009/article/details/89810355" target="_blank" rel="noopener">DRM 驱动程序开发（开篇）</a></li>
<li><a href="http://tinylab.org/linux-graphics-stack-overview#%E8%83%8C%E6%99%AFdrm--buffer-managementframe-buffer--planekernel-mode-setting" target="_blank" rel="noopener">Linux 图形栈一览：基于 DRM 和 Wayland</a></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>drm</tag>
        <tag>crtc</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd服务的添加</title>
    <url>/post/1fc281b1.html</url>
    <content><![CDATA[<p>在linux的平时使用中，需要一些常驻后台的程序，这些为了方便操作可以将其作成一个systemd服务，通过systemd的操作命令进行管理。</p>
<a id="more"></a>
<p>systemd服务的目录<code>/usr/lib/systemd/system</code>下添加<code>test.service</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Test service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;LD_LIBRARY_PATH=/usr/local/lib/:/usr/local/lib64/&quot;</span><br><span class="line">Environment=&quot;MY_ENV=123&quot;</span><br><span class="line">ExecStart=/bin/testcmd</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<ul>
<li>开启：<code>systemctl start test</code></li>
<li>关闭：<code>systemctl stop test</code></li>
</ul>
<h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;LD_LIBRARY_PATH=/usr/local/lib/:/usr/local/lib64/&quot;</span><br><span class="line">Environment=&quot;MY_ENV=123&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>systemctl --help</code></p>
</blockquote>
<p><code>EnvironmentFile</code>关键字是在环境变量配置较多的情况下，可以编辑到一个文件通过该变量一次性导入，编辑文件的一行为一个环境变量的定义。</p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><ul>
<li><code>ExecStart=</code>： 启动服务时执行的命令</li>
<li><code>ExecStartPre=, ExecStartPost=</code>： 启动服务之前与之后执行的命令</li>
</ul>
<p>在启动服务前执行的相关命令中，如果存在权限问题可以在执行命令前加<code>+</code>，如<code>ExecStartPre=+/bin/mkdir test</code></p>
<blockquote>
<p><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html#ExecStart=" target="_blank" rel="noopener">https://www.freedesktop.org/software/systemd/man/systemd.service.html#ExecStart=</a></p>
</blockquote>
<h2 id="Unit模板"><a href="#Unit模板" class="headerlink" title="Unit模板"></a>Unit模板</h2><p>模板文件的主要特点是，文件名以<code>@</code>符号结尾，而启动的时候指定的Unit名称为模板名称附加一个参数字符串,比如<code>test@.service</code>, 在服务启动时可以在<code>@</code>后面放置一个用于区分服务实例的附加字符串参数,这样在参数将会传入到服务启动文件，在文件内部可以通过占位符<code>%i</code>获取服务启动是传入的参数，从而达到启动多个服务实例的目的。</p>
<ul>
<li>启动：<code>systemctl start test@1</code> 这样<code>1</code>将传入服务编辑文件，可以通过<code>%i</code>传给服务启动的进程中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Test service mul</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;LD_LIBRARY_PATH=/usr/local/lib/:/usr/local/lib64/&quot;</span><br><span class="line">Environment=&quot;MY_ENV=123&quot;</span><br><span class="line">ExecStart=/bin/testcmd  %i #传入的参数</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>%n</code></td>
<td style="text-align:center">完整的 Unit 文件名字，包括 .service 后缀名</td>
</tr>
<tr>
<td style="text-align:center"><code>%m</code></td>
<td style="text-align:center">实际运行的节点的 Machine ID，适合用来做Etcd路径的一部分，例如 /machines/%m/units</td>
</tr>
<tr>
<td style="text-align:center"><code>%b</code></td>
<td style="text-align:center">作用有点像 Machine ID，但这个值每次节点重启都会改变，称为 Boot ID</td>
</tr>
<tr>
<td style="text-align:center"><code>%H</code></td>
<td style="text-align:center">实际运行节点的主机名</td>
</tr>
<tr>
<td style="text-align:center"><code>%p</code></td>
<td style="text-align:center">Unit 文件名中在 @ 符号之前的部分，不包括 @ 符号</td>
</tr>
<tr>
<td style="text-align:center"><code>%i</code></td>
<td style="text-align:center">Unit 文件名中在 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/1516125" target="_blank" rel="noopener">可能是史上最全面易懂的 Systemd 服务管理教程！( 强烈建议收藏 )</a></li>
<li><a href="https://serverfault.com/questions/413397/how-to-set-environment-variable-in-systemd-service" target="_blank" rel="noopener">How to set environment variable in systemd service?</a></li>
<li><a href="http://www.jinbuguo.com/systemd/systemd.service.html" target="_blank" rel="noopener">systemd.service 中文手册</a></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>systemd</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机性能优化——qemu</title>
    <url>/post/7b57e643.html</url>
    <content><![CDATA[<p>虚拟机性能优化</p>
<a id="more"></a>
<h2 id="CPU-amp-vCPU"><a href="#CPU-amp-vCPU" class="headerlink" title="CPU&amp;vCPU"></a>CPU&amp;vCPU</h2><p><img src="/images/2020/10/cpu_and_vcpu.png" alt="CPU and vCPU"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html-single/virtualization_tuning_and_optimization_guide/index#sect-Virtualization_Tuning_Optimization_Guide-NUMA-Auto_NUMA_Balancing" target="_blank" rel="noopener">虚拟化调试和优化指南</a></li>
<li><a href="https://frankdenneman.nl/2011/01/11/beating-a-dead-horse-using-cpu-affinity/" target="_blank" rel="noopener">Beating a dead horse – using CPU affinity</a></li>
<li><a href="https://docs.pexip.com/server_design/vmware_numa_affinity.htm" target="_blank" rel="noopener">VMware NUMA affinity and hyperthreading</a></li>
<li><a href="https://glennklockwood.com/hpc-howtos/process-affinity.html#2-types-of-thread-scheduling" target="_blank" rel="noopener">Managing Process Affinity in Linux</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>DRM笔记——基本概念</title>
    <url>/post/195f15d1.html</url>
    <content><![CDATA[<p><code>DRM</code>（Direct Rendering Manager）是linux中主流的图形显示框架，它将GPU的管理驱动和Display驱动，使得软件架构更为统一，方便管理和维护</p>
<p><img src="/images/2020/11/drm.png" alt="DRM"></p>
<p>DRM主要可以分为3部分：<code>libdrm</code>、<code>KMS</code>、<code>GEM</code></p>
<a id="more"></a>
<h2 id="libdrm"><a href="#libdrm" class="headerlink" title="libdrm"></a>libdrm</h2><p>对linux系统底层接口进行了封装，向上层通过统一的API接口，主要是将驱动的各种ioctl接口的封装</p>
<h2 id="KMS"><a href="#KMS" class="headerlink" title="KMS"></a>KMS</h2><blockquote>
<p>目的：将不同的像素缓冲区渲染到屏幕上或内存中。</p>
</blockquote>
<p>Kernel Mode Setting，所谓Mode setting，其实说白了就两件事：<code>更新画面</code>和<code>设置显示参数</code>。</p>
<ul>
<li>更新画面：显示buffer的切换，多图层的合成方式，以及每个图层的显示位置。</li>
<li>设置显示参数：包括分辨率、刷新率、电源状态（休眠唤醒）等。</li>
</ul>
<h2 id="GEM"><a href="#GEM" class="headerlink" title="GEM"></a>GEM</h2><p>Graphic Execution Manager，主要负责显示buffer的分配和释放，也是GPU唯一用到DRM的地方。</p>
<h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><p>DRM框架涉及到的元素很多，大致如下：<br>KMS：<code>CRTC</code>，<code>ENCODER</code>，<code>CONNECTOR</code>，<code>PLANE</code>，<code>FB</code>，<code>VBLANK</code>，<code>property</code><br>GEM：<code>DUMB</code>、<code>PRIME</code>、<code>fence</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.landley.net/kdocs/htmldocs/drm.html#drmIntroduction" target="_blank" rel="noopener">Linux DRM Developer’s Guide</a></li>
<li><a href="https://blog.csdn.net/hexiaolong2009/article/details/83720940" target="_blank" rel="noopener">DRM（Direct Rendering Manager）学习简介</a></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>driver</tag>
        <tag>kernel</tag>
        <tag>gpu</tag>
        <tag>drm</tag>
      </tags>
  </entry>
  <entry>
    <title>idr与ida</title>
    <url>/post/e5599899.html</url>
    <content><![CDATA[<ul>
<li><code>IDR</code>在Linux内核中指的是整数ID管理机制。实质上来讲，这就是一种将一个整数ID号和一个指针关联在一起的机制。</li>
<li><code>IDA</code>是用IDR来实现的ID分配机制,与IDR的区别是IDA仅仅<code>分配</code>与<code>管理</code>ID,并不将ID与指针相关联.</li>
</ul>
<a id="more"></a>
<h2 id="IDR"><a href="#IDR" class="headerlink" title="IDR"></a>IDR</h2><blockquote>
<p>所谓IDR，其实就是和身份证的含义差不多，我们知道，每个人有一个身份证，身份证只是一串数字，从数字，我们就能知道这个人的信息。同样道理，idr的要完成的任务是给要管理的对象分配一个数字，可以通过这个数字找到要管理的对象。</p>
</blockquote>
<h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2>]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu20_04系统桌面卡死</title>
    <url>/post/17750668.html</url>
    <content><![CDATA[<p>ubuntu20.04在使用过程中桌面出现莫名其妙的卡死现象，但是系统正常没有死，可以通过<code>CTRL+ALT+Fn</code>切换不同的终端，并登录进行操作。这种卡死现象在之前使用的ubuntu18.04中也出现过，根据网上很多解决方法尝试后均无法解决，最后重装新系统ubuntu20.04该问题还是存在，这次就将其在这里简单记录一下。</p>
<a id="more"></a>
<h2 id="桌面卡死后的日志："><a href="#桌面卡死后的日志：" class="headerlink" title="桌面卡死后的日志："></a>桌面卡死后的日志：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17:01:55 QTM4600-pc dnsmasq[1009]: reading /etc/resolv.conf</span><br><span class="line">17:01:55 QTM4600-pc dnsmasq[1009]: using nameserver 127.0.0.53#53</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;25&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event2  - Power Button: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;28&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event1  - Power Button: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;29&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event0  - Sleep Button: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;33&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event12 - Logitech USB Optical Mouse: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;31&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event4  - USB USB Keykoard: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;32&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event9  - USB USB Keykoard System Control: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;48&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;48&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event8  - USB USB Keykoard Consumer Control: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) AIGLX: Suspending AIGLX clients for VT switch</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:73</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:72</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:65</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 226:0</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:66</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:64</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:76</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:68</span><br><span class="line">17:02:34 QTM4600-pc systemd[1]: Started Getty on tty4.</span><br></pre></td></tr></table></figure>
<p>初步怀疑与gdm3有关，将其换为<code>lightdm</code>看是否会出现卡死现象<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install lightdm</span><br></pre></td></tr></table></figure></p>
<p><strong>后来又出现了一次界面卡死现象，不过每一次的卡死界面都是在firefox浏览器，后面改用chrome浏览器后情况好了点，暂时没有出现卡死现象</strong></p>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>gdm</tag>
      </tags>
  </entry>
  <entry>
    <title>vanilla kernel</title>
    <url>/post/b4e9a1bb.html</url>
    <content><![CDATA[<blockquote>
<p>The kernels at <a href="https://www.kernel.org" target="_blank" rel="noopener">www.kernel.org</a> are vanilla kernels.</p>
</blockquote>
<p><code>vanilla</code>: 表示原始的，最基本的结构或框架</p>
<a id="more"></a>
<ul>
<li><a href="https://www.linuxquestions.org/questions/linux-general-1/what-is-vanilla-kernel-79388/" target="_blank" rel="noopener">What is Vanilla kernel ? </a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>VESA</title>
    <url>/post/293ebfd8.html</url>
    <content><![CDATA[<blockquote>
<p>Video Electronics Standards Association（视频电子标准协会，简称“VESA”）是制定计算机和小型工作站视频设备标准的国际组织，1989年由NEC及其他8家显卡制造商赞助成立。</p>
</blockquote>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.monstersoft.com/tutorial1/VESA_intro.html" target="_blank" rel="noopener">Introduction to VESA programming</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>edid</tag>
        <tag>vesa</tag>
      </tags>
  </entry>
  <entry>
    <title>Android自动化测试工具——Appium</title>
    <url>/post/2b439260.html</url>
    <content><![CDATA[<blockquote>
<p>官网： <a href="http://appium.io" target="_blank" rel="noopener">http://appium.io</a><br>Github： <a href="https://github.com/appium" target="_blank" rel="noopener">https://github.com/appium</a></p>
</blockquote>
<p><code>Appium</code>是一个开源工具，用于自动化<code>iOS手机</code>、 <code>Android手机</code>和<code>Windows桌面平台</code>上的原生、移动 Web 和混合应用。「原生应用」指那些用 iOS、 Android 或者 Windows SDKs 编写的应用。「移动 Web 应用」是用移动端浏览器访问的应用（ Appium 支持 iOS 上的 Safari 、Chrome 和 Android 上的内置浏览器）。「混合应用」带有一个「webview」的包装器——用来和 Web 内容交互的原生控件。类似于 Apache Cordova 或 Phonegap 项目，创建一个混合应用使得用 Web 技术开发然后打包进原生包装器创建一个混合应用变得容易了。</p>
<p>重要的是，Appium 是跨平台的：它允许你用同样的 API 对多平台（iOS、Android、Windows）写测试。做到在 iOS、Android 和 Windows 测试套件之间复用代码。</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>appium</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU与GPU的Benchmark测试</title>
    <url>/post/30b31d51.html</url>
    <content><![CDATA[<p>测试CPU与GPU性能的测试工具</p>
<a id="more"></a>
<h1 id="CPU性能测试"><a href="#CPU性能测试" class="headerlink" title="CPU性能测试"></a>CPU性能测试</h1><h2 id="geekbench"><a href="#geekbench" class="headerlink" title="geekbench"></a>geekbench</h2><ul>
<li>支持macOS，windows，linux，android，iOS</li>
</ul>
<blockquote>
<p><a href="https://browser.geekbench.com" target="_blank" rel="noopener">https://browser.geekbench.com</a></p>
</blockquote>
<h1 id="GPU性能测试"><a href="#GPU性能测试" class="headerlink" title="GPU性能测试"></a>GPU性能测试</h1><h2 id="specviewperf13"><a href="#specviewperf13" class="headerlink" title="specviewperf13"></a>specviewperf13</h2><ul>
<li>支持linux,windows<blockquote>
<p><a href="https://www.spec.org/gwpg/gpc.static/vp13info.html" target="_blank" rel="noopener">https://www.spec.org/gwpg/gpc.static/vp13info.html</a></p>
</blockquote>
</li>
</ul>
<p><strong>Running the SPECviewperf 13 Linux Edition benchmark</strong></p>
<p>The benchmark has the following minimum system requirements:</p>
<ul>
<li>Ubuntu Linux 16.04 and 18.04</li>
<li><code>OpenGL 4.0</code></li>
<li>2GB of video memory</li>
<li>8GB of installed system memory</li>
<li>80GB available disk space</li>
<li>1920x1080 screen resolution for submissions published on the SPEC website</li>
</ul>
<blockquote>
<p><a href="http://spec.cs.miami.edu/gwpg/gpc.static/vp13linuxinfo.html" target="_blank" rel="noopener">http://spec.cs.miami.edu/gwpg/gpc.static/vp13linuxinfo.html</a></p>
</blockquote>
<h3 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h3><blockquote>
<p>os: ubuntu20.04</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install xterm libgconf2-dev</span><br></pre></td></tr></table></figure>
<h2 id="gfxbench"><a href="#gfxbench" class="headerlink" title="gfxbench"></a>gfxbench</h2><ul>
<li>gfxbench 4.0 — Android, iOS, OSX, Windows 7,8,10, <code>Linux</code></li>
<li>gfxbench 5.0 — Android, iOS, OSX, Windows</li>
</ul>
<h2 id="3Dmark"><a href="#3Dmark" class="headerlink" title="3Dmark"></a>3Dmark</h2><ul>
<li>只支持windows,android和apple<blockquote>
<p><a href="https://www.3dmark.com" target="_blank" rel="noopener">https://www.3dmark.com</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>基准测试具有自然寿命，若不再能针对现代硬件提供有意义的结果，其自然寿命将终止。此页面上的基准测试不再受 UL 支持，在此仅供娱乐之用。它们可能不适用于最新的操作系统，并且在线服务可能也已经停止。我们建议您使用最新版本的 3DMark 和 PCMark 测试现代硬件和设备。</p>
<ul>
<li><a href="https://benchmarks.ul.com/zh-hans/legacy-benchmarks?redirected=true#" target="_blank" rel="noopener">不受支持的基准测试</a></li>
</ul>
</blockquote>
<h2 id="unigine-benchmark"><a href="#unigine-benchmark" class="headerlink" title="unigine benchmark"></a>unigine benchmark</h2><ul>
<li>支持linux, windows<blockquote>
<p><a href="https://benchmark.unigine.com/" target="_blank" rel="noopener">https://benchmark.unigine.com/</a></p>
</blockquote>
</li>
</ul>
<h3 id="Superposition-2017"><a href="#Superposition-2017" class="headerlink" title="Superposition 2017"></a>Superposition 2017</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hardware</span><br><span class="line">    GPU:</span><br><span class="line">        AMD Radeon HD 7xxx and higher</span><br><span class="line">        Intel HD 5xxx and higher</span><br><span class="line">        NVIDIA GeForce GTX 6xx and higher</span><br><span class="line">    Video memory: 2 GB</span><br><span class="line">    Disk space: 5 GB</span><br></pre></td></tr></table></figure>
<p>Unigine Superposition Benchmark只提供<code>DirectX 11</code>和<code>OpenGL 4.5 API</code></p>
<h3 id="Valley-2013-ok"><a href="#Valley-2013-ok" class="headerlink" title="Valley 2013  (ok)"></a>Valley 2013  (ok)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hardware</span><br><span class="line">    GPU:</span><br><span class="line">        ATI Radeon HD 4xxx and higher</span><br><span class="line">        Intel HD 3000 and higher</span><br><span class="line">        NVIDIA GeForce 8xxx and higher</span><br><span class="line">    Video memory: 512 MB</span><br><span class="line">    Disk space: 1.5 GB</span><br></pre></td></tr></table></figure>
<h2 id="glmark2"><a href="#glmark2" class="headerlink" title="glmark2"></a>glmark2</h2><ul>
<li>支持linux<blockquote>
<p><code>glmark2</code> is an OpenGL 2.0 and ES 2.0 benchmark.</p>
</blockquote>
</li>
</ul>
<p>glmark提供了一系列涉及图形单元性能各个方面（缓冲，建筑物，照明，纹理等）的测试，从而可以进行更全面，更有意义的测试。每次测试进行10秒钟，并分别计算帧频。最后，用户会根据之前的所有测试获得性能得分。此工具具备简单性和完美的操作。</p>
<h2 id="Cinebench"><a href="#Cinebench" class="headerlink" title="Cinebench"></a>Cinebench</h2><ul>
<li>只支持windows和apple<blockquote>
<p><a href="https://www.maxon.net/en/cinebench" target="_blank" rel="noopener">https://www.maxon.net/en/cinebench</a></p>
</blockquote>
</li>
</ul>
<p>Cinebench is a real-world cross-platform test suite that evaluates your computer’s hardware capabilities. Improvements to Cinebench Release 23 reflect the overall advancements to CPU and rendering technology in recent years, providing a more accurate measurement of Cinema 4D’s ability to take advantage of multiple CPU cores and modern processor features available to the average user. Best of all: It’s free</p>
<h2 id="ShaderToyMark"><a href="#ShaderToyMark" class="headerlink" title="ShaderToyMark"></a>ShaderToyMark</h2><ul>
<li>只支持windows<blockquote>
<p><a href="https://www.geeks3d.com/20111215/shadertoymark-0-3-0-opengl-pixel-shader-benchmark-updated/" target="_blank" rel="noopener">https://www.geeks3d.com/20111215/shadertoymark-0-3-0-opengl-pixel-shader-benchmark-updated/</a></p>
</blockquote>
</li>
</ul>
<p><code>ShaderToyMark</code> is an OpenGL benchmark, developed with GeeXLab, and focused on pixel shaders only. Why ShaderToyMark? Simply because I recently played with the pixel shaders available with Shader Toy, a great WebGL tool for testing GLSL shaders. And I said to myself: that would be nice to see several of these shaders running at the same time in the same 3D window… ShaderToyMark was born.</p>
<h2 id="Geeks3D-TessMark"><a href="#Geeks3D-TessMark" class="headerlink" title="Geeks3D TessMark"></a>Geeks3D TessMark</h2><ul>
<li>只支持windows<blockquote>
<p><a href="https://www.geeks3d.com/20110408/download-tessmark-0-3-0-released/" target="_blank" rel="noopener">https://www.geeks3d.com/20110408/download-tessmark-0-3-0-released/</a></p>
</blockquote>
</li>
</ul>
<p>TessMark is a graphics benchmark focused on the GPU tessellation, one of the killer feature of OpenGL 4 capable cards (GeForce GTX 400, GTX 500, Radeon HD 5000, HD 6000).</p>
<h2 id="V-Ray-Benchmark"><a href="#V-Ray-Benchmark" class="headerlink" title="V-Ray Benchmark"></a>V-Ray Benchmark</h2><ul>
<li>支持windows、linux和Mac OS<blockquote>
<p><a href="https://www.chaosgroup.com/vray/benchmark" target="_blank" rel="noopener">https://www.chaosgroup.com/vray/benchmark</a></p>
</blockquote>
</li>
</ul>
<p>V-Ray Benchmark是一个免费的独立应用程序（不需要安装V-Ray），可以帮助用户测试其硬件的性能。 该基准测试包括两个测试场景，一个场景用于GPU，另一个场景用于CPU，具体取决于您要衡量的性能类型。</p>
<p>V-Ray Benchmark是一个免费的独立应用程序，用于测试系统渲染的速度。 简单，快速，并包含三个渲染引擎测试：</p>
<ul>
<li>V-Ray — CPU compatible</li>
<li>V-Ray GPU CUDA — GPU and CPU compatible</li>
<li>V-Ray GPU RTX — RTX GPU compatible</li>
</ul>
<h2 id="OctaneBench"><a href="#OctaneBench" class="headerlink" title="OctaneBench"></a>OctaneBench</h2><ul>
<li>支持windows、linux和Mac OS<blockquote>
<p><a href="https://render.otoy.com/octanebench/" target="_blank" rel="noopener">https://render.otoy.com/octanebench/</a></p>
</blockquote>
</li>
</ul>
<p>OctaneBench®允许您使用OctaneRender基准测试GPU。 通过确保每个人使用相同的版本以及相同的场景和设置来提供一个公平的竞争环境。 没有这些限制，基准测试结果可能会有很大差异，无法进行比较。</p>
<ul>
<li>nvidia GPU (cuda)，在linux下运行测试，需要cuda库的支持</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://alternativeto.net/software/3dmark-vantage/?platform=linux" target="_blank" rel="noopener">https://alternativeto.net/software/3dmark-vantage/?platform=linux</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/61167045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61167045</a></li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>cpu</tag>
        <tag>gpu</tag>
        <tag>benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>DRM笔记——驱动初始化</title>
    <url>/post/53854910.html</url>
    <content><![CDATA[<p>drm的驱动加载主要是为了实现各种回调函数的注册，初始化时主要实现的数据结构是<code>struct drm_driver</code></p>
<p>这里以virtio-gpu为例，了解drm驱动的初始化</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module_virtio_driver(virtio_gpu_driver);</span><br><span class="line">  \-&gt;.probe = virtio_gpu_probe (driver与devices匹配后的入口函数)</span><br><span class="line">    \-&gt; drm_dev_alloc(&amp;driver, &amp;vdev-&gt;dev); -- 申请和初始化struct drm_driver结构体</span><br></pre></td></tr></table></figure>
<h2 id="struct-drm-driver初始化"><a href="#struct-drm-driver初始化" class="headerlink" title="struct drm_driver初始化"></a><code>struct drm_driver</code>初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_driver</span> <span class="title">driver</span> = &#123;</span></span><br><span class="line">    <span class="comment">//drm驱动的功能特性</span></span><br><span class="line">    .driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_RENDER | DRIVER_ATOMI</span><br><span class="line">    <span class="comment">//用于设置驱动程序-私有数据结构，如缓冲区分配器、执行上下文（上下文ID）或类似内容</span></span><br><span class="line">    .<span class="built_in">open</span> = virtio_gpu_driver_open,</span><br><span class="line">    <span class="comment">//与open相对应，用于open接口申请资源的释放</span></span><br><span class="line">    .postclose = virtio_gpu_driver_postclose,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建dumb buffer （用户通过 ioctl 调用）</span></span><br><span class="line">    .dumb_create = virtio_gpu_mode_dumb_create,</span><br><span class="line">    <span class="comment">//在drm设备节点的地址空间中分配偏移量，以便能够存储映射一个dumb buffer  （用户通过 ioctl 调用）</span></span><br><span class="line">    .dumb_map_offset = virtio_gpu_mode_dumb_mmap,</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_DEBUG_FS)</span><br><span class="line">    .debugfs_init = virtio_gpu_debugfs_init,</span><br><span class="line">#endif</span><br><span class="line">    <span class="comment">//Main PRIME export function（输出）</span></span><br><span class="line">    .prime_handle_to_fd = drm_gem_prime_handle_to_fd,</span><br><span class="line">    <span class="comment">//Main PRIME import function（输入）</span></span><br><span class="line">    .prime_fd_to_handle = drm_gem_prime_fd_to_handle,</span><br><span class="line">    <span class="comment">//用于实现dma-buf mmap</span></span><br><span class="line">    .gem_prime_mmap = drm_gem_prime_mmap,</span><br><span class="line">    <span class="comment">//export接口钩子GEM驱动</span></span><br><span class="line">    .gem_prime_export = virtgpu_gem_prime_export,</span><br><span class="line">    <span class="comment">//import接口钩子GEM驱动</span></span><br><span class="line">    .gem_prime_import = virtgpu_gem_prime_import,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    .gem_prime_import_sg_table = virtgpu_gem_prime_import_sg_table,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//GEM对象的构造函数</span></span><br><span class="line">    .gem_create_object = virtio_gpu_create_object,</span><br><span class="line">    <span class="comment">//DRM 设备节点的文件操作</span></span><br><span class="line">    .fops = &amp;virtio_gpu_driver_fops,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//驱动私有的IOCTL描述条目数组</span></span><br><span class="line">    .ioctls = virtio_gpu_ioctls,</span><br><span class="line">    .num_ioctls = DRM_VIRTIO_NUM_IOCTLS,</span><br><span class="line"></span><br><span class="line">    .name = DRIVER_NAME,</span><br><span class="line">    .desc = DRIVER_DESC,</span><br><span class="line">    .date = DRIVER_DATE,</span><br><span class="line">    .major = DRIVER_MAJOR,</span><br><span class="line">    .minor = DRIVER_MINOR,</span><br><span class="line">    .patchlevel = DRIVER_PATCHLEVEL,</span><br><span class="line">    <span class="comment">//用于在释放最终引用后销毁设备数据</span></span><br><span class="line">    .<span class="built_in">release</span> = virtio_gpu_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>driver</tag>
        <tag>kernel</tag>
        <tag>gpu</tag>
        <tag>drm</tag>
      </tags>
  </entry>
  <entry>
    <title> linux下shell基础——创建可执行文件</title>
    <url>/post/5b5dea38.html</url>
    <content><![CDATA[<p>在平时通过shell脚本部署一个服务和应用时，除了自身的脚本外可能还依赖一些二进制文件，如何将二者一起打包发布，使其变为一个可执行文件，方便后期维护和使用</p>
<p>为实现以上目标可以使用<code>sed</code>实现，具体流程如下：</p>
<ul>
<li>前期使用<code>cat</code>将两个文件合并为一个文件</li>
<li>后期运行是通过<code>sed</code>将两个文件分开，后在具体操作</li>
</ul>
<a id="more"></a>
<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo "This is test shell"</span><br></pre></td></tr></table></figure>
<h2 id="打包测试脚本（如同二进制文件）"><a href="#打包测试脚本（如同二进制文件）" class="headerlink" title="打包测试脚本（如同二进制文件）"></a>打包测试脚本（如同二进制文件）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zcvf test.tar.gz test.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实际应用中可以根据实际需要使用其他二进制文件</p>
</blockquote>
<h2 id="运行测试脚本-run-sh"><a href="#运行测试脚本-run-sh" class="headerlink" title="运行测试脚本(run.sh)"></a>运行测试脚本(run.sh)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">echo "Test shell+bin"</span><br><span class="line">mkdir tmp</span><br><span class="line"></span><br><span class="line">sed -n '1,/^exit 0$/!p' $0 &gt; ./tmp/test.tar.gz</span><br><span class="line"></span><br><span class="line">cd tmp</span><br><span class="line">tar zxvf test.tar.gz</span><br><span class="line">bash ./test.sh</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>sed -n &#39;1,/^exit 0$/!p&#39; $0 &gt; ./tmp/test.tar.gz</code>命令用于将后面<code>cat</code>合并两个文件重新分开，并执行</p>
<ul>
<li>当前文件中除了<code>第一行</code>和<code>exit 0</code>所在行中间的部分，也就是<code>exit 0</code>后面的内容，输出到<code>./tmp/test.tar.gz</code>。<code>$0</code>是当前脚本的名，也就是<code>run.sh</code></li>
<li><code>exit 0</code>在这里可以看作一个分割标志，可以使用其他字符串代替</li>
</ul>
</blockquote>
<h2 id="合并可执行文件"><a href="#合并可执行文件" class="headerlink" title="合并可执行文件"></a>合并可执行文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat run.sh test.tar.gz &gt; run-tst.sh</span><br></pre></td></tr></table></figure>
<p>重新生成的运行脚本：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">echo "Test shell+bin"</span><br><span class="line">mkdir tmp</span><br><span class="line"></span><br><span class="line">sed -n '1,/^exit 0$/!p' $0 &gt; ./tmp/test.tar.gz</span><br><span class="line"></span><br><span class="line">cd tmp</span><br><span class="line">tar zxvf test.tar.gz</span><br><span class="line">bash ./test.sh</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">exit 0                                                                                                                                                                                         </span><br><span class="line">^_?^H^@^@^@^@^@^@^C??AK?0^T^G?^?O?\?[??^M?&amp;?GO?^B?^ZL???d?^S(;&#123;???N?ɛ^H~?֯a?^^??@^YC??^H&lt;??=x?8e???`??????r?????DȀ???I?d"^Cƅ^_^H??u?/^K???(X^[????????????T?Ynu^T?Z^Tә)^U???*^L3r?????^K???ϖ?*??T^W&gt;=iT?   </span><br><span class="line">TAS??3^RL?????n?^Ri?~??~?m???^S??[?p֮n?????^O?*;o̕3u^Uf^?Y:Rs]?`??%^????jU?????^B^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@??;??z^]^@(^@^@</span><br></pre></td></tr></table></figure></p>
<h2 id="shell加密——shc"><a href="#shell加密——shc" class="headerlink" title="shell加密——shc"></a>shell加密——shc</h2><p>将shell脚本转换为一个可执行的二进制文件，可以保护shell脚本中的一些敏感信息和具体的执行步骤。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install shc</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shc -v -f run-tst.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Frame Buffer</title>
    <url>/post/302c8d9a.html</url>
    <content><![CDATA[<p>OpenGL中<code>Frame Buffer</code>包含多种不同类型的buffer,主要有<code>ColorBuffers</code>,<code>Z buffer</code>, <code>double-buffer</code></p>
<a id="more"></a>
<h2 id="double-buffer"><a href="#double-buffer" class="headerlink" title="double-buffer"></a>double-buffer</h2><blockquote>
<p><code>Front buffer</code> = what is being shown on screen (the last frame)<br><code>Back buffer</code> = where you’re currently drawing (the current frame)</p>
</blockquote>
<h2 id="Z-buffer"><a href="#Z-buffer" class="headerlink" title="Z buffer"></a>Z buffer</h2><p>Z-buffer也称为Depth Buffer存储fragment的深度，即离视点的距离</p>
<h2 id="Stencil-Buffer"><a href="#Stencil-Buffer" class="headerlink" title="Stencil Buffer"></a>Stencil Buffer</h2><p>模版缓冲（stencil buffer）或印模缓冲，是在OpenGL三维绘图等计算机图像硬件中常见的除颜色缓冲、像素缓冲、深度缓冲之外另一种数据缓冲。</p>
<p><code>stencil buffer</code>可以将绘图限制到屏幕的规定部分，比如透过窗户的场景。</p>
<h2 id="Accumulation-Buffer"><a href="#Accumulation-Buffer" class="headerlink" title="Accumulation Buffer"></a>Accumulation Buffer</h2><p>Accumulation Buffer存储的也是颜色值，这个buffer累积一些列的图像，得到一个最终图像，可用于super sampling antialiasing。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.geeksforgeeks.org/z-buffer-depth-buffer-method/" target="_blank" rel="noopener">Z-Buffer or Depth-Buffer method</a></li>
<li><a href="https://www.gamedev.net/forums/topic/619051-what-is-back-and-front-buffer/" target="_blank" rel="noopener">What is Back and Front Buffer?</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>[PDF]Qemu Libvirt &amp; KVM</title>
    <url>/post/7f314dbc.html</url>
    <content><![CDATA[<p>Qemu Libvirt &amp; KVM</p>
<a id="more"></a>
<div class="pdf" target="https://winddoing.gitee.io/docs/libvirt/LibvirtQemuKVM.pdf" height></div>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>kvm</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Systrace</title>
    <url>/post/7f0df936.html</url>
    <content><![CDATA[<p>Android性能分析工具</p>
<a id="more"></a>
<h2 id="下载android-sdk-platform-tools"><a href="#下载android-sdk-platform-tools" class="headerlink" title="下载android-sdk-platform-tools"></a>下载android-sdk-platform-tools</h2><blockquote>
<p><a href="https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn</a></p>
</blockquote>
<p>解压后直接使用</p>
<h2 id="获取systrace日志并转换为html"><a href="#获取systrace日志并转换为html" class="headerlink" title="获取systrace日志并转换为html"></a>获取systrace日志并转换为html</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">ip="127.0.0.1"</span><br><span class="line">port="5555"</span><br><span class="line"></span><br><span class="line">TRACE_BUFFER_SZ_KB=16384 #16MB</span><br><span class="line">TRACE_FILE="/data/local/tmp/trace_$port.log"</span><br><span class="line"></span><br><span class="line">adb disconnect</span><br><span class="line">adb connect $ip:$port</span><br><span class="line">adb root</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> adb shell atrace --list_categories</span></span><br><span class="line">tracedump=$(echo `adb shell atrace --list_categories | awk '&#123;print $1&#125;'` | sed 's/\n//g')</span><br><span class="line"></span><br><span class="line">adb shell "atrace -b $TRACE_BUFFER_SZ_KB -t 30 -z $tracedump &gt; $TRACE_FILE"</span><br><span class="line">adb pull $TRACE_FILE</span><br><span class="line"></span><br><span class="line">python platform-tools/systrace/systrace.py  -b $TRACE_BUFFER_SZ_KB --from-file trace_$port.log -o trace_$port.html</span><br></pre></td></tr></table></figure>
<h2 id="查看trace文件的快捷键"><a href="#查看trace文件的快捷键" class="headerlink" title="查看trace文件的快捷键"></a>查看trace文件的快捷键</h2><table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">放大</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">缩小</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center">e</td>
<td style="text-align:center">右移</td>
</tr>
</tbody>
</table>
<h2 id="使用Systrace-检测卡顿丢帧问题"><a href="#使用Systrace-检测卡顿丢帧问题" class="headerlink" title="使用Systrace 检测卡顿丢帧问题"></a>使用Systrace 检测卡顿丢帧问题</h2><ul>
<li>Systrace报告列出了每个进程呈现UI frame，并显示沿着时间线的每个渲染帧。 在<code>绿色框</code>架圆圈中，是指在16.6ms内呈现每秒稳定60帧， 花费16.6ms以上渲染的帧用<code>黄色或红色圆</code>圈表示。</li>
</ul>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="ImportError-No-module-named-six"><a href="#ImportError-No-module-named-six" class="headerlink" title="ImportError: No module named six"></a>ImportError: No module named six</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install python-six</span><br></pre></td></tr></table></figure>
<h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error opening /sys/kernel/debug/tracing/options/overwrite: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/buffer_size_kb: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/trace_clock: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/tracing_on: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/tracing_on: Permission denied (13)</span><br><span class="line">unable to start tracing</span><br><span class="line">error opening /sys/kernel/debug/tracing/options/overwrite: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/buffer_size_kb: Permission denied (13)</span><br></pre></td></tr></table></figure>
<p>通过<code>adb root</code>获取权限</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/75aa88d1b575" target="_blank" rel="noopener">Android Systrace 使用详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>systrace</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下性能分析---perf</title>
    <url>/post/d5a39290.html</url>
    <content><![CDATA[<p><code>perf</code>是Linux kernel自带的系统性能优化工具</p>
<a id="more"></a>
<h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">perf</span></span><br><span class="line"></span><br><span class="line"> usage: perf [--version] [--help] [OPTIONS] COMMAND [ARGS]</span><br><span class="line"></span><br><span class="line"> The most commonly used perf commands are:</span><br><span class="line">   annotate        Read perf.data (created by perf record) and display annotated code</span><br><span class="line">   archive         Create archive with object files with build-ids found in perf.data file</span><br><span class="line">   bench           General framework for benchmark suites</span><br><span class="line">   buildid-cache   Manage build-id cache.</span><br><span class="line">   buildid-list    List the buildids in a perf.data file</span><br><span class="line">   c2c             Shared Data C2C/HITM Analyzer.</span><br><span class="line">   config          Get and set variables in a configuration file.</span><br><span class="line">   data            Data file related processing</span><br><span class="line">   diff            Read perf.data files and display the differential profile</span><br><span class="line">   evlist          List the event names in a perf.data file</span><br><span class="line">   ftrace          simple wrapper for kernel's ftrace functionality</span><br><span class="line">   inject          Filter to augment the events stream with additional information</span><br><span class="line">   kallsyms        Searches running kernel for symbols</span><br><span class="line">   kmem            Tool to trace/measure kernel memory properties</span><br><span class="line">   kvm             Tool to trace/measure kvm guest os</span><br><span class="line">   list            List all symbolic event types</span><br><span class="line">   lock            Analyze lock events</span><br><span class="line">   mem             Profile memory accesses</span><br><span class="line">   record          Run a command and record its profile into perf.data</span><br><span class="line">   report          Read perf.data (created by perf record) and display the profile</span><br><span class="line">   sched           Tool to trace/measure scheduler properties (latencies)</span><br><span class="line">   script          Read perf.data (created by perf record) and display trace output</span><br><span class="line">   stat            Run a command and gather performance counter statistics</span><br><span class="line">   test            Runs sanity tests.</span><br><span class="line">   timechart       Tool to visualize total system behavior during a workload</span><br><span class="line">   top             System profiling tool.</span><br><span class="line">   version         display the version of perf binary</span><br><span class="line">   probe           Define new dynamic tracepoints</span><br><span class="line">   trace           strace inspired tool</span><br><span class="line"></span><br><span class="line"> See 'perf help COMMAND' for more information on a specific command.</span><br></pre></td></tr></table></figure>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">top</td>
<td style="text-align:center">动态时实追踪显示占用CPU较高的进程</td>
</tr>
<tr>
<td style="text-align:center">record</td>
<td style="text-align:center">由于top只能实时查看不能保存，不便于事后分析，用此参数保存追踪的内容，文件名为perf.data</td>
</tr>
<tr>
<td style="text-align:center">report</td>
<td style="text-align:center">重放perf.data的内容</td>
</tr>
</tbody>
</table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo perf record -g -p &lt;pid&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">回放</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo perf report</span></span><br></pre></td></tr></table></figure>
<h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> perf kvm <span class="built_in">stat</span> record -a sleep 100</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> perf kvm <span class="built_in">stat</span> report</span></span><br><span class="line"></span><br><span class="line">Analyze events for all VMs, all VCPUs:</span><br><span class="line"></span><br><span class="line">             VM-EXIT    Samples  Samples%     Time%    Min Time    Max Time         Avg time</span><br><span class="line"></span><br><span class="line">           MSR_WRITE      42521    53.32%     0.06%      0.50us     52.94us      1.71us ( +-   0.48% )</span><br><span class="line">                 HLT      15885    19.92%    99.89%      0.63us  17539.26us   8224.34us ( +-   0.61% )</span><br><span class="line">      IO_INSTRUCTION      10892    13.66%     0.03%      2.14us     47.60us      3.02us ( +-   0.48% )</span><br><span class="line">          APIC_WRITE       6226     7.81%     0.02%      0.52us     41.71us      3.88us ( +-   0.94% )</span><br><span class="line">  EXTERNAL_INTERRUPT       1965     2.46%     0.00%      0.42us     42.59us      1.46us ( +-   2.38% )</span><br><span class="line">    PREEMPTION_TIMER       1805     2.26%     0.00%      0.54us     16.87us      2.13us ( +-   1.59% )</span><br><span class="line">       EPT_MISCONFIG        302     0.38%     0.00%      0.76us    171.85us     16.38us ( +-   7.97% )</span><br><span class="line">            MSR_READ        132     0.17%     0.00%      0.74us      3.52us      1.56us ( +-   4.86% )</span><br><span class="line">   PAUSE_INSTRUCTION         16     0.02%     0.00%      0.45us      0.87us      0.66us ( +-   4.89% )</span><br><span class="line"></span><br><span class="line">Total Samples:79744, Total events handled time:130785328.50us.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>HLT</code>: (halt)是由于CPU进入idle状态时，就会调用该指令把CPU挂起。这样虚拟CPU挂起后就能出让物理CPU给其它进程使用。</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>perf</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL中的共享上下文</title>
    <url>/post/44245d70.html</url>
    <content><![CDATA[<p>OpenGL渲染中有一个<code>线程相关</code>的上下文(Context), OpenGL所创建的资源, 其实对程序员可见的仅仅是<code>上下文ID</code>而已, 其内容依赖于这个上下文, 有时候为了方便起见, 在某个线程中创建了上下文之后, 所有的OpenGL操作都转到此线程来调用. 这样在简单的2d/3d 渲染中尚可, 但是如果涉及复杂的OpenGL渲染时, 这样就未必足够， 事实上OpenGL已经考虑到这一点， <code>上下文是可以在多个线程间共享的</code>，在使用<code>glXCreateContext</code>或<code>eglCreateContext</code>时， 可以传入一个已创建成功的上下文， 这样就可以得到一个共享的上下文(Shared Context).</p>
<a id="more"></a>
<p>OpenGL的绘制命令都是作用在当前的Context上，这个Current Context是一个<code>线程私有（thread-local）的变量</code>，也就是说如果我们在线程中绘制，那么需要为该线程制定一个Current Context的，当多个线程参与绘制任务时，需要原线程解绑再重新绑定新的线程。多个线程不能同时指定同一个Context为Current Context，否则会导致崩溃。</p>
<h2 id="共享上下文"><a href="#共享上下文" class="headerlink" title="共享上下文"></a>共享上下文</h2><p>一个是进程可以创建多个Context，它们可以分别描绘出不同的图形界面，就像一个应用程序可以打开多个窗口一样。每个OpenGL Context是相互独立的，它们都有自己的OpenGL对象集。但有时会有场景需要多个上下文使用同一份纹理资源的情况，创建Context，意味着系统资源的占用，同一份纹理重复申请会造成资源浪费，因此OpenGL上下文允许共享一部分资源。大部分OpenGL Objects是可以共享的，包括<code>Sync Object</code>和<code>GLSL Objects</code>。<code>Container Objects</code>和<code>Query Objects</code>是不能共享的。例如纹理、shader、Buffer等资源是可以共享的，但Frame Buffer Object(FBO)、Vertex Array Object（VAO）等容器对象不可共享，但可将共享的纹理和VBO绑定到各自上下文的容器对象上。</p>
<ul>
<li>共享资源: <code>纹理</code>、<code>shader</code>、<code>Buffer</code></li>
<li>不共享资源: <code>FBO</code>, <code>VAO</code></li>
</ul>
<h2 id="EGL-Context"><a href="#EGL-Context" class="headerlink" title="EGL Context"></a>EGL Context</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EGLContext <span class="title">eglCreateContext</span><span class="params">(EGLDisplay <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  	                        EGLConfig <span class="built_in">config</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  	                        EGLContext share_context,</span></span></span><br><span class="line"><span class="function"><span class="params">  	                        EGLint <span class="keyword">const</span> * attrib_list)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="GLX-Context"><a href="#GLX-Context" class="headerlink" title="GLX Context"></a>GLX Context</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">GLXContext <span class="title">glXCreateContext</span><span class="params">(Display * dpy,</span></span></span><br><span class="line"><span class="function"><span class="params"> 	                        XVisualInfo * vis,</span></span></span><br><span class="line"><span class="function"><span class="params"> 	                        GLXContext shareList,</span></span></span><br><span class="line"><span class="function"><span class="params"> 	                        Bool direct)</span></span>;</span><br></pre></td></tr></table></figure>
<p>GLX创建共享上下文：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLXContext currctx = glXGetCurrentContext();</span><br><span class="line">GLXFBConfig* fb_config;</span><br><span class="line"><span class="keyword">int</span> fb_config_id;</span><br><span class="line"><span class="keyword">int</span> nelements;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">XInitThreads();</span><br><span class="line"></span><br><span class="line">Display* dpy = XOpenDisplay(<span class="literal">NULL</span>);</span><br><span class="line">assert(dpy != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">res = glXQueryContext(dpy, currctx, GLX_FBCONFIG_ID, &amp;fb_config_id);</span><br><span class="line">assert(res);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visual_attribs[] = &#123;</span><br><span class="line">    GLX_FBCONFIG_ID, fb_config_id,</span><br><span class="line">    None</span><br><span class="line">&#125;;</span><br><span class="line">fb_config = glXChooseFBConfig(dpy, DefaultScreen(dpy), visual_attribs, &amp;nelements);</span><br><span class="line">assert(fb_config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> context_attribs[] = &#123;</span><br><span class="line">    GLX_CONTEXT_MAJOR_VERSION_ARB, <span class="number">4</span>,</span><br><span class="line">    GLX_CONTEXT_MINOR_VERSION_ARB, <span class="number">0</span>,</span><br><span class="line">    GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_CORE_PROFILE_BIT_ARB,</span><br><span class="line">    None</span><br><span class="line">&#125;;</span><br><span class="line">GLXContext glx_share_context = glXCreateContextAttribsARB(dpy, fb_config[<span class="number">0</span>], currctx,</span><br><span class="line">        True, context_attribs);</span><br><span class="line">assert(glx_share_context);</span><br></pre></td></tr></table></figure></p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>在执行OpenGL函数之前,必须将切换到其当前的上下文进行处理</p>
<h3 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EGLBoolean <span class="title">eglMakeCurrent</span><span class="params">(EGLDisplay <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  	                      EGLSurface draw,</span></span></span><br><span class="line"><span class="function"><span class="params">  	                      EGLSurface <span class="built_in">read</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  	                      EGLContext context)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">eglMakeCurrent(<span class="built_in">display</span>, EGL_NO_SURFACE, EGL_NO_SURFACE, context);</span><br></pre></td></tr></table></figure>
<h3 id="GLX"><a href="#GLX" class="headerlink" title="GLX"></a>GLX</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">glXMakeCurrent</span><span class="params">(Display * dpy,</span></span></span><br><span class="line"><span class="function"><span class="params"> 	                GLXDrawable drawable,</span></span></span><br><span class="line"><span class="function"><span class="params"> 	                GLXContext ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglCreateContext.xhtml" target="_blank" rel="noopener">https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglCreateContext.xhtml</a></li>
<li><a href="https://khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glXCreateContext.xml" target="_blank" rel="noopener">https://khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glXCreateContext.xml</a></li>
<li><a href="https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglMakeCurrent.xhtml" target="_blank" rel="noopener">https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglMakeCurrent.xhtml</a></li>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glXMakeCurrent.xml" target="_blank" rel="noopener">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glXMakeCurrent.xml</a></li>
<li><a href="https://blog.csdn.net/shenyi0_0/article/details/109382509" target="_blank" rel="noopener">OpenGL中的上下文 理解整理</a></li>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/" target="_blank" rel="noopener">GLX Reference Pages</a></li>
<li><a href="https://www.khronos.org/registry/EGL/sdk/docs/man/" target="_blank" rel="noopener">EGL Reference Pages</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
        <tag>egl</tag>
        <tag>glx</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM实现原理</title>
    <url>/post/633d906.html</url>
    <content><![CDATA[<p>KVM是一个基于Linux内核的虚拟机，它属于完全虚拟化范畴.</p>
<p>X86架构下的KVM实现，分为AMD的虚拟化技术AMD-V（<code>svm</code>）,Intel的虚拟化技术Intel-VT(<code>vmx</code>)</p>
<a id="more"></a>
<h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><h3 id="完全虚拟化：Full-Virtualization，Native-Virtualization"><a href="#完全虚拟化：Full-Virtualization，Native-Virtualization" class="headerlink" title="完全虚拟化：Full Virtualization，Native Virtualization"></a>完全虚拟化：Full Virtualization，Native Virtualization</h3><ul>
<li>全虚拟化为客户机提供了完整的虚拟X86平台， 包括处理器、 内存和外设， 支持运行任何理论上可在真实物理平台上运行的操作系统， 为虚拟机的配置提供了最大程度的灵活性。</li>
<li>全虚拟化对于虚拟机是无感知的，不清楚自己运行在虚拟化环境中。</li>
<li>CPU如果不支持硬件虚拟化技术：那么所有指令都是通过VMM虚拟的，通过VMM内的BT动态翻译技术把虚拟机要运行的特权指令转换为物理指令集，然后到CPU上运行。</li>
<li>CPU如果支持硬件虚拟化技术：VMM运行ring -1，而GuestOS运行在ring 0。</li>
</ul>
<blockquote>
<p>虚拟机： VMWare Workstation, VirtualBox, VMWare Server, qemu(hvm), XEN(hvm),Qemu_kvm</p>
</blockquote>
<h3 id="半虚拟化：Para-Virutalization"><a href="#半虚拟化：Para-Virutalization" class="headerlink" title="半虚拟化：Para-Virutalization"></a>半虚拟化：Para-Virutalization</h3><ul>
<li>半虚拟化需要对运行在虚拟机上的客户机操作系统进行修改（这些客户机操作系统会意识到它们运行在虚拟环境里）并提供相近的性能，但半虚拟化的性能要比完全虚拟化更优越。</li>
<li>半虚拟化对于虚拟机知道自己运行在虚拟化环境中。</li>
<li>虚拟机内核明确知道自己是运行在虚拟化之上的，对于硬件资源的使用不再需要BT而是自己向VMM申请使用，如对于内存或CPU的使用是直接向VMM申请使用，直接调用而非翻译。</li>
</ul>
<blockquote>
<p>虚拟机：xen</p>
</blockquote>
<h2 id="Qemu-KVM"><a href="#Qemu-KVM" class="headerlink" title="Qemu+KVM"></a>Qemu+KVM</h2><p>KVM主要分：CPU虚拟化、CPU调度原理、KVM内存管理、KVM存储管理、KVM设备管理</p>
<p><img src="/images/2021/03/qemu_kvm.png" alt="qemu_kvm"></p>
<ul>
<li>kvm:是硬件辅助的虚拟化技术，主要负责比较繁琐的cpu虚拟化和内存虚拟化</li>
<li>QEMU:负责IO设备虚拟化</li>
<li>VMM:虚拟机管理器（virtual machine monitor）在底层对其上的虚拟机的管理,提供虚拟机的创建和删除</li>
</ul>
<h3 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h3><p>Intel在处理器级别提供了对虚拟化技术的支持，被称为<code>VMX</code>（virtual-machine extensions）</p>
<p>VMX引入了两个操作模式进行CPU虚拟化：<code>VMX根操作</code>（root operation） 与<code>VMX非根操作</code>（non-root operation）</p>
<h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h3><p>内存虚拟化的目的是给虚拟客户机操作系统提供一个从0地址开始的连续物理内存空间，同时在多个客户机之间实现隔离和调度。在虚拟化环境中，内存地址的访问会主要涉及以下4个基础概念，</p>
<ol>
<li>客户机虚拟地址，GVA（Guest Virtual Address）</li>
<li>客户机物理地址，GPA（Guest Physical Address）</li>
<li>宿主机虚拟地址，HVA（Host Virtual Address）</li>
<li>宿主机物理地址，HPA（Host Physical Address）</li>
</ol>
<blockquote>
<p>内存虚拟化就是要将客户机虚拟地址（GVA）转化为最终能够访问的宿主机上的物理地址（HPA）</p>
</blockquote>
<h3 id="I-O虚拟化"><a href="#I-O虚拟化" class="headerlink" title="I/O虚拟化"></a>I/O虚拟化</h3><p>在虚拟化的架构下，虚拟机监控器必须支持来自客户机的I/O请求。通常情况下有以下4种I/O虚拟化方式。</p>
<ol>
<li>设备模拟：在虚拟机监控器中模拟一个传统的I/O设备的特性，比如在QEMU中模拟一个Intel的千兆网卡或者一个IDE硬盘驱动器，在客户机中就暴露为对应的硬件设备。客户机中的I/O请求都由虚拟机监控器捕获并模拟执行后返回给客户机。</li>
<li>前后端驱动接口：在虚拟机监控器与客户机之间定义一种全新的适合于虚拟化环境的交互接口，比如常见的virtio协议就是在客户机中暴露为virtio-net、virtio-blk等网络和磁盘设备，在QEMU中实现相应的virtio后端驱动。</li>
<li>设备直接分配：将一个物理设备，如一个网卡或硬盘驱动器直接分配给客户机使用，这种情况下I/O请求的链路中很少需要或基本不需要虚拟机监控器的参与，所以性能很好。</li>
<li>设备共享分配：其实是设备直接分配方式的一个扩展。在这种模式下，一个（具有特定特性的）物理设备可以支持多个虚拟机功能接口，可以将虚拟功能接口独立地分配给不同的客户机使用。如SR-IOV就是这种方式的一个标准协议。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/yearn520/article/details/6461047" target="_blank" rel="noopener">KVM实现机制</a></li>
<li><a href="https://blog.csdn.net/Ghostpant/article/details/110825472" target="_blank" rel="noopener">KVM虚拟化技术原理简介</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>kvm</tag>
      </tags>
  </entry>
  <entry>
    <title>linux kernel之NMI</title>
    <url>/post/98e04b95.html</url>
    <content><![CDATA[<p><code>NMI</code>(non-maskable interrupt)，即非可屏蔽中断。即使在内核代码中设置了屏蔽所有中断的时候，NMI也是不可以被屏蔽的。根据Intel的Software Developer手册Volume 3，NMI可由以下两种方式触发：</p>
<ul>
<li>外部assert了CPU的NMI引脚</li>
<li>CPU从系统总线收到了一个中断请求并且delivery mode是NMI</li>
</ul>
<a id="more"></a>
<ol>
<li>无法恢复的硬件错误通常包括：芯片错误、内存ECC校验错、总线数据损坏等等。</li>
<li>当系统挂起，失去响应的时候，可以人工触发NMI，使系统重置，如果早已配置好了kdump，那么会保存crash dump以供分析。有的服务器提供了NMI按钮，而刀片服务器通常不提供按钮，但可以用iLO命令触发。</li>
<li>Linux还提供一种称为”NMI watchdog“的机制，用于检测系统是否失去响应（也称为lockup），可以配置为在发生lockup时自动触发panic。原理是周期性地生成NMI，由NMI handler检查hrtimer中断的发生次数，如果一定时间内这个数字停顿了，表示系统失去了响应，于是调用panic例程。NMI watchdog的开关是通过内核参数<code>kernel.nmi_watchdog</code>或者在boot parameter中加入<code>”nmi_watchdog=1″</code>参数实现，比如：</li>
</ol>
<p>在centos上编辑<code>/boot/grub2/grub.cfg</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">kernel /vmlinuz-2.6.18-128.el5 ro root=/dev/sda nmi_watchdog=1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>命令行设置：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl kernel.nmi_watchdog=1</span><br></pre></td></tr></table></figure></p>
<h2 id="NMI中断的生成"><a href="#NMI中断的生成" class="headerlink" title="NMI中断的生成"></a>NMI中断的生成</h2><ul>
<li>perf性能优化工具使用时，生成大量的NMI中断</li>
</ul>
<blockquote>
<p>Run the ‘perf’ tool in a mode (top or record) that generates many frequent performance monitoring non-maskable interrupts (see “NMI” in /proc/interrupts).  This exercises the NMI entry/exit code which is known to trigger bugs in code paths that did not expect to be interrupted, including nested NMIs.  Using “-c” boosts the rate of NMIs, and using two -c with separate counters encourages nested NMIs and less deterministic behavior.<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while true; do perf record -c 10000 -e instructions,cycles -a sleep 10; done</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wiki.osdev.org/Non_Maskable_Interrupt" target="_blank" rel="noopener">Non Maskable Interrupt</a></li>
<li><a href="https://lwn.net/Articles/484932/" target="_blank" rel="noopener">The x86 NMI iret problem</a></li>
<li><a href="https://blog.csdn.net/yhb1047818384/article/details/70833825" target="_blank" rel="noopener">linux 内核笔记之watchdog</a></li>
<li><a href="http://linuxperf.com/?p=72" target="_blank" rel="noopener">NMI是什么</a></li>
<li><a href="http://blog.bytemem.com/post/linux-kernel-nmi-handler-x86" target="_blank" rel="noopener">Linux内核对x86平台NMI中断的处理</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/trace/events-nmi.html" target="_blank" rel="noopener">NMI Trace Events</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>nmi</tag>
      </tags>
  </entry>
  <entry>
    <title>电源管理——P-State和C-State</title>
    <url>/post/4a7ca2c.html</url>
    <content><![CDATA[<p>CPU电源状态：<code>C-state</code>(CPU Power states）)<br>CPU性能状态：<code>P-state</code>(CPU Performance states)</p>
<blockquote>
<p> The concepts of C/P-states originally come from  ACPI (Advanced Configuration and Power Interface) specification, Cx talk about processor sleep status, while P about running status. please check wiki for more details:</p>
</blockquote>
<a id="more"></a>
<h2 id="C-state"><a href="#C-state" class="headerlink" title="C-state"></a>C-state</h2><p>C-state有C0，C1…Cn多种模式，但只有<code>C0</code>是正常工作模式（active），其他方式都是idle状态，只是idle的程度不同，<code>C后的数越高，CPU睡眠得越深，CPU的功耗被降低得越多</code>，同时需要更多的时间回到C0模式</p>
<h3 id="C1状态（挂起）"><a href="#C1状态（挂起）" class="headerlink" title="C1状态（挂起）"></a>C1状态（挂起）</h3><ul>
<li>可以通过执行汇编指令“HLT（挂起）”进入这一状态</li>
<li>唤醒时间超快！（快到只需10纳秒！）</li>
<li>可以节省70%的CPU功耗</li>
<li>所有现代处理器都必须支持这一功耗状态</li>
</ul>
<h3 id="C2状态（停止允许）"><a href="#C2状态（停止允许）" class="headerlink" title="C2状态（停止允许）"></a>C2状态（停止允许）</h3><ul>
<li>处理器时钟频率和I/O缓冲被停止</li>
<li>换言之，处理器执行引擎和I/0缓冲已经没有时钟频率</li>
<li>在C2状态下也可以节约70%的CPU和平台能耗</li>
<li>从C2切换到C0状态需要100纳秒以上</li>
</ul>
<h3 id="C3状态（深度睡眠）"><a href="#C3状态（深度睡眠）" class="headerlink" title="C3状态（深度睡眠）"></a>C3状态（深度睡眠）</h3><ul>
<li>总线频率和PLL均被锁定</li>
<li>在多核心系统下，缓存无效</li>
<li>在单核心系统下，内存被关闭，但缓存仍有效</li>
<li>可以节省70%的CPU功耗，但平台功耗比C2状态下大一些</li>
<li>唤醒时间需要50微妙</li>
</ul>
<h3 id="C4状态（更深度睡眠）"><a href="#C4状态（更深度睡眠）" class="headerlink" title="C4状态（更深度睡眠）"></a>C4状态（更深度睡眠）</h3><ul>
<li>与C3相似，但有两大区别</li>
<li>一是核心电压低于1.0V</li>
<li>二是二级缓存内的数据存储将有所减少</li>
<li>可以节约98%的CPU最大功耗</li>
<li>唤醒时间比较慢，但不超过1秒</li>
</ul>
<h3 id="C5状态"><a href="#C5状态" class="headerlink" title="C5状态"></a>C5状态</h3><ul>
<li>二级缓存的数据被减为零</li>
<li>唤醒时间超过200微妙</li>
</ul>
<h3 id="C6状态"><a href="#C6状态" class="headerlink" title="C6状态"></a>C6状态</h3><ul>
<li>这是Penryn处理器中新增的功耗管理模式</li>
<li>二级缓存减至零后，CPU的核心电压更低</li>
<li>不保存CPU context</li>
<li>功耗未知，应该接近零</li>
<li>唤醒时间未知</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.chinaunix.net/uid-28541347-id-5822288.html" target="_blank" rel="noopener">linux电源管理——C-state,P-state,turbo分析</a></li>
<li><a href="http://blog.chinaunix.net/uid-25871104-id-3072582.html" target="_blank" rel="noopener">关于CPU C-States 省电模式，你需要知道的事情</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>power</tag>
      </tags>
  </entry>
  <entry>
    <title>IPMI接口的BMC系统管理工具——ipmitool</title>
    <url>/post/c41b411e.html</url>
    <content><![CDATA[<p><code>ipmitool</code>是一种可用在 Linux/Unix 系统下的基于命令行方式的 ipmi 平台管理工具。它支持 ipmi 1.5 和ipmi 2.0 规范（最新的规范为 ipmi 2.0）。利用它可以实现获取传感器的信息、显示系统日志内容、网络远程开关机等功能。其主要功能包括读取和显示传感器数据（SDR），显示System Evernt Log（SEL）的内容，显示打印Field Replaceable Unit（FRU）信息，<code>读取和设置BMC模块</code>的LAN配置，远程控制服务器主机的电源。</p>
<a id="more"></a>
<h2 id="查看BMC的信息"><a href="#查看BMC的信息" class="headerlink" title="查看BMC的信息"></a>查看BMC的信息</h2><ul>
<li>本机BMC信息<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipmitool mc info</span></span><br><span class="line">Device ID                 : 34</span><br><span class="line">Device Revision           : 1</span><br><span class="line">Firmware Revision         : 2.48</span><br><span class="line">IPMI Version              : 2.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看BMC的LAN信息"><a href="#查看BMC的LAN信息" class="headerlink" title="查看BMC的LAN信息"></a>查看BMC的LAN信息</h2><ul>
<li><p>本机LAN信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipmitool lan <span class="built_in">print</span> 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设定channel1从DHCP获得IP:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipmitool lan <span class="built_in">set</span> 1 ipsrc dhcp</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置channel1为静态IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipmitool lan <span class="built_in">set</span> 1 ipsrc static</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置channel1的地址为192.168.1.11</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipmitool lan <span class="built_in">set</span> 1 ipaddr 192.168.1.11</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ipmitool lan <span class="built_in">set</span> 1 netmask 255.255.255.0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ipmitool lan <span class="built_in">set</span> 1 defgw ipaddr 192.168.1.1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="重置BMC（包括BIOS）"><a href="#重置BMC（包括BIOS）" class="headerlink" title="重置BMC（包括BIOS）"></a>重置BMC（包括BIOS）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipmitool raw 0x32 0x66</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/2021/03/ipmitool_restore_bmc.png" alt="ipmitool_restore_bmc"></p>
<blockquote>
<p>来源：<a href="http://www.staroceans.org/e-book/S2B%20IPMI%20Commands.pdf" target="_blank" rel="noopener">IPMI Commands</a></p>
</blockquote>
<h2 id="查看主机传感器信息"><a href="#查看主机传感器信息" class="headerlink" title="查看主机传感器信息"></a>查看主机传感器信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipmitool sensor | grep <span class="string">"Temp "</span></span></span><br><span class="line">BB Inlet Temp    | 25.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 60.000    | 65.000    | na        </span><br><span class="line">BB BMC Temp      | 36.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 85.000    | 90.000    | na        </span><br><span class="line">BB CPU1 VR Temp  | 47.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na        </span><br><span class="line">BB CPU2 VR Temp  | 37.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na        </span><br><span class="line">BB MISC VR Temp  | 49.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na        </span><br><span class="line">BB Outlet Temp   | 46.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na        </span><br><span class="line">SSB Temp         | 42.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 98.000    | 103.000   | na        </span><br><span class="line">LAN NIC Temp     | 56.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 115.000   | 120.000   | na        </span><br><span class="line">Mem 1 VRD Temp   | 39.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na        </span><br><span class="line">Mem 2 VRD Temp   | 25.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na        </span><br><span class="line">EV CPU1VR Temp   | 37.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na</span><br></pre></td></tr></table></figure>
<h2 id="配置用户名密码"><a href="#配置用户名密码" class="headerlink" title="配置用户名密码"></a>配置用户名密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置channel3通过dhcp获取ip</span></span><br><span class="line">ipmitool lan set 3 ipsrc dhcp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看channel3的ip</span></span><br><span class="line">ipmitool lan print 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取ip后查看channel3的用户信息</span></span><br><span class="line">ipmitool user list 3</span><br><span class="line">ID  Name	     Callin  Link Auth	IPMI Msg   Channel Priv Limit</span><br><span class="line">1                    true    false      false      NO ACCESS</span><br><span class="line">2                    true    false      false      NO ACCESS</span><br><span class="line">3   test             true    false      false      NO ACCESS</span><br><span class="line">4                    true    false      false      NO ACCESS</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">选择用户ID 3，配置用户名密码</span></span><br><span class="line">ipmitool user set name 3 test</span><br><span class="line">ipmitool user set password 3 123456@abc#ABC</span><br><span class="line">ipmitool channel setaccess 1 3 callin=on ipmi=on link=on privilege=4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置用户3的访问权限</span></span><br><span class="line">ipmitool user priv 3 0x4 3</span><br><span class="line">ipmitool user list 3</span><br><span class="line">ID  Name	     Callin  Link Auth	IPMI Msg   Channel Priv Limit</span><br><span class="line">1                    true    false      false      NO ACCESS</span><br><span class="line">2                    true    false      false      NO ACCESS</span><br><span class="line">3   test             true    false      false      ADMINISTRATOR</span><br><span class="line">4                    true    false      false      NO ACCESS</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： channel的选择以接入的网口所属channel为主，配置用户名和密码是用户ID和channel id选择一致</p>
</blockquote>
<h2 id="常用的基本命令"><a href="#常用的基本命令" class="headerlink" title="常用的基本命令"></a>常用的基本命令</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ipmitool sel list</code></td>
<td style="text-align:left">打印日志</td>
</tr>
<tr>
<td style="text-align:left"><code>ipmitool sensor</code></td>
<td style="text-align:left">获取传感器中的各种监测值和该值的监测阈值，包括（CPU温度，电压，风扇转速，电源调制模块温度，电源电压等信息）</td>
</tr>
<tr>
<td style="text-align:left"><code>ipmitool chassis status</code></td>
<td style="text-align:left">查看底盘状态，其中包括了底盘电源信息，底盘工作状态等</td>
</tr>
<tr>
<td style="text-align:left"><code>ipmitool user list 1</code></td>
<td style="text-align:left">查询当前BMC的用户</td>
</tr>
<tr>
<td style="text-align:left"><code>ipmitool sdr</code></td>
<td style="text-align:left">查看SDR Sensor信息</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/lianglab/p/14106113.html" target="_blank" rel="noopener">运维管理利器系列–ipmitool</a></li>
<li><a href="https://blog.csdn.net/pansaky/article/details/102807046" target="_blank" rel="noopener">IPMITOOL工具使用详解（待验证）</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>bmc</tag>
        <tag>ipmitool</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel: mce: [Hardware Error]: Machine check events logged</title>
    <url>/post/3ae1a27e.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost.localdomain kernel: mce: [Hardware Error]: Machine check events logged</span><br><span class="line">localhost.localdomain mcelog[2226]: Hardware event. This is not a software error.</span><br><span class="line">localhost.localdomain mcelog[2226]: MCE 0</span><br><span class="line">localhost.localdomain mcelog[2226]: CPU 0 BANK 7 TSC b98e63765d2</span><br><span class="line">localhost.localdomain mcelog[2226]: MISC 200005c280201086 ADDR 20b5cf8880</span><br><span class="line">localhost.localdomain mcelog[2226]: TIME 1617035952 Tue Mar 30 00:39:12 2021</span><br><span class="line">localhost.localdomain mcelog[2226]: MCG status:</span><br><span class="line">localhost.localdomain mcelog[2226]: MCi status:</span><br><span class="line">localhost.localdomain mcelog[2226]: Corrected error</span><br><span class="line">localhost.localdomain mcelog[2226]: Error enabled</span><br><span class="line">localhost.localdomain mcelog[2226]: MCi_MISC register valid</span><br><span class="line">localhost.localdomain mcelog[2226]: MCi_ADDR register valid</span><br><span class="line">localhost.localdomain mcelog[2226]: MCA: MEMORY CONTROLLER RD_CHANNEL0_ERR</span><br><span class="line">localhost.localdomain mcelog[2226]: Transaction: Memory read error</span><br><span class="line">localhost.localdomain mcelog[2226]: M2M: MscodDataRdErr</span><br><span class="line">localhost.localdomain mcelog[2226]: STATUS 9c00004001010090 MCGSTATUS 0</span><br><span class="line">localhost.localdomain mcelog[2226]: MCGCAP f000c14 APICID 0 SOCKETID 0</span><br><span class="line">localhost.localdomain mcelog[2226]: CPUID Vendor Intel Family 6 Model 85</span><br><span class="line">localhost.localdomain mcelog[2226]: warning: 8 bytes ignored in each record</span><br><span class="line">localhost.localdomain mcelog[2226]: consider an update</span><br></pre></td></tr></table></figure>
<p>内存模块出现错误</p>
<a id="more"></a>
<h2 id="Machine-Check-Exceptions-MCE"><a href="#Machine-Check-Exceptions-MCE" class="headerlink" title="Machine Check Exceptions (MCE)"></a>Machine Check Exceptions (MCE)</h2><blockquote>
<p>X86 CPUs report errors detected by the CPU as machine check events (MCEs). These can be data corruption detected in the CPU caches, in main memory by an integrated memory controller, data transfer errors on the front side bus or CPU interconnect or other internal errors. Possible causes can be cosmic radiation, instable power supplies, cooling problems, broken hardware, running systems out of specification, or bad luck.</p>
</blockquote>
<blockquote>
<p>Most errors can be corrected by the CPU by internal error correction mechanisms. Uncorrected errors cause machine check exceptions which may kill processes or panic the machine. A small number of corrected errors is usually not a cause for worry, but a large number can indicate future failure.</p>
</blockquote>
<blockquote>
<p>When a corrected or recovered error happens the x86 kernel writes a record describing the MCE into a internal ring buffer available through the /dev/mcelog device. mcelog retrieves errors from /dev/mcelog, decodes them into a human readable format and prints them on the standard output or optionally into the system log.</p>
</blockquote>
<p>用来报告主机硬件相关问题的一种日志机制</p>
<h2 id="常见的MCE错误原因"><a href="#常见的MCE错误原因" class="headerlink" title="常见的MCE错误原因"></a>常见的MCE错误原因</h2><ul>
<li>内存错误或ECC(Error Correction Code)问题</li>
<li>冷却不充分/处理器过热</li>
<li>系统总线错误</li>
<li>处理器或硬件的缓存错误</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://mcelog.org/manpage.html" target="_blank" rel="noopener">mcelog</a></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>mce</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能测试——CPU性能及工作状态</title>
    <url>/post/e3720616.html</url>
    <content><![CDATA[<p>Linux下查看系统状态的一些命令<code>mpstat</code>、<code>vmstat</code>、<code>iostat</code>、<code>sar</code>、<code>top</code>、<code>pidstat</code>、<code>pstack</code></p>
<p><img src="/images/2021/03/linux_observability_tools.png" alt="Linux Performance Tools"></p>
<a id="more"></a>
<h2 id="衡量CPU性能的指标"><a href="#衡量CPU性能的指标" class="headerlink" title="衡量CPU性能的指标"></a>衡量CPU性能的指标</h2><ol>
<li>用户使用CPU<ul>
<li>CPU运行实时进程</li>
<li>CPU运行niced process</li>
<li>CPU运行常规用户进程</li>
</ul>
</li>
<li>系统使用CPU<ul>
<li>用于I/O管理：中断和驱动</li>
<li>用于内存管理：页面交换</li>
<li>用于进程管理：进程开始和上下文切换</li>
</ul>
</li>
<li>WIO：用于进程等待磁盘I/O而使CPU处于空闲状态的比率。</li>
<li>CPU的空闲率，除了上面的WIO以外的空闲时间</li>
<li>CPU用于上下文交换的比率</li>
<li>nice</li>
<li>real-time</li>
<li>运行进程队列的长度</li>
<li>平均负载</li>
</ol>
<h2 id="Linux常用监控CPU整体性能的工具"><a href="#Linux常用监控CPU整体性能的工具" class="headerlink" title="Linux常用监控CPU整体性能的工具"></a>Linux常用监控CPU整体性能的工具</h2><ul>
<li><code>mpstat</code>： mpstat不但能查看所有CPU的平均信息，还能查看指定CPU的信息,以及中断利用率</li>
<li><code>vmstat</code>：只能查看所有CPU的平均信息；查看cpu队列信息；</li>
<li><code>iostat</code>: 只能查看所有CPU的平均信息。</li>
<li><code>sar</code>： 与mpstat 一样，不但能查看CPU的平均信息，还能查看指定CPU的信息。</li>
<li><code>top</code>：显示的信息同ps接近，但是top可以了解到CPU消耗，可以根据用户指定的时间来更新显示。</li>
<li><code>pidstat</code>:用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况,<code>-w</code>可以查看每个进程的上下文切换情况。</li>
<li><code>pstack</code>：显示每个进程的栈跟踪，可以确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的PID。</li>
<li><code>gstack</code>: 打印运行进程（线程）调用栈。</li>
<li><code>gcore</code>: 生成正在运行的程序的core文件，可以进行gdb调试。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/z1134145881/article/details/52089698" target="_blank" rel="noopener">linux CPU性能及工作状态查看指令</a></li>
<li><a href="http://www.brendangregg.com/linuxperf.html" target="_blank" rel="noopener">Linux Performance</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>linux性能测试——load average</title>
    <url>/post/4d1d787a.html</url>
    <content><![CDATA[<p><code>uptime</code>和<code>top</code>等命令都可以看到<code>load average</code>指标，从左至右三个数字分别表示<code>1分钟</code>、<code>5分钟</code>、<code>15分钟</code>的load average：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uptime</span></span><br><span class="line"> 09:52:13 up 20:03, 14 users,  load average: 48.59, 46.08, 46.00</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>判断一个系统负载是否偏高需要计算单核CPU的平均负载，等于这里uptime命令显示的系统平均负载/CPU核数，一般以0.7为比较合适的值, 偏高说明有比较多的进程在等待使用CPU资源。<br>除了等待运行的进程还有不可中断的线程</p>
</blockquote>
<a id="more"></a>
<h2 id="系统负载"><a href="#系统负载" class="headerlink" title="系统负载"></a>系统负载</h2><ul>
<li>系统负载度量旨在将系统“资源需求”表示为一个数字。 在经典Unix上，它仅计算对CPU的需求（处于Runnable状态的线程）</li>
<li>系统负载度量的单位是“进程/线程数”（或在Linux上称为调度单位的任务）。 平均负载是一个时间段（最后1,5,15分钟）内平均线程数，该时间段在经典unix上“竞争CPU”或在Linux上“竞争CPU或以不间断的睡眠状态等待”</li>
<li>可运行状态表示“不受任何阻止”，可以在CPU上运行。 该线程当前正在CPU上运行，或者在CPU运行队列中等待OS调度程序将其放到CPU上</li>
<li>在Linux上，系统负载包括处于<code>Runnable（R）</code>和处于<code>Uninterruptible sleep（D）</code>状态的线程（通常是磁盘I/O，但并非总是如此）</li>
</ul>
<p> 当前系统负载只是Linux上处于R或D状态的线程（称为任务）的数量。 我们可以运行ps列出这些状态下的当前线程数：<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps -eo s,user | grep ^[RD] | sort | uniq -c | sort -nbr | head -20</span></span><br><span class="line">     3 R root</span><br><span class="line">     1 D root</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://tanelpoder.com/posts/high-system-load-low-cpu-utilization-on-linux/" target="_blank" rel="noopener">High System Load with Low CPU Utilization on Linux?</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统调用——vsyscall和vDSO</title>
    <url>/post/f04c402b.html</url>
    <content><![CDATA[<p><code>vsyscall</code>和<code>vDSO</code>段是用于加速Linux中某些系统调用的两种机制。</p>
<blockquote>
<p>The <code>&quot;vDSO&quot;</code> (virtual dynamic shared object) is a small shared library<br>that the kernel automatically maps into the address space of all user-space applications.  Applications usually do not need to concern themselves with these details as the vDSO is most commonly called by the C library.  This way you can code in the normal way using standard functions and the C library will take care of using any functionality that is available via the vDSO.</p>
</blockquote>
<a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/1073909" target="_blank" rel="noopener">人见人爱的vDSO机制，如今也靠不住了</a></li>
<li><a href="https://stackoverflow.com/questions/19938324/what-are-vdso-and-vsyscall" target="_blank" rel="noopener">What are vdso and vsyscall?</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>syscall</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL ES —— surfaces</title>
    <url>/post/b1cee24c.html</url>
    <content><![CDATA[<p>EGL™ is an interface between Khronos rendering APIs such as OpenGL ES or OpenVG and the underlying native platform window system. It handles graphics context management, surface/buffer binding, and rendering synchronization and enables high-performance, accelerated, mixed-mode 2D and 3D rendering using other Khronos APIs. EGL also provides interop capability between Khronos to enable efficient transfer of data between APIs – for example between a video subsystem running OpenMAX AL and a GPU running OpenGL ES.</p>
<p>EGL provides mechanisms for creating rendering surfaces onto which client APIs like OpenGL ES and OpenVG can draw, creates graphics contexts for client APIs, and synchronizes drawing by client APIs as well as native platform rendering APIs. This enables seamless rendering using both OpenGL ES and OpenVG for high-performance, accelerated, mixed-mode 2D and 3D rendering.</p>
<a id="more"></a>
<blockquote>
<p>EGLSurface可以是一个EGL分配的离屏缓冲区(称为 “pbuffer”) 或由操作系统分配的窗口</p>
</blockquote>
<h2 id="Window-surfaces"><a href="#Window-surfaces" class="headerlink" title="Window surfaces"></a>Window surfaces</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* create an EGL window surface */</span></span><br><span class="line">surface = eglCreateWindowSurface(<span class="built_in">display</span>, <span class="built_in">config</span>, target, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (surface == EGL_NO_SURFACE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create surface failed: 0x%x\n"</span>, eglGetError());</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pixmap-surfaces"><a href="#Pixmap-surfaces" class="headerlink" title="Pixmap surfaces"></a>Pixmap surfaces</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pmsurface = eglCreatePixmapSurface(<span class="built_in">display</span>, chosen, gfsurface, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pmsurface == EGL_NO_SURFACE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create Pixmap failed: 0x%x\n"</span>, eglGetError());</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pbuffer-surfaces"><a href="#pbuffer-surfaces" class="headerlink" title="pbuffer surfaces"></a>pbuffer surfaces</h2><p>To create a pbuffer surface, the application must specify the width and height of the surfaces via the EGL_WIDTH and EGL_HEIGHT attributes. In the case of a pbuffer surface, the actual surface memory is always allocated internally by OpenGL ES.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* create an EGL pbuffer surface */</span></span><br><span class="line">pbsurface = eglCreatePbufferSurface(<span class="built_in">display</span>, chosen, pb_attrs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pbsurface == EGL_NO_SURFACE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create PBuffer failed: 0x%x\n"</span>, eglGetError());</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* connect the context to the PBuffer surface */</span></span><br><span class="line"><span class="keyword">if</span> (eglMakeCurrent(<span class="built_in">display</span>, pbsurface, pbsurface, context) == EGL_FALSE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Make current failed: 0x%x\n"</span>, eglGetError());</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>opengl</tag>
        <tag>surfaces</tag>
      </tags>
  </entry>
  <entry>
    <title>[译]GPU体系结构：数据并行吞吐量的结构</title>
    <url>/post/b5b80551.html</url>
    <content><![CDATA[<p>根据Wikipedia的说法，GPU卡（也称为图形卡或视频卡）是一种专用的电子电路。 它是专门为快速处理和更改内存而设计的，以加快在帧缓冲区中创建图像的速度，因此可以输出到诸如计算机监视器或电视屏幕之类的显示设备。</p>
<p>现代GPU架构在处理图形以及图像处理方面非常有效。 高度并行的结构使其比用于并行处理大型数据块的通用CPU（中央处理单元）体系结构更有效。</p>
<p>在PC内，GPU可以嵌入扩展卡（视频卡）中，预先安装在主板上（专用GPU）或集成到CPU裸片（集成GPU）中。<br><a id="more"></a></p>
<h2 id="GPU架构"><a href="#GPU架构" class="headerlink" title="GPU架构"></a>GPU架构</h2><p>在谈到视频卡体系结构时，它总是涉及CPU体系结构或与之比较。</p>
<h3 id="GPU-vs-CPU架构"><a href="#GPU-vs-CPU架构" class="headerlink" title="GPU vs CPU架构"></a>GPU vs CPU架构</h3><p><img src="/images/2021/03/cpu_vs_gpu.png" alt="CPU vs GPU"></p>
<p>GPU的功能是优化数据吞吐量。它允许一次通过其内部推送尽可能多的任务，这比CPU一次可以处理的任务多得多。这是因为通常情况下，图形卡具有比CPU多得多的内核。</p>
<p>但是，实际上，我们称内核为CUDA（计算统一设备体系结构）内核，该内核由GPU中的全流水线整数ALU（算术逻辑单元）和FPU（浮点单元）组成。在NVIDIA GPU架构中，ALU支持所有指令的完整32位精度。并且，对整数ALU进行了优化，以有效地支持64位扩展精度运算以及各种指令，例如布尔运算，比较，转换，移动，移位，位反向插入，位域提取和填充计数。</p>
<p>通常，GPU的体系结构与CPU的体系结构非常相似。它们都利用高速缓存层，全局内存和内存控制器的内存构造。</p>
<p>高级GPU架构仅涉及数据并行吞吐量计算，并使可用的内核正常工作，而不是像CPU那样专注于低延迟高速缓存的访问。</p>
<blockquote>
<p>注意：详细的图形卡体系结构在很大程度上取决于不同制造商的品牌和型号。 Nvidia GPU架构与AMD GPU架构不同。</p>
</blockquote>
<h2 id="GPU体系结构基础"><a href="#GPU体系结构基础" class="headerlink" title="GPU体系结构基础"></a>GPU体系结构基础</h2><p>在GPU设备中，有多个处理器集群（PC），其中包含多个流式多处理器（SM）。 并且，每个SM都包含一个1层指令高速缓存层及其相关的内核。 通常，一个SM在从全局GDDR-5存储器中提取数据之前，会采用专用的第1层高速缓存和共享的第2层高速缓存。 因此，GPU处理器体系结构可容忍内存延迟。</p>
<p><img src="/images/2021/03/nvidia_gpu_architecture.png" alt="Nvidia GPU Architecture"></p>
<h3 id="GCA-Graphics-Compute-Array"><a href="#GCA-Graphics-Compute-Array" class="headerlink" title="GCA (Graphics Compute Array)"></a>GCA (Graphics Compute Array)</h3><p>通常，GCA（也称为3D引擎）由像素着色器，顶点着色器或统一着色器，流处理器（CUDA核心），纹理映射单元（TMU），渲染输出单元（ROP），二级缓存，几何处理器， 等等。</p>
<h3 id="GMC-Graphics-Memory-Controller"><a href="#GMC-Graphics-Memory-Controller" class="headerlink" title="GMC (Graphics Memory Controller)"></a>GMC (Graphics Memory Controller)</h3><p>GMC，也称为内存芯片控制器（MCC）或内存控制器单元（MCU），是一种数字电路，用于控制进出计算机图形内存的数据流。 它可以是单独的芯片； 它也可以集成到另一个芯片中，例如放置在同一芯片上或作为微处理器的组成部分。 如果GMC作为组成部分存在，则称为IMC（集成内存控制器）。<br>内存GMC控件包括VRAM，WRAM，MDRAM，DDR，GDDR和HBM。</p>
<h3 id="VGA-BIOS-Video-Graphics-Array-Basic-Input-Output-System"><a href="#VGA-BIOS-Video-Graphics-Array-Basic-Input-Output-System" class="headerlink" title="VGA BIOS (Video Graphics Array Basic Input/Output System)"></a>VGA BIOS (Video Graphics Array Basic Input/Output System)</h3><p>VGA BIOS，也称为视频BIOS，是计算机中图形卡的BIOS。 它是位于图形卡上的独立芯片，不是GPU的一部分。</p>
<h3 id="BIF-Bus-Interface"><a href="#BIF-Bus-Interface" class="headerlink" title="BIF (Bus Interface)"></a>BIF (Bus Interface)</h3><p>总线接口（BI）是用于将小型外围设备（例如闪存）与处理器接口的计算机总线。 通常，它包括SA，VLB，PCI，AGP和PCIe。</p>
<h3 id="PMU-Power-Management-Unit"><a href="#PMU-Power-Management-Unit" class="headerlink" title="PMU (Power Management Unit)"></a>PMU (Power Management Unit)</h3><p>PMU是控制数字平台电源功能的微控制器（微芯片）。 它具有许多与普通计算机类似的组件，例如CPU，内存，固件，软件等。PMU是为数不多的几个组件之一，即使计算机完全关闭，该组件仍由备用电池供电，这些组件仍可以保持活动状态。</p>
<p>在便携式计算机中，PMU协调以下功能：</p>
<ul>
<li>监视电源连接和电池电量。</li>
<li>闲置时，请关闭不必要的系统部件。</li>
<li>控制睡眠和电源功能（打开或关闭）。</li>
<li>控制其他集成电路的电源。</li>
<li>管理内置键盘或触控板的界面。</li>
<li>必要时给电池充电。</li>
<li>调节实时时钟（RTC）。</li>
</ul>
<h3 id="VPU-Video-Processing-Unit"><a href="#VPU-Video-Processing-Unit" class="headerlink" title="VPU (Video Processing Unit)"></a>VPU (Video Processing Unit)</h3><p>VPU是一种专用处理器，将视频流作为输入，并且可以对输入流执行非常复杂的过程。 它通常用于机器学习应用程序和设备中，并充当那些设备中的辅助组件。</p>
<p>VPU是负责视频编码和解码的视频编解码器。 因此，它也被称为视频编码器和解码器。 VPU执行MPEG2，Theora，VP8，H.264，H.265，VP9，VC-1等的压缩或解压缩。</p>
<h3 id="DIF-Display-Interface"><a href="#DIF-Display-Interface" class="headerlink" title="DIF (Display Interface)"></a>DIF (Display Interface)</h3><p>显示接口，也称为显示控制器，定义了主机，图像数据源和目标设备之间的串行总线和通信协议。 它包括RAMDAC，HDMI音频，DP音频，视频底图（VGA，DVI，HDMI，DisplayPort，S-Video，复合视频，分量视频），PHY（LVDS，TIMDS）和EDID。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.partitionwizard.com/partitionmagic/gpu-architecture.html" target="_blank" rel="noopener">GPU Architecture: A Structure for Data Parallel Throughput</a></li>
</ul>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>nvidia</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC---共享内存</title>
    <url>/post/a83ba476.html</url>
    <content><![CDATA[<p>进程间通信的一种方式，多个进程共享一段内存，即“<code>共享内存</code>”。与其他的ipc方式（如：pipe，fifo，messages）相比少copy一次内存</p>
<a id="more"></a>
<h2 id="共享内存接口函数"><a href="#共享内存接口函数" class="headerlink" title="共享内存接口函数"></a>共享内存接口函数</h2><h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><p>创建新的，或者获取已有的共享内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;                           </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;                           </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>key</code>: 类似共享内存的标签,如果key值没有对应任何共享内存,则创建一个新的共享内存；如果已存在,则直接使用创建好的共享内存<blockquote>
<p>由<code>ftok</code>生成的key标识，标识系统的唯一IPC资源</p>
</blockquote>
</li>
<li>返回值: 返回共享内存的标识符，用于后续对该共享内存的操作</li>
</ul>
<h3 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h3><p>将shmid所指向的共享内存空间映射到进程空间（虚拟内存空间），并返回影射后的起始地址（虚拟地址）。有了这个地址后，就可以通过这个地址对共享内存进行读写操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;                                         </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;                                           </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h3><p>取消建立的映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;                                      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;                                      </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="共享内存的使用步骤"><a href="#共享内存的使用步骤" class="headerlink" title="共享内存的使用步骤"></a>共享内存的使用步骤</h2><ul>
<li>进程调用shmget函数创建新的或获取已有共享内存</li>
<li>进程调用shmat函数，将物理内存映射到自己的进程空间，说白了就是让虚拟地址和真实物理地址建议一一对应的映射关系。</li>
<li>shmdt函数，取消映射</li>
<li>调用shmctl函数释放开辟的那片物理内存空间和消息队列的msgctl的功能是一样的，只不过这个是共享内存的。</li>
</ul>
<h2 id="共享内存的删除"><a href="#共享内存的删除" class="headerlink" title="共享内存的删除"></a>共享内存的删除</h2><ol>
<li>重启OS，很麻烦，服务器也不是随随便便就让你去重启的。</li>
<li>进程结束时，调用相应的API来删除</li>
<li>使用ipcrm命令删除</li>
</ol>
<h2 id="查看当前系统中的共享内存"><a href="#查看当前系统中的共享内存" class="headerlink" title="查看当前系统中的共享内存"></a>查看当前系统中的共享内存</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcs -m</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/qq_43648751/article/details/104836005" target="_blank" rel="noopener">共享内存详解（本机IPC）【linux】</a></li>
<li><a href="https://blog.csdn.net/guoping16/article/details/6584058" target="_blank" rel="noopener">共享内存函数（shmget、shmat、shmdt、shmctl）及其范例</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ipc</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title>vim的简单配置（无插件）</title>
    <url>/post/cce68b0.html</url>
    <content><![CDATA[<p>vim简单的配置信息，记录在此方便后期使用</p>
<a id="more"></a>
<p>vimrc配置文件：<a href="/software/vimrc">.vimrc</a></p>
]]></content>
  </entry>
  <entry>
    <title>`GLIBCXX_3.4.21&#39; not found</title>
    <url>/post/851846f4.html</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by /usr/local/bin/a.out)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序运行是加载的<code>libstdc++</code>库版本低， 解决方法直接升级gcc版本</p>
</blockquote>
<a id="more"></a>
<h2 id="检查引用库GLIBCXX版本"><a href="#检查引用库GLIBCXX版本" class="headerlink" title="检查引用库GLIBCXX版本"></a>检查引用库GLIBCXX版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> strings /usr/lib64/libstdc++.so.6|grep GLIBCXX</span></span><br><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">GLIBCXX_3.4.2</span><br><span class="line">GLIBCXX_3.4.3</span><br><span class="line">GLIBCXX_3.4.4</span><br><span class="line">GLIBCXX_3.4.5</span><br><span class="line">GLIBCXX_3.4.6</span><br><span class="line">GLIBCXX_3.4.7</span><br><span class="line">GLIBCXX_3.4.8</span><br><span class="line">GLIBCXX_3.4.9</span><br><span class="line">GLIBCXX_3.4.10</span><br><span class="line">GLIBCXX_3.4.11</span><br><span class="line">GLIBCXX_3.4.12</span><br><span class="line">GLIBCXX_3.4.13</span><br><span class="line">GLIBCXX_3.4.14</span><br><span class="line">GLIBCXX_3.4.15</span><br><span class="line">GLIBCXX_3.4.16</span><br><span class="line">GLIBCXX_3.4.17</span><br><span class="line">GLIBCXX_3.4.18</span><br><span class="line">GLIBCXX_3.4.19</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br></pre></td></tr></table></figure>
<h2 id="CentOS升级gcc"><a href="#CentOS升级gcc" class="headerlink" title="CentOS升级gcc"></a>CentOS升级gcc</h2><h3 id="安装gcc9"><a href="#安装gcc9" class="headerlink" title="安装gcc9"></a>安装gcc9</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以安装多个版本，使用时自由切换</p>
</blockquote>
<h3 id="切换gcc版本"><a href="#切换gcc版本" class="headerlink" title="切换gcc版本"></a>切换gcc版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scl enable devtoolset-9 bash</span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line">source /opt/rh/devtoolset-3/enable</span><br></pre></td></tr></table></figure>
<h3 id="libstdc"><a href="#libstdc" class="headerlink" title="libstdc++"></a>libstdc++</h3><p>安装后的文件：<code>/opt/rh/devtoolset-9/root/usr/lib/gcc/x86_64-redhat-linux/9/libstdc++.so</code></p>
<h2 id="程序运行时加载库的流程"><a href="#程序运行时加载库的流程" class="headerlink" title="程序运行时加载库的流程"></a>程序运行时加载库的流程</h2><p>升级完成gcc后，切换到高版本进行编译后，可以正常运行，但是此时系统中存在多个<code>libstdc++</code>库，它是如何找到那个高版本库加载的？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ldd /usr/<span class="built_in">local</span>/bin/a.out | grep c++</span></span><br><span class="line">	libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007fab09a88000)</span><br></pre></td></tr></table></figure>
<p>ldd查看其依赖库依然是<code>/lib64/libstdc++.so.6</code>，这个gcc低版本库，正常应该是不能运行的，但是此时程序运行是正常的（使用系统默认gcc编译后无法正常运行）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strings /opt/rh/devtoolset-9/root/usr/lib/gcc/x86_64-redhat-linux/9/libstdc++.so</span><br><span class="line">/* GNU ld script</span><br><span class="line">   Use the shared library, but some functions are only in</span><br><span class="line">   the static library, so try that secondarily.  */</span><br><span class="line">OUTPUT_FORMAT(elf64-x86-64)</span><br><span class="line">INPUT ( /usr/lib64/libstdc++.so.6 -lstdc++_nonshared )</span><br></pre></td></tr></table></figure>
<p>通过<code>strings</code>查看该库时，发现以上信息。个人理解应该是再切换了编译器后，在编译时将部分代码结构，以静态的方式直接编译到了可执行程序中，这样在运行时即使加载旧的<code>libstdc++</code>库，也可以正常运行。</p>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc编译参数：-Wl,-Bsymbolic与-Bsymbolic</title>
    <url>/post/2a74814.html</url>
    <content><![CDATA[<p>在实际应用中，编译C++代码时使用了<code>-Wl,-Bsymbolic</code>参数编译后生成的动态库文件，在被加载使用时出现错误<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">** Error in `.a.out&apos;: free(): invalid pointer: 0x0000000000414320 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib64/libc.so.6(+0x81299)[0x7ff6d99a1299]</span><br></pre></td></tr></table></figure></p>
<p>同样的代码，同样的编译参数，编译生成静态库可以正常使用，但是动态库只要运行时就报错。将<code>-Wl,-Bsymbolic</code>参数删除不用或者改为<code>-Bsymbolic</code>后，编译生成的动态库均可以正常使用，这两个参数对程序编译存在什么影响？</p>
<a id="more"></a>
<h2 id="Bsymbolic"><a href="#Bsymbolic" class="headerlink" title="-Bsymbolic"></a>-Bsymbolic</h2><p>正常情况下，在linux平台上(不使用-Bsymbolic)，加载的目标文件中第一次出现的符号将在程序中一直被使用，不论是定义在静态可执行部分，还是在动态目标文件中。这是通过符号抢占(symbol preemption)来实现的。动态加载器构建符号表，所有的动态符号根据该符号表被决议。所以正常情况下，如果一个符号实例出现在动态库（DSO）中，但是已经在静态可执行文件或者之前加载的动态库中被定义，那么以前的定义也将被用于当前的动态库中。</p>
<blockquote>
<p>Binds references to all global symbols in a program to the definitions within a user’s shared library.</p>
</blockquote>
<p>链接器选项<code>-Bsymbolic</code>可以与<code>-shared</code>一起使用。 ld -shared -Bsymbolic与-pie非常相似。</p>
<p><code>-Bsymbolic</code>遵循ELF DF_SYMBOLIC语义：所有定义的符号都是不可抢占的，优先使用本地符号</p>
<h2 id="Wl-Bsymbolic"><a href="#Wl-Bsymbolic" class="headerlink" title="-Wl,-Bsymbolic"></a>-Wl,-Bsymbolic</h2><blockquote>
<p>-Wl,option<br>  Pass option as an option to the linker. If option contains commas, it is split into multiple options at the commas. You can use this syntax to pass an argument to the option. For example, -Wl,-Map,output.map passes -Map output.map to the linker. When using the GNU linker, you can also get the same effect with -Wl,-Map=output.map.</p>
<blockquote>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options</a></p>
</blockquote>
</blockquote>
<p><code>-Wl,-Bsymbolic</code>其中Wl表示将紧跟其后的参数，传递给连接器ld。<code>Bsymbolic</code>表示强制采用本地的全局变量定义，这样就不会出现动态链接库的全局变量定义被应用程序/动态链接库中的同名定义给覆盖了</p>
<p>最开始的错误，可能是由于某一个全局对象生成相同的符号表后，在程序进行free时，多次free造成的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://maskray.me/blog/2021-05-16-elf-interposition-and-bsymbolic" target="_blank" rel="noopener">ELF interposition and -Bsymbolic</a></li>
<li><a href="https://flameeyes.blog/2012/10/07/symbolism-and-elf-files-or-what-does-bsymbolic-do/" target="_blank" rel="noopener">Symbolism and ELF files (or, what does -Bsymbolic do?)</a></li>
<li><a href="https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/compiler-options/compiler-option-details/linking-or-linker-options/bsymbolic.html#bsymbolic" target="_blank" rel="noopener">Bsymbolic</a></li>
<li><a href="https://blog.csdn.net/weixin_41964962/article/details/107209950" target="_blank" rel="noopener">Option -Bsymbolic 会导致严重副作用</a></li>
<li><a href="https://www.cnblogs.com/tcxa/p/14813372.html" target="_blank" rel="noopener">解决动态库的符号冲突</a></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>bsymbolic</tag>
      </tags>
  </entry>
  <entry>
    <title>基于bonding实现网卡聚合</title>
    <url>/post/c9919005.html</url>
    <content><![CDATA[<p><code>bonding</code>是一个linux kernel的driver，加载了它以后，linux支持将多个物理网卡捆绑成一个虚拟的bond网卡</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lsmod | grep bond</span></span><br><span class="line">bonding               155648  0</span><br></pre></td></tr></table></figure>
<p>利用bonding技术与交换机的端口动态聚合实现双网口的绑定</p>
<p><img src="/images/2021/06/网口聚合bond.png" alt="网口聚合bond"></p>
<a id="more"></a>
<h2 id="bond模式"><a href="#bond模式" class="headerlink" title="bond模式"></a>bond模式</h2><table>
<thead>
<tr>
<th style="text-align:center">mode</th>
<th style="text-align:left">别名</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">交换机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mode=0</td>
<td style="text-align:left">mode=balance-rr</td>
<td style="text-align:left">平衡抡循环策略，传输数据包顺序是依次传输，此模式提供负载平衡和容错能力</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">mode=1</td>
<td style="text-align:left">mode=active-backup</td>
<td style="text-align:left">主-备份策略，只有一个设备处于活动状态，当一个宕掉另一个马上由备份转换为主设备，其中一条线若断线，其他线路将会自动备援</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">mode=2</td>
<td style="text-align:left">mode=balance-xor</td>
<td style="text-align:left">平衡策略，基于指定的传输HASH策略传输数据包。缺省的策略是：(源MAC地址 XOR 目标MAC地址)% slave数量</td>
<td style="text-align:left">传输策略可以通过xmit_hash_policy选项指定</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">mode=3</td>
<td style="text-align:left">mode=broadcast</td>
<td style="text-align:left">广播策略，在每个slave接口上传输每个数据包，此模式提供了容错能力</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">mode=4</td>
<td style="text-align:left">mode=802.3ad</td>
<td style="text-align:left">IEEE802.3ad 动态链接聚合（LACP）</td>
<td style="text-align:left">xmit_hash_policy选项从缺省的XOR策略改变到其他策略</td>
<td style="text-align:left">交换机支持IEEE 802.3ad动态链路聚合，及开启LACP功能</td>
</tr>
<tr>
<td style="text-align:center">mode=5</td>
<td style="text-align:left">mode=balance-tlb</td>
<td style="text-align:left">适配器传输负载均衡</td>
<td style="text-align:left"></td>
<td style="text-align:left">不需要交换机支持</td>
</tr>
<tr>
<td style="text-align:center">mode=6</td>
<td style="text-align:left">mode=balance-alb</td>
<td style="text-align:left">适配器适应性负载均衡</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>注： 除了<code>balance-rr</code>模式外的其它bonding负载均衡模式一样，任何连接都不能使用多于一个接口的带宽。</p>
<h2 id="配置实例（802-3ad-mode4）"><a href="#配置实例（802-3ad-mode4）" class="headerlink" title="配置实例（802.3ad/mode4）"></a>配置实例（802.3ad/mode4）</h2><blockquote>
<p>802.3ad or 4</p>
<p>   IEEE 802.3ad Dynamic link aggregation.  Creates<br>   aggregation groups that share the same speed and<br>   duplex settings.  Utilizes all slaves in the active<br>   aggregator according to the 802.3ad specification.</p>
<p>   Slave selection for outgoing traffic is done according<br>   to the transmit hash policy, which may be changed from<br>   the default simple XOR policy via the xmit_hash_policy<br>   option, documented below.  Note that not all transmit<br>   policies may be 802.3ad compliant, particularly in<br>   regards to the packet mis-ordering requirements of<br>   section 43.2.4 of the 802.3ad standard.  Differing<br>   peer implementations will have varying tolerances for<br>   noncompliance.</p>
<p>   Prerequisites:</p>
<ol>
<li><p>Ethtool support in the base drivers for retrieving<br>the speed and duplex of each slave.</p>
</li>
<li><p>A switch that supports IEEE 802.3ad Dynamic link<br>aggregation.</p>
<p>Most switches will require some type of configuration<br>to enable 802.3ad mode.</p>
</li>
</ol>
<p>来自内核文档： <a href="https://elixir.bootlin.com/linux/latest/source/Documentation/networking/bonding.rst" target="_blank" rel="noopener">Documentation/networking/bonding.rst</a></p>
</blockquote>
<h3 id="bond0"><a href="#bond0" class="headerlink" title="bond0"></a>bond0</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-bond0</span><br><span class="line">DEVICE=bond0</span><br><span class="line">NAME=bond0</span><br><span class="line">TYPE=Bond</span><br><span class="line">BONDING_MASTER=yes</span><br><span class="line">IPADDR=192.168.1.1</span><br><span class="line">PREFIX=24</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED="no"</span><br></pre></td></tr></table></figure>
<h3 id="网卡eth1"><a href="#网卡eth1" class="headerlink" title="网卡eth1"></a>网卡eth1</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/sysconfig/network-scripts/ifcfg-eth1</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">DEVICE=eth1</span><br><span class="line">NAME=eth1</span><br><span class="line">ONBOOT=yes</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">NM_CONTROLLED="no"</span><br></pre></td></tr></table></figure>
<h3 id="网卡eth2"><a href="#网卡eth2" class="headerlink" title="网卡eth2"></a>网卡eth2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/sysconfig/network-scripts/ifcfg-eth2</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">DEVICE=eth2</span><br><span class="line">NAME=eth2</span><br><span class="line">ONBOOT=yes</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">NM_CONTROLLED="no"</span><br></pre></td></tr></table></figure>
<ul>
<li>重启网络或者bond0虚拟机网卡</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifdown bond0 &amp;&amp; ifup bond0</span><br></pre></td></tr></table></figure>
<ul>
<li>查看bond0虚拟网卡信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/net/bonding/bond0</span><br></pre></td></tr></table></figure>
<h2 id="RDMA网卡"><a href="#RDMA网卡" class="headerlink" title="RDMA网卡"></a>RDMA网卡</h2><p>RoCE LAG是一种用于模拟IB设备的以太网绑定的功能，仅适用于双端口卡。部分网卡支持一下3种模式</p>
<ul>
<li>active-backup (mode 1)</li>
<li>balance-xor (mode 2)</li>
<li>802.3ad (LACP) (mode 4)</li>
</ul>
<blockquote>
<p>在mode4模式下，进行数据传输的始终只有一个端口，带宽与一个端口传输一样，但是将其中任意一个端口拔掉后，数据传输切换到另一个端口，实际业务不受影响。也是一种主备模式，在IB模式下只支持主备模式</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.sina.com.cn/s/blog_d83f9fc50102v8fe.html" target="_blank" rel="noopener">七种网卡绑定模式详解</a></li>
<li><a href="https://docs.mellanox.com/pages/viewpage.action?pageId=39284930" target="_blank" rel="noopener">RDMA over Converged Ethernet (RoCE)</a></li>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/networking_guide/sec-network_bonding_using_the_command_line_interface" target="_blank" rel="noopener">7.4. USING THE COMMAND LINE INTERFACE (CLI)</a></li>
<li><a href="https://community.mellanox.com/s/article/How-to-Configure-RoCE-over-LAG-ConnectX-4-ConnectX-5-ConnectX-6" target="_blank" rel="noopener">How to Configure RoCE over LAG (ConnectX-4/ConnectX-5-/ConnectX-6)</a></li>
<li><a href="https://bbs.huaweicloud.com/forum/thread-42234-1-1.html" target="_blank" rel="noopener">双25GE网卡做bond4测试，其中一个网口没有流量一个网口可以打满的问题分享</a></li>
<li><a href="https://m.linuxidc.com/Linux/2011-05/35326.htm" target="_blank" rel="noopener">链路层的网卡聚合-基于Linux bonding</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网卡</tag>
        <tag>bond</tag>
        <tag>聚合</tag>
      </tags>
  </entry>
  <entry>
    <title>字节序</title>
    <url>/post/79aef41.html</url>
    <content><![CDATA[<p>字节序有<code>大端字节序</code>与<code>小端字节序</code>,目前X86、arm、mips基本都使用<code>小端字节序</code>。但是在网络数据传输时，使用<code>大端字节序</code>。</p>
<blockquote>
<p>TCP/IP协议，RFC1700规定使用“大端”字节序为网络字节序，其他不使用大端的计算机要注意了，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化</p>
</blockquote>
<a id="more"></a>
<p>大小端字节序转换</p>
<h2 id="32bit字节转换"><a href="#32bit字节转换" class="headerlink" title="32bit字节转换"></a>32bit字节转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;                </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="64bit字节转换"><a href="#64bit字节转换" class="headerlink" title="64bit字节转换"></a>64bit字节转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;                                  </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htobe16</span><span class="params">(<span class="keyword">uint16_t</span> host_16bits)</span></span>;              </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htole16</span><span class="params">(<span class="keyword">uint16_t</span> host_16bits)</span></span>;              </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">be16toh</span><span class="params">(<span class="keyword">uint16_t</span> big_endian_16bits)</span></span>;        </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">le16toh</span><span class="params">(<span class="keyword">uint16_t</span> little_endian_16bits)</span></span>;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htobe32</span><span class="params">(<span class="keyword">uint32_t</span> host_32bits)</span></span>;              </span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htole32</span><span class="params">(<span class="keyword">uint32_t</span> host_32bits)</span></span>;              </span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">be32toh</span><span class="params">(<span class="keyword">uint32_t</span> big_endian_32bits)</span></span>;        </span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">le32toh</span><span class="params">(<span class="keyword">uint32_t</span> little_endian_32bits)</span></span>;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">htobe64</span><span class="params">(<span class="keyword">uint64_t</span> host_64bits)</span></span>;              </span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">htole64</span><span class="params">(<span class="keyword">uint64_t</span> host_64bits)</span></span>;              </span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">be64toh</span><span class="params">(<span class="keyword">uint64_t</span> big_endian_64bits)</span></span>;        </span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">le64toh</span><span class="params">(<span class="keyword">uint64_t</span> little_endian_64bits)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>字节序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据压缩算法---霍夫曼编码（Huffman）</title>
    <url>/post/3506.html</url>
    <content><![CDATA[<p>霍夫曼编码是一种基于<code>最小冗余编码</code>的压缩算法。最小冗余编码是指，如果知道一组数据中符号出现的频率，就可以用一种特殊的方式来表示符号从而减少数据需要的存储空间。</p>
<ul>
<li>用较少的位对出现频率高的符号编码</li>
<li>用较多的位对出现频率低的符号编码</li>
</ul>
<p>一个符号不一定必须是文本字符，它可以是任何大小的数据，但往往它只占一个字节。</p>
<blockquote>
<p>Huffman Coding：译为哈夫曼编码、赫夫曼编码、霍夫曼编码。 是<code>可变字长编码(VLC)</code>的一种。用于<code>无损数据压缩</code>的<code>熵编码（权编码）</code>算法，是一种通过字符出现频率，根据二叉树实现。</p>
</blockquote>
<a id="more"></a>
<h2 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h2><h3 id="编码字符统计"><a href="#编码字符统计" class="headerlink" title="编码字符统计"></a>编码字符统计</h3><table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">概率</th>
<th style="text-align:center">每个实例的熵</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">U</td>
<td style="text-align:center">12/72</td>
<td style="text-align:center">2.584 963</td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">18/72</td>
<td style="text-align:center">2.000 000</td>
</tr>
<tr>
<td style="text-align:center">W</td>
<td style="text-align:center">7/72</td>
<td style="text-align:center">3.362 570</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">15/72</td>
<td style="text-align:center">2.263 034</td>
</tr>
<tr>
<td style="text-align:center">Y</td>
<td style="text-align:center">20/72</td>
<td style="text-align:center">1.847 997</td>
</tr>
</tbody>
</table>
<h4 id="熵和最小冗余"><a href="#熵和最小冗余" class="headerlink" title="熵和最小冗余"></a>熵和最小冗余</h4><p>每个数据集都有一定的信息量，这就是所谓的熵。一组数据的熵是数据中每个符号熵的总和<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sz = -lg2 Pz</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>Pz</code> 就数据集中z出现的频率</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Su = -lg2(12/72) = 2.584 963位</span><br></pre></td></tr></table></figure>
<blockquote>
<p>72个字符的字符串中，U字符最少可以使用3位表示（四舍五入）</p>
</blockquote>
<h3 id="构造霍夫曼树"><a href="#构造霍夫曼树" class="headerlink" title="构造霍夫曼树"></a>构造霍夫曼树</h3><p><img src="/images/2019/02/huffman_tree.png" alt="huffman_tree"></p>
<p><strong>出现频率越多的会越在上层，编码也越短，出现频率越少的就越在下层，编码也越长</strong></p>
<blockquote>
<p>用霍夫曼树压缩数据，给定一个具体的符号，从树的根开始，然后沿着树的叶向叶子结点追踪。在向下追踪的过程中.</p>
<ul>
<li>当向左分支移动时，向当前编码的末尾追加<code>0</code>；</li>
<li>当向右分支移动时，向当前编码的末尾追加<code>1</code></li>
</ul>
</blockquote>
<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">U</td>
<td style="text-align:center">‘101’</td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">‘01’</td>
</tr>
<tr>
<td style="text-align:center">W</td>
<td style="text-align:center">‘100’</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">‘00’</td>
</tr>
<tr>
<td style="text-align:center">Y</td>
<td style="text-align:center">‘11’</td>
</tr>
</tbody>
</table>
<h3 id="编码效率"><a href="#编码效率" class="headerlink" title="编码效率"></a>编码效率</h3><ul>
<li>不压缩数据大小：72*8=576bit</li>
<li><p>压缩后数据大小：12<em>3+18</em>2+7<em>3+15</em>2+20*2=163bit</p>
</li>
<li><p><strong>压缩比</strong>：1 - 163/576 = 71.7%</p>
</li>
</ul>
<p>在通常情况下，霍夫曼编码并不是最高效的压缩方法，但它压缩和解压缩的速度非常快。</p>
<ul>
<li>一般来说，造成霍夫曼编码比较耗时的原因是它需要<code>扫描两次数据</code>：一次用来计算频率；另一次才是用来压缩数据。</li>
<li>而解压缩数据非常高效，因为解码每个符号的序列只需要扫描一次霍夫曼树。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.jobbole.com/20091/" target="_blank" rel="noopener">霍夫曼编码压缩算法</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>编码</category>
      </categories>
      <tags>
        <tag>huffman</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化---指令预取</title>
    <url>/post/35506.html</url>
    <content><![CDATA[<p><strong>指令预取</strong>: 是指提前将所需要的数据取出来，在使用时可用。</p>
<blockquote>
<p>具体方法就是在不命中时，当数据从主存储器中取出送往CPU的同时，把主存储器相邻几个单元中的数据（称为一个数据块）都取出来送入Cache中。</p>
</blockquote>
<p>CPU在cache不命中的情况下，将从内存读取一个连续的cacheline大小数据。</p>
<ul>
<li>如果访问数据地址连续，CPU产生Cache不命中的情况少，省时</li>
<li>如果访问数据地址不连续，CPU产生的Cache不命中的情况多，耗时</li>
</ul>
<a id="more"></a>
<h2 id="示例–矩阵乘法"><a href="#示例–矩阵乘法" class="headerlink" title="示例–矩阵乘法"></a>示例–矩阵乘法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __aarch64__</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> nop asm(<span class="meta-string">"nop"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> nop</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">700</span>;</span><br><span class="line">    <span class="keyword">int</span> res[N][N], mul1[N][N], mul2[N][N];</span><br><span class="line">    <span class="keyword">clock_t</span> start, <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">long</span> time1 = <span class="number">0</span>, time2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            mul1[i][j] = (i + <span class="number">1</span>) * j;</span><br><span class="line">            mul2[i][j] = i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="comment">/* mul2的地址空间不是连续的</span></span><br><span class="line"><span class="comment">     * 初始化时mul2[0][x], 一行一行赋值，地址连续</span></span><br><span class="line"><span class="comment">     * 执行读取mul2[x][0], 一列一列读取，地址不连续*/</span></span><br><span class="line">    nop;nop;nop;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; ++k) &#123;</span><br><span class="line">                <span class="comment">// 行 x 列</span></span><br><span class="line">                res[i][j] += mul1[i][k] * mul2[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nop;nop;nop;</span><br><span class="line">    <span class="built_in">end</span> = clock();</span><br><span class="line">    time1 = <span class="built_in">end</span> - start;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Run Time1 %f s\n"</span>, (<span class="keyword">double</span>)time1 / CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp[N][N];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            mul1[i][j] = (i + <span class="number">1</span>) * j;</span><br><span class="line">            mul2[i][j] = i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="comment">// 矩阵转换，列变换（列变行）</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            tmp[i][j] = mul2[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* CPU读取连续的tmp地址时，使用指令预取（硬件）</span></span><br><span class="line"><span class="comment">     * DCache 命中效率*/</span></span><br><span class="line">    nop;nop;nop;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; ++k) &#123;</span><br><span class="line">                res[i][j] += mul1[i][k] * tmp[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nop;nop;nop;</span><br><span class="line">    <span class="built_in">end</span> = clock();</span><br><span class="line">    time2 = <span class="built_in">end</span> - start;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Run Time2 %f s\n"</span>, (<span class="keyword">double</span>)time2 / CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Time2 and Time1 upgrade %f %\n"</span>, (<span class="keyword">double</span>)(time1 - time2) / time1 * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果–arm平台</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[shell@localhost:/]$ ./prefetch</span><br><span class="line">Run Time1 5.966075 s</span><br><span class="line">Run Time2 4.530201 s</span><br><span class="line">Time2 and Time1 upgrade 24.067314 %</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码运行速度提升<code>24%</code></p>
</blockquote>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>Cache命中率</li>
<li>乘法运算与赋值运算的效率</li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>性能</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg学习笔记——颜色编码</title>
    <url>/post/49519.html</url>
    <content><![CDATA[<p>颜色编码：<code>YUV</code>、<code>RGB</code></p>
<p><img src="/images/2018/09/bt601_uv_yuv.png" alt="BT601_UV_YUV "></p>
<blockquote>
<ul>
<li>BT601 UV 的坐标图（量化后）： （横坐标为u，纵坐标为v，左下角为原点）</li>
<li><code>U越大, 蓝色越蓝</code>; <code>V越大，红色越红</code></li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h2><p>YUV，分为三个分量，<code>“Y”</code>表示明亮度（Luminance或Luma），也就是灰度值（gray）；而<code>“U”</code>和<code>“V”</code> 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>
<p><strong>作用：</strong> 主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以<code>用YUV方式传送占用极少的频宽</code>。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>YUV Formats分成两个格式：</p>
<ul>
<li><code>紧缩格式（packed formats）</code>：将Y、U、V值储存成Macro Pixels阵列，和RGB的存放方式类似, 将YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个<code>宏像素</code>（macro-pixel）。</li>
<li><code>平面格式（planar formats）</code>：将Y、U、V的三个分量分别存放在不同的矩阵中, 使用三个数组分开存放YUV三个分量，就像是一个三维平面一样。</li>
</ul>
<h3 id="采样方式"><a href="#采样方式" class="headerlink" title="采样方式"></a>采样方式</h3><p>主流的采样方式有三种，<code>YUV4:4:4</code>，<code>YUV4:2:2</code>，<code>YUV4:2:0</code></p>
<ul>
<li><code>YUV4:4:4</code>:表示完全取样。</li>
<li><code>YUV4:2:2</code>:表示2:1的水平取样，垂直完全采样。</li>
<li><code>YUV4:2:0</code>:表示2:1的水平取样，垂直2：1采样。</li>
</ul>
<p><img src="/images/2018/08/yuv_sample_way.png" alt="yuv_sample_way"></p>
<blockquote>
<ul>
<li><code>黑点</code>:表示采样该像素点的Y分量;</li>
<li><code>空心圆圈</code>:表示采用该像素点的UV分量。</li>
</ul>
</blockquote>
<ol>
<li><code>YUV 4:4:4</code>采样，每一个Y对应一组UV分量， 每个像素32bit。</li>
<li><code>YUV 4:2:2</code>采样，每两个Y共用一组UV分量， 每个像素16bit。</li>
<li><code>YUV 4:2:0</code>采样，每四个Y共用一组UV分量， 每个像素16bit。</li>
</ol>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>下面我用图的形式给出常见的YUV码流的存储方式，并在存储方式后面附有取样每个像素点的YUV数据的方法，其中，Cb、Cr的含义等同于U、V。</p>
<h4 id="YUYV格式-（属于YUV422）"><a href="#YUYV格式-（属于YUV422）" class="headerlink" title="YUYV格式 （属于YUV422）"></a>YUYV格式 （属于YUV422）</h4><blockquote>
<p>YUV 4:2:2</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start + 0:    Y&apos;00    Cb00    Y&apos;01    Cr00    Y&apos;02    Cb01    Y&apos;03    Cr01</span><br><span class="line">start + 8:    Y&apos;10    Cb10    Y&apos;11    Cr10    Y&apos;12    Cb11    Y&apos;13    Cr11</span><br><span class="line">start +16:    Y&apos;20    Cb20    Y&apos;21    Cr20    Y&apos;22    Cb21    Y&apos;23    Cr21</span><br><span class="line">start +24:    Y&apos;30    Cb30    Y&apos;31    Cr30    Y&apos;32    Cb31    Y&apos;33    Cr31</span><br></pre></td></tr></table></figure>
<p>YUYV为YUV422采样的存储格式中的一种，相邻的两个Y共用其相邻的两个Cb、Cr，分析，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00，其他的像素点的YUV取值依次类推。</p>
<h4 id="UYVY格式（属于YUV422）"><a href="#UYVY格式（属于YUV422）" class="headerlink" title="UYVY格式（属于YUV422）"></a>UYVY格式（属于YUV422）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start + 0:    Cb00    Y&apos;00    Cr00    Y&apos;01    Cb01    Y&apos;02    Cr01    Y&apos;03</span><br><span class="line">start + 8:    Cb10    Y&apos;10    Cr10    Y&apos;11    Cb11    Y&apos;12    Cr11    Y&apos;13</span><br><span class="line">start +16:    Cb20    Y&apos;20    Cr20    Y&apos;21    Cb21    Y&apos;22    Cr21    Y&apos;23</span><br><span class="line">start +24:    Cb30    Y&apos;30    Cr30    Y&apos;31    Cb31    Y&apos;32    Cr31    Y&apos;33</span><br></pre></td></tr></table></figure>
<p>每四字节代表两个像素，包含两个Y’，一个Cb和Cr。两个Y是两个像素的数据，而Cb和Cr对于两个像素来说都是一样的。如你所见，Cr和Cb部分只有相对于Y部分的一半竖向分辨率。</p>
<h4 id="YV12，YU12格式（属于YUV420）"><a href="#YV12，YU12格式（属于YUV420）" class="headerlink" title="YV12，YU12格式（属于YUV420）"></a>YV12，YU12格式（属于YUV420）</h4><blockquote>
<p>YUV4:2:0</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start + 0:    Y&apos;00    Y&apos;01    Y&apos;02    Y&apos;03</span><br><span class="line">start + 4:    Y&apos;10    Y&apos;11    Y&apos;12    Y&apos;13</span><br><span class="line">start + 8:    Y&apos;20    Y&apos;21    Y&apos;22    Y&apos;23</span><br><span class="line">start +12:    Y&apos;30    Y&apos;31    Y&apos;32    Y&apos;33</span><br><span class="line">start +16:    Cr00    Cr01</span><br><span class="line">start +18:    Cr10    Cr11</span><br><span class="line">start +20:    Cb00    Cb01</span><br><span class="line">start +22:    Cb10    Cb11</span><br></pre></td></tr></table></figure>
<p>YU12和YV12属于YUV420格式，也是一种Plane模式，将Y、U、V分量分别打包，依次存储。其每一个像素点的YUV数据提取遵循YUV420格式的提取方式，即4个Y分量共用一组UV。注意，上图中，Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00，其他依次类推。</p>
<h4 id="NV12、NV21格式（属于YUV420）"><a href="#NV12、NV21格式（属于YUV420）" class="headerlink" title="NV12、NV21格式（属于YUV420）"></a>NV12、NV21格式（属于YUV420）</h4><blockquote>
<p>YUV4:2:0</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start + 0:    Y&apos;00    Y&apos;01    Y&apos;02    Y&apos;03</span><br><span class="line">start + 4:    Y&apos;10    Y&apos;11    Y&apos;12    Y&apos;13</span><br><span class="line">start + 8:    Y&apos;20    Y&apos;21    Y&apos;22    Y&apos;23</span><br><span class="line">start +12:    Y&apos;30    Y&apos;31    Y&apos;32    Y&apos;33</span><br><span class="line">start +16:    Cb00    Cr00    Cb01    Cr01</span><br><span class="line">start +20:    Cb10    Cr10    Cb11    Cr11</span><br></pre></td></tr></table></figure>
<p>NV12和NV21属于YUV420格式，是一种two-plane模式，即Y和UV分为两个Plane，但是UV（CbCr）为交错存储，而不是分为三个plane。其提取方式与上一种类似，即Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00</p>
<h3 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h3><p>假设，图片大小：<code>w</code>，<code>h</code></p>
<blockquote>
<p>这里的<code>w</code>和<code>h</code>，代表的是<code>y</code>在整个编码中的个数</p>
</blockquote>
<h4 id="YUV420"><a href="#YUV420" class="headerlink" title="YUV420"></a>YUV420</h4><blockquote>
<ul>
<li>Y = w * h</li>
<li>UV = (w * h)/2</li>
<li>所占内存：YUV = Y + UV = (w <em> h </em> 3) / 2</li>
</ul>
</blockquote>
<h4 id="YUV422"><a href="#YUV422" class="headerlink" title="YUV422"></a>YUV422</h4><blockquote>
<ul>
<li>所占内存：YUV = (w <em> h) </em> 2</li>
</ul>
</blockquote>
<h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p><code>RGB：</code> 三原色光模式（RGB color model），又称RGB颜色模型或红绿蓝颜色模型，是一种<code>加色模型</code>，将<code>红（Red）</code>、<code>绿（Green）</code>、<code>蓝（Blue）</code>三原色的色光以不同的比例相加，以产生多种多样的色光。(且三原色的红绿蓝不可能用其他单色光合成)</p>
<p><img src="/images/2018/08/rgb.png" alt="rgb"></p>
<blockquote>
<p>三原色光的相加：<code>红光加绿光为黄光</code>，<code>黄光加蓝光为白光</code></p>
</blockquote>
<h3 id="RGB颜色查询对照表"><a href="#RGB颜色查询对照表" class="headerlink" title="RGB颜色查询对照表"></a>RGB颜色查询对照表</h3><ul>
<li><a href="http://www.114la.com/other/rgb.htm" target="_blank" rel="noopener">RGB颜色查询对照表</a></li>
</ul>
<h3 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h3><ul>
<li><code>RGB565</code>: 每个像素用16位表示，RGB分量分别使用5位、6位、5位</li>
<li><code>RGB555</code>: 每个像素用16位表示，RGB分量都使用5位（剩下1位不用）</li>
<li><code>RGB24</code>: 每个像素用24位表示，RGB分量各使用8位</li>
<li><code>RGB32</code>: 每个像素用32位表示，RGB分量各使用8位（剩下8位不用）</li>
<li><code>ARGB32</code>: 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）</li>
</ul>
<h3 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h3><h4 id="RGB565"><a href="#RGB565" class="headerlink" title="RGB565"></a>RGB565</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">high                         low</span><br><span class="line">7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0</span><br><span class="line">R R R R R G G G  G G G B B B B B</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RGB565_MASK_RED    0xF800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RGB565_MASK_GREEN  0x07E0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RGB565_MASK_BLUE   0x001F</span></span><br><span class="line"></span><br><span class="line">R = (wPixel &amp; RGB565_MASK_RED) &gt;&gt; <span class="number">11</span>;   <span class="comment">// 取值范围0-31</span></span><br><span class="line">G = (wPixel &amp; RGB565_MASK_GREEN) &gt;&gt; <span class="number">5</span>;  <span class="comment">// 取值范围0-63</span></span><br><span class="line">B =  wPixel &amp; RGB565_MASK_BLUE;         <span class="comment">// 取值范围0-31</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RGB(r,g,b) (unsigned int)( (r|0x08 &lt;&lt; 10) | (g|0x08 &lt;&lt; 5) | b|0x08 )</span></span><br></pre></td></tr></table></figure>
<h4 id="RGB555"><a href="#RGB555" class="headerlink" title="RGB555"></a>RGB555</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X R R R R R G G  G G G B B B B B</span><br></pre></td></tr></table></figure>
<h3 id="RGB24"><a href="#RGB24" class="headerlink" title="RGB24"></a>RGB24</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rgb24</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> rgbtBlue;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> rgbtGreen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> rgbtRed;</span><br><span class="line">&#125; RGB;</span><br></pre></td></tr></table></figure>
<h3 id="RGB32"><a href="#RGB32" class="headerlink" title="RGB32"></a>RGB32</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rgb32</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> rgbBlue;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> rgbGreen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> rgbRed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> rgbReserved;</span><br><span class="line">&#125; RGB；</span><br></pre></td></tr></table></figure>
<h2 id="YUV模型和RGB模型的关系"><a href="#YUV模型和RGB模型的关系" class="headerlink" title="YUV模型和RGB模型的关系"></a>YUV模型和RGB模型的关系</h2><p>YUV色彩模型来源于RGB模型，该模型的特点是将<code>亮度</code>和<code>色度</code>分离开，从而适合于图像处理领域。</p>
<ol>
<li><p>应用——模拟领域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y&apos;= 0.299*R&apos; + 0.587*G&apos; + 0.114*B&apos;</span><br><span class="line">U&apos;= -0.147*R&apos; - 0.289*G&apos; + 0.436*B&apos; = 0.492*(B&apos;- Y&apos;)</span><br><span class="line">V&apos;= 0.615*R&apos; - 0.515*G&apos; - 0.100*B&apos; = 0.877*(R&apos;- Y&apos;)</span><br><span class="line">R&apos; = Y&apos; + 1.140*V&apos;</span><br><span class="line">G&apos; = Y&apos; - 0.394*U&apos; - 0.581*V&apos;</span><br><span class="line">B&apos; = Y&apos; + 2.032*U&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用——数字领域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y’ = 0.257*R&apos; + 0.504*G&apos; + 0.098*B&apos; + 16</span><br><span class="line">Cb&apos; = -0.148*R&apos; - 0.291*G&apos; + 0.439*B&apos; + 128</span><br><span class="line">Cr&apos; = 0.439*R&apos; - 0.368*G&apos; - 0.071*B&apos; + 128</span><br><span class="line">R&apos; = 1.164*(Y’-16) + 1.596*(Cr&apos;-128)</span><br><span class="line">G&apos; = 1.164*(Y’-16) - 0.813*(Cr&apos;-128) - 0.392*(Cb&apos;-128)</span><br><span class="line">B&apos; = 1.164*(Y’-16) + 2.017*(Cb&apos;-128)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>YCbCr模型来源于YUV模型。YCbCr是 YUV 颜色空间的偏移版本.</p>
<blockquote>
<p>上面各个符号都带了一撇，表示该符号在原值基础上进行了<code>伽马校正</code>,伽马校正有助于弥补在抗锯齿的过程中，线性分配伽马值所带来的细节损失，使图像细节更加丰富。在没有采用伽马校正的情况下，暗部细节不容易显现出来，而采用了这一图像增强技术以后，图像的层次更加明晰了。所以说<code>H264</code>里面的YUV应属于<code>YCbCr</code>.</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/airk000/article/details/25032901" target="_blank" rel="noopener">V4L2文档翻译（十）</a></li>
<li><a href="https://www.cnblogs.com/luoyinjie/p/7219319.html" target="_blank" rel="noopener">YUV与RGB互转各种公式</a></li>
<li><a href="https://www.jianshu.com/p/e498326a55b1" target="_blank" rel="noopener">运用NEON指令集加速RGB与YUV相互转换</a></li>
</ul>
]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>repo服务器的搭建测试</title>
    <url>/post/44256.html</url>
    <content><![CDATA[<p><code>repo</code>的作用就是进行多个git仓库的统一管理，其实repo就是一个python的脚本，这里测试repo服务的搭建和使用</p>
<a id="more"></a>
<h2 id="下载repo"><a href="#下载repo" class="headerlink" title="下载repo"></a>下载repo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://review.mfunz.com/git-repo git-repo-core.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>服务端</code>和<code>客户端</code></p>
<ul>
<li>服务端： <code>git-repo-core</code></li>
<li>客户端： <code>git-repo-core/repo</code></li>
</ul>
</blockquote>
<ol>
<li>进入<code>git-repo-core</code>将<code>repo</code>拷贝到客户端或本地的<code>/user/bin/</code>下（或者自定义的目录下使用时通过绝对路径）</li>
<li>指定拷贝后客户端使用的<code>repo</code>中的<code>REPO_URL</code>变量为<code>git-repo-core</code>的路径（服务器将是IP:path）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPO_URL = &apos;/home/xxx/test/repo-test/server/git-repo-core.git&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>edit: <code>vi client/repo</code></p>
</blockquote>
<ol start="3">
<li>测试目录结构<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$tree -L 2</span><br><span class="line">.</span><br><span class="line">├── client</span><br><span class="line">│   └── repo</span><br><span class="line">└── server</span><br><span class="line">    └── git-repo-core.git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>pwd:<code>/home/xxx/test/repo-test</code></p>
</blockquote>
<h2 id="repo服务器"><a href="#repo服务器" class="headerlink" title="repo服务器"></a>repo服务器</h2><h3 id="新建manifest仓库"><a href="#新建manifest仓库" class="headerlink" title="新建manifest仓库"></a>新建manifest仓库</h3><p>在server目录下创建<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p repos/manifest</span><br></pre></td></tr></table></figure></p>
<p>在manifest目录下添加<code>default.xml</code>文件。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">remote</span> <span class="attr">name</span>=<span class="string">"origin"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">fetch</span>=<span class="string">"/home/xxx/test/repo-test/server/repos"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">default</span> <span class="attr">remote</span>=<span class="string">"origin"</span> <span class="attr">revision</span>=<span class="string">"master"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"test1"</span> <span class="attr">path</span>=<span class="string">"test1"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"test2"</span> <span class="attr">path</span>=<span class="string">"test2"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"test3"</span> <span class="attr">path</span>=<span class="string">"tst333"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>file: default.xml</p>
</blockquote>
<h4 id="xml文件语法"><a href="#xml文件语法" class="headerlink" title="xml文件语法"></a>xml文件语法</h4><ul>
<li><p><code>remote</code>: 设置服务器端的路径和名称</p>
<ul>
<li><code>name</code>: 服务器端名称</li>
<li><code>fetch</code>：指repo仓库服务器端所在的位置，可以是远程，也可以是本地，测试使用本地<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin	/home/xxx/test/repo-test/server/repos/test1 (fetch)</span><br><span class="line">origin	/home/xxx/test/repo-test/server/repos/test1 (push)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>default</code>: 设置服务器端名和分支名</p>
<ul>
<li><code>remote</code>: 服务器端名称（与<code>remote</code>中的name相同）</li>
<li><code>revision</code>: 分支名</li>
<li><code>sync-j</code>： 指定在sync操作时的线程数，（sync-j=”4”）</li>
</ul>
</li>
<li><code>project</code>: 设置repo管理的git仓库<ul>
<li><code>name</code>： git仓库服务端（远端）的名字</li>
<li><code>path</code>： clone到本地的名字</li>
<li><code>revision</code>： 指定需要获取的git提交点，可以定义成固定的branch，或者是明确的commit哈希值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project name=&quot;test1&quot; path=&quot;test1&quot; revision=&quot;088216c4e32e&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="manifest文件格式"><a href="#manifest文件格式" class="headerlink" title="manifest文件格式"></a>manifest文件格式</h4><ul>
<li><copyfile>标签</copyfile></li>
</ul>
<blockquote>
<p>可以作为<project>标签的子标签，每一个<copyfile>标签表明了在repo sync的时候从src把文件拷贝到dest。 src相对于该project来说，dest相对于根目录来说。</copyfile></project></p>
</blockquote>
<ul>
<li><linkfile>标签</linkfile></li>
</ul>
<blockquote>
<p>和<copyfile>标签的作用类似，不过是不进行拷贝，而是进行一个符号链接</copyfile></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-       &lt;project name=&quot;tools&quot; path=&quot;tools&quot;/&gt;</span><br><span class="line">+       &lt;project name=&quot;tools&quot; path=&quot;tools&quot;&gt;</span><br><span class="line">+               &lt;linkfile dest=&quot;envsetup.sh&quot; src=&quot;envsetup.sh&quot;/&gt;</span><br><span class="line">+       &lt;/project&gt;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>
<ul>
<li><include>标签</include></li>
</ul>
<blockquote>
<p>用来引入一个其他的manifest,有一个name属性指向被引用的manifest, 路径是相对于mamanifest库的根目录</p>
</blockquote>
<h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><ol>
<li><p>进入<code>manifest</code>目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"init manifest"</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回<code>manifest</code>上一级目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> --bare manifest</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建完成<code>manifest.git</code>仓库后，<code>manifest</code>可以删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[xxx@xxx-pc]~/test/repo-test/server/repos</span><br><span class="line">=====&gt;$ls</span><br><span class="line">manifest manifest.git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="新建test1和test2仓库"><a href="#新建test1和test2仓库" class="headerlink" title="新建test1和test2仓库"></a>新建test1和test2仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir test1 test2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> test1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> test1 &gt; readme.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"init test1"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> --bare test1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>test2</code>仓库以相同的步骤建立</p>
</blockquote>
<ul>
<li>结果：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[xxx@xxx-pc]~/test/repo-test/server/repos</span><br><span class="line">=====&gt;$ls</span><br><span class="line">manifest  manifest.git  test1  test1.git  test2  test2.git  test3  test3.git</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="repo测试"><a href="#repo测试" class="headerlink" title="repo测试"></a>repo测试</h2><p>进入client目录</p>
<h3 id="初始化-repo-init"><a href="#初始化-repo-init" class="headerlink" title="初始化 repo init"></a>初始化 repo init</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./repo init -u /home/xxx/<span class="built_in">test</span>/repo-test/server/repos/manifest.git</span></span><br><span class="line">Get /home/xxx/test/repo-test/server/git-repo-core.git</span><br><span class="line">remote: Counting objects: 4050, done.</span><br><span class="line">remote: Compressing objects: 100% (1844/1844), done.</span><br><span class="line">remote: Total 4050 (delta 2144), reused 4050 (delta 2144)</span><br><span class="line">Receiving objects: 100% (4050/4050), 3.45 MiB | 31.58 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (2144/2144), done.</span><br><span class="line">From /home/xxx/test/repo-test/server/git-repo-core</span><br><span class="line"> * [new branch]      stable     -&gt; origin/stable</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line"> ...</span><br><span class="line"> * [new tag]         v1.9.4     -&gt; v1.9.4</span><br><span class="line"> * [new tag]         v1.9.5     -&gt; v1.9.5</span><br><span class="line"> * [new tag]         v1.9.6     -&gt; v1.9.6</span><br><span class="line">Get /home/xxx/test/repo-test/server/repos/manifest.git</span><br><span class="line">remote: Counting objects: 9, done.</span><br><span class="line">remote: Compressing objects: 100% (6/6), done.</span><br><span class="line">remote: Total 9 (delta 2), reused 0 (delta 0)</span><br><span class="line">From /home/xxx/test/repo-test/server/repos/manifest</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line"></span><br><span class="line">Your identity is: xxx &lt;xxx@xx.com&gt;</span><br><span class="line">If you want to change this, please re-run 'repo init' with --config-name</span><br><span class="line"></span><br><span class="line">repo has been initialized in /home/xxx/test/repo-test/client</span><br></pre></td></tr></table></figure>
<h3 id="同步代码-repo-sync"><a href="#同步代码-repo-sync" class="headerlink" title="同步代码 repo sync"></a>同步代码 repo sync</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./repo sync</span></span><br><span class="line">Fetching project test2</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">From /home/xxx/test/repo-test/server/repos/test2</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line">Fetching project test1</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">From /home/xxx/test/repo-test/server/repos/test1</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br></pre></td></tr></table></figure>
<ul>
<li>下载目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ls</span><br><span class="line">repo  test1  test2  tst333</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="遍历repo每个仓库并执行相同代码-repo-forall"><a href="#遍历repo每个仓库并执行相同代码-repo-forall" class="headerlink" title="遍历repo每个仓库并执行相同代码 repo forall"></a>遍历repo每个仓库并执行相同代码 repo forall</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./repo forall -h</span><br><span class="line">Usage: repo forall [&lt;project&gt;...] -c &lt;command&gt; [&lt;arg&gt;...]</span><br><span class="line">repo forall -r str1 [str2] ... -c &lt;command&gt; [&lt;arg&gt;...]"</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r, --regex           Execute the command only on projects matching regex or</span><br><span class="line">                        wildcard expression</span><br><span class="line">  -i, --inverse-regex   Execute the command only on projects not matching</span><br><span class="line">                        regex or wildcard expression</span><br><span class="line">  -g GROUPS, --groups=GROUPS</span><br><span class="line">                        Execute the command only on projects matching the</span><br><span class="line">                        specified groups</span><br><span class="line">  -c, --command         Command (and arguments) to execute</span><br><span class="line">  -e, --abort-on-errors</span><br><span class="line">                        Abort if a command exits unsuccessfully</span><br><span class="line"></span><br><span class="line">  Output:</span><br><span class="line">    -p                  Show project headers before output</span><br><span class="line">    -v, --verbose       Show command error messages</span><br><span class="line">    -j JOBS, --jobs=JOBS</span><br><span class="line">                        number of commands to execute simultaneously</span><br></pre></td></tr></table></figure>
<ul>
<li>示例<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$./repo forall -c "git log"</span><br><span class="line">commit 088216c4e32e0257ec23f2ac61c87866f8e8dd98 (HEAD, origin/master, m/master)</span><br><span class="line">Author: xxx &lt;xxx@xx.com&gt;</span><br><span class="line">Date:   Thu Oct 11 20:04:17 2018 +0800</span><br><span class="line"></span><br><span class="line">    init test1</span><br><span class="line">commit c150415858ffbdfa7c010d35d66b6282cd7b3cbe (HEAD, origin/master, m/master)</span><br><span class="line">Author: xxx &lt;xxx@xx.com&gt;</span><br><span class="line">Date:   Thu Oct 11 20:05:19 2018 +0800</span><br><span class="line"></span><br><span class="line">    init test2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="repo支持命令"><a href="#repo支持命令" class="headerlink" title="repo支持命令"></a>repo支持命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./repo --trace</span></span><br><span class="line">usage: repo COMMAND [ARGS]</span><br><span class="line">The most commonly used repo commands are:</span><br><span class="line">  abandon        Permanently abandon a development branch</span><br><span class="line">  branch         View current topic branches</span><br><span class="line">  branches       View current topic branches</span><br><span class="line">  checkout       Checkout a branch for development</span><br><span class="line">  cherry-pick    Cherry-pick a change.</span><br><span class="line">  diff           Show changes between commit and working tree</span><br><span class="line">  diffmanifests  Manifest diff utility</span><br><span class="line">  download       Download and checkout a change</span><br><span class="line">  grep           Print lines matching a pattern</span><br><span class="line">  info           Get info on the manifest branch, current branch or unmerged branches</span><br><span class="line">  init           Initialize repo in the current directory</span><br><span class="line">  list           List projects and their associated directories</span><br><span class="line">  overview       Display overview of unmerged project branches</span><br><span class="line">  prune          Prune (delete) already merged topics</span><br><span class="line">  rebase         Rebase local branches on upstream branch</span><br><span class="line">  smartsync      Update working tree to the latest known good revision</span><br><span class="line">  stage          Stage file(s) for commit</span><br><span class="line">  start          Start a new branch for development</span><br><span class="line">  status         Show the working tree status</span><br><span class="line">  sync           Update working tree to the latest revision</span><br><span class="line">  upload         Upload changes for code review</span><br><span class="line">See 'repo help &lt;command&gt;' for more information on a specific command.</span><br><span class="line">See 'repo help --all' for a complete list of recognized commands.</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.360doc.com/content/15/0122/22/426085_442956619.shtml" target="_blank" rel="noopener">本地/远程搭建repo</a></li>
<li><a href="https://blog.csdn.net/eastmoon502136/article/details/72598297" target="_blank" rel="noopener">简易repo服务器搭建</a></li>
<li><a href="https://www.jianshu.com/p/d40444267e8d" target="_blank" rel="noopener">repo manifest文件格式说明</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>repo</tag>
      </tags>
  </entry>
  <entry>
    <title>RTCP协议</title>
    <url>/post/32277.html</url>
    <content><![CDATA[<blockquote>
<p>Real-time Transport Control Protocol或RTP Control Protocol或简写RTCP）是实时传输协议（RTP）的一个姐妹协议。RTCP由<a href="https://tools.ietf.org/html/rfc3550" target="_blank" rel="noopener">RFC 3550</a>定义（取代作废的RFC 1889）。RTP 使用一个 偶数 UDP port ；而RTCP 则使用 RTP 的下一个 port，也就是一个奇数 port。RTCP与RTP联合工作，RTP实施实际数据的传输，RTCP则负责将控制包送至电话中的每个人。其主要功能是就RTP正在提供的服务质量(Quality of Service)做出反馈。</p>
</blockquote>
<p>RTCP协议将控制包周期发送给所有连接者，应用与数据包相同的分布机制。低层协议提供数据与控制包的复用，如使用单独的UDP端口号。</p>
<p>作用:</p>
<ul>
<li>主要是提供数据发布的质量反馈</li>
<li>RTCP带有称作规范名字（CNAME）的RTP源持久传输层标识</li>
<li>传送最小连接控制信息，如参加者辨识</li>
</ul>
<a id="more"></a>
<h2 id="RTCP分类"><a href="#RTCP分类" class="headerlink" title="RTCP分类"></a>RTCP分类</h2><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">缩写</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:center">SR（Sender Report）</td>
<td style="text-align:center">发送端报告</td>
</tr>
<tr>
<td style="text-align:center">201</td>
<td style="text-align:center">RR（Receiver Report）</td>
<td style="text-align:center">接收端报告</td>
</tr>
<tr>
<td style="text-align:center">202</td>
<td style="text-align:center">SDES（Source Description Items）</td>
<td style="text-align:center">源点描述</td>
</tr>
<tr>
<td style="text-align:center">203</td>
<td style="text-align:center">BYE</td>
<td style="text-align:center">结束传输</td>
</tr>
<tr>
<td style="text-align:center">204</td>
<td style="text-align:center">APP</td>
<td style="text-align:center">特定应用</td>
</tr>
</tbody>
</table>
<h3 id="RTCP的扩展"><a href="#RTCP的扩展" class="headerlink" title="RTCP的扩展"></a>RTCP的扩展</h3><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">缩写</th>
<th style="text-align:center">用途</th>
<th style="text-align:center">所在RFC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">195</td>
<td style="text-align:center">1J(Extended Jitter Report)</td>
<td style="text-align:center">扩展Jitter报告</td>
<td style="text-align:center">RFC 5450</td>
</tr>
<tr>
<td style="text-align:center">205</td>
<td style="text-align:center">RTPFB(Transport FB)</td>
<td style="text-align:center">传输层反馈</td>
<td style="text-align:center"><a href="https://tools.ietf.org/html/rfc4585" target="_blank" rel="noopener">RFC 4585</a></td>
</tr>
<tr>
<td style="text-align:center">206</td>
<td style="text-align:center">PSFB(Payload-specific FB)</td>
<td style="text-align:center">负载相关反馈</td>
<td style="text-align:center">RFC 5104</td>
</tr>
<tr>
<td style="text-align:center">207</td>
<td style="text-align:center">XR(Exteneded Report)</td>
<td style="text-align:center">扩展报告</td>
<td style="text-align:center">RFC 3611</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>FB: Feedback(反馈)</li>
</ul>
</blockquote>
<h2 id="反馈报文"><a href="#反馈报文" class="headerlink" title="反馈报文"></a>反馈报文</h2><p>类型:</p>
<ul>
<li>Transport layer FB messages</li>
<li>Payload-specific FB messages</li>
<li>Application layer FB messages</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |V=2|P|   FMT   |       PT      |          length               |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |                  SSRC of packet sender                        |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |                  SSRC of media source                         |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> :            Feedback Control Information (FCI)                 :</span><br><span class="line"> :                                                               :</span><br></pre></td></tr></table></figure>
<ul>
<li>version(V), 2bits : 标识当前RTP版本2</li>
<li>padding(P), 1bit : 填充位标识</li>
<li>Feedback message type(FMT), 5bits : 标识反馈消息的类型</li>
<li>Payload type (PT), 8 bits : rtcp包的类型</li>
<li>Length, 16 bits :</li>
</ul>
<h3 id="FMT报文子类型"><a href="#FMT报文子类型" class="headerlink" title="FMT报文子类型"></a>FMT报文子类型</h3><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">子类型</th>
<th style="text-align:center">缩写</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">205</td>
<td style="text-align:center">1</td>
<td style="text-align:center">Generic NACK</td>
<td style="text-align:center">RTP丢包重传</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">3</td>
<td style="text-align:center">TMMBR</td>
<td style="text-align:center">Temporary Maximum Media Stream Bitrate Request</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">4</td>
<td style="text-align:center">TMMBN</td>
<td style="text-align:center">Temporary Maximum Media Stream Bitrate Notification</td>
</tr>
<tr>
<td style="text-align:center">206</td>
<td style="text-align:center">1</td>
<td style="text-align:center">PLI</td>
<td style="text-align:center">Picture Loss Indication</td>
</tr>
</tbody>
</table>
<h3 id="Generic-NACK"><a href="#Generic-NACK" class="headerlink" title="Generic NACK"></a>Generic NACK</h3><blockquote>
<p>The Generic NACK message is identified by <code>PT=RTPFB</code> and <code>FMT=1</code>.</p>
</blockquote>
<p>消息语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |            PID                |             BLP               |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p>
<ul>
<li>PID: Packet ID (PID): 16 bits<ul>
<li>丢失RTP包的ID</li>
</ul>
</li>
<li>BLP:  bitmask of following lost packets (BLP): 16 bits<ul>
<li>从PID开始接下来16个RTP数据包的丢失情况,一个NACK报文可以携带多个RTP序列号，NACK接收端对这些序列号逐个处理。</li>
</ul>
</li>
</ul>
<h2 id="丢包重传"><a href="#丢包重传" class="headerlink" title="丢包重传"></a>丢包重传</h2><p>如果在接收端检查到出现丢包现象,通过RTCP发送丢包ID接可以让丢包重传.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RequestLostPacket</span><span class="params">(<span class="keyword">rtp_t</span> *rtp, <span class="keyword">unsigned</span> <span class="keyword">int</span> rtpSsrc, <span class="keyword">int</span> seqNo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> FB_msg_packet[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> srcId = rtpSsrc;</span><br><span class="line">    <span class="keyword">int</span> blp = <span class="number">0</span>; <span class="comment">//表示一个只处理一个丢包</span></span><br><span class="line"></span><br><span class="line">    FB_msg_packet[<span class="number">0</span>] = <span class="number">0x80</span> | <span class="number">1</span>;  <span class="comment">// version=2, Generic NACK</span></span><br><span class="line">    FB_msg_packet[<span class="number">1</span>] = <span class="number">205</span>;       <span class="comment">// RTPFB</span></span><br><span class="line">    FB_msg_packet[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">3</span>] = <span class="number">3</span>;         <span class="comment">//length = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SSRC of packet sender</span></span><br><span class="line">    FB_msg_packet[<span class="number">4</span>] = <span class="number">0xde</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">5</span>] = <span class="number">0xad</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">6</span>] = <span class="number">0xbe</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">7</span>] = <span class="number">0xef</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SSRC of media source</span></span><br><span class="line">    FB_msg_packet[<span class="number">8</span>] = (srcId &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">9</span>] = (srcId &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">10</span>] = (srcId &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">11</span>] = (srcId &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lost packet ID</span></span><br><span class="line">    FB_msg_packet[<span class="number">12</span>] = (seqNo &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">13</span>] = (seqNo &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BLP</span></span><br><span class="line">    FB_msg_packet[<span class="number">14</span>] = (blp &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">15</span>] = (blp &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    net_session_write(&amp;rtp-&gt;rtcp_net, FB_msg_packet, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他格式"><a href="#其他格式" class="headerlink" title="其他格式"></a>其他格式</h2><h3 id="SR-Sender-Report-RTCP-Packet"><a href="#SR-Sender-Report-RTCP-Packet" class="headerlink" title="SR: Sender Report RTCP Packet"></a>SR: Sender Report RTCP Packet</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">header |V=2|P|    RC   |   PT=SR=200   |             length            |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                         SSRC of sender                        |</span><br><span class="line">       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">sender |              NTP timestamp, most significant word             |</span><br><span class="line">info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |             NTP timestamp, least significant word             |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                         RTP timestamp                         |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                     sender&apos;s packet count                     |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                      sender&apos;s octet count                     |</span><br><span class="line">       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">report |                 SSRC_1 (SSRC of first source)                 |</span><br><span class="line">block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  1    | fraction lost |       cumulative number of packets lost       |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |           extended highest sequence number received           |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                      interarrival jitter                      |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                         last SR (LSR)                         |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                   delay since last SR (DLSR)                  |</span><br><span class="line">       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">report |                 SSRC_2 (SSRC of second source)                |</span><br><span class="line">block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  2    :                               ...                             :</span><br><span class="line">       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">       |                  profile-specific extensions                  |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h3 id="RR-Receiver-Report-RTCP-Packet"><a href="#RR-Receiver-Report-RTCP-Packet" class="headerlink" title="RR: Receiver Report RTCP Packet"></a>RR: Receiver Report RTCP Packet</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">header |V=2|P|    RC   |   PT=RR=201   |             length            |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                     SSRC of packet sender                     |</span><br><span class="line">     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">report |                 SSRC_1 (SSRC of first source)                 |</span><br><span class="line">block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">1    | fraction lost |       cumulative number of packets lost       |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |           extended highest sequence number received           |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                      interarrival jitter                      |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                         last SR (LSR)                         |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                   delay since last SR (DLSR)                  |</span><br><span class="line">     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">report |                 SSRC_2 (SSRC of second source)                |</span><br><span class="line">block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">2    :                               ...                             :</span><br><span class="line">     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">     |                  profile-specific extensions                  |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>传输</category>
      </categories>
      <tags>
        <tag>rtcp</tag>
      </tags>
  </entry>
  <entry>
    <title>proc文件系统解析--进程</title>
    <url>/post/30680.html</url>
    <content><![CDATA[<p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p>
<blockquote>
<p>所有说明均可通过<code>man proc</code>获取</p>
</blockquote>
<a id="more"></a>
<p>系统环境：<code>arm64bit</code>， <code>Linux4.4.70</code></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li>测试进程<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps</span></span><br><span class="line">...</span><br><span class="line">570 root      2728 S    top</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ls -ls</span></span><br><span class="line">    0 dr-xr-xr-x    2 root     root             0 Jan  1 04:14 attr</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 auxv</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 cgroup</span><br><span class="line">    0 --w-------    1 root     root             0 Jan  1 04:14 clear_refs</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 03:31 cmdline</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 comm</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 coredump_filter</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 cpuset</span><br><span class="line">    0 lrwxrwxrwx    1 root     root             0 Jan  1 04:14 cwd -&gt; /proc</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 environ</span><br><span class="line">    0 lrwxrwxrwx    1 root     root             0 Jan  1 04:14 exe -&gt; /bin/busybox</span><br><span class="line">    0 dr-x------    2 root     root             0 Jan  1 04:14 fd</span><br><span class="line">    0 dr-x------    2 root     root             0 Jan  1 04:14 fdinfo</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 gid_map</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 limits</span><br><span class="line">    0 dr-x------    2 root     root             0 Jan  1 04:14 map_files</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 maps</span><br><span class="line">    0 -rw-------    1 root     root             0 Jan  1 04:14 mem</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 mountinfo</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 mounts</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 mountstats</span><br><span class="line">    0 dr-xr-xr-x   10 root     root             0 Jan  1 04:14 net</span><br><span class="line">    0 dr-x--x--x    2 root     root             0 Jan  1 04:14 ns</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 oom_adj</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 oom_score</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 oom_score_adj</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 pagemap</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 personality</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 projid_map</span><br><span class="line">    0 lrwxrwxrwx    1 root     root             0 Jan  1 04:14 root -&gt; /</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 sched</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 schedstat</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 setgroups</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 smaps</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 stack</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 03:31 stat</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 statm</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 status</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 syscall</span><br><span class="line">    0 dr-xr-xr-x    3 root     root             0 Jan  1 04:14 task</span><br><span class="line">    0 -rw-rw-rw-    1 root     root             0 Jan  1 04:14 timerslack_ns</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 uid_map</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 wchan</span><br></pre></td></tr></table></figure>
<h2 id="进程目录"><a href="#进程目录" class="headerlink" title="进程目录"></a>进程目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls /proc/570/</span></span><br><span class="line">attr             fd               ns               smaps</span><br><span class="line">auxv             fdinfo           oom_adj          stack</span><br><span class="line">cgroup           gid_map          oom_score        stat</span><br><span class="line">clear_refs       limits           oom_score_adj    statm</span><br><span class="line">cmdline          map_files        pagemap          status</span><br><span class="line">comm             maps             personality      syscall</span><br><span class="line">coredump_filter  mem              projid_map       task</span><br><span class="line">cpuset           mountinfo        root             timerslack_ns</span><br><span class="line">cwd              mounts           sched            uid_map</span><br><span class="line">environ          mountstats       schedstat        wchan</span><br><span class="line">exe              net              setgroups</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cmdline</td>
<td style="text-align:left">启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息</td>
</tr>
<tr>
<td style="text-align:center">cwd</td>
<td style="text-align:left">指向当前进程运行目录的一个符号链接</td>
</tr>
<tr>
<td style="text-align:center">exe</td>
<td style="text-align:left">指向启动当前进程的可执行文件（完整路径）的符号链接</td>
</tr>
<tr>
<td style="text-align:center">fd</td>
<td style="text-align:left">指向启动当前进程的可执行文件（完整路径）的符号链接</td>
</tr>
<tr>
<td style="text-align:center">limits</td>
<td style="text-align:left">当前进程所使用的每一个受限资源的软限制、硬限制和管理单元；此文件仅可由实际启动当前进程的UID用户读取；</td>
</tr>
<tr>
<td style="text-align:center">maps</td>
<td style="text-align:left">当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表；</td>
</tr>
<tr>
<td style="text-align:center">mem</td>
<td style="text-align:left">当前进程所占用的内存空间，由open、read和lseek等系统调用使用，不能被用户读取；</td>
</tr>
<tr>
<td style="text-align:center">root</td>
<td style="text-align:left">指向当前进程运行根目录的符号链接；在Unix和Linux系统上，通常采用chroot命令使每个进程运行于独立的根目录；</td>
</tr>
<tr>
<td style="text-align:center">stat</td>
<td style="text-align:left">当前进程的状态信息，包含一系统格式化后的数据列，可读性差，通常由ps命令使用；</td>
</tr>
<tr>
<td style="text-align:center">statm</td>
<td style="text-align:left">当前进程占用内存的状态信息，通常以“页面”（page）表示；</td>
</tr>
<tr>
<td style="text-align:center">status</td>
<td style="text-align:left">与stat所提供信息类似，但可读性较好</td>
</tr>
<tr>
<td style="text-align:center">task</td>
<td style="text-align:left">包含由当前进程所运行的每一个线程的相关信息，每个<code>线程</code>的相关信息文件均保存在一个由线程号（tid）命名的目录中，这类似于其内容类似于每个进程目录中的内容</td>
</tr>
</tbody>
</table>
<h3 id="proc-PID-stat"><a href="#proc-PID-stat" class="headerlink" title="/proc/[PID]/stat"></a>/proc/[PID]/stat</h3><blockquote>
<p>包含了所有CPU活跃的信息，该文件中的所有值都是<code>从系统启动开始累计到当前时刻</code>。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">cat /proc/570/<span class="built_in">stat</span></span></span><br><span class="line">570 (top) S 565 570 565 34817 570 4210688 110 0 0 0 209 648 0 0 20 0 1 0 1266675 2793472 111 18446744073709551615 4194304 4867856 548828687344 548828686432 548186418324 0 0 0 58751527 1 0 0 17 3 0 0 0 0 0 4933392 4937189 1042927616 548828688219 548828688223 548828688223 548828688363 0</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:left">表示</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">pid=570</td>
<td style="text-align:left">进程(包括轻量级进程，即线程)号</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">comm=top</td>
<td style="text-align:left">应用程序或命令的名字</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">task_state=R</td>
<td style="text-align:left">任务的状态，R:runnign, S:sleeping (TASK_INTERRUPTIBLE), D:disk sleep (TASK_UNINTERRUPTIBLE), T: stopped, T:tracing stop,Z:zombie, X:dead</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">ppid=565</td>
<td style="text-align:left">父进程ID</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">pgid=570</td>
<td style="text-align:left">线程组ID</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">session=565</td>
<td style="text-align:left">该任务所在的会话组ID</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left">tty_nr=34817</td>
<td style="text-align:left">该任务的tty终端的设备号</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:left">tpgid=570</td>
<td style="text-align:left">终端的进程组号，当前运行在该任务所在终端的前台任务(包括shell 应用程序)的PID。</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:left">task-&gt;flags=4210688</td>
<td style="text-align:left">进程标志位，查看该任务的特性</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:left">min_flt=110</td>
<td style="text-align:left">该任务不需要从硬盘拷数据而发生的缺页（次缺页）的次数</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:left">cmin_flt=0</td>
<td style="text-align:left">累计的该任务的所有的waited-for进程曾经发生的次缺页的次数目</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:left">maj_flt=0</td>
<td style="text-align:left">该任务需要从硬盘拷数据而发生的缺页（主缺页）的次数</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:left">cmaj_flt=0</td>
<td style="text-align:left">累计的该任务的所有的waited-for进程曾经发生的主缺页的次数目</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:left">utime=209</td>
<td style="text-align:left">该任务在用户态运行的时间，单位为jiffies</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:left">stime=648</td>
<td style="text-align:left">该任务在核心态运行的时间，单位为jiffies</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:left">cutime=0</td>
<td style="text-align:left">累计的该任务的所有的waited-for进程曾经在用户态运行的时间，单位为jiffies</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:left">cstime=0</td>
<td style="text-align:left">累计的该任务的所有的waited-for进程曾经在核心态运行的时间，单位为jiffies</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:left">priority=20</td>
<td style="text-align:left">任务的动态优先级</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:left">nice=0</td>
<td style="text-align:left">任务的静态优先级</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:left">num_threads=1</td>
<td style="text-align:left">该任务所在的线程组里线程的个数</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:left">it_real_value=0</td>
<td style="text-align:left">由于计时间隔导致的下一个 SIGALRM 发送进程的时延，以jiffy为单位.</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:left">start_time=1266675</td>
<td style="text-align:left">该任务启动的时间，单位为jiffies</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:left">vsize=2793472</td>
<td style="text-align:left">该任务的虚拟地址空间大小, 单位为page</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:left">rss=111</td>
<td style="text-align:left">该任务当前驻留物理地址空间的大小，单位为page</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:left">rlim=18446744073709551615</td>
<td style="text-align:left">该任务能驻留物理地址空间的最大值. 单位：byte</td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:left">start_code=4194304</td>
<td style="text-align:left">该任务在虚拟地址空间的代码段的起始地址</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:left">end_code=4867856</td>
<td style="text-align:left">该任务在虚拟地址空间的代码段的结束地址</td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td style="text-align:left">startstack=548828687344</td>
<td style="text-align:left">堆栈的起始地址（即底部）</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:left">kstkesp=548828686432</td>
<td style="text-align:left">esp(堆栈指针) 的当前值, 与在进程的内核堆栈页得到的一致</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:left">kstkeip=548186418324</td>
<td style="text-align:left">指向将要执行的指令的指针, EIP(指令指针)的当前值.</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:left">signal=0</td>
<td style="text-align:left">待处理信号的位图，记录发送给进程的普通信号</td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td style="text-align:left">blocked=0</td>
<td style="text-align:left">阻塞信号的位图</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td style="text-align:left">sigignore=0</td>
<td style="text-align:left">忽略的信号的位图</td>
</tr>
<tr>
<td style="text-align:center">34</td>
<td style="text-align:left">sigcatch=58751527</td>
<td style="text-align:left">被俘获的信号的位图</td>
</tr>
<tr>
<td style="text-align:center">35</td>
<td style="text-align:left">wchan=1</td>
<td style="text-align:left">如果该进程是睡眠状态，该值给出调度的调用点</td>
</tr>
<tr>
<td style="text-align:center">36</td>
<td style="text-align:left">nswap=0</td>
<td style="text-align:left">交换的页数（未维护）</td>
</tr>
<tr>
<td style="text-align:center">37</td>
<td style="text-align:left">cnswap=0</td>
<td style="text-align:left">子进程的累积nswap（未维护）。</td>
</tr>
<tr>
<td style="text-align:center">38</td>
<td style="text-align:left">exit_signal=17</td>
<td style="text-align:left">该进程结束时，向父进程所发送的信号</td>
</tr>
<tr>
<td style="text-align:center">39</td>
<td style="text-align:left">task_cpu(task)=3</td>
<td style="text-align:left">运行在哪个CPU上</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td style="text-align:left">task_rt_priority=0</td>
<td style="text-align:left">实时进程的相对优先级别</td>
</tr>
<tr>
<td style="text-align:center">41</td>
<td style="text-align:left">task_policy=0</td>
<td style="text-align:left">进程的调度策略，0=非实时进程，1=FIFO实时进程；2=RR实时进程</td>
</tr>
<tr>
<td style="text-align:center">42</td>
<td style="text-align:left">delayacct_blkio_ticks=0</td>
<td style="text-align:left">聚合块I/O延迟，以时钟周期（厘秒,百分之一秒）为单位。</td>
</tr>
<tr>
<td style="text-align:center">43</td>
<td style="text-align:left">guest_time=0</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:center">44</td>
<td style="text-align:left">cguest_time=0</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:center">45</td>
<td style="text-align:left">start_data=4933392</td>
<td style="text-align:left">放置程序数据和未初始化（BSS）数据的地址。</td>
</tr>
<tr>
<td style="text-align:center">46</td>
<td style="text-align:left">end_data  =4937189</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:center">47</td>
<td style="text-align:left">start_brk=1042927616</td>
<td style="text-align:left">可以使用brk(2)扩展程序堆的地址。</td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:left">arg_start=548828688219</td>
<td style="text-align:left">放置程序命令行参数（argv）的地址。</td>
</tr>
<tr>
<td style="text-align:center">49</td>
<td style="text-align:left">arg_end  =548828688223</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:center">50</td>
<td style="text-align:left">env_start=548828688223</td>
<td style="text-align:left">放置程序环境变量的地址。</td>
</tr>
<tr>
<td style="text-align:center">51</td>
<td style="text-align:left">env_end  =548828688363</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:center">52</td>
<td style="text-align:left">exit_code=0</td>
<td style="text-align:left">线程的退出状态采用waitpid(2)报告的形式。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>文件系统</category>
        <category>proc</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Ticket spinlocks</title>
    <url>/post/50889.html</url>
    <content><![CDATA[<p><code>Ticket Spinlock</code>思路：类似银行办业务，先取一个号排队，然后等待叫号叫到自己<br><a id="more"></a></p>
<p>在x86架构中，在2.6.24内核中，自旋锁由整数值表示，其值为1表示锁是可用的。 <code>spin_lock()</code>代码通过递减值（以系统范围的原子方式），然后查看结果是否为0; 如果为0，表示锁已成功获得。 相反，如果递减的结果是负数，则<code>spin_lock()</code>知道该锁是由其他人拥有的。所以它忙着等待（“自旋”）进入一个循环，直到锁的值变为正数; 然后它回到开始并再次尝试。</p>
<p>代码一旦执行到关键部分，锁的所有者通过将其设置为1来释放锁。</p>
<blockquote>
<p>这种方法存在一个缺点：这是<code>不公平</code>。当自旋等待获取锁的对象增多，一旦释放锁，第一个能够减少锁定的处理器将成为新的所有者。 没有办法确保等待时间最长的处理器先获得锁定; 实际上，刚刚释放锁的CPU可以凭借拥有该缓存行而具有优势，快速重新获取锁。</p>
</blockquote>
<h2 id="ticket-spinlocks"><a href="#ticket-spinlocks" class="headerlink" title="ticket spinlocks"></a>ticket spinlocks</h2><blockquote>
<p>ARM平台为例，Linux4.4</p>
</blockquote>
<p>一个自旋锁变成了<code>32位</code>数，分成两个部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		u32 slock;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> __<span class="title">raw_tickets</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARMEB__</span></span><br><span class="line">			u16 next;</span><br><span class="line">			u16 owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			u16 owner;</span><br><span class="line">			u16 next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125; tickets;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; <span class="keyword">arch_spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch/arm/include/asm/spinclok_types.h</p>
</blockquote>
<p><img src="/images/2019/04/spinlock_struct.png" alt="spinlock_struct"></p>
<p>每个半字可以被认为是一个票号。 如果你去过一家商店，客户拿纸票确保按照到货顺序送达，您可以将<code>next</code>字段视为分配器中下一张票的号码，而<code>owner</code>是在柜台上的<code>正在服务</code>显示中出现的号码。</p>
<p>因此，在新的方案中，锁的值被初始化（两个字段）为零。 spin_lock()开始记录锁的值，然后递增<code>next</code>字段(所有这些都在一个原子操作中)。 如果<code>next</code>（在增量之前）的值等于<code>owner</code>，则已获得锁并且可以继续工作。 否则处理器将自旋，等待<code>owner</code>增加到正确的值。 在这个方案中，释放锁是一个简单的增加<code>owner</code>的问题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><table>
<thead>
<tr>
<th style="text-align:center">汇编指令</th>
<th style="text-align:left">解释</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">prfm</td>
<td style="text-align:left">Prefetch Memory (register)预取</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">stxr</td>
<td style="text-align:left">赋值存储，并保存存储状态</td>
<td style="text-align:left">STXR <ws>, <wt>, [Xn{,#0}]，将Wt写入Xn中，并保存写入状态到Ws</wt></ws></td>
</tr>
<tr>
<td style="text-align:center">cbnz</td>
<td style="text-align:left">不等于0</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">cbz</td>
<td style="text-align:left">等于0</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">sevl</td>
<td style="text-align:left">Send Event Local是一个提示指令，它使事件在本地发出信号，而不需要将事件通知多处理器系统中的其他PE。 它可以启动一个以WFE指令开始的等待循环。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ldaxrh</td>
<td style="text-align:left">Load-Acquire Exclusive Register Halfword, 从存储器加载半字，对其进行零扩展并将其写入寄存器,</td>
<td style="text-align:left">LDAXRH <wt>, [Xn{,#0}], 将Xn赋值给Wt</wt></td>
</tr>
<tr>
<td style="text-align:center">staddlh</td>
<td style="text-align:left">Atomic add on halfword in memory</td>
<td style="text-align:left">STADDH <ws>, [Xn]，Xn加Ws并保存到Xn</ws></td>
</tr>
<tr>
<td style="text-align:center">ldadda</td>
<td style="text-align:left">Atomic add on word or doubleword in memory</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>PE 指的是<code>Process Element</code>， 就是逻辑核心(logic core)，一个逻辑核心上可以跑一个线程</li>
<li>Load-Acquire/Store-Release指令是ARMv8的特性，在执行load和store操作的时候顺便执行了memory barrier相关的操作, 如ldaxr，ldaxrh等指令</li>
</ul>
</blockquote>
<h3 id="spin-lock-init"><a href="#spin-lock-init" class="headerlink" title="spin_lock_init"></a>spin_lock_init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED	&#123; 0 , 0 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __raw_spin_lock_init(<span class="keyword">raw_spinlock_t</span> *lock, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">			  struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we are not reinitializing a held lock:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	debug_check_no_locks_freed((<span class="keyword">void</span> *)lock, <span class="keyword">sizeof</span>(*lock));</span><br><span class="line">	lockdep_init_map(&amp;lock-&gt;dep_map, name, key, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">//初始化，next=owner=0</span></span><br><span class="line">	lock-&gt;raw_lock = (<span class="keyword">arch_spinlock_t</span>)__ARCH_SPIN_LOCK_UNLOCKED;</span><br><span class="line">	lock-&gt;magic = SPINLOCK_MAGIC;</span><br><span class="line">	lock-&gt;owner = SPINLOCK_OWNER_INIT;</span><br><span class="line">	lock-&gt;owner_cpu = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(__raw_spin_lock_init);</span><br></pre></td></tr></table></figure>
<h3 id="spin-lock"><a href="#spin-lock" class="headerlink" title="spin_lock"></a>spin_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">arch_spin_trylock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">arch_spinlock_t</span> lockval;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(ARM64_LSE_ATOMIC_INSN(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/* LL/SC */</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//prfm: Prefetch Memory (register)预取</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//pstl1strm: 表示预取数据为一级Cache的流式存储</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//将lock结构存储到一级Cache，提高访问速度</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	prfm	pstl1strm, %2\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//赋值，将lock赋值给lockval</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"1:	ldaxr	%w0, %2\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//eor:按位异或</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//ror:循环右移</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//相当于if(next == owner)</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	eor	%w1, %w0, %w0, ror #16\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//比较如果tmp不是0，跳转标号2，next与owner不相等</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	cbnz	%w1, 2f\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">/* next == owner，该锁未被使用，no busy */</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//lockval中的next加1</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	add	%w0, %w0, %3\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//将lockval写入lock，并保存赋值状态到tmp</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	stxr	%w1, %w0, %2\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//如果tmp不等于0，则跳转标号1</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	cbnz	%w1, 1b\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">/* next != owner, 该锁已被使用，busy */</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"2:"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/* LSE atomics */</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//将lock赋值给lockval</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	ldr	%w0, %2\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//判断next与owner是否相等</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	eor	%w1, %w0, %w0, ror #16\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//如果tmp不等于0，跳转标号1</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	cbnz	%w1, 1f\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//lockval中的next加1</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	add	%w1, %w0, %3\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//casa:Compare and Swap</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//比较lockval与tmp，如果相等，将tmp写入lockval，否则跳转标号2(原子指令)</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	casa	%w0, %w1, %2\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//將tmp中的next減去1</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	sub	%w1, %w1, %3\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//判斷lockval与tmp是否相等</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	eor	%w1, %w1, %w0\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">/* lockval与tmp，相等：退出；不相等：跳转标号1，循环 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"1:"</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"=&amp;r"</span> (lockval), <span class="string">"=&amp;r"</span> (tmp), <span class="string">"+Q"</span> (*lock)</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"I"</span> (<span class="number">1</span> &lt;&lt; TICKET_SHIFT)</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_spin_lock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">arch_spinlock_t</span> lockval, newval;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/* Atomically increment the next ticket. */</span></span></span></span><br><span class="line"><span class="function"><span class="params">	ARM64_LSE_ATOMIC_INSN(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/* LL/SC */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	prfm	pstl1strm, %3\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"1:	ldaxr	%w0, %3\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	add	%w1, %w0, %w5\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	stxr	%w2, %w1, %3\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	cbnz	%w2, 1b\n"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/* LSE atomics */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	mov	%w2, %w5\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* next加1 */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	ldadda	%w2, %w0, %3\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	nop\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	nop\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	nop\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/* Did we get the lock? */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	eor	%w1, %w0, %w0, ror #16\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	cbz	%w1, 3f\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/*</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">	 * No: spin on the owner. Send a local event to avoid missing an</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">	 * unlock before the exclusive load.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">	 */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* 使CPU进入低功耗模式， 等待自旋 */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	sevl\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"2:	wfe\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//==&gt; 其他cpu唤醒本cpu，获取当前owner值</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	ldaxrh	%w2, %4\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	eor	%w1, %w2, %w0, lsr #16\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"	cbnz	%w1, 2b\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/* We got the lock. Critical section starts here. */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"3:"</span></span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"=&amp;r"</span> (lockval), <span class="string">"=&amp;r"</span> (newval), <span class="string">"=&amp;r"</span> (tmp), <span class="string">"+Q"</span> (*lock)</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"Q"</span> (lock-&gt;owner), <span class="string">"I"</span> (<span class="number">1</span> &lt;&lt; TICKET_SHIFT)</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Wait For Event is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. Wakeup events include the event signaled as a result of executing the <code>SEV</code> instruction on any PE in the multiprocessor system. For more information, see Wait for Event mechanism and Send event on page D1-2255.</p>
</blockquote>
<h3 id="spin-unlock"><a href="#spin-unlock" class="headerlink" title="spin_unlock"></a>spin_unlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_spin_unlock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(ARM64_LSE_ATOMIC_INSN(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/* LL/SC */</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	ldrh	%w1, %0\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	add	%w1, %w1, #1\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	stlrh	%w1, %0"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/* LSE atomics */</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	mov	%w1, #1\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	nop\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">/* owner加1 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"	staddlh	%w1, %0"</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"=Q"</span> (lock-&gt;owner), <span class="string">"=&amp;r"</span> (tmp)</span></span></span><br><span class="line"><span class="function"><span class="params">	:</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有sev指令，如何唤醒进入低功耗模式（wfe）的CPU core？？</li>
</ul>
<blockquote>
<p>ARMv8 provides Wait For Event, Send Event, and Send Event Local instructions, WFE, SEV, and SEVL, that can assist with reducing power consumption and bus contention caused by PEs repeatedly attempting to obtain a spin-lock. These instructions can be used at the application level, but a complete understanding of what they do depends on a system level understanding of exceptions. They are described in Wait for Event mechanism and Send event on page D1-2255. However, in ARMv8, when the global monitor for a PE changes from <code>Exclusive Access</code> state to Open Access state, an event is generated.</p>
</blockquote>
<p><strong><code>stlrh</code>和<code>staddlh</code>指令存在Exclusive操作，当PE（n）对x地址发起了exclusive操作的时候，PE（n）的global monitor从open access迁移到exclusive access状态，来自其他PE上针对x（该地址已经被mark for PE（n））的store操作会导致PE（n）的global monitor从exclusive access迁移到open access状态，这时候，PE（n）的Event register会被写入event，就好象生成一个event，将该PE唤醒，从而可以省略一个SEV的指令</strong></p>
<p><img src="/images/2019/04/spin_lock_pe_n.png" alt="spin_lock_pe_n"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://lwn.net/Articles/267968/" target="_blank" rel="noopener">Ticket spinlocks</a></li>
<li><a href="https://dev.tencent.com/u/Winddoing/p/blog_docs/git/raw/master/DDI0487D_a_armv8_arm.pdf" target="_blank" rel="noopener">ARMv8®体系结构参考手册</a></li>
<li><a href="http://www.wowotech.net/armv8a_arch/wfe_wfi.html" target="_blank" rel="noopener">ARM WFI和WFE指令</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
        <category>同步</category>
      </categories>
      <tags>
        <tag>spinlock</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]GCC下itoa函数的演变：itoa with GCC</title>
    <url>/post/60077.html</url>
    <content><![CDATA[<p>转载链接：<a href="https://blog.csdn.net/u013074465/article/details/46499959" target="_blank" rel="noopener">https://blog.csdn.net/u013074465/article/details/46499959</a></p>
<p>原文：<a href="http://www.strudel.org.uk/itoa/" target="_blank" rel="noopener">http://www.strudel.org.uk/itoa/</a></p>
<p>这篇文章中有对部分函数的具体分析：对itoa函数的分析。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>我怎么在GCC下使用<code>itoa()</code>？</p>
</blockquote>
<p>啊，C/C++！itoa()不是<code>ANSI C</code>标准而且它不能在linux下的GCC中工作（至少我使用的版本是这样的）。这是很让人沮丧的，特别是当你想让代码跨平台可用时（Windows/Linux/Solaris或其他任何机器）。</p>
<p>很多人说可以使用sprintf来写字符串但是sprintf不满足itoa()的一个特征：itoa函数<code>允许将int转换为除十进制以外其他进制的形式</code>。该文章包含一系列itoa函数实现的演化版本。较老的版本在文章后边。请确认你用的是最新版本。</p>
<a id="more"></a>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>在我们继续之前，我要感谢以下为解决方案作出贡献的人。这个函数是由以下人员贡献的：Stuart Lowe (本文作者)，Robert Jan Schaper，Ray-Yuan Sheu， Rodrigo de Salvo Braz，Wes Garland，John Maloney，Brian Hunt，Fernando Corradi and Lukás Chmela。</p>
<h2 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h2><p>以下是早期的一个版本，由Robert Jan Schaper表述于Google groups：</p>
<h3 id="char-version-0-1"><a href="#char-version-0-1" class="headerlink" title="char* version 0.1"></a>char* version 0.1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> base)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">for</span>(; val &amp;&amp; i ; --i, val /= base)</span><br><span class="line">	    buf[i] = <span class="string">"0123456789abcdef"</span>[val % base];</span><br><span class="line">	<span class="keyword">return</span> &amp;buf[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我所使用的版本和这个版本看起来不太一样，它更像是这样的形式：itoa(int value, char* buffer, int radix)。在最后，我给出了我自己使用std::string代替字符串的版本。</p>
<h3 id="std-string-version-0-1"><a href="#std-string-version-0-1" class="headerlink" title="std::string version 0.1"></a>std::string version 0.1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_itoa</span><span class="params">(<span class="keyword">int</span> value, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; buf, <span class="keyword">int</span> base)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">	buf = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">for</span>(; value &amp;&amp; i ; --i, value /= base)</span><br><span class="line">        buf = <span class="string">"0123456789abcdef"</span>[value % base] + buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新：(2005/02/11)</p>
<p>Ray-Yuan Sheu发邮件给我，他提出了一个更新版本：做了更多错误检测，例如基底base越界、负整数等。</p>
<p>更新：(2005/04/08)</p>
<p>Rodrigo de Salvo Braz指出了一个bug：当输入为0时没有返回。现在函数返回0。Luc Gallant也指出了这个bug。</p>
<h3 id="std-string-version-0-2"><a href="#std-string-version-0-2" class="headerlink" title="std::string version 0.2"></a>std::string version 0.2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version std::string style "itoa":</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">unsigned</span> <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> digitMap[] = <span class="string">"0123456789abcdef"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Guard:</span></span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">0</span> || base &gt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="comment">// Error: may add more trace/log output here</span></span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take care of negative int:</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sign;</span><br><span class="line">    <span class="keyword">int</span> _value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for case when input is zero:</span></span><br><span class="line">    <span class="keyword">if</span> (_value == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        _value = -value;</span><br><span class="line">        sign = <span class="string">"-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translating number to string with base:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; _value &amp;&amp; i ; --i) &#123;</span><br><span class="line">        buf = digitMap[ _value % base ] + buf;</span><br><span class="line">        _value /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign.append(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新：(2005/05/07)</p>
<p>Wes Garland指出lltostr函数在Solaris和其他linux变体中存在。函数应该返回long long的<code>char *</code>形式处理多种数基。还有针对无符号数值的ulltostr函数。</p>
<p>更新：(2005/05/30)</p>
<p>John Maloney指出了之前函数的多个问题。一个主要问题是函数包含大量栈分配。他建议尽可能移除栈分配以加快算法速度。char<em> 版本比上述的代码快至少10倍。新版本的std::string比原来的快3倍。尽管char</em>版本更快，但是你必须检查以确保为函数输出分配了足够的空间。</p>
<h3 id="std-string-version-0-3"><a href="#std-string-version-0-3" class="headerlink" title="std::string version 0.3"></a>std::string version 0.3</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version std::string style "itoa":</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; kMaxDigits = <span class="number">35</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">    buf.reserve( kMaxDigits ); <span class="comment">// Pre-allocate enough space.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) <span class="keyword">return</span> buf;</span><br><span class="line">    <span class="keyword">int</span> quotient = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translating number to string with base:</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        buf += <span class="string">"0123456789abcdef"</span>[ <span class="built_in">std</span>::<span class="built_in">abs</span>( quotient % base ) ];</span><br><span class="line">        quotient /= base;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append the negative sign for base 10</span></span><br><span class="line">    <span class="keyword">if</span> ( value &lt; <span class="number">0</span> &amp;&amp; base == <span class="number">10</span>) buf += <span class="string">'-'</span>;</span><br><span class="line">    <span class="built_in">std</span>::reverse( buf.<span class="built_in">begin</span>(), buf.<span class="built_in">end</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="char-version-0-2"><a href="#char-version-0-2" class="headerlink" title="char *version 0.2"></a>char *version 0.2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version char* style "itoa":</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">itoa</span><span class="params">( <span class="keyword">int</span> value, <span class="keyword">char</span>* result, <span class="keyword">int</span> base )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) &#123; *result = <span class="number">0</span>; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* out = result;</span><br><span class="line">    <span class="keyword">int</span> quotient = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *out = <span class="string">"0123456789abcdef"</span>[ <span class="built_in">std</span>::<span class="built_in">abs</span>( quotient % base ) ];</span><br><span class="line">        ++out;</span><br><span class="line">        quotient /= base;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only apply negative sign for base 10</span></span><br><span class="line">    <span class="keyword">if</span> ( value &lt; <span class="number">0</span> &amp;&amp; base == <span class="number">10</span>) *out++ = <span class="string">'-'</span>;</span><br><span class="line">    <span class="built_in">std</span>::reverse( result, out );</span><br><span class="line">    *out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新：(2006/10/15)</p>
<p>Luiz Gon?lves告诉我：尽管itoa不是ANSI标准函数，但是该函数来自很多开发包并且被写进了很多教科书。他提出了一个来自于Kernighan &amp; Ritchie’sAnsi C的完全基于ANSI C的版本。基底base错误通过返回空字符来表述，并且没有分配内存。这个std::string版本和C++的<code>char* itoa()</code>版本在下方提供，做了一些细微的修改。</p>
<p><strong><em> 译注：下面的方法是最容易想到的：</em></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ansi C "itoa" based on Kernighan &amp; Ritchie's "Ansi C":</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strreverse</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">begin</span>, <span class="keyword">char</span>* <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> aux;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">end</span>&gt;<span class="built_in">begin</span>)</span><br><span class="line">		aux=*<span class="built_in">end</span>, *<span class="built_in">end</span>--=*<span class="built_in">begin</span>, *<span class="built_in">begin</span>++=aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">char</span>* str, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> num[] = <span class="string">"0123456789abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line">    <span class="keyword">char</span>* wstr=str;</span><br><span class="line">    <span class="keyword">int</span> sign;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate base</span></span><br><span class="line">    <span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">35</span>)&#123; *wstr=<span class="string">'\0'</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take care of sign</span></span><br><span class="line">    <span class="keyword">if</span> ((sign=value) &lt; <span class="number">0</span>) value = -value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Conversion. Number is reversed.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *wstr++ = num[value%base];</span><br><span class="line">    &#125; <span class="keyword">while</span>(value/=base);</span><br><span class="line">    <span class="keyword">if</span>(sign&lt;<span class="number">0</span>) *wstr++=<span class="string">'-'</span>;</span><br><span class="line">    *wstr=<span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reverse string</span></span><br><span class="line">    strreverse(str,wstr<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ansi C "itoa" based on Kernighan &amp; Ritchie's "Ansi C"</span></span><br><span class="line"><span class="comment"> * with slight modification to optimize for specific architecture:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strreverse</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">begin</span>, <span class="keyword">char</span>* <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> aux;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">end</span>&gt;<span class="built_in">begin</span>)</span><br><span class="line">		aux=*<span class="built_in">end</span>, *<span class="built_in">end</span>--=*<span class="built_in">begin</span>, *<span class="built_in">begin</span>++=aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">char</span>* str, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> num[] = <span class="string">"0123456789abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line">	<span class="keyword">char</span>* wstr=str;</span><br><span class="line">	<span class="keyword">int</span> sign;</span><br><span class="line">	<span class="keyword">div_t</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate base</span></span><br><span class="line">	<span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">35</span>)&#123; *wstr=<span class="string">'\0'</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Take care of sign</span></span><br><span class="line">	<span class="keyword">if</span> ((sign=value) &lt; <span class="number">0</span>) value = -value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Conversion. Number is reversed.</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		res = div(value,base);</span><br><span class="line">		*wstr++ = num[res.rem];</span><br><span class="line">	&#125;<span class="keyword">while</span>(value=res.quot);</span><br><span class="line">	<span class="keyword">if</span>(sign&lt;<span class="number">0</span>) *wstr++=<span class="string">'-'</span>;</span><br><span class="line">	*wstr=<span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reverse string</span></span><br><span class="line">	strreverse(str,wstr<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新：(2009/07/08)</p>
<p>过去一年我收到了一些改进<code>std::string</code>和<code>char *</code>版本的代码。我最终有时间测试了这些代码。在std::string版本中，Brian Hunt建议将reverse移到base的检查之后，保存内存分配。这样可以加快速度。</p>
<h3 id="std-string-version-0-4"><a href="#std-string-version-0-4" class="headerlink" title="std::string version 0.4"></a>std::string version 0.4</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.4 std::string style "itoa":</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check that the base if valid</span></span><br><span class="line">	<span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) <span class="keyword">return</span> buf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum</span> &#123; kMaxDigits = <span class="number">35</span> &#125;;</span><br><span class="line">	buf.reserve( kMaxDigits ); <span class="comment">// Pre-allocate enough space.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> quotient = value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Translating number to string with base:</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		buf += <span class="string">"0123456789abcdef"</span>[ <span class="built_in">std</span>::<span class="built_in">abs</span>( quotient % base ) ];</span><br><span class="line">		quotient /= base;</span><br><span class="line">	&#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Append the negative sign</span></span><br><span class="line">	<span class="keyword">if</span> ( value &lt; <span class="number">0</span>) buf += <span class="string">'-'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::reverse( buf.<span class="built_in">begin</span>(), buf.<span class="built_in">end</span>() );</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一些针对char*版本的建议。Fernando Corradi提议使用abs()因为仅仅使用一次，不使用取余操作（%）而是通过手动计算除数。这样可以加快速度：</p>
<h3 id="char-version-0-3"><a href="#char-version-0-3" class="headerlink" title="char  *version 0.3"></a>char  *version 0.3</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.3 char* style "itoa":</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">itoa</span><span class="params">( <span class="keyword">int</span> value, <span class="keyword">char</span>* result, <span class="keyword">int</span> base )</span> </span>&#123;</span><br><span class="line">	<span class="comment">// check that the base if valid</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) &#123; *result = <span class="number">0</span>; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* out = result;</span><br><span class="line">	<span class="keyword">int</span> quotient = <span class="built_in">abs</span>(value);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> tmp = quotient / base;</span><br><span class="line">		*out = <span class="string">"0123456789abcdef"</span>[ quotient - (tmp*base) ];</span><br><span class="line">		++out;</span><br><span class="line">		quotient = tmp;</span><br><span class="line">	&#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Apply negative sign</span></span><br><span class="line">	<span class="keyword">if</span> ( value &lt; <span class="number">0</span>) *out++ = <span class="string">'-'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::reverse( result, out );</span><br><span class="line">	*out = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="char-version-0-4"><a href="#char-version-0-4" class="headerlink" title="char* version 0.4"></a>char* version 0.4</h3><p>Lukás Chmela重写了代码，该函数不再有“最小负数”bug：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.4 char* style "itoa":</span></span><br><span class="line"><span class="comment"> * Written by Lukás Chmela</span></span><br><span class="line"><span class="comment"> * Released under GPLv3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">char</span>* result, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">36</span>) &#123; *result = <span class="string">'\0'</span>; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* ptr = result, *ptr1 = result, tmp_char;</span><br><span class="line">    <span class="keyword">int</span> tmp_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        tmp_value = value;</span><br><span class="line">        value /= base;</span><br><span class="line">        *ptr++ = <span class="string">"zyxwvutsrqponmlkjihgfedcba9876543210123456789</span></span><br><span class="line"><span class="string">            abcdefghijklmnopqrstuvwxyz"</span> [<span class="number">35</span> + (tmp_value - value * base)];</span><br><span class="line">    &#125; <span class="keyword">while</span> ( value );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply negative sign</span></span><br><span class="line">    <span class="keyword">if</span> (tmp_value &lt; <span class="number">0</span>) *ptr++ = <span class="string">'-'</span>;</span><br><span class="line">    *ptr-- = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr1 &lt; ptr) &#123;</span><br><span class="line">        tmp_char = *ptr;</span><br><span class="line">        *ptr--= *ptr1;</span><br><span class="line">        *ptr1++ = tmp_char;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h2><p>下面是最新版本的itoa，你可以根据喜好选择char*或std::string版本。我没有将基于Kernighan &amp; Ritchie的版本放在这个部分，因为我不确定其版权的状态。然而，下列函数已经被上述提到的人开发并且是可以使用的。</p>
<h3 id="std-string-version-0-4-1"><a href="#std-string-version-0-4-1" class="headerlink" title="std::string version 0.4"></a>std::string version 0.4</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.4 std::string style "itoa":</span></span><br><span class="line"><span class="comment"> * Contributions from Stuart Lowe, Ray-Yuan Sheu,</span></span><br><span class="line"><span class="comment"> * Rodrigo de Salvo Braz, Luc Gallant, John Maloney</span></span><br><span class="line"><span class="comment"> * and Brian Hunt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) <span class="keyword">return</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123; kMaxDigits = <span class="number">35</span> &#125;;</span><br><span class="line">    buf.reserve( kMaxDigits ); <span class="comment">// Pre-allocate enough space.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> quotient = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translating number to string with base:</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        buf += <span class="string">"0123456789abcdef"</span>[ <span class="built_in">std</span>::<span class="built_in">abs</span>( quotient % base ) ];</span><br><span class="line">        quotient /= base;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append the negative sign</span></span><br><span class="line">    <span class="keyword">if</span> ( value &lt; <span class="number">0</span>) buf += <span class="string">'-'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::reverse( buf.<span class="built_in">begin</span>(), buf.<span class="built_in">end</span>() );</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="char-version-0-4-1"><a href="#char-version-0-4-1" class="headerlink" title="char* version 0.4"></a>char* version 0.4</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.4 char* style "itoa":</span></span><br><span class="line"><span class="comment"> * Written by Lukás Chmela</span></span><br><span class="line"><span class="comment"> * Released under GPLv3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">char</span>* result, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">36</span>) &#123; *result = <span class="string">'\0'</span>; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* ptr = result, *ptr1 = result, tmp_char;</span><br><span class="line">    <span class="keyword">int</span> tmp_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        tmp_value = value;</span><br><span class="line">        value /= base;</span><br><span class="line">        *ptr++ = <span class="string">"zyxwvutsrqponmlkjihgfedcba9876543210123456789</span></span><br><span class="line"><span class="string">            abcdefghijklmnopqrstuvwxyz"</span> [<span class="number">35</span> + (tmp_value - value * base)];</span><br><span class="line">    &#125; <span class="keyword">while</span> ( value );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply negative sign</span></span><br><span class="line">    <span class="keyword">if</span> (tmp_value &lt; <span class="number">0</span>) *ptr++ = <span class="string">'-'</span>;</span><br><span class="line">    *ptr-- = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr1 &lt; ptr) &#123;</span><br><span class="line">        tmp_char = *ptr;</span><br><span class="line">        *ptr--= *ptr1;</span><br><span class="line">        *ptr1++ = tmp_char;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>我已经对itoa的各个版本做了测试，研究其转换-32768到32768之间整数，基底在2到20之间时所需要的平均时间（代码仅仅在基底最高位16有效，因此其余的base仅仅是作为测试）。测试结果如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">function</th>
<th style="text-align:center">relative time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char<em> style “itoa” (v 0.2) <br> char</em> itoa(int value, char* result, int base)</td>
<td style="text-align:center">1.0 (XP, Cygwin, g++)</td>
</tr>
<tr>
<td style="text-align:left">char<em> style “itoa” (v 0.3) <br> char</em> itoa(int value, char* result, int base)</td>
<td style="text-align:center">0.93</td>
</tr>
<tr>
<td style="text-align:left">char<em> style “itoa” (v 0.4) <br> char</em> itoa(int value, char* result, int base)</td>
<td style="text-align:center">0.72</td>
</tr>
<tr>
<td style="text-align:left">Ansi C “itoa” based on Kernighan &amp; Ritchie’s “Ansi C” with modification to optimize for specific architecture <br>void itoa(int value, char* str, int base)</td>
<td style="text-align:center">0.92</td>
</tr>
<tr>
<td style="text-align:left">std::string style “itoa” (v 0.3) <br> std::string itoa(int value, int base)</td>
<td style="text-align:center">41.5</td>
</tr>
<tr>
<td style="text-align:left">std::string style “itoa” (v 0.4) <br> std::string itoa(int value, int base)</td>
<td style="text-align:center">40.8</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>itoa</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下出现死机的处理方法</title>
    <url>/post/8229.html</url>
    <content><![CDATA[<p>服务器中Linux系统出现死机后的处理：查看系统<strong>日志</strong>，定位死机原因</p>
<blockquote>
<p>linux系统： CentOS</p>
</blockquote>
<a id="more"></a>
<h2 id="查看运行日志"><a href="#查看运行日志" class="headerlink" title="查看运行日志"></a>查看运行日志</h2><h3 id="TTY文字界面"><a href="#TTY文字界面" class="headerlink" title="TTY文字界面"></a>TTY文字界面</h3><p>按<code>Ctrl+Alt+F1</code>,就会切换到TTY文字界面</p>
<blockquote>
<p><code>Ctrl + Alt + Backspace</code>重启 X server</p>
</blockquote>
<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><ul>
<li><code>/var/log/message</code>: 系统启动后的信息和错误日志</li>
<li><code>/var/log/secure</code>: 与安全相关的日志信息</li>
<li><code>/var/log/maillog</code>: 与邮件相关的日志信息</li>
<li><code>/var/log/cron</code>: 与定时任务相关的日志信息</li>
<li><code>/var/log/spooler</code>: 与UUCP和news设备相关的日志信息</li>
<li><code>/var/log/boot.log</code>: 守护进程启动和停止相关的日志消息</li>
<li><code>/var/log/wtmp</code>: 永久记录每个用户登录、注销及系统的启动、停机的事件</li>
<li><code>/var/run/utmp</code>: 记录当前正在登录系统的用户信息；</li>
<li><code>/var/log/btmp</code>: 记录失败的登录尝试信息。</li>
</ul>
<h3 id="var-log-messages"><a href="#var-log-messages" class="headerlink" title="/var/log/messages"></a>/var/log/messages</h3><blockquote>
<p>用于记录系统常见的系统和服务错误信息.</p>
</blockquote>
<p>如果系统默认没有开启，打开方法：</p>
<p>将<code>/etc/rsyslog.d/50-default.conf</code>文件中的相关注释去掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Some &quot;catch-all&quot; log files.</span><br><span class="line">#</span><br><span class="line">#*.=debug;\</span><br><span class="line">#   auth,authpriv.none;\</span><br><span class="line">#   news.none;mail.none -/var/log/debug</span><br><span class="line">#*.=info;*.=notice;*.=warn;\</span><br><span class="line">#   auth,authpriv.none;\</span><br><span class="line">#   cron,daemon.none;\</span><br><span class="line">#   mail,news.none      -/var/log/messages</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>去掉第<code>4</code>行到第<code>10</code>行的<code>#</code>注释，并重启<code>rsyslog</code>服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/rsyslog restart</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：如果 /var/log/messages 被写满，导致空间被占用较多，可以查看下哪些内容被写入到文件了，然后在<code>/etc/rsyslog.d/50-default.conf</code>文件中注释掉即可.</p>
<h2 id="reisb"><a href="#reisb" class="headerlink" title="reisb"></a>reisb</h2><p>利用<code>reisub</code>,可以在各种情况下安全地重启计算机</p>
<p>在系统正常启动后需要激活内核<code>sysrq</code>功能:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;1&quot; &gt; /proc/sys/Kernel/sysrq</span><br><span class="line"></span><br><span class="line">sysctl -w kernel.sysrq=1</span><br></pre></td></tr></table></figure></p>
<p>或者，修改<code>/etc/sysctl.conf</code>文件，设置<code>kernel.sysrq = 1</code></p>
<blockquote>
<p>方法： 按住 <code>Alt+Print(Sys Rq)</code>,然后依次按下 <code>reisub</code> 这几个键,按完<code>b</code>系统就会重启。</p>
</blockquote>
<ul>
<li><code>r</code>: unRaw 将键盘控制从 X Server 那里抢回来</li>
<li><code>e</code>: tErminate 给所有进程发送 SIGTERM 信号,让他们自己解决善后</li>
<li><code>i</code>: kIll 给所有进程发送 SIGKILL 信号,强制他们马上关闭</li>
<li><code>s</code>: Sync 将所有数据同步至磁盘</li>
<li><code>u</code>: Unmount 将所有分区挂载为只读模式</li>
<li><code>b</code>: reBoot 重启</li>
</ul>
<h2 id="判断死机情况"><a href="#判断死机情况" class="headerlink" title="判断死机情况"></a>判断死机情况</h2><ul>
<li>在桌面卡死不动的情况下，可以通过键盘<code>Caps Lock/Num Lock/Scroll Lock</code>按键按后,判断对应LED可以正常亮灭，确定属于X server崩溃，还是内核崩溃<ul>
<li>LED亮灭正常，属于X server崩溃</li>
<li>LED灯没反应，属于内核崩溃</li>
</ul>
</li>
</ul>
<h2 id="Kdump-crash"><a href="#Kdump-crash" class="headerlink" title="Kdump + crash"></a>Kdump + crash</h2><p><code>kdump</code>是一种基于kexec的内核崩溃转储技术。kdump需要两个内核，分别是生产内核和捕获内核，生产内核是捕获内核服务的对象，且保留了内存的一部分给捕获内核启动使用。当系统崩溃时，kdump使用kexec启动捕获内核，以相应的ramdisk一起组建一个微环境，用以对生产内核下的内存进行收集和转存。</p>
<p><code>kexec</code>是一个Linux内核到内核的引导加载程序，可以帮助从第一个内核的上下文引导到第二个内核。kexec会关闭第一个内核，绕过BIOS或固件阶段，并跳转到第二个内核。当第一个内核崩溃时第二个内核启动，第二个内核用于复制第一个内核的内存转储，可以使用gdb和crash等工具分析崩溃的原因。</p>
<p><code>crash</code>用于调试内核崩溃的转储文件</p>
<p><img src="/images/2019/09/kdump_panic.png" alt="kdump-panic"></p>
<blockquote>
<p><a href="http://lse.sourceforge.net/kdump/documentation/ols2005-kdump-presentation.pdf" target="_blank" rel="noopener">A Kexec Based Kernel Crash Dumping Mechanism</a></p>
</blockquote>
<h3 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h3><blockquote>
<p>Linux localhost.localdomain 4.14.0-115.10.1.el7a.aarch64 #1 SMP Tue Jul 30 14:50:37 UTC 2019 aarch64 aarch64 aarch64 GNU/Linux</p>
</blockquote>
<h4 id="安装kexec-tools"><a href="#安装kexec-tools" class="headerlink" title="安装kexec-tools"></a>安装kexec-tools</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum install kexec-tools</span><br></pre></td></tr></table></figure>
<h4 id="配置GRUB2中的内存"><a href="#配置GRUB2中的内存" class="headerlink" title="配置GRUB2中的内存"></a>配置GRUB2中的内存</h4><ul>
<li>在内核崩溃后，转存coredump文件所需的内存大小，配置参数<code>crashkernel=[size]</code></li>
</ul>
<blockquote>
<p>配置文件： /etc/default/grub</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=&quot;$(sed &apos;s, release .*$,,g&apos; /etc/system-release)&quot;</span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_DISABLE_SUBMENU=true</span><br><span class="line">GRUB_TERMINAL_OUTPUT=&quot;console&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap&quot;</span><br><span class="line">GRUB_DISABLE_RECOVERY=&quot;true&quot;</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：在网络大多数的文章说<code>crashkernel=128M或512M</code>，但是测试直接配置<code>crashkernel=auto</code>同样可以转存coredump文件</p>
<blockquote>
<p>在Linux4.15中使用<code>crashkernel=auto</code>，内核将通过<code>memblock_find_in_range</code>自动计算小内核的内存大小和起始位置，但是有些内核可能不支持，需要手动指定大小<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;  <span class="keyword">if</span> (!high)</span><br><span class="line">     crash_base = memblock_find_in_range(CRASH_ALIGN,</span><br><span class="line">                 CRASH_ADDR_LOW_MAX,</span><br><span class="line">                 crash_size, CRASH_ALIGN);</span><br><span class="line"> <span class="keyword">if</span> (!crash_base)</span><br><span class="line">     crash_base = memblock_find_in_range(CRASH_ALIGN,</span><br><span class="line">                 CRASH_ADDR_HIGH_MAX,</span><br><span class="line">                 crash_size, CRASH_ALIGN);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>file：arch/x86/kernel/setup.c</p>
</blockquote>
<ul>
<li>如果修改grub文件后，需要重新生成grub文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>
<p> <strong>注意不同的系统可能使用的grub不同</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -ls /boot/grub2</span><br><span class="line">0 lrwxrwxrwx. 1 root root 25 Aug 13 04:34 grubenv -&gt; ../efi/EFI/centos/grubenv</span><br></pre></td></tr></table></figure>
<h4 id="配置kdump"><a href="#配置kdump" class="headerlink" title="配置kdump"></a>配置kdump</h4><blockquote>
<p>配置文件路径： <code>/etc/kdump.conf</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path /var/crash   #指定coredump文件放在/var/crash文件夹中</span><br><span class="line">core_collector makedumpfile -l --message-level 1 -d 31</span><br><span class="line">default reboot    #生成coredump后，重启系统</span><br></pre></td></tr></table></figure>
<h4 id="开启kdump"><a href="#开启kdump" class="headerlink" title="开启kdump"></a>开启kdump</h4><ul>
<li>检查内核启动命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/cmdline</span><br><span class="line">BOOT_IMAGE=/vmlinuz-4.14.0-115.10.1.el7a.aarch64 root=/dev/mapper/centos-root ro crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>
<ul>
<li>开启kdump服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable kdump.service  #设置开机启动</span><br><span class="line">systemctl start kdump.service   #启动kdump</span><br></pre></td></tr></table></figure>
<h4 id="测试kdump"><a href="#测试kdump" class="headerlink" title="测试kdump"></a>测试kdump</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl is-active kdump</span><br><span class="line">active</span><br></pre></td></tr></table></figure>
<ul>
<li>查看捕获内核是否加载</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat /sys/kernel/kexec_crash_loaded</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前的保留内存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /sys/kernel/kexec_crash_size</span><br><span class="line">536870912</span><br></pre></td></tr></table></figure>
<blockquote>
<p>保留内存大小：512M<br>cat /proc/iomem | grep “Crash kernel” 应该有一个分配的范围。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmesg | grep crashkernel</span><br></pre></td></tr></table></figure>
<ul>
<li>查看kdump服务状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># service kdump status</span><br><span class="line">Redirecting to /bin/systemctl status kdump.service</span><br><span class="line">● kdump.service - Crash recovery kernel arming</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/kdump.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (exited) since Wed 2019-09-04 02:04:18 EDT; 1h 8min ago</span><br><span class="line">  Process: 1825 ExecStart=/usr/bin/kdumpctl start (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 1825 (code=exited, status=0/SUCCESS)</span><br><span class="line">    Tasks: 0</span><br><span class="line">   CGroup: /system.slice/kdump.service</span><br><span class="line"></span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: drwxr-xr-x   2 root     root            0 Sep  4  2019 usr/share/zoneinfo/America</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: -rw-r--r--   1 root     root         3519 Jul 10 17:44 usr/share/zoneinfo/America/New_York</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: drwxr-xr-x   2 root     root            0 Sep  4  2019 var</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: lrwxrwxrwx   1 root     root           11 Sep  4  2019 var/lock -&gt; ../run/lock</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: lrwxrwxrwx   1 root     root            6 Sep  4  2019 var/run -&gt; ../run</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: ========================================================================</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: *** Creating initramfs image file &apos;/boot/initramfs-4.14.0-115.10.1.el7a.aarch64kdump.img&apos; done ***</span><br><span class="line">Sep 04 02:04:18 localhost.localdomain kdumpctl[1825]: kexec: loaded kdump kernel</span><br><span class="line">Sep 04 02:04:18 localhost.localdomain kdumpctl[1825]: Starting kdump: [OK]</span><br><span class="line">Sep 04 02:04:18 localhost.localdomain systemd[1]: Started Crash recovery kernel arming.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># echo 1 &gt; /proc/sys/kernel/sysrq</span><br><span class="line"># echo c &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>c</code>: Will perform a system crash by a NULL pointer dereference.(故意使内核崩溃)</li>
</ul>
</blockquote>
<p>这将强制Linux内核崩溃，并且<code>loaclhost(ip)-YYYY-MM-DD-HH：MM：SS/vmcore</code>文件将被复制到配置中选择的位置, 默认<code>/var/crash</code></p>
<h4 id="用crash工具分析"><a href="#用crash工具分析" class="headerlink" title="用crash工具分析"></a>用crash工具分析</h4><ul>
<li>安装对应的kernel-debuginfo软件包,<a href="http://debuginfo.centos.org/7/" target="_blank" rel="noopener">地址</a></li>
</ul>
<blockquote>
<p>内核版本：<code>uname -r</code> 4.14.0-115.10.1.el7a.aarch64</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://debuginfo.centos.org/7/aarch64/kernel-debuginfo-$(uname -r).rpm</span><br><span class="line">wget http://debuginfo.centos.org/7/aarch64/kernel-debuginfo-common-aarch64-$(uname -r).rpm</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -ivh kernel-debuginfo-common-aarch64-4.14.0-115.10.1.el7a.aarch64.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rpm -ivh kernel-debuginfo-4.14.0-115.10.1.el7a.aarch64.rpm</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls /usr/lib/debug/lib/modules/4.14.0-115.10.1.el7a.aarch64/vmlinux</span><br><span class="line">/usr/lib/debug/lib/modules/4.14.0-115.10.1.el7a.aarch64/vmlinux</span><br></pre></td></tr></table></figure>
<ul>
<li>启动crash</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crash /usr/lib/debug/lib/modules/4.14.0-115.10.1.el7a.aarch64/vmlinux /var/crash/127.0.0.1-2019-09-04-10\:02\:53/vmcore</span><br></pre></td></tr></table></figure>
<p>在输入<code>bt</code>可以展示kernel-stack的backtrace，更多crash中的命令见<code>man crash</code></p>
<h3 id="ubuntu18-04"><a href="#ubuntu18-04" class="headerlink" title="ubuntu18.04"></a>ubuntu18.04</h3><h4 id="安装crashdump工具包"><a href="#安装crashdump工具包" class="headerlink" title="安装crashdump工具包"></a>安装crashdump工具包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-crashdump</span><br></pre></td></tr></table></figure>
<blockquote>
<p>linux-crashdump实际上安装了三个工具，分别是：crash，kexec-tools，以及makedumpfile</p>
</blockquote>
<h4 id="开启kdump服务"><a href="#开启kdump服务" class="headerlink" title="开启kdump服务"></a>开启kdump服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service kdump start</span><br></pre></td></tr></table></figure>
<h4 id="查看kdump配置"><a href="#查看kdump配置" class="headerlink" title="查看kdump配置"></a>查看kdump配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$kdump-config show</span><br><span class="line">DUMP_MODE:        kdump</span><br><span class="line">USE_KDUMP:        1</span><br><span class="line">KDUMP_SYSCTL:     kernel.panic_on_oops=1</span><br><span class="line">KDUMP_COREDIR:    /var/crash</span><br><span class="line">crashkernel addr: 0x</span><br><span class="line">   /var/lib/kdump/vmlinuz: symbolic link to /boot/vmlinuz-4.15.0-58-generic</span><br><span class="line">kdump initrd:</span><br><span class="line">   /var/lib/kdump/initrd.img: symbolic link to /var/lib/kdump/initrd.img-4.15.0-58-generic</span><br><span class="line">current state:    ready to kdump</span><br><span class="line"></span><br><span class="line">kexec command:</span><br><span class="line">  /sbin/kexec -p --command-line=&quot;BOOT_IMAGE=/vmlinuz-4.15.0-58-generic root=UUID=1ff21bc1-eece-439d-a3ab-de37bc03537f ro quiet splash vt.handoff=1 nr_cpus=1 systemd.unit=kdump-tools-dump.service irqpoll nousb ata_piix.prefer_ms_hyperv=0&quot; --initrd=/var/lib/kdump/initrd.img /var/lib/kdump/vmlinuz</span><br></pre></td></tr></table></figure>
<h4 id="Crash文件分析"><a href="#Crash文件分析" class="headerlink" title="Crash文件分析"></a>Crash文件分析</h4><p>crash工具需要内核调试信息<code>dbgsym</code></p>
<ul>
<li>安装dbgsym，下载<a href="http://ddebs.ubuntu.com/pool/main/l/linux/" target="_blank" rel="noopener">地址</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line">Linux version 4.15.0-58-generic (buildd@lcy01-amd64-013) (gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)) #64-Ubuntu SMP Tue Aug 6 11:12:41 UTC 2019</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://ddebs.ubuntu.com/pool/main/l/linux/linux-image-4.15.0-58-generic-dbgsym_4.15.0-58.64_arm64.ddeb</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i linux-image-unsigned-4.15.0-58-generic-dbgsym_4.15.0-58.64_amd64.ddeb</span><br><span class="line"></span><br><span class="line">$ ls -lsh /usr/lib/debug/boot/vmlinux-4.15.0-58-generic</span><br><span class="line">566M -rw-r--r-- 1 root root 566M 8月   6 18:45 /usr/lib/debug/boot/vmlinux-4.15.0-58-generic</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo crash /usr/lib/debug/boot/vmlinux-4.15.0-58-generic /var/crash/201909041647/dump.201909041647</span><br></pre></td></tr></table></figure>
<h2 id="ubuntu-apport"><a href="#ubuntu-apport" class="headerlink" title="ubuntu apport"></a>ubuntu apport</h2><p><code>apport</code>就是ubuntu上的”crash report”服务，就是当有程序崩溃时弹出的那个发送error report的程序窗口, 并在<code>/var/crash/</code>中将保存一个<code>*.crash</code>的文件，其中存在CoreDump转储文件和当前崩溃程序运行环境的信息，可以解压获取并通过gdb获取相关信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apport-unpack systemGeneratedCrashReportPath.crash yourNewUnpackDirectoryHere</span><br><span class="line">cd yourNewUnpackDirectoryHere/</span><br><span class="line">gdb `cat ExecutablePath` CoreDump #(pay attention to tildes here!)</span><br><span class="line">bt  #(output actual back-trace)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat ExecutablePath</span></span><br><span class="line">/usr/lib/x86_64-linux-gnu/piglit/bin/shader_runner</span><br></pre></td></tr></table></figure>
<h3 id="配置apport"><a href="#配置apport" class="headerlink" title="配置apport"></a>配置apport</h3><blockquote>
<p>默认属于开启状态</p>
</blockquote>
<ul>
<li>关闭<code>crash report</code>服务，修改<code>/etc/default/apport</code>文件中的<code>enabled=0</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># set this to 0 to disable apport, or to 1 to enable it</span><br><span class="line"># you can temporarily override this with</span><br><span class="line"># sudo service apport start force_start=1</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>
<h2 id="定期清理内存-——-桌面卡死"><a href="#定期清理内存-——-桌面卡死" class="headerlink" title="定期清理内存 —— 桌面卡死"></a>定期清理内存 —— 桌面卡死</h2><blockquote>
<p>该操作可能导致部分浏览器页面内容丢失</p>
</blockquote>
<p>主要用于电脑系统内存、交换分区饱满，导致系统桌面卡死的问题</p>
<ul>
<li>清理脚本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">used=`free -m | awk 'NR==2' | awk '&#123;print $3&#125;'`</span><br><span class="line">free=`free -m | awk 'NR==2' | awk '&#123;print $4&#125;'`</span><br><span class="line"></span><br><span class="line">echo "===========================" &gt;&gt; /var/log/mem.log</span><br><span class="line">date &gt;&gt; /var/log/mem.log</span><br><span class="line">echo "Memory usage | [Use：$&#123;used&#125;MB][Free：$&#123;free&#125;MB]" &gt;&gt; /var/log/mem.log</span><br><span class="line"></span><br><span class="line">if [ $free -le 100 ] ; then</span><br><span class="line">	sync &amp;&amp; echo 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">	sync &amp;&amp; echo 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">	sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">	echo "OK" &gt;&gt; /var/log/mem.log</span><br><span class="line">else</span><br><span class="line">	echo "Not required" &gt;&gt; /var/log/mem.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>-定期执行脚本<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">crontab -e</span></span><br><span class="line"><span class="meta">#</span><span class="bash">添加：</span></span><br><span class="line">*/10 * * * * /root/freemem.sh</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>每十分钟执行一次内存清理脚本</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-kdump3/index.html?ca=drs-" target="_blank" rel="noopener">Kdump 实现的基本原理</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-kdump4/index.html?ca=drs-" target="_blank" rel="noopener">kdump 的亲密战友 crash</a></li>
<li><a href="https://www.jianshu.com/p/8e031b28d98b" target="_blank" rel="noopener">CentOS7配置kdump</a></li>
<li><a href="http://www.361way.com/centos-kdump/3751.html" target="_blank" rel="noopener">centos配置kdump捕获内核崩溃</a></li>
<li><a href="https://www.thegeekdiary.com/centos-rhel-7-how-to-configure-kdump/" target="_blank" rel="noopener">CentOS / RHEL 7 : How to configure kdump</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>死机</tag>
      </tags>
  </entry>
  <entry>
    <title>boost asio for anbox</title>
    <url>/post/31474.html</url>
    <content><![CDATA[<p>Boost.Asio是用于<code>网络</code>和<code>低层IO</code>编程的跨平台C++库,为开发者提供了C++环境下稳定的<code>异步模型</code>。</p>
<a id="more"></a>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p><code>io_service</code>对象是asio框架中的<code>调度器</code>，所有异步io事件都是通过它来分发处理的（io对象的构造函数中都需要传入一个io_service对象）, 其提供着是一个<code>生产者消费者模型</code>。<br><code>io_service</code>类在多线程编程模型中提供了任务队列和任务分发功能,最常用的接口：<code>run</code>、<code>post</code>、<code>stop</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boost::asio::io_service io_service;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_service)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="同步IO处理"><a href="#同步IO处理" class="headerlink" title="同步IO处理"></a>同步IO处理</h3><p><img src="/images/2020/02/asio_socket_sync.png" alt="asio_socket_sync"></p>
<ol>
<li>应用程序调用IO对象成员函数执行IO操作</li>
<li>IO对象向io_service 提出请求.</li>
<li>io_service 调用操作系统的功能<code>执行连接</code>操作.</li>
<li>操作系统向io_service 返回执行结果.</li>
<li>io_service将错误的操作结果翻译为boost::system::error_code类型，再传递给IO对象.</li>
<li>如果操作失败,IO对象抛出boost::system::system_error类型的异常.</li>
</ol>
<h3 id="异步IO处理"><a href="#异步IO处理" class="headerlink" title="异步IO处理"></a>异步IO处理</h3><p><img src="/images/2020/02/asio_socket_async.png" alt="asio_socket_async"></p>
<ol>
<li>应用程序调用IO对象成员函数执行IO操作</li>
<li>IO对象请求io_service的服务</li>
<li>io_service 通知操作系统其需要开始一个<code>异步连接</code>操作.</li>
<li>操作系统指示连接操作完成, io_service从队列中获取操作结果</li>
<li>应用程序必须调用io_service::run()以便于接收结果</li>
<li>调用io_service::run()后,io_service返回一个操作结果,并将其翻译为error_code,传递到事件回调函数中</li>
</ol>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><ul>
<li>post</li>
</ul>
<p>post用于发布io事件，如timer，socket读写等，一般由asio框架相应对象调用，无需我们显式调用。</p>
<ul>
<li>run</li>
</ul>
<p>run用于<code>监听io事件</code>响应，并执行响应回调，对于异步io操作需要在代码中显式调用，对于同步io操作则由io对象隐式调用（并不是run函数，不过也是等待io事件）。</p>
<h2 id="boost-asio-io-service"><a href="#boost-asio-io-service" class="headerlink" title="boost::asio::io_service"></a>boost::asio::io_service</h2><p><code>io_service</code>类在多线程编程里面提供了<code>任务队列</code>和<code>任务分发</code>功能，在socket、io编程里主要作为一个事件驱动器(完成端口、select、poll、epoll等)。</p>
<p><img src="/images/2020/02/asio_io_service.png" alt="asio_io_service"></p>
<blockquote>
<p><code>io_service</code>都一个公有任务队列，和多个私有任务队列，公有队列由各个线程共享，私有队列则是每个线程独享</p>
</blockquote>
<ol>
<li>调用run方法，进入主loop；</li>
<li>判断公有队列是否为空，不为空则取出任务并执行，当任务数大于1时同时唤醒其他空闲线程；</li>
<li>任务执行结束，把各个线程的私有队里面的任务移动到公有任务队列里面；</li>
<li>触发reactor，linux下面一般是<code>epoll</code>，当有事件时，把相应的事件的任务放到私有队列里。</li>
<li>当队列为空时，把当前线程加到空闲线程队列里面，同时进入wait状态，等待其他线程的唤醒（task_operation）。</li>
<li>当用户调用post时，任务是直接投递到公有队列op_queue里面。</li>
</ol>
<h2 id="Anbox-IO模型"><a href="#Anbox-IO模型" class="headerlink" title="Anbox IO模型"></a>Anbox IO模型</h2><p>Anbox 的 I/O 模型基于 boost.asio 构建。Anbox 中所有的 I/O 事件，在一个线程池中，通过一个<code>boost::asio::io_service</code>对象来派发并处理。Anbox 用<code>anbox::Runtime</code>类封装一个 <code>boost::asio::io_service</code>对象，并管理执行任务的<code>线程池</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> anbox &#123;</span><br><span class="line"><span class="comment">// We bundle our "global" runtime dependencies here, specifically</span></span><br><span class="line"><span class="comment">// a dispatcher to decouple multiple in-process providers from one</span></span><br><span class="line"><span class="comment">// another , forcing execution to a well known set of threads.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> :</span> <span class="keyword">public</span> DoNotCopyOrMove,</span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Runtime&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Our default concurrency setup.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">uint32_t</span> worker_threads = <span class="number">8</span>;</span><br><span class="line">  <span class="comment">// create returns a Runtime instance with pool_size worker threads</span></span><br><span class="line">  <span class="comment">// executing the underlying service.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Runtime&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="built_in">std</span>::<span class="keyword">uint32_t</span> pool_size = worker_threads)</span></span>;</span><br><span class="line">  <span class="comment">// Tears down the runtime, stopping all worker threads.</span></span><br><span class="line">  ~Runtime() <span class="keyword">noexcept</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// start executes the underlying io_service on a thread pool with</span></span><br><span class="line">  <span class="comment">// the size configured at creation time.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// stop cleanly shuts down a Runtime instance.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// to_dispatcher_functional returns a function for integration</span></span><br><span class="line">  <span class="comment">// with components that expect a dispatcher for operation.</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::function&lt;<span class="title">void</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;)</span>&gt; <span class="title">to_dispatcher_functional</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// service returns the underlying boost::asio::io_service that is executed</span></span><br><span class="line">  <span class="comment">// by the Runtime.</span></span><br><span class="line">  boost::<span class="function">asio::io_service&amp; <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Runtime constructs a new instance, firing up pool_size</span></span><br><span class="line">  <span class="comment">// worker threads.</span></span><br><span class="line">  Runtime(<span class="built_in">std</span>::<span class="keyword">uint32_t</span> pool_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">uint32_t</span> pool_size_;</span><br><span class="line">  boost::asio::io_service service_;</span><br><span class="line">  boost::asio::io_service::strand strand_;</span><br><span class="line">  boost::asio::io_service::work keep_alive_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; workers_;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace anbox</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: anbox/src/anbox/runtime.h</p>
</blockquote>
<p><code>anbox::Runtime</code> 类封装了一个 <code>boost::asio::io_service</code> 对象及多个工作线程 <code>std::thread</code>，它还继承 <code>std::enable_shared_from_this</code> 以获得从 <code>this</code> 指针创建智能指针 <code>std::shared_ptr</code> 的能力，同时继承了 <code>DoNotCopyOrMove</code>，以禁掉类的拷贝和移动操作。</p>
<p><code>anbox::Runtime</code> 类有两大职责:</p>
<ul>
<li>一是 <code>boost::asio::io_service</code> 对象的生命周期管理；</li>
<li>二是向 <code>boost::asio::io_service</code> 中提交任务。</li>
</ul>
<p>在 <code>anbox::Runtime::start()</code> 函数中创建并启动多个线程，执行一个执行 <code>boost::asio::io_service::run()</code> 函数的函数 <code>exception_safe_run()</code>。在 <code>anbox::Runtime::stop()</code> 函数中停掉 <code>boost::asio::io_service</code> 的执行。<code>anbox::Runtime</code> 的析够函数中，还会调用 <code>stop()</code> 函数停掉 <code>boost::asio::io_service</code> 的执行。<code>anbox::Runtime</code> 的类型为 <code>boost::asio::io_service::work</code> 的成员变量 <code>keep_alive_</code> 也是用于管理 <code>boost::asio::io_service</code> 对象的生命周期的，该对象在析够时也会停掉 <code>boost::asio::io_service</code> 的执行。</p>
<p>Anbox 的 I/O 模型可以理解为，底层有一个多路复用器或事件循环 <code>boost::asio::io_service</code>，有一个包含了 8 个线程的线程池基于此 <code>boost::asio::io_service</code> 运行，处理 I/O 事件及其它各种类型的任务。</p>
<p>Anbox 需要处理如下这样一些网络 I/O 过程：</p>
<ul>
<li>监听 Unix 域 Socket 接受连接。Anbox 的 SessionManager 通过 Unix 域 Socket 与 ContainerManager 进行通信，同时也通过 Unix 域 Socket 与 ContainerManager 启动的 Android 容器内的应用程序通信。首先 ContainerManager 监听在特定位置的 Unix 域 Socket 上。随后 SessionManager 监听几个位置上的 Unix 域 Socket，然后请求 ContainerManager 启动 Android 容器，并将这几个 Unix 域 Socket 映射到容器内的 <code>/dev/</code> 目录下。Android 容器启动后，一些进程，如 surfaceflinger、cameraservice 等连接这些 Unix 域 Socket，并通过这些 Unix 域 Socket 与 SessionManager 通信，进而操作宿主机的硬件设备。</li>
<li>监听 TCP Socket 接受连接。Anbox 的 SessionManager 作为容器中运行的 Android 与 ADB 进行通信的桥梁，它在与容器中运行的 Android 通过 Unix 域 Socket 通信的同时，也需要与宿主机上的 ADB 通信。SessionManager 通过 TCP 与宿主机上的 ADB 守护进程通信。如同模拟器等 Android 设备一样，SessionManager 遵从 ADB 的通信协议，在发起与 ADB 之间的 TCP 连接的同时，也需要监听一个 TCP 端口，等待 ADB 守护进程发起的连接，以完成整个 ADB 协议。</li>
<li>处理从监听的 Unix 域 Socket 接受的 Unix 域 Socket。监听的 Unix 域 Socket 接受新连接之后，需要将新创建的 Unix 域 Socket 提交给底层的 I/O 多路复用器，并为该 Socket 提供读写等 I/O 事件处理处理回调，以完成 Anbox 的应用逻辑。</li>
<li>处理从监听的 TCP Scoket 接受的 TCP Socket。监听的 TCP Socket 接受新连接之后，需要将新创建的 TCP Socket 提交给底层的 I/O 多路复用器，并为该 Socket 提供读写等 I/O 事件处理处理回调，以完成 Anbox 的应用逻辑。</li>
<li>发起一个到 TCP 服务器的连接。如前面提到的，Anbox 的 SessionManager 通过 TCP 连接与 ADB 守护进程通信，它会先发起一个到 ADB 守护进程的 TCP 连接。</li>
<li>发起一个到 Unix 域 Socket 服务的连接。Anbox 的 SessionManager 与 ContainerManager 之间通过 Unix 域 Socket 通信，SessionManager 会发起到 ContainerManager 监听的 Unix 域 Socket 服务的连接。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://charette.no-ip.com:81/programming/doxygen/boost/classboost_1_1asio_1_1io__service_1_1strand.html" target="_blank" rel="noopener">boost::asio::io_service::strand Class Reference</a></li>
<li><a href="https://www.boost.org/doc/libs/1_72_0/doc/html/boost_asio.html" target="_blank" rel="noopener">Boost.Asio</a></li>
<li><a href="https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/Chapter1.html" target="_blank" rel="noopener">Boost.Asio入门</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
        <tag>anbox</tag>
        <tag>c++</tag>
        <tag>asio</tag>
      </tags>
  </entry>
  <entry>
    <title>X Sever —— Xorg</title>
    <url>/post/39845.html</url>
    <content><![CDATA[<p>Xorg：基于<code>X11</code>协议的服务端。管理硬件设备（驱动），键盘鼠标显示器等</p>
<a id="more"></a>
<h2 id="Xorg配置文件"><a href="#Xorg配置文件" class="headerlink" title="Xorg配置文件"></a>Xorg配置文件</h2><p>生成配置文件<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Xorg -configure :0</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>:0</code>显示窗口，在Xorg启动的情况下，无法获取当前的Xorg配置文件，可以随意指定数字</p>
</blockquote>
<h3 id="xorg-conf"><a href="#xorg-conf" class="headerlink" title="xorg.conf"></a>xorg.conf</h3><blockquote>
<p>具体参数说明：<code>man xorg.conf</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Section &quot;ServerLayout&quot;</span><br><span class="line">	Identifier     &quot;X.org Configured&quot;</span><br><span class="line">	Screen      0  &quot;Screen0&quot; 0 0</span><br><span class="line">	Screen      1  &quot;Screen1&quot; RightOf &quot;Screen0&quot;</span><br><span class="line">	InputDevice    &quot;Mouse0&quot; &quot;CorePointer&quot;</span><br><span class="line">	InputDevice    &quot;Keyboard0&quot; &quot;CoreKeyboard&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Files&quot;</span><br><span class="line">	ModulePath   &quot;/usr/lib/xorg/modules&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/misc&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/cyrillic&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/100dpi/:unscaled&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/75dpi/:unscaled&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/Type1&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/100dpi&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/75dpi&quot;</span><br><span class="line">	FontPath     &quot;built-ins&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Module&quot;</span><br><span class="line">	Load  &quot;glx&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;InputDevice&quot;</span><br><span class="line">	Identifier  &quot;Keyboard0&quot;</span><br><span class="line">	Driver      &quot;kbd&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;InputDevice&quot;</span><br><span class="line">	Identifier  &quot;Mouse0&quot;</span><br><span class="line">	Driver      &quot;mouse&quot;</span><br><span class="line">	Option	    &quot;Protocol&quot; &quot;auto&quot;</span><br><span class="line">	Option	    &quot;Device&quot; &quot;/dev/input/mice&quot;</span><br><span class="line">	Option	    &quot;ZAxisMapping&quot; &quot;4 5 6 7&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">	Identifier   &quot;Monitor0&quot;</span><br><span class="line">	VendorName   &quot;Monitor Vendor&quot;</span><br><span class="line">	ModelName    &quot;Monitor Model&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">	Identifier   &quot;Monitor1&quot;</span><br><span class="line">	VendorName   &quot;Monitor Vendor&quot;</span><br><span class="line">	ModelName    &quot;Monitor Model&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">        ### Available Driver options are:-</span><br><span class="line">        ### Values: &lt;i&gt;: integer, &lt;f&gt;: float, &lt;bool&gt;: &quot;True&quot;/&quot;False&quot;,</span><br><span class="line">        ### &lt;string&gt;: &quot;String&quot;, &lt;freq&gt;: &quot;&lt;f&gt; Hz/kHz/MHz&quot;,</span><br><span class="line">        ### &lt;percent&gt;: &quot;&lt;f&gt;%&quot;</span><br><span class="line">        ### [arg]: arg optional</span><br><span class="line">        #Option     &quot;Accel&quot;              	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;SWcursor&quot;           	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;EnablePageFlip&quot;     	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;SubPixelOrder&quot;      	# [&lt;str&gt;]</span><br><span class="line">        #Option     &quot;ZaphodHeads&quot;        	# &lt;str&gt;</span><br><span class="line">        #Option     &quot;AccelMethod&quot;        	# &lt;str&gt;</span><br><span class="line">        #Option     &quot;DRI3&quot;               	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;DRI&quot;                	# &lt;i&gt;</span><br><span class="line">        #Option     &quot;ShadowPrimary&quot;      	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;TearFree&quot;           	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;DeleteUnusedDP12Displays&quot; 	# [&lt;bool&gt;]</span><br><span class="line">	Identifier  &quot;Card0&quot;</span><br><span class="line">	Driver      &quot;amdgpu&quot;</span><br><span class="line">	BusID       &quot;PCI:1:0:0&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">        ### Available Driver options are:-</span><br><span class="line">        ### Values: &lt;i&gt;: integer, &lt;f&gt;: float, &lt;bool&gt;: &quot;True&quot;/&quot;False&quot;,</span><br><span class="line">        ### &lt;string&gt;: &quot;String&quot;, &lt;freq&gt;: &quot;&lt;f&gt; Hz/kHz/MHz&quot;,</span><br><span class="line">        ### &lt;percent&gt;: &quot;&lt;f&gt;%&quot;</span><br><span class="line">        ### [arg]: arg optional</span><br><span class="line">        #Option     &quot;Accel&quot;              	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;SWcursor&quot;           	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;EnablePageFlip&quot;     	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;SubPixelOrder&quot;      	# [&lt;str&gt;]</span><br><span class="line">        #Option     &quot;ZaphodHeads&quot;        	# &lt;str&gt;</span><br><span class="line">        #Option     &quot;AccelMethod&quot;        	# &lt;str&gt;</span><br><span class="line">        #Option     &quot;DRI3&quot;               	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;DRI&quot;                	# &lt;i&gt;</span><br><span class="line">        #Option     &quot;ShadowPrimary&quot;      	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;TearFree&quot;           	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;DeleteUnusedDP12Displays&quot; 	# [&lt;bool&gt;]</span><br><span class="line">	Identifier  &quot;Card1&quot;</span><br><span class="line">	Driver      &quot;amdgpu&quot;</span><br><span class="line">	BusID       &quot;PCI:1:0:1&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">	Identifier &quot;Screen0&quot;</span><br><span class="line">	Device     &quot;Card0&quot;</span><br><span class="line">	Monitor    &quot;Monitor0&quot;</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     1</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     4</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     8</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     15</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     16</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     24</span><br><span class="line">	EndSubSection</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">	Identifier &quot;Screen1&quot;</span><br><span class="line">	Device     &quot;Card1&quot;</span><br><span class="line">	Monitor    &quot;Monitor1&quot;</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     1</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     4</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     8</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     15</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     16</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     24</span><br><span class="line">	EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：在<code>xorg.conf</code>中配置显卡总线地址<code>BusID</code>时，必须以<code>十进制</code>表示，比如<code>lspci</code>总线地址（以十六进制显示）为<code>91:00.0</code>，将其转换为十进制<code>145:00:0</code>（16x9+1）配置在xorg.conf中。<br>细节有两点:</p>
<ol>
<li>总线地址的进制转换(十六进制转十进制)</li>
<li>总线地址的分隔符,在xorg.conf中,地址均为<code>:</code>分隔</li>
</ol>
</blockquote>
<ul>
<li><p><code>Driver</code>的选择必须根据使用的显卡和系统的支持情况配置,在系统不支持的情况下可以使用<code>modesetting</code>代替测试，不一定配置成功</p>
<ul>
<li><p>centos系统支持的驱动在<code>/lib64/xorg/modules/drivers/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls /lib64/xorg/modules/drivers/</span></span><br><span class="line">ati_drv.so  dummy_drv.so  fbdev_drv.so  modesetting_drv.so  nouveau_drv.so  qxl_drv.so  radeon_drv.so  v4l_drv.so</span><br></pre></td></tr></table></figure>
</li>
<li><p>ubuntu系统支持的驱动在<code>/usr/lib/xorg/modules/drivers/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /usr/lib/xorg/modules/drivers/</span><br><span class="line">amdgpu_drv.so  ati_drv.so  fbdev_drv.so  intel_drv.so  modesetting_drv.so  nouveau_drv.so  qxl_drv.so  radeon_drv.so  vesa_drv.so  vmware_drv.so</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$man Xorg</span><br><span class="line">$man xorg.conf</span><br><span class="line">$man Xserver</span><br><span class="line">$man modesetting</span><br><span class="line">$man fbdevhw</span><br><span class="line">$man Xwrapper.config</span><br><span class="line"></span><br><span class="line">$man Xephyr</span><br><span class="line">$man exa</span><br><span class="line">$man cvt</span><br><span class="line">$man gtf</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Xephyr</code>: X服务器输出到预先存在的X显示器上的窗口</li>
</ul>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># nvidia-settings: X configuration file generated by nvidia-settings</span><br><span class="line"># nvidia-settings:  version 440.82</span><br><span class="line"></span><br><span class="line">Section &quot;ServerLayout&quot;</span><br><span class="line">    Identifier     &quot;Layout0&quot;</span><br><span class="line">    Screen      0  &quot;Screen0&quot; 0 0</span><br><span class="line">    InputDevice    &quot;Keyboard0&quot; &quot;CoreKeyboard&quot;</span><br><span class="line">    InputDevice    &quot;Mouse0&quot; &quot;CorePointer&quot;</span><br><span class="line">    Option         &quot;Xinerama&quot; &quot;0&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Files&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;InputDevice&quot;</span><br><span class="line">    # generated from default</span><br><span class="line">    Identifier     &quot;Mouse0&quot;</span><br><span class="line">    Driver         &quot;mouse&quot;</span><br><span class="line">    Option         &quot;Protocol&quot; &quot;auto&quot;</span><br><span class="line">    Option         &quot;Device&quot; &quot;/dev/input/mice&quot;</span><br><span class="line">    Option         &quot;Emulate3Buttons&quot; &quot;no&quot;</span><br><span class="line">    Option         &quot;ZAxisMapping&quot; &quot;4 5&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;InputDevice&quot;</span><br><span class="line">    # generated from default</span><br><span class="line">    Identifier     &quot;Keyboard0&quot;</span><br><span class="line">    Driver         &quot;kbd&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">    # HorizSync source: edid, VertRefresh source: edid</span><br><span class="line">    Identifier     &quot;Monitor0&quot;</span><br><span class="line">    VendorName     &quot;Unknown&quot;</span><br><span class="line">    ModelName      &quot;Philips PHL 237E7&quot;</span><br><span class="line">    HorizSync       30.0 - 83.0</span><br><span class="line">    VertRefresh     56.0 - 76.0</span><br><span class="line">    Option         &quot;DPMS&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">    Identifier     &quot;Device0&quot;</span><br><span class="line">    Driver         &quot;nvidia&quot;</span><br><span class="line">    VendorName     &quot;NVIDIA Corporation&quot;</span><br><span class="line">    BoardName      &quot;Quadro P6000&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">    Identifier     &quot;Screen0&quot;</span><br><span class="line">    Device         &quot;Device0&quot;</span><br><span class="line">    Monitor        &quot;Monitor0&quot;</span><br><span class="line">    DefaultDepth    24</span><br><span class="line">    Option         &quot;Stereo&quot; &quot;0&quot;</span><br><span class="line">    Option         &quot;nvidiaXineramaInfoOrder&quot; &quot;DFP-8&quot;</span><br><span class="line">    Option         &quot;metamodes&quot; &quot;DP-5: nvidia-auto-select +1920+0, DP-7: nvidia-auto-select +0+0&quot;</span><br><span class="line">    Option         &quot;SLI&quot; &quot;Off&quot;</span><br><span class="line">    Option         &quot;MultiGPU&quot; &quot;Off&quot;</span><br><span class="line">    Option         &quot;BaseMosaic&quot; &quot;off&quot;</span><br><span class="line">    SubSection     &quot;Display&quot;</span><br><span class="line">      Depth       24</span><br><span class="line">    EndSection</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">startx -- -layout seat0 -seat seat0 -novtswitch -sharevts</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数详解： <code>man Xorg</code></p>
</blockquote>
<ul>
<li><code>-novtswitch</code>: 如果操作系统支持，请禁用自动启动服务器时将X服务器重置和关机自动切换到激活的VT的功能</li>
<li><code>-sharevts</code>: 如果操作系统支持，则与另一个X服务器共享虚拟终端。</li>
</ul>
<h2 id="xinitrc"><a href="#xinitrc" class="headerlink" title="xinitrc"></a>xinitrc</h2><blockquote>
<p><code>$HOME/.xinitrc</code>指定启动的桌面环境,比如xterm</p>
</blockquote>
<p><code>~/.xinitrc</code>由xinit执行，通常通过startx调用。 登录后将执行该程序：首先登录文本控制台，然后使用startx启动GUI。<code>.xinitrc</code>的作用是启动会话的GUI部分，通常是通过设置一些与GUI相关的设置，例如键绑定（使用xmodmap或xkbcomp），X资源（使用xrdb）等，以及启动会话管理器或窗口管理器（可能是桌面环境的一部分）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> xinit /etc/X11/xinitrc -- /usr/bin/X :1 -config /etc/X11/xorg.conf.new -novtswitch -sharevts vt2 -keeptty -listen tcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> X :1 -config /etc/X11/xorg.conf.new -novtswitch -sharevts vt2 -keeptty -listen tcp</span></span><br></pre></td></tr></table></figure>
<h3 id="窗口管理器"><a href="#窗口管理器" class="headerlink" title="窗口管理器"></a>窗口管理器</h3><ul>
<li>fvwm:虚拟窗口管理器,占用资源少</li>
<li>twm:(Tab Window Manager for the X Window System)</li>
</ul>
<h2 id="驱动模块——Driver"><a href="#驱动模块——Driver" class="headerlink" title="驱动模块——Driver"></a>驱动模块——Driver</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ls /usr/lib/xorg/modules/drivers/</span></span><br><span class="line">amdgpu_drv.so  ati_drv.so  fbdev_drv.so  intel_drv.so  modesetting_drv.so  nouveau_drv.so  qxl_drv.so  radeon_drv.so  vesa_drv.so  vmware_drv.so</span><br></pre></td></tr></table></figure>
<p>每一个驱动模块的详细信息，可以通过<code>man</code>手册进行查看，比如<code>man modesetting</code>、<code>man intel</code>、<code>man amdgpu</code>等</p>
<h3 id="modesetting"><a href="#modesetting" class="headerlink" title="modesetting"></a>modesetting</h3><blockquote>
<p><code>modesetting</code> is an Xorg driver for KMS devices.</p>
</blockquote>
<p>The modesetting driver supports all hardware where a KMS driver is available. modesetting uses the Linux DRM KMS ioctls and dumb object create/map.</p>
<p>modesetting是KMS设备的Xorg驱动程序。 该驱动程序支持在帧缓冲区深度为15、16、24和30的TrueColor视觉效果。multi-head配置支持RandR 1.2。 对于至少支持OpenGL ES 2.0或OpenGL 2.1的设备，可以通过glamor进行加速。 如果未启用魅力，则根据KMS驱动程序的偏好配置阴影帧缓冲区（除非帧缓冲区为每像素24位，在这种情况下始终使用阴影帧缓冲区）。</p>
<h3 id="vesa"><a href="#vesa" class="headerlink" title="vesa"></a>vesa</h3><p><code>vesa</code>是用于通用VESA视频卡的Xorg驱动程序。 它可以驱动大多数与VESA兼容的视频卡，但仅使用这些卡通用的基本标准VESA内核。驱动程序支持深度8、15、16和24。</p>
<h3 id="Driver配置的缺失"><a href="#Driver配置的缺失" class="headerlink" title="Driver配置的缺失"></a>Driver配置的缺失</h3><p>如果在xorg.conf的配置中将Driver字段的配置缺失，系统会默认选择加载<code>modeseting</code>、<code>fbdev</code>、<code>vesa</code>驱动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Section &quot;Device&quot;</span><br><span class="line">  Identifier &quot;devname&quot;</span><br><span class="line">  #Driver &quot;modesetting&quot; #将该字段注释掉，Xorg将自动进行加载</span><br><span class="line">  BusID  &quot;pci:bus:dev:func&quot;</span><br><span class="line">  ...</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">(II) xfree86: Adding drm device (/dev/dri/card2)</span><br><span class="line">(II) Platform probe for /sys/devices/pci0000:ae/0000:ae:00.0/0000:af:00.0/0000:b0:10.0/0000:bb:00.0/0000:bc:01.0/0000:bd:00.0/drm/card2</span><br><span class="line">(II) &quot;glx&quot; will be loaded. This was enabled by default and also specified in the config file.</span><br><span class="line">(II) LoadModule: &quot;glx&quot;</span><br><span class="line">(II) Loading /usr/lib64/xorg/modules/extensions/libglx.so</span><br><span class="line">(II) Module glx: vendor=&quot;X.Org Foundation&quot;</span><br><span class="line">   compiled for 1.20.4, module version = 1.0.0</span><br><span class="line">   ABI class: X.Org Server Extension, version 10.0</span><br><span class="line"></span><br><span class="line">(==) Matched modesetting as autoconfigured driver 0</span><br><span class="line">(==) Matched fbdev as autoconfigured driver 1</span><br><span class="line">(==) Matched vesa as autoconfigured driver 2</span><br><span class="line">(==) Assigned the driver to the xf86ConfigLayout</span><br><span class="line"></span><br><span class="line">(II) LoadModule: &quot;modesetting&quot;</span><br><span class="line">(II) Loading /usr/lib64/xorg/modules/drivers/modesetting_drv.so</span><br><span class="line">(II) Module modesetting: vendor=&quot;X.Org Foundation&quot;</span><br><span class="line">   compiled for 1.20.4, module version = 1.20.4</span><br><span class="line">   Module class: X.Org Video Driver</span><br><span class="line">   ABI class: X.Org Video Driver, version 24.0</span><br><span class="line">(II) LoadModule: &quot;fbdev&quot;</span><br><span class="line">(II) Loading /usr/lib64/xorg/modules/drivers/fbdev_drv.so</span><br><span class="line">(II) Module fbdev: vendor=&quot;X.Org Foundation&quot;</span><br><span class="line">   compiled for 1.20.1, module version = 0.5.0</span><br><span class="line">   Module class: X.Org Video Driver</span><br><span class="line">   ABI class: X.Org Video Driver, version 24.0</span><br><span class="line">(II) LoadModule: &quot;vesa&quot;</span><br><span class="line">(II) Loading /usr/lib64/xorg/modules/drivers/vesa_drv.so</span><br><span class="line">(II) Module vesa: vendor=&quot;X.Org Foundation&quot;</span><br><span class="line">   compiled for 1.20.1, module version = 2.4.0</span><br><span class="line">   Module class: X.Org Video Driver</span><br><span class="line">   ABI class: X.Org Video Driver, version 24.0</span><br><span class="line">(II) modesetting: Driver for Modesetting Kernel Drivers: kms</span><br><span class="line">(II) FBDEV: driver for framebuffer: fbdev</span><br><span class="line">(II) VESA: driver for VESA chipsets: vesa</span><br><span class="line">(II) modeset(0): using drv /dev/dri/card2</span><br></pre></td></tr></table></figure>
<h2 id="DISPLAY环境变量"><a href="#DISPLAY环境变量" class="headerlink" title="DISPLAY环境变量"></a>DISPLAY环境变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export DISPLAY=:0</span><br><span class="line">export DISPLAY=192.168.1.1:0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export DISPLAY=[hostname][:number[.screen_number]]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hostname</code>: 指定物理连接显示器的主机的名称, 主机名后加上单冒号（:)或双冒号（::)。</li>
<li><code>number</code>: 指定该主机上Xserver的编号,在此显示编号后加上句点(.),一个CPU可以有多个显示器, 多个显示通常从零开始编号。</li>
<li><code>screen_number</code>: 指定要在该服务器上使用的屏幕, 单个Xserver可以控制多个屏幕, screen_number设置一个内部变量，如果使用的是C以外的语言，则可以使用<code>DefaultScreen()</code>宏或<code>XDefaultScreen()</code>函数进行访问（请参见“(Display Macros)[<a href="https://tronche.com/gui/x/xlib/display/information.html#display]”）。" target="_blank" rel="noopener">https://tronche.com/gui/x/xlib/display/information.html#display]”）。</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/a379039233/article/details/80782351" target="_blank" rel="noopener">X,X11,Xorg,XServer,XClient,Xlib</a></li>
<li><a href="https://www.cnblogs.com/uetucci/p/7794335.html" target="_blank" rel="noopener">Linux学习-X Server 配置文件解析与设定</a></li>
<li><a href="https://blog.csdn.net/seaship/article/details/95481154" target="_blank" rel="noopener">xorg的配置文件</a></li>
<li><a href="https://blog.csdn.net/ohappytime/article/details/7384001" target="_blank" rel="noopener">xorg.conf 配置详解</a></li>
<li><a href="https://www.cnblogs.com/rickerliang/p/5673015.html" target="_blank" rel="noopener">nvidia gpu fan speed control</a></li>
<li><a href="http://http.download.nvidia.com/XFree86/Linux-x86/1.0-8774/README/appendix-d.html" target="_blank" rel="noopener">Appendix D. X Config Options</a></li>
<li><a href="https://www.x.org/releases/current/doc/man/man5/xorg.conf.5.xhtml" target="_blank" rel="noopener">xorg.conf</a></li>
<li><a href="https://unix.stackexchange.com/questions/281858/difference-between-xinitrc-xsession-and-xsessionrc" target="_blank" rel="noopener">Difference between .xinitrc, .xsession and .xsessionrc</a></li>
<li><a href="https://download.nvidia.com/XFree86/Linux-x86_64/304.137/README/configtwinview.html" target="_blank" rel="noopener">Chapter 13. Configuring Multiple Display Devices on One X Screen</a></li>
<li><a href="https://tronche.com/gui/x/xlib/display/opening.html" target="_blank" rel="noopener">Opening the Display</a></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
        <category>Xorg</category>
      </categories>
      <tags>
        <tag>x11</tag>
        <tag>xorg</tag>
      </tags>
  </entry>
  <entry>
    <title>mesa框架与目录结构</title>
    <url>/post/39ae47e2.html</url>
    <content><![CDATA[<p><code>mesa</code>在平台实现OpenGL接口的实现.官网:<a href="https://mesa3d.org" target="_blank" rel="noopener">https://mesa3d.org</a></p>
<a id="more"></a>
<p>由于工作原因接触到mesa,在这里主要记录一下最近对mesa整体框架的一些认识和其整个目录的结构,可能有些理解错误以后慢慢更新.</p>
<ul>
<li>整体框架组成</li>
<li>目录结构</li>
</ul>
<p>mesa版本:<code>20.2.0-devel</code>(代码库最新代码)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://gitlab.freedesktop.org/mesa/mesa.git</span><br></pre></td></tr></table></figure>
<h2 id="mesa框架"><a href="#mesa框架" class="headerlink" title="mesa框架"></a>mesa框架</h2><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul>
<li><strong>docs</strong> - Documentation</li>
<li><strong>include</strong> - Public OpenGL header files</li>
<li><strong>src</strong><ul>
<li><strong>amd</strong> - AMD-specific sources<ul>
<li><strong>addrlib</strong> - common sources for creating images</li>
<li><strong>common</strong> - common code between RADV, radeonsi and ACO</li>
<li><strong>compiler</strong> - ACO shader compiler</li>
<li><strong>llvm</strong> - common code between RADV and radeonsi for compiling shaders using LLVM</li>
<li><strong>registers</strong> - register definitions</li>
<li><strong>vulkan</strong> - RADV Vulkan implementation for AMD Southern Island and newer</li>
</ul>
</li>
<li><strong>compiler</strong> - Common utility sources for different compilers.<ul>
<li><strong>glsl</strong> - the GLSL IR and compiler</li>
<li><strong>nir</strong> - the NIR IR and compiler</li>
<li><strong>spirv</strong> - the SPIR-V compiler</li>
</ul>
</li>
<li><strong>egl</strong> - EGL library sources<ul>
<li><strong>drivers</strong> - EGL drivers</li>
<li><strong>main</strong> - main EGL library implementation. This is where all the EGL API functions are implemented, like eglCreateContext().</li>
</ul>
</li>
<li><strong>freedreno</strong> - Adreno-specific sources<ul>
<li><strong>fdl</strong> - mipmap layout manager</li>
<li><strong>vulkan</strong> - Turnip is a Vulkan implementation for Qualcomm Adreno</li>
</ul>
</li>
<li><strong>gbm</strong> - Generic Buffer Manager is a memory allocator for device buffers</li>
<li><strong>intel</strong> - Intel-specific sources<ul>
<li><strong>blorp</strong> - BLit Or Resolve Pass is a blit and HiZ resolve framework</li>
<li><strong>vulkan</strong> - Anvil is a Vulkan implementation for Intel gen 7 (Ivy Bridge) and newer</li>
</ul>
</li>
<li><strong>mapi</strong> - Mesa APIs<ul>
<li><strong>glapi</strong> - OpenGL API dispatch layer. This is where all the GL entrypoints like glClear, glBegin, etc. are generated, as well as the GL dispatch table. All GL function calls jump through the dispatch table to functions found in main/.</li>
</ul>
</li>
<li><strong>mesa</strong> - Main Mesa sources<ul>
<li><strong>main</strong> - The core Mesa code (mainly state management)</li>
<li><strong>drivers</strong> - Mesa drivers (not used with Gallium)<ul>
<li><strong>common</strong> - code which may be shared by all drivers</li>
<li><strong>dri</strong> - Direct Rendering Infrastructure drivers<ul>
<li><strong>common</strong> - code shared by all DRI drivers</li>
<li><strong>i915</strong> - driver for Intel i915/i945</li>
<li><strong>i965</strong> - driver for Intel i965</li>
<li><strong>nouveau</strong> - driver for nVidia nv04/nv10/nv20</li>
<li><strong>radeon</strong> - driver for ATI R100</li>
<li><strong>r200</strong> - driver for ATI R200</li>
<li><strong>swrast</strong> - software rasterizer driver that uses the swrast module</li>
</ul>
</li>
<li><strong>x11</strong> - Xlib-based software driver</li>
<li><strong>osmesa</strong> - off-screen software driver</li>
</ul>
</li>
<li><strong>math</strong> - vertex array translation and transformation code (not used with Gallium)</li>
<li><strong>program</strong> - Vertex/fragment shader and GLSL compiler code</li>
<li><strong>sparc</strong> - Assembly code/optimizations for SPARC systems (not used with Gallium)</li>
<li><strong>state_tracker</strong> - Translator from Mesa to Gallium. This is basically a Mesa device driver that speaks to Gallium. This directory may be moved to src/mesa/drivers/gallium at some point.</li>
<li><strong>swrast</strong> - Software rasterization module. For drawing points, lines, triangles, bitmaps, images, etc. in software. (not used with Gallium)</li>
<li><strong>swrast_setup</strong> - Software primitive setup. Does things like polygon culling, glPolygonMode, polygon offset, etc. (not used with Gallium)</li>
<li><strong>tnl</strong> - Software vertex Transformation ‘n Lighting. (not used with Gallium)</li>
<li><strong>tnl_dd</strong> - TNL code for device drivers. (not used with Gallium)</li>
<li><strong>vbo</strong> - Vertex Buffer Object code. All drawing with glBegin/glEnd, glDrawArrays, display lists, etc. goes through this module. The results is a well-defined set of vertex arrays which are passed to the device driver (or tnl module) for rendering.</li>
<li><strong>x86</strong> - Assembly code/optimizations for 32-bit x86 systems (not used with Gallium)</li>
<li><strong>x86-64</strong> - Assembly code/optimizations for 64-bit x86 systems (not used with Gallium)</li>
</ul>
</li>
<li><strong>gallium</strong> - Gallium3D source code<ul>
<li><strong>include</strong> - Gallium3D header files which define the Gallium3D interfaces</li>
<li><strong>drivers</strong> - Gallium3D device drivers<ul>
<li><strong>etnaviv</strong> - Driver for Vivante.</li>
<li><strong>freedreno</strong> - Driver for Qualcomm Adreno.</li>
<li><strong>i915</strong> - Driver for Intel i915/i945.</li>
<li><strong>iris</strong> - Driver for Intel gen 8 (Broadwell) and newer.</li>
<li><strong>lima</strong> - Driver for ARM Mali-400 (Utgard) series.</li>
<li><strong>llvmpipe</strong> - Software driver using LLVM for runtime code generation.</li>
<li><strong>nouveau</strong> - Driver for NVIDIA GPUs.</li>
<li><strong>panfrost</strong> - Driver for ARM Mali Txxx (Midgard) and Gxx (Bifrost) GPUs.</li>
<li><strong>radeon</strong> - Shared module for the r600 and radeonsi drivers.</li>
<li><strong>r300</strong> - Driver for ATI R300 - R500.</li>
<li><strong>r600</strong> - Driver for ATI/AMD R600 - Northern Island (Terascale).</li>
<li><strong>radeonsi</strong> - Driver for AMD Southern Island and newer (GCN, RDNA).</li>
<li><strong>softpipe</strong> - Software reference driver.</li>
<li><strong>svga</strong> - Driver for VMware’s SVGA virtual GPU.</li>
<li><strong>swr</strong> - Software driver with massively parellel vertex processing.</li>
<li><strong>tegra</strong> - Driver for NVIDIA Tegra GPUs.</li>
<li><strong>v3d</strong> - Driver for Broadcom VideoCore 5 and newer.</li>
<li><strong>vc4</strong> - Driver for Broadcom VideoCore 4.</li>
<li><strong>virgl</strong> - Driver for Virtio virtual GPU of QEMU.</li>
<li><strong>zink</strong> - Driver that uses Vulkan for rendering.</li>
</ul>
</li>
<li><strong>auxiliary</strong> - Gallium support code<ul>
<li><strong>pipe-loader</strong> - provides device enumeration and creation of winsys/pipe_screen instances. 用于加载driver/winsys</li>
<li><strong>cso_cache</strong> - Constant State Objects Cache. Used to filter out redundant state changes between frontends and drivers.</li>
<li><strong>draw</strong> - Software vertex processing and primitive assembly module. This includes vertex program execution, clipping, culling and optional stages for drawing wide lines, stippled lines, polygon stippling, two-sided lighting, etc. Intended for use by drivers for hardware that does not have vertex shaders. Geometry shaders will also be implemented in this module.</li>
<li><strong>gallivm</strong> - LLVM module for Gallium. For LLVM-based compilation, optimization and code generation for TGSI shaders. Incomplete.</li>
<li><strong>hud</strong> - Heads-Up Display, an overlay showing GPU statistics</li>
<li><strong>pipebuffer</strong> - utility module for managing buffers</li>
<li><strong>rbug</strong> - Gallium remote debug utility</li>
<li><strong>rtasm</strong> - run-time assembly/machine code generation. Currently there’s run-time code generation for x86/SSE, PowerPC and Cell SPU.</li>
<li><strong>tessellator</strong>- used by software drivers to implement tessellation shaders</li>
<li><strong>tgsi</strong> - TG Shader Infrastructure. Code for encoding, manipulating and interpreting GPU programs.</li>
<li><strong>translate</strong> - module for translating vertex data from one format to another.</li>
<li><strong>util</strong> - assorted utilities for arithmetic, hashing, surface creation, memory management, 2D blitting, simple rendering, etc.</li>
<li><strong>vl</strong> - utility code for video decode/encode</li>
<li>XXX more</li>
</ul>
</li>
<li><strong>frontends</strong> - These implement various libraries using the device drivers(各种使用设备驱动的用户空间库)<ul>
<li><strong>clover</strong> - OpenCL frontend</li>
<li><strong>dri</strong> - Meta frontend for DRI drivers, see mesa/state_tracker(前端驱动的接口)</li>
<li><strong>glx</strong> - Meta frontend for GLX</li>
<li><strong>hgl</strong> - Haiku OpenGL</li>
<li><strong>nine</strong> - D3D9 frontend, see targets/d3dadapter9</li>
<li><strong>omx</strong> - OpenMAX Bellagio frontend</li>
<li><strong>osmesa</strong> - Off-screen OpenGL rendering library</li>
<li><strong>va</strong> - VA-API frontend</li>
<li><strong>vdpau</strong> - VDPAU frontend</li>
<li><strong>wgl</strong> - Windows WGL frontend</li>
<li><strong>xa</strong> - XA frontend</li>
<li><strong>xvmc</strong> - XvMC frontend</li>
</ul>
</li>
<li><strong>winsys</strong> - The device drivers are platform-independent, the winsys connects them to various platforms. There is usually one winsys per device family, and within the winsys directory there can be multiple flavors connecting to different platforms.<ul>
<li><strong>drm</strong> - Direct Rendering Manager on Linux</li>
<li><strong>gdi</strong> - Windows</li>
<li><strong>xlib</strong> - indirect rendering on X Window System</li>
<li>XXX more</li>
</ul>
</li>
<li><strong>targets</strong> - These control how the Gallium code is compiled into different libraries. Each of these roughly corresponds to one frontend.<ul>
<li><strong>d3dadapter9</strong> - d3dadapter9.so for Wine</li>
<li><strong>dri</strong> - libgallium_dri.so loaded by libGL.so</li>
<li><strong>graw</strong> - raw gallium interface without a frontend</li>
<li>XXX more</li>
</ul>
</li>
</ul>
</li>
<li><strong>glx</strong> - The GLX library code for building libGL.so using DRI drivers.</li>
<li><strong>loader</strong> - Used by libGL.so to find and load the appropriate DRI driver.</li>
<li><strong>panfrost</strong> - Panfrost-specific sources<ul>
<li><strong>bifrost</strong> - shader compiler for the Bifrost generation GPUs</li>
<li><strong>midgard</strong> - shader compiler for the Midgard generation GPUs</li>
<li><strong>pandecode</strong> - command stream debugger</li>
</ul>
</li>
<li><strong>util</strong> - Various utility codes</li>
<li><strong>vulkan</strong> - Common code for Vulkan drivers</li>
</ul>
</li>
</ul>
<blockquote>
<p>From: <a href="https://docs.mesa3d.org/sourcetree.html" target="_blank" rel="noopener">https://docs.mesa3d.org/sourcetree.html</a>  time:2020-07-14</p>
</blockquote>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>mesa</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>opengl</tag>
        <tag>mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>windows系统之批处理bat语法</title>
    <url>/post/29269ff3.html</url>
    <content><![CDATA[<p>windows下的批处理工具<code>bat</code>的基本语法和使用</p>
<a id="more"></a>
<p>这里只是遇到的一些简单用法具体的详细可以通过<code>关键字</code>+<code>/?</code>查看详细的帮助文档。</p>
<figure class="highlight plain"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">set /? #注意在CMD中输入查看，powershel不知道为什么没有输出</span><br></pre></td></tr></table></figure>
<p>内置命令：<code>help</code></p>
<figure class="highlight plain"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">C:\&gt;help</span><br><span class="line">有关某个命令的详细信息，请键入 HELP 命令名</span><br><span class="line">ASSOC          显示或修改文件扩展名关联。</span><br><span class="line">ATTRIB         显示或更改文件属性。</span><br><span class="line">BREAK          设置或清除扩展式 CTRL+C 检查。</span><br><span class="line">BCDEDIT        设置启动数据库中的属性以控制启动加载。</span><br><span class="line">CACLS          显示或修改文件的访问控制列表(ACL)。</span><br><span class="line">CALL           从另一个批处理程序调用这一个。</span><br><span class="line">CD             显示当前目录的名称或将其更改。</span><br><span class="line">CHCP           显示或设置活动代码页数。</span><br><span class="line">CHDIR          显示当前目录的名称或将其更改。</span><br><span class="line">CHKDSK         检查磁盘并显示状态报告。</span><br><span class="line">CHKNTFS        显示或修改启动时间磁盘检查。</span><br><span class="line">CLS            清除屏幕。</span><br><span class="line">CMD            打开另一个 Windows 命令解释程序窗口。</span><br><span class="line">COLOR          设置默认控制台前景和背景颜色。</span><br><span class="line">COMP           比较两个或两套文件的内容。</span><br><span class="line">COMPACT        显示或更改 NTFS 分区上文件的压缩。</span><br><span class="line">CONVERT        将 FAT 卷转换成 NTFS。你不能转换</span><br><span class="line">               当前驱动器。</span><br><span class="line">COPY           将至少一个文件复制到另一个位置。</span><br><span class="line">DATE           显示或设置日期。</span><br><span class="line">DEL            删除至少一个文件。</span><br><span class="line">DIR            显示一个目录中的文件和子目录。</span><br><span class="line">DISKPART       显示或配置磁盘分区属性。</span><br><span class="line">DOSKEY         编辑命令行、撤回 Windows 命令并</span><br><span class="line">               创建宏。</span><br><span class="line">DRIVERQUERY    显示当前设备驱动程序状态和属性。</span><br><span class="line">ECHO           显示消息，或将命令回显打开或关闭。</span><br><span class="line">ENDLOCAL       结束批文件中环境更改的本地化。</span><br><span class="line">ERASE          删除一个或多个文件。</span><br><span class="line">EXIT           退出 CMD.EXE 程序(命令解释程序)。</span><br><span class="line">FC             比较两个文件或两个文件集并显示</span><br><span class="line">               它们之间的不同。</span><br><span class="line">FIND           在一个或多个文件中搜索一个文本字符串。</span><br><span class="line">FINDSTR        在多个文件中搜索字符串。</span><br><span class="line">FOR            为一组文件中的每个文件运行一个指定的命令。</span><br><span class="line">FORMAT         格式化磁盘，以便用于 Windows。</span><br><span class="line">FSUTIL         显示或配置文件系统属性。</span><br><span class="line">FTYPE          显示或修改在文件扩展名关联中使用的文件</span><br><span class="line">               类型。</span><br><span class="line">GOTO           将 Windows 命令解释程序定向到批处理程序</span><br><span class="line">               中某个带标签的行。</span><br><span class="line">GPRESULT       显示计算机或用户的组策略信息。</span><br><span class="line">GRAFTABL       使 Windows 在图形模式下显示扩展</span><br><span class="line">               字符集。</span><br><span class="line">HELP           提供 Windows 命令的帮助信息。</span><br><span class="line">ICACLS         显示、修改、备份或还原文件和</span><br><span class="line">               目录的 ACL。</span><br><span class="line">IF             在批处理程序中执行有条件的处理操作。</span><br><span class="line">LABEL          创建、更改或删除磁盘的卷标。</span><br><span class="line">MD             创建一个目录。</span><br><span class="line">MKDIR          创建一个目录。</span><br><span class="line">MKLINK         创建符号链接和硬链接</span><br><span class="line">MODE           配置系统设备。</span><br><span class="line">MORE           逐屏显示输出。</span><br><span class="line">MOVE           将一个或多个文件从一个目录移动到另一个</span><br><span class="line">               目录。</span><br><span class="line">OPENFILES      显示远程用户为了文件共享而打开的文件。</span><br><span class="line">PATH           为可执行文件显示或设置搜索路径。</span><br><span class="line">PAUSE          暂停批处理文件的处理并显示消息。</span><br><span class="line">POPD           还原通过 PUSHD 保存的当前目录的上一个</span><br><span class="line">               值。</span><br><span class="line">PRINT          打印一个文本文件。</span><br><span class="line">PROMPT         更改 Windows 命令提示。</span><br><span class="line">PUSHD          保存当前目录，然后对其进行更改。</span><br><span class="line">RD             删除目录。</span><br><span class="line">RECOVER        从损坏的或有缺陷的磁盘中恢复可读信息。</span><br><span class="line">REM            记录批处理文件或 CONFIG.SYS 中的注释(批注)。</span><br><span class="line">REN            重命名文件。</span><br><span class="line">RENAME         重命名文件。</span><br><span class="line">REPLACE        替换文件。</span><br><span class="line">RMDIR          删除目录。</span><br><span class="line">ROBOCOPY       复制文件和目录树的高级实用工具</span><br><span class="line">SET            显示、设置或删除 Windows 环境变量。</span><br><span class="line">SETLOCAL       开始本地化批处理文件中的环境更改。</span><br><span class="line">SC             显示或配置服务(后台进程)。</span><br><span class="line">SCHTASKS       安排在一台计算机上运行命令和程序。</span><br><span class="line">SHIFT          调整批处理文件中可替换参数的位置。</span><br><span class="line">SHUTDOWN       允许通过本地或远程方式正确关闭计算机。</span><br><span class="line">SORT           对输入排序。</span><br><span class="line">START          启动单独的窗口以运行指定的程序或命令。</span><br><span class="line">SUBST          将路径与驱动器号关联。</span><br><span class="line">SYSTEMINFO     显示计算机的特定属性和配置。</span><br><span class="line">TASKLIST       显示包括服务在内的所有当前运行的任务。</span><br><span class="line">TASKKILL       中止或停止正在运行的进程或应用程序。</span><br><span class="line">TIME           显示或设置系统时间。</span><br><span class="line">TITLE          设置 CMD.EXE 会话的窗口标题。</span><br><span class="line">TREE           以图形方式显示驱动程序或路径的目录</span><br><span class="line">               结构。</span><br><span class="line">TYPE           显示文本文件的内容。</span><br><span class="line">VER            显示 Windows 的版本。</span><br><span class="line">VERIFY         告诉 Windows 是否进行验证，以确保文件</span><br><span class="line">               正确写入磁盘。</span><br><span class="line">VOL            显示磁盘卷标和序列号。</span><br><span class="line">XCOPY          复制文件和目录树。</span><br><span class="line">WMIC           在交互式命令 shell 中显示 WMI 信息。</span><br><span class="line"></span><br><span class="line">有关工具的详细信息，请参阅联机帮助中的命令行参考。</span><br></pre></td></tr></table></figure>
<h2 id="bat脚本"><a href="#bat脚本" class="headerlink" title="bat脚本"></a>bat脚本</h2><p>在windows下bat脚本的文件名后缀一般为<code>bat</code>或<code>cmd</code></p>
<h2 id="bat语法"><a href="#bat语法" class="headerlink" title="bat语法"></a>bat语法</h2><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th style="text-align:center">对应linux命令</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cd</code></td>
<td>显示当前目录名或改变当前目录</td>
<td style="text-align:center"><code>cd</code></td>
</tr>
<tr>
<td><code>dir</code></td>
<td>显示目录中的文件和子目录列表</td>
<td style="text-align:center"><code>ls</code></td>
</tr>
<tr>
<td><code>mkdir</code>/<code>md</code></td>
<td>创建目录</td>
<td style="text-align:center"><code>mkdir</code></td>
</tr>
<tr>
<td><code>pushd</code></td>
<td>保存当前目录，并切换目录，如<code>pushd c:\work</code></td>
<td style="text-align:center"><code>pushd</code></td>
</tr>
<tr>
<td><code>popd</code></td>
<td>恢复当前目录为刚才保存的，如<code>popd</code></td>
<td style="text-align:center"><code>popd</code></td>
</tr>
<tr>
<td><code>del</code></td>
<td>删除一个或多个文件,<code>del xxx /f</code></td>
<td style="text-align:center"><code>rm</code></td>
</tr>
<tr>
<td><code>rd</code></td>
<td>删除目录， <code>rd /s /q build</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>mklink</code></td>
<td>创建符号链接</td>
<td style="text-align:center"><code>ln</code></td>
</tr>
<tr>
<td><code>rename</code>/<code>ren</code></td>
<td>重命名文件</td>
<td style="text-align:center"><code>mv</code></td>
</tr>
<tr>
<td><code>copy</code></td>
<td>将一份或多份文件复制到另一个位置</td>
<td style="text-align:center"><code>cp</code></td>
</tr>
<tr>
<td><code>type</code></td>
<td>显示文本文件的内容</td>
<td style="text-align:center"><code>cat</code></td>
</tr>
</tbody>
</table>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cls</code></td>
<td>清除屏幕</td>
</tr>
<tr>
<td><code>pause</code></td>
<td>暂停批处理文件的处理并显示消息:<code>请按任意键继续. . .</code></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p><code>%var%</code>：变量的引用，通过两个%号即可引用该变量的值使用</p>
<ul>
<li>自定义变量，多用于脚本</li>
<li>系统内置变量</li>
</ul>
<table>
<thead>
<tr>
<th>系统内置变量名</th>
<th>变量值</th>
</tr>
</thead>
<tbody>
<tr>
<td>%SYSTEMROOT%</td>
<td><code>C:\Windows</code></td>
</tr>
<tr>
<td>%ERRORLEVEL%</td>
<td>程序返回码，正确返回0</td>
</tr>
<tr>
<td>%PROCESSOR_ARCHITECTURE%</td>
<td>判断系统位数，比如<code>AMD64</code></td>
</tr>
<tr>
<td>%cd%</td>
<td>当前路径，比如<code>C:\Users</code></td>
</tr>
<tr>
<td>%~dp0</td>
<td>当前路径，比如<code>C:\Users\</code></td>
</tr>
<tr>
<td>NUL</td>
<td>相当于，linux中的dev/null</td>
</tr>
</tbody>
</table>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@</code></td>
<td>回显屏蔽</td>
</tr>
<tr>
<td><code>^</code></td>
<td>转义符</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="注释与打印"><a href="#注释与打印" class="headerlink" title="注释与打印"></a>注释与打印</h3><h4 id="rem-和"><a href="#rem-和" class="headerlink" title="rem 和 ::"></a>rem 和 ::</h4><ul>
<li><code>rem</code>: 注释命令，一般用来给程序加上注解，该命令后的内容不被执行，但能回显</li>
<li><code>::</code> 也可以起到rem 的注释作用, 而且更简洁有效，其后的字符行在执行时不会回显, 无论是否用echo on打开命令行回显状态, 因为命令解释器不认为他是一个有效的命令行</li>
</ul>
<h4 id="echo-和"><a href="#echo-和" class="headerlink" title="echo 和 @"></a>echo 和 @</h4><p><code>@</code>字符放在命令前将关闭该命令回显，无论此时echo是否为打开状态</p>
<h3 id="变量设置—set"><a href="#变量设置—set" class="headerlink" title="变量设置—set"></a>变量设置—set</h3><p>设置环境变量</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> var=abcdefg</span><br><span class="line">#or</span><br><span class="line"><span class="built_in">set</span> "var=abcdefg"</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<blockquote>
<p> SET /A expression<br> SET /P variable=[promptString]</p>
</blockquote>
<ul>
<li><p><code>/a</code> ：可以用各种表达式为变量赋值</p>
<figure class="highlight plain"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">set /a var=1+1 #var=2</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>/p</code> ：可以在用户输入前加一段说明性的描述，即想让用户输入什么内容之类的说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set /p var=请输入变量的值：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="清空变量名"><a href="#清空变量名" class="headerlink" title="清空变量名"></a>清空变量名</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> VARNAME=</span><br><span class="line">#or</span><br><span class="line"><span class="built_in">set</span> "VARNAME="</span><br></pre></td></tr></table></figure>
<h3 id="数值检查运算符"><a href="#数值检查运算符" class="headerlink" title="数值检查运算符"></a>数值检查运算符</h3><table>
<thead>
<tr>
<th>比较运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>EQU</td>
<td>等于</td>
</tr>
<tr>
<td>NEQ</td>
<td>不等于</td>
</tr>
<tr>
<td>LSS</td>
<td>小于</td>
</tr>
<tr>
<td>LEQ</td>
<td>小于或等于</td>
</tr>
<tr>
<td>GTR</td>
<td>大于</td>
</tr>
<tr>
<td>GEQ</td>
<td>大于或等于</td>
</tr>
</tbody>
</table>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><blockquote>
<p>IF [NOT] ERRORLEVEL number command<br>IF [NOT] string1==string2 command<br>IF [NOT] EXIST filename command</p>
<p>  NOT               指定只有条件为 false 的情况下，Windows 才<br>                    应该执行该命令。</p>
<p>  ERRORLEVEL number 如果最后运行的程序返回一个等于或大于<br>                    指定数字的退出代码，指定条件为 true。</p>
<p>  string1==string2  如果指定的文字字符串匹配，指定条件为 true。</p>
<p>  EXIST filename    如果指定的文件名存在，指定条件为 true。</p>
<p>  command           如果符合条件，指定要执行的命令。如果指定的<br>                    条件为 FALSE，命令后可跟 ELSE 命令，该命令将<br>                    在 ELSE 关键字之后执行该命令。</p>
</blockquote>
<ul>
<li><p><code>/I</code> : 如果指定说明要进行的字符串比较不分大小写,</p>
<figure class="highlight plain"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">@IF /I NOT &quot;%swr%&quot;==&quot;y&quot; GOTO opengles</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="goto-和"><a href="#goto-和" class="headerlink" title="goto 和 :"></a>goto 和 :</h4><p>跳转到指定的标号处。</p>
<p>在批处理中允许以<code>:xxx</code>来构建一个标号，然后用<code>goto xxx</code>跳转到标号<code>:xxx</code>处，然后执行标号后的命令。</p>
<figure class="highlight plain"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:start</span><br><span class="line">set /a var+=1</span><br><span class="line">echo %var%</span><br><span class="line">    if %var% leq 3 goto start</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<h3 id="CMD窗口名"><a href="#CMD窗口名" class="headerlink" title="CMD窗口名"></a>CMD窗口名</h3><p>设置cmd窗口的标题</p>
<figure class="highlight plain"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">title 新标题     #可以看到cmd窗口的标题栏变了</span><br></pre></td></tr></table></figure>
<h3 id="setlocal-与-endlocal-命令"><a href="#setlocal-与-endlocal-命令" class="headerlink" title="setlocal 与 endlocal 命令"></a>setlocal 与 endlocal 命令</h3><blockquote>
<p>开始与终止批处理文件中环境改动的本地化操作。在执行 Setlocal 之后所做的环境改动只限于批处理文件。要还原原先的设置，必须执行 Endlocal。达到批处理文件结尾时，对于该批处理文件的每个尚未执行的 Setlocal 命令，都会有一个隐含的 Endlocal 被执行。Endlocal结束批处理文件中环境改动的本地化操作。在执行Endlocal 之后所做的环境改动不再仅限于批处理文件。批处理文件结束后，原先的设置无法还原。</p>
</blockquote>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">setlocal</span> /?</span><br><span class="line">开始批处理文件中环境改动的本地化操作。在执行 <span class="built_in">SETLOCAL</span> 之后</span><br><span class="line">所做的环境改动只限于批处理文件。要还原原先的设置，必须执</span><br><span class="line">行 <span class="built_in">ENDLOCAL</span>。达到批处理文件结尾时，对于该批处理文件的每个</span><br><span class="line">尚未执行的 <span class="built_in">SETLOCAL</span> 命令，都会有一个隐含的 <span class="built_in">ENDLOCAL</span> 被执行。</span><br><span class="line"></span><br><span class="line"><span class="built_in">SETLOCAL</span></span><br><span class="line"></span><br><span class="line">如果启用命令扩展，则 <span class="built_in">SETLOCAL</span> 更改如下:</span><br><span class="line"></span><br><span class="line"><span class="built_in">SETLOCAL</span> 批命令现在可以接受可选参数:</span><br><span class="line">        ENABLEEXTENSIONS / DISABLEEXTENSIONS</span><br><span class="line">            启用或禁用命令处理器扩展。这些</span><br><span class="line">            参数比 <span class="built_in">CMD</span> /E:ON 或 /E:OFF</span><br><span class="line">            开关有优先权。请参阅 <span class="built_in">CMD</span> /? 获取详细信息。</span><br><span class="line">        ENABLEDELAYEDEXPANSION / DISABLEDELAYEDEXPANSION</span><br><span class="line">            启用或禁用延缓环境变量</span><br><span class="line">            扩展。这些参数比 <span class="built_in">CMD</span></span><br><span class="line">            /V:ON 或 /V:OFF 开关有优先权。请参阅 <span class="built_in">CMD</span> /? 获取详细信息。</span><br><span class="line">无论在 <span class="built_in">SETLOCAL</span> 命令之前的设置是什么，这些修改会一直</span><br><span class="line">生效，直到出现相应的 <span class="built_in">ENDLOCAL</span> 命令。</span><br><span class="line"></span><br><span class="line">在给定参数的情况下，</span><br><span class="line"><span class="built_in">SETLOCAL</span> 命令将设置 <span class="keyword">ERRORLEVEL</span> 值。如果给定两个有效参数中的一个，另一个未给定，</span><br><span class="line">则该值为零。</span><br><span class="line">通过以下方法，你可以在批脚本中</span><br><span class="line">使用此项来确定扩展是否可用:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VERIFY</span> OTHER <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="获取管理员权限"><a href="#获取管理员权限" class="headerlink" title="获取管理员权限"></a>获取管理员权限</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">@<span class="built_in">cd</span> /d "%~dp0"</span><br><span class="line">@<span class="built_in">set</span> "<span class="keyword">ERRORLEVEL</span>="</span><br><span class="line">@<span class="built_in">CMD</span> /C <span class="keyword">EXIT</span> <span class="number">0</span></span><br><span class="line">@"<span class="variable">%SYSTEMROOT%</span>\system32\<span class="built_in">cacls</span>.exe" "<span class="variable">%SYSTEMROOT%</span>\system32\config\system" &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">@<span class="keyword">if</span> <span class="keyword">NOT</span> "<span class="variable">%ERRORLEVEL%</span>"=="<span class="number">0</span>" (</span><br><span class="line">@powershell -Command <span class="built_in">Start</span>-Process ""%<span class="number">0</span>"" -Verb runAs <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">@<span class="keyword">exit</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/lizm166/p/11132601.html" target="_blank" rel="noopener">bat脚本的基本命令语法</a></li>
<li><a href="https://www.cnblogs.com/Braveliu/p/5081084.html" target="_blank" rel="noopener">批处理命令——set</a></li>
<li><a href="https://www.cnblogs.com/smwikipedia/archive/2009/03/30/1424749.html" target="_blank" rel="noopener">Windows脚本 - %~dp0的含义</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>bat</tag>
        <tag>批处理</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt for qemu</title>
    <url>/post/de22fd34.html</url>
    <content><![CDATA[<blockquote>
<p><code>libvirt</code>是目前使用最为广泛的针对KVM虚拟机进行管理的工具和API。<code>libvirtd</code>是一个daemon进程，可以被本地和远程的virsh(命令行工具)调用，Libvirtd通过调用qemu-kvm操作管理虚拟机。libvirt 由应用程序编程接口 (API) 库、一个守护进程 (libvirtd)，和默认命令行实用工具<code>(virsh)</code>等部分组成</p>
</blockquote>
<a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y qemu-kvm qemu-kvm-tools libvirt virt-install</span><br></pre></td></tr></table></figure>
<h1 id="libvirtd"><a href="#libvirtd" class="headerlink" title="libvirtd"></a>libvirtd</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status libvirtd.service</span><br><span class="line">● libvirtd.service - Virtualization daemon</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/libvirtd.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Mon 2020-08-24 09:22:15 CST; 7h ago</span><br><span class="line">TriggeredBy: ● libvirtd-admin.socket</span><br><span class="line">             ● libvirtd.socket</span><br><span class="line">             ● libvirtd-ro.socket</span><br><span class="line">       Docs: man:libvirtd(8)</span><br><span class="line">             https://libvirt.org</span><br><span class="line">   Main PID: 1022 (libvirtd)</span><br><span class="line">      Tasks: 20 (limit: 32768)</span><br><span class="line">     Memory: 65.7M</span><br><span class="line">     CGroup: /system.slice/libvirtd.service</span><br><span class="line">             ├─1022 /usr/sbin/libvirtd</span><br><span class="line">             ├─1412 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/lib/libvirt/libvirt_leaseshelper</span><br><span class="line">             └─1413 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/lib/libvirt/libvirt_leaseshelper</span><br></pre></td></tr></table></figure>
<p>主要提供的功能包括：</p>
<ul>
<li>虚拟机生命周期管理：包括不同的领域生命周期操作，比如：启动、停止、暂停、保存、恢复和迁移。支持多种设备类型的热插拔操作，包括：磁盘、网卡、内存和CPU。</li>
<li>本地&amp;&amp;远程访问：通过在本地运行libvirt daemon,本机和远程机器，都可以访问并使用libvirt的功能。远程一般通过简单配置SSH即可。</li>
<li>存储管理：除了虚拟机管理，任何运行了libvirt daemon的主机都可以用来管理不同类型的存储：创建不同格式的文件镜像（qcow2、vmdk、raw等）、挂接NFS共享、列出现有的LVM卷组、创建新的LVM卷组和逻辑卷、对未处理过的磁盘设备分区、挂接iSCSI共享等。</li>
<li>虚拟网络管理：可以用来管理和创建虚拟网络，管理物理和逻辑的网络接口。</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>libvirtd服务的配置文件: <code>/etc/libvirt/libvirtd.conf</code></p>
<p>客户端主配置文件: <code>/etc/libvirt/libvirt.conf</code></p>
<p>qemu的主配置文件: <code>/etc/libvirt/qemu.conf</code></p>
<h3 id="libvirtd-conf"><a href="#libvirtd-conf" class="headerlink" title="libvirtd.conf"></a>libvirtd.conf</h3><ul>
<li>日志配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_filters=&quot;1:libvirt 1:util 1:qemu&quot;</span><br><span class="line">log_outputs=&quot;1:file:/var/log/libvirt/libvirtd.log&quot;</span><br></pre></td></tr></table></figure>
<h1 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h1><h2 id="libvirt与qemu如何绑定"><a href="#libvirt与qemu如何绑定" class="headerlink" title="libvirt与qemu如何绑定"></a>libvirt与qemu如何绑定</h2><blockquote>
<p>通过最新qemu源码编译的qemu-kvm，被libvirt进行管理</p>
</blockquote>
<p>virsh编辑配置文件的<code>emulator</code>部分：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/local/bin/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改后使其生效时，会出现权限错误：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> virsh define ./qemu/win10.xml</span></span><br><span class="line">error: Failed to define domain from ./qemu/win10.xml</span><br><span class="line">error: internal error: Failed to start QEMU binary /usr/local/bin/qemu-system-x86_64 for probing: libvirt:  error : cannot execute binary /usr/local/bin/qemu-system-x86_64: Permission denied</span><br></pre></td></tr></table></figure></p>
<p>解决方法：</p>
<blockquote>
<p>在<code>/etc/apparmor.d/usr.sbin.libvirtd</code>文件中，添加一行:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/* PUx,</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># force the use of virt-aa-helper</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/* rmix,</span></span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>使能生效：<code>sudo systemctl reload apparmor</code>或<code>sudo systemctl restart apparmor.service</code></p>
</blockquote>
<p>原因： <code>libvirtd</code>应用的权限被<code>apparmor-profiles</code>所控制，而<code>/usr/local/bin</code>目录下的可执行文件，没有被添加到apparmor-profiles的配置中，因此使用时检测到没有权限。</p>
<ul>
<li>AppArmor 是一款与SeLinux类似的安全框架/工具，其主要作用是控制应用程序的各种权限，例如对某个目录/文件的读/写，对网络端口的打开/读/写等</li>
<li>Ubuntu的默认选择</li>
<li>在<code>centos</code>中如果出现该错误，可以通过临时禁用SELinux进行测试: <code>setenforce 0</code></li>
</ul>
<p><code>apparmor-profiles</code>的状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apparmor_status</span><br></pre></td></tr></table></figure></p>
<p>开启虚拟机时，出现无法执行错误：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: internal error: process exited while connecting to monitor: libvirt:  error : cannot execute binary /usr/local/bin/qemu-system-x86_64: Permission denied</span><br></pre></td></tr></table></figure></p>
<p>原因：不能在<a href="https://blog.csdn.net/iteye_12675/article/details/82519399" target="_blank" rel="noopener">apparmor禁用</a><code>usr.sbin.libvirtd</code>，<code>usr.lib.libvirt.virt-aa-helper</code>,也就是将其生成软连接到<code>/etc/apparmor.d/disable</code>.如果要禁掉可能必须重新编译libvirt同时添加<code>--without-apparmor</code>选项(未测试)</p>
<h3 id="其他apparmor权限的问题"><a href="#其他apparmor权限的问题" class="headerlink" title="其他apparmor权限的问题"></a>其他apparmor权限的问题</h3><p>在libvirtd中对qemu的运行存在一些权限的设置，为了方便调试，将权限控制禁用。在配置文件<code>/etc/libvirt/qemu.conf</code>中添加下行代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security_driver = &quot;none&quot;</span><br></pre></td></tr></table></figure></p>
<p>重启<code>libvirtd.service</code>服务:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart libvirtd.service</span><br></pre></td></tr></table></figure></p>
<h1 id="virsh"><a href="#virsh" class="headerlink" title="virsh"></a>virsh</h1><h2 id="查看虚拟机状态"><a href="#查看虚拟机状态" class="headerlink" title="查看虚拟机状态"></a>查看虚拟机状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">virsh list --all</span></span><br><span class="line"> Id   Name          State</span><br><span class="line"> ------------------------------</span><br><span class="line">  -    ubuntu20.04   shut off</span><br><span class="line">  -    win10         shut off</span><br></pre></td></tr></table></figure>
<h2 id="显示虚拟机的XML配置"><a href="#显示虚拟机的XML配置" class="headerlink" title="显示虚拟机的XML配置"></a>显示虚拟机的XML配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">virsh dumpxml ubuntu20.04</span></span><br></pre></td></tr></table></figure>
<h2 id="编辑虚拟机的XML配置文件"><a href="#编辑虚拟机的XML配置文件" class="headerlink" title="编辑虚拟机的XML配置文件"></a>编辑虚拟机的XML配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virsh edit ubuntu20.04</span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virsh list</code></td>
<td>显示正在运行的虚拟机</td>
</tr>
<tr>
<td><code>virsh list --all</code></td>
<td>显示所有的虚拟机</td>
</tr>
<tr>
<td><code>virsh start vm-name</code></td>
<td>启动vm-name虚拟机</td>
</tr>
<tr>
<td><code>virsh shutdown vm-name</code></td>
<td>关闭vm-name虚拟机</td>
</tr>
<tr>
<td><code>virsh destroy vm-name</code></td>
<td>虚拟机vm-name强制断电</td>
</tr>
<tr>
<td><code>virsh suspend vm-name</code></td>
<td>挂起vm-name虚拟机</td>
</tr>
<tr>
<td><code>virsh define vm-name</code></td>
<td>将domain注册，但是没有启动,下次启动时生效</td>
</tr>
<tr>
<td><code>virsh undefine vm-name</code></td>
<td>删除虚拟机，慎用</td>
</tr>
<tr>
<td><code>virsh dominfo vm-name</code></td>
<td>查看虚拟机的配置信息</td>
</tr>
<tr>
<td><code>virsh domiflist</code></td>
<td>查看网卡配置信息</td>
</tr>
<tr>
<td><code>virsh domblklist vm-name</code></td>
<td>查看该虚拟机的磁盘位置</td>
</tr>
<tr>
<td><code>virsh edit vm-name</code></td>
<td>修改vm-name的xml配置文件</td>
</tr>
<tr>
<td><code>virsh dumpxml vm-name</code></td>
<td>查看KVM虚拟机当前配置</td>
</tr>
<tr>
<td><code>virsh autostart vm-name</code></td>
<td>KVM物理机开机自启动虚拟机，配置后会在此目录生成配置文件/etc/libvirt/qemu/autostart/vm-name.xml</td>
</tr>
<tr>
<td><code>virsh autostart --disable vm-name</code></td>
<td>取消开机自启动</td>
</tr>
</tbody>
</table>
<h1 id="命令行参数转XML配置文件"><a href="#命令行参数转XML配置文件" class="headerlink" title="命令行参数转XML配置文件"></a>命令行参数转XML配置文件</h1><h2 id="domxml-from-native"><a href="#domxml-from-native" class="headerlink" title="domxml-from-native"></a>domxml-from-native</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo virsh domxml-from-native qemu-argv aa.txt</span><br></pre></td></tr></table></figure>
<p>错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: this function is not supported by the connection driver: virConnectDomainXMLFromNative</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最新qemu中删除了该功能，因为在实践中它过于不可靠和不完整而无用</p>
</blockquote>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="添加显卡显示SDL"><a href="#添加显卡显示SDL" class="headerlink" title="添加显卡显示SDL"></a>添加显卡显示SDL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;graphics type=&apos;sdl&apos; display=&apos;:0.0&apos; xauth=&apos;/root/.Xauthority&apos;&gt;</span><br><span class="line">    &lt;gl enable=&apos;yes&apos;/&gt;</span><br><span class="line">&lt;/graphics&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>以上配置在<code>Xfce</code>桌面环境下可以生效</strong></p>
</blockquote>
<h3 id="权限错误"><a href="#权限错误" class="headerlink" title="权限错误:"></a>权限错误:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: internal error: cannot load AppArmor profile &apos;libvirt-39466e8a-545d-420e-ba0f-b942d09a5bdb&apos;</span><br></pre></td></tr></table></figure>
<p>解决方法：在<code>/etc/apparmor.d/usr.sbin.libvirtd</code>配置文件中添加<code>/usr/local/bin/* rmix,</code></p>
<h3 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not initialize SDL(x11 not available) - exiting</span><br></pre></td></tr></table></figure>
<p>原因：未找到<br>解决方法：安装xfce桌面环境<br>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groups install Xfce</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>for centos7.8</p>
</blockquote>
<h2 id="编译使能SDL"><a href="#编译使能SDL" class="headerlink" title="编译使能SDL"></a>编译使能SDL</h2><p>在配置中使能SDL：<code>--enable-sdl</code></p>
<h2 id="异常错误"><a href="#异常错误" class="headerlink" title="异常错误"></a>异常错误</h2><h3 id="mlock"><a href="#mlock" class="headerlink" title="mlock"></a>mlock</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64: -realtime mlock=off: warning: &apos;-realtime mlock=...&apos; is deprecated, please use &apos;-overcommit mem-lock=...&apos; instead</span><br></pre></td></tr></table></figure>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>虚拟机配置文件：<a href="/src/ubuntu20.04.xml">ubuntu20.04</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 域——domain</span><br><span class="line"></span><br><span class="line">## 池——pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 升级libvirt</span><br><span class="line"></span><br><span class="line">## libvirt5.0.0 for centos7</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#url=&quot;http://mirror.centos.org/centos/7.8.2003/virt/x86_64/libvirt-latest/&quot;</span><br><span class="line">url=&quot;http://mirrors.huaweicloud.com/centos/7/virt/x86_64/libvirt-latest/&quot;</span><br><span class="line"></span><br><span class="line">curl $url &gt; page.txt</span><br><span class="line"></span><br><span class="line">grep &quot;5.0.0-1.el7.x86_64&quot; page.txt &gt; fff.txt</span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    #截取href前多余字符串</span><br><span class="line">    aaa=$&#123;line: 24&#125;</span><br><span class="line">    #截取title后多余字符串</span><br><span class="line">    bbb=$&#123;aaa%title*&#125;</span><br><span class="line">    #设置为href变量</span><br><span class="line">    export $bbb</span><br><span class="line">    #去掉变量值两边的引号</span><br><span class="line">    ccc=`echo $href | sed &apos;s/\&quot;//g&apos;`</span><br><span class="line"></span><br><span class="line">    echo $url$ccc</span><br><span class="line">    wget $url$ccc</span><br><span class="line"></span><br><span class="line">done &lt; fff.txt</span><br><span class="line"></span><br><span class="line">rm page.txt fff.txt -rf</span><br><span class="line"></span><br><span class="line">#yum install ./*</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://libvirt.org/formatdomain.html" target="_blank" rel="noopener">Domain XML format</a></li>
<li><a href="https://wiki.libvirt.org/page/QEMUSwitchToLibvirt" target="_blank" rel="noopener">QEMUSwitchToLibvirt</a></li>
<li><a href="https://www.cnblogs.com/wn1m/p/11280605.html" target="_blank" rel="noopener">libvirt原理</a></li>
<li><a href="https://unix.stackexchange.com/questions/471345/changing-libvirt-emulator-permission-denied" target="_blank" rel="noopener">Changing libvirt emulator: Permission denied</a></li>
<li><a href="https://www.cnblogs.com/qiuhom-1874/p/13508231.html" target="_blank" rel="noopener">虚拟化技术之kvm管理工具virsh常用基础命令（一）</a></li>
<li><a href="https://blog.csdn.net/jiuzuidongpo/article/details/44342509" target="_blank" rel="noopener">编译qemu和libvirt使支持SDL</a></li>
<li><a href="https://discourse.ubuntu.com/t/virtualization-libvirt/11522/1" target="_blank" rel="noopener">Virtualization - libvirt</a></li>
<li><a href="https://blog.51cto.com/4746316/2336524" target="_blank" rel="noopener">KVM 虚拟机 XML 配置文件详解</a></li>
<li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html-single/virtualization_tuning_and_optimization_guide/index#sect-Virtualization_Tuning_Optimization_Guide-NUMA-Auto_NUMA_Balancing" target="_blank" rel="noopener">虚拟化调试和优化指南</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
        <category>qemu</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>NUMA与PCI</title>
    <url>/post/13d4e2a6.html</url>
    <content><![CDATA[<p><img src="/images/2020/10/numa_pci_mapping.png" alt="NUMA PCI mapping"><br>NUMA与PCI之间的关系：<br><a id="more"></a></p>
<p>多物理CPU之间通过<code>QPI</code>总线进行通信</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lspci -s 02:0.0 -vv</span></span><br><span class="line">02:00.0 VGA compatible controller: xxx [VGA controller])</span><br><span class="line">	Physical Slot: 2</span><br><span class="line">  ...</span><br><span class="line">	Latency: 0</span><br><span class="line">	Interrupt: pin A routed to IRQ 240</span><br><span class="line">	NUMA node: 0         #不同的pci卡槽对应的node节点可能不同，与其绑定的CPU相关</span><br></pre></td></tr></table></figure>
<p>在不同的NUMA node下的pci设备进行内存读写时速度与响应时间存在差异，相同的NUMA node节点下的设备与内存的读写效果会更好。</p>
<p>例如，如果客户机被固定在NUMA节点0-1上，但是其PCI设备中的一个隶属于节点2，那么节点之间的数据传输将花费一段时间。</p>
<p><code>lstopo</code>命令可以查看系统的硬件拓扑结构</p>
<h2 id="安装lstopo命令"><a href="#安装lstopo命令" class="headerlink" title="安装lstopo命令"></a>安装lstopo命令</h2><ul>
<li><p>ubuntu</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install hwloc</span><br></pre></td></tr></table></figure>
</li>
<li><p>centos</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install hwloc-gui</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/images/2020/10/lstopo_test1.png" alt="lstopo my pc"></p>
<p><img src="/images/2020/10/lstopo_test2.png" alt="lstopo test"></p>
<h2 id="虚拟机中资源的最佳分布"><a href="#虚拟机中资源的最佳分布" class="headerlink" title="虚拟机中资源的最佳分布"></a>虚拟机中资源的最佳分布</h2><blockquote>
<p>虚拟机所使用的到的所有硬件资源尽可能的分布在同一个node节点之上，这样将提高设备的利用率和虚拟机性能</p>
</blockquote>
<p><img src="/images/2020/10/vm_resources_mapping.png" alt="VM Resources Mapping"></p>
<h2 id="CPU与内存吞吐量测试"><a href="#CPU与内存吞吐量测试" class="headerlink" title="CPU与内存吞吐量测试"></a>CPU与内存吞吐量测试</h2><blockquote>
<p>Intel处理器测试工具:<a href="https://github.com/opcm/pcm" target="_blank" rel="noopener">Processor Counter Monitor</a></p>
</blockquote>
<ul>
<li>内存的读写速度</li>
<li>多物理CPU之间的QPI速度</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pcm-202009]#</span><span class="bash"> ls ./pcm-*.x</span></span><br><span class="line">./pcm-core.x  ./pcm-latency.x  ./pcm-memory.x  ./pcm-msr.x   ./pcm-pcicfg.x  ./pcm-power.x  ./pcm-sensor-server.x  ./pcm-tsx.x</span><br><span class="line">./pcm-iio.x   ./pcm-lspci.x    ./pcm-mmio.x    ./pcm-numa.x  ./pcm-pcie.x    ./pcm-raw.x    ./pcm-sensor.x</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ./pcm.x 20</span><br><span class="line"></span><br><span class="line"> Processor Counter Monitor  (2020-10-01 16:31:57 +0200 ID=f510546)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IBRS and IBPB supported  : yes</span><br><span class="line">STIBP supported          : yes</span><br><span class="line">Spec arch caps supported : yes</span><br><span class="line">Number of physical cores: 32</span><br><span class="line">Number of logical cores: 64</span><br><span class="line">Number of online logical cores: 64</span><br><span class="line">Threads (logical cores) per physical core: 2</span><br><span class="line">Num sockets: 2</span><br><span class="line">Physical cores per socket: 16</span><br><span class="line">Core PMU (perfmon) version: 4</span><br><span class="line">Number of core PMU generic (programmable) counters: 4</span><br><span class="line">Width of generic (programmable) counters: 48 bits</span><br><span class="line">Number of core PMU fixed counters: 3</span><br><span class="line">Width of fixed counters: 48 bits</span><br><span class="line">Nominal core frequency: 2300000000 Hz</span><br><span class="line">IBRS enabled in the kernel   : no</span><br><span class="line">STIBP enabled in the kernel  : no</span><br><span class="line">The processor is not susceptible to Rogue Data Cache Load: yes</span><br><span class="line">The processor supports enhanced IBRS                     : yes</span><br><span class="line">Package thermal spec power: 125 Watt; Package minimum power: 68 Watt; Package maximum power: 307 Watt;</span><br><span class="line">Socket 0: 2 memory controllers detected with total number of 6 channels. 3 QPI ports detected. 2 M2M (mesh to memory) blocks detected. 0 Home Agents detected. 3 M3UPI blocks detected.</span><br><span class="line">Socket 1: 2 memory controllers detected with total number of 6 channels. 3 QPI ports detected. 2 M2M (mesh to memory) blocks detected. 0 Home Agents detected. 3 M3UPI blocks detected.</span><br><span class="line">Delay: 20</span><br><span class="line">Disabling NMI watchdog since it consumes one hw-PMU counter.</span><br><span class="line">Trying to use Linux perf events...</span><br><span class="line">Successfully programmed on-core PMU using Linux perf</span><br><span class="line">Link 3 is disabled</span><br><span class="line">Link 3 is disabled</span><br><span class="line">Socket 0</span><br><span class="line">Max QPI link 0 speed: 23.3 GBytes/second (10.4 GT/second)</span><br><span class="line">Max QPI link 1 speed: 23.3 GBytes/second (10.4 GT/second)</span><br><span class="line">Socket 1</span><br><span class="line">Max QPI link 0 speed: 23.3 GBytes/second (10.4 GT/second)</span><br><span class="line">Max QPI link 1 speed: 23.3 GBytes/second (10.4 GT/second)</span><br><span class="line"></span><br><span class="line">Detected Intel(R) Xeon(R) Gold 5218 CPU @ 2.30GHz &quot;Intel(r) microarchitecture codename Cascade Lake-SP&quot; stepping 7 microcode level 0x5002f01</span><br><span class="line"></span><br><span class="line"> EXEC  : instructions per nominal CPU cycle</span><br><span class="line"> IPC   : instructions per CPU cycle</span><br><span class="line"> FREQ  : relation to nominal CPU frequency=&apos;unhalted clock ticks&apos;/&apos;invariant timer ticks&apos; (includes Intel Turbo Boost)</span><br><span class="line"> AFREQ : relation to nominal CPU frequency while in active state (not in power-saving C state)=&apos;unhalted clock ticks&apos;/&apos;invariant timer ticks while in C0-state&apos;  (includes Intel Turbo Boost)</span><br><span class="line"> L3MISS: L3 (read) cache misses</span><br><span class="line"> L2MISS: L2 (read) cache misses (including other core&apos;s L2 cache *hits*)</span><br><span class="line"> L3HIT : L3 (read) cache hit ratio (0.00-1.00)</span><br><span class="line"> L2HIT : L2 cache hit ratio (0.00-1.00)</span><br><span class="line"> L3MPI : number of L3 (read) cache misses per instruction</span><br><span class="line"> L2MPI : number of L2 (read) cache misses per instruction</span><br><span class="line"> READ  : bytes read from main memory controller (in GBytes)</span><br><span class="line"> WRITE : bytes written to main memory controller (in GBytes)</span><br><span class="line"> LOCAL : ratio of local memory requests to memory controller in %</span><br><span class="line">LLCRDMISSLAT: average latency of last level cache miss for reads and prefetches (in ns)</span><br><span class="line"> PMM RD : bytes read from PMM memory (in GBytes)</span><br><span class="line"> PMM WR : bytes written to PMM memory (in GBytes)</span><br><span class="line"> L3OCC : L3 occupancy (in KBytes)</span><br><span class="line"> TEMP  : Temperature reading in 1 degree Celsius relative to the TjMax temperature (thermal headroom): 0 corresponds to the max temperature</span><br><span class="line"> energy: Energy in Joules</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Core (SKT) | EXEC | IPC  | FREQ  | AFREQ | L3MISS | L2MISS | L3HIT | L2HIT | L3MPI | L2MPI |   L3OCC | TEMP</span><br><span class="line"></span><br><span class="line">   0    0     0.02   0.50   0.03    1.26     926 K   9825 K    0.89    0.42    0.00    0.01      128     43</span><br><span class="line">   1    1     0.03   0.67   0.05    0.84    4930 K   6272 K    0.14    0.63    0.00    0.00      320     55</span><br><span class="line">   2    0     0.22   0.81   0.28    1.05    5539 K     12 M    0.53    0.79    0.00    0.00     1472     54</span><br><span class="line">   3    1     0.00   0.29   0.00    1.33      23 K     44 K    0.38    0.86    0.00    0.00        0     47</span><br><span class="line">   4    0     0.14   0.84   0.17    0.96    3001 K   7083 K    0.53    0.79    0.00    0.00      640     49</span><br><span class="line">   5    1     0.01   0.53   0.03    0.99     129 K   2453 K    0.93    0.61    0.00    0.00      256     61</span><br><span class="line">   6    0     0.21   0.85   0.25    1.04    5115 K     11 M    0.50    0.80    0.00    0.00      384     54</span><br><span class="line">   7    1     0.03   0.55   0.05    1.10     273 K   4573 K    0.93    0.60    0.00    0.00     1344     57</span><br><span class="line">   8    0     0.21   0.80   0.26    1.06    5361 K     11 M    0.49    0.80    0.00    0.00     1216     54</span><br><span class="line">   9    1     0.09   0.57   0.16    1.32     769 K     14 M    0.94    0.65    0.00    0.00     2048     57</span><br><span class="line">  10    0     0.21   0.74   0.29    1.26    7000 K     14 M    0.48    0.79    0.00    0.00      256     52</span><br><span class="line">  11    1     0.02   0.44   0.04    1.30    1072 K   2780 K    0.36    0.62    0.00    0.00        0     54</span><br><span class="line">  12    0     0.20   0.84   0.23    1.08    4916 K     11 M    0.50    0.78    0.00    0.00      640     53</span><br><span class="line">  13    1     0.01   0.55   0.03    1.06     158 K   2583 K    0.92    0.61    0.00    0.00      192     57</span><br><span class="line">  14    0     0.14   0.70   0.20    1.26    2654 K   7546 K    0.58    0.81    0.00    0.00     1664     52</span><br><span class="line">  15    1     0.00   0.52   0.01    0.78      54 K    897 K    0.78    0.57    0.00    0.00        0     54</span><br><span class="line">  16    0     0.11   0.74   0.14    0.96    2978 K   7413 K    0.54    0.78    0.00    0.00     3328     53</span><br><span class="line">  17    1     0.00   0.50   0.01    0.80      38 K    610 K    0.79    0.57    0.00    0.00        0     59</span><br><span class="line">  18    0     0.15   0.69   0.22    1.00    5981 K     12 M    0.45    0.78    0.00    0.00     2368     53</span><br><span class="line">  19    1     0.13   2.30   0.06    1.07     186 K    952 K    0.79    0.53    0.00    0.00      128     58</span><br><span class="line">  20    0     0.11   0.74   0.14    0.87    5408 K     10 M    0.43    0.74    0.00    0.00     4928     52</span><br><span class="line">  21    1     0.01   0.44   0.03    1.05    1742 K   2476 K    0.22    0.74    0.00    0.00      448     55</span><br><span class="line">  22    0     0.20   0.84   0.23    0.98    4198 K   9626 K    0.51    0.81    0.00    0.00      576     55</span><br><span class="line">  23    1     0.00   0.87   0.00    0.52     191 K    316 K    0.37    0.59    0.00    0.00      192     60</span><br><span class="line">  24    0     0.15   0.86   0.17    1.05    2357 K   6482 K    0.58    0.80    0.00    0.00      384     52</span><br><span class="line">  25    1     0.01   1.18   0.00    0.50     123 K    275 K    0.49    0.82    0.00    0.00        0     59</span><br><span class="line">  26    0     0.12   0.76   0.16    1.02    4988 K     10 M    0.43    0.77    0.00    0.00      704     52</span><br><span class="line">  27    1     0.01   1.06   0.01    0.69     125 K   1009 K    0.87    0.63    0.00    0.00        0     55</span><br><span class="line">  28    0     0.15   0.83   0.18    0.99    4284 K   9017 K    0.46    0.79    0.00    0.00     1792     53</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://fatmin.com/2016/06/10/numa-node-to-pci-slot-mapping-in-red-hat-enterpise-linux/" target="_blank" rel="noopener">NUMA Node to PCI Slot Mapping in Red Hat Enterpise Linux</a></li>
<li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html-single/virtualization_tuning_and_optimization_guide/index#sect-Virtualization_Tuning_Optimization_Guide-NUMA-Auto_NUMA_Balancing" target="_blank" rel="noopener">虚拟化调试和优化指南</a></li>
<li><a href="https://github.com/LucaCanali/Miscellaneous/blob/master/Spark_Notes/Tools_Linux_Memory_Perf_Measure.md" target="_blank" rel="noopener">Notes and tools for measuring CPU-to-memory throughput in Linux</a></li>
<li><a href="https://frankdenneman.nl/2020/01/30/machine-learning-workload-and-gpgpu-numa-node-locality/" target="_blank" rel="noopener">Machine Learning Workload and GPGPU NUMA Node Locality</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>pci</tag>
        <tag>numa</tag>
      </tags>
  </entry>
  <entry>
    <title>RDMA的底层传输模式</title>
    <url>/post/53570e5e.html</url>
    <content><![CDATA[<p><img src="/images/2021/06/rdma_protocol.png" alt="rdma_protocol"></p>
<p>常见的RDMA实现有<code>InfiniBand (IB)</code>,<code>RDMA over Converged Etherent (RoCE)</code>以及<code>iWARP</code></p>
<a id="more"></a>
<h2 id="RDMA协议"><a href="#RDMA协议" class="headerlink" title="RDMA协议"></a>RDMA协议</h2><h3 id="InfiniBand"><a href="#InfiniBand" class="headerlink" title="InfiniBand"></a>InfiniBand</h3><p>InfiniBand (IB) 是一组高性能网络通信标准，由 InfiniBand Trade Association (IBTA) 制定并推动。InfiniBand 架构规范的 1.0 版本发布于 2000 年，其中原生地支持了 RDMA，大概也是最早的 RDMA 实现。然而，IB 架构并不兼容以太网，在部署时除了需要支持 IB 的网卡外，还需要购买相应的交换设备。</p>
<h3 id="RoCE"><a href="#RoCE" class="headerlink" title="RoCE"></a>RoCE</h3><p>RoCE 是基于以太网的 RDMA 标准，同样由 IBTA 制定，允许在以太网网络中实现远程直接内存访问。RoCE 有两个版本：<code>RoCE v1</code>与<code>RoCE v2</code>。RoCE v1 是链路层协议（L2），可以实现在同一广播域中任意两台主机之间的通信。RoCE v2 是网络层协议（L3），这意味着 RoCE v2 的数据包可以被路由，也就是说可以通过传统的以太网交换机来使用 RDMA。</p>
<p>RoCE v2 构筑于 UDP/IP 协议之上，这种简单快乐的连接虽然保证了高性能与低 CPU 开销，但不能提供可靠传输。一种解决方案是，在 L2 对网络中的流传输进行控制，通过实现无损的以太网传输来保证数据传输的可靠性。另一种解决方案是增加 RoCE 协议的可靠性，向 RoCE 中添加握手，以牺牲性能为代价提供可靠性。业内似乎更倾向于第一种解决方案，即在不丢包的前提下，尽可能提高通信性能，或者说“拥塞控制”。随着大型企业将 RDMA 技术应用到数据中心，各种拥塞控制算法也在不断被提出，比如微软的 DCQCN，谷歌的 Swift，阿里的 HPCC… 其实有关数据中心的拥塞控制也是杀意已决一直想写的话题，不过我还是不给自己挖坑了（喂喂…</p>
<h3 id="iWARP"><a href="#iWARP" class="headerlink" title="iWARP"></a>iWARP</h3><p>iWARP 是基于 TCP/IP 协议、面向连接的 RDMA 传输。由 IEFT 在 2007 年提出。与 RoCE v2 一样，iWARP 数据包可以路由，但在大规模数据中心或大规模应用程序中使用 iWARP 时，大量的 TCP 连接与可靠传输将导致凄惨的性能，在此也不打算过多介绍。牙膏厂曾写过一篇名为“Understanding iWARP”的文章，各位可以访问这里参详。</p>
<h2 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h2><h3 id="RoCEv2-vs-InfiniBand"><a href="#RoCEv2-vs-InfiniBand" class="headerlink" title="RoCEv2 vs InfiniBand"></a>RoCEv2 vs InfiniBand</h3><p>网络架构：InfiniBand 只能在 IB 架构规范中实现，RoCE 可以在以太网架构中实现。<br>链路级的流量控制：InfiniBand 使用一个积分算法（credit-based，不是 integral-based）来保证无损的 HCA-to-HCA 通信。RDMA 需要通过无损的 L2 网络（DCB: PFC + ECN）实现可靠的数据传输。<br>拥塞控制：InfiniBand 使用基于 FECN/BECN 的拥塞控制，RoCE v2 定义了一个拥塞控制协议，通过 ECN 与 CNP 进行拥塞控制。</p>
<h3 id="RoCEv2-vs-RoCEv1"><a href="#RoCEv2-vs-RoCEv1" class="headerlink" title="RoCEv2 vs RoCEv1"></a>RoCEv2 vs RoCEv1</h3><p><img src="/images/2021/06/rdma_rocev1_vs_rocev2.png" alt="RDMA_rocev1_vs_rocev2"><br>路由：RoCE v1只能在广播域内通信，RoCE v2支持L3路由。</p>
<h3 id="iWARP-vs-RoCEv2"><a href="#iWARP-vs-RoCEv2" class="headerlink" title="iWARP vs RoCEv2"></a>iWARP vs RoCEv2</h3><p>底层：iWARP基于TCP/IP协议，RoCE v2基于UDP/IP协议。<br>iWARP 支持传输层的拥塞控制。<br>不需要无损的L2网络。<br>性能表现可能会比RoCE糟糕。</p>
<h2 id="链路层模式"><a href="#链路层模式" class="headerlink" title="链路层模式"></a>链路层模式</h2><p>链路层主要分为两类：<code>InfiniBand</code>和<code>Ethernet</code></p>
<p>查看链路类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ibstat</span><br><span class="line">CA &apos;mlx4_0&apos;</span><br><span class="line">	CA type: MT4099</span><br><span class="line">	Number of ports: 1</span><br><span class="line">	Firmware version: 2.36.5000</span><br><span class="line">	Hardware version: 1</span><br><span class="line">	Node GUID: 0x001e670300bd84ec</span><br><span class="line">	System image GUID: 0x001e670300bd84ef</span><br><span class="line">	Port 1:</span><br><span class="line">		State: Down</span><br><span class="line">		Physical state: Disabled</span><br><span class="line">		Rate: 10</span><br><span class="line">		Base lid: 0</span><br><span class="line">		LMC: 0</span><br><span class="line">		SM lid: 0</span><br><span class="line">		Capability mask: 0x00010000</span><br><span class="line">		Port GUID: 0x021e67fffebd84ed</span><br><span class="line">		Link layer: Ethernet</span><br></pre></td></tr></table></figure></p>
<h2 id="InfiniBand与Ethernet之间的区别"><a href="#InfiniBand与Ethernet之间的区别" class="headerlink" title="InfiniBand与Ethernet之间的区别"></a>InfiniBand与Ethernet之间的区别</h2><ul>
<li>InfiniBand模式的延时更低，带宽更高<ul>
<li>ConnectX-4 Lx EN （Ethernet）提供 1、10、25、40 和50GbE带宽、<code>亚微秒级延迟</code></li>
<li>ConnectX-5 具备 Virtual Protocol Interconnect®,支持具有 100Gb/s InfiniBand 和以太网连接、小于<code>600纳秒的延迟</code></li>
</ul>
</li>
<li>InfiniBand采用Cut-Through转发模式，减少转发时延，基于Credit流控机制，保证无丢包。RoCE性能与IB网络相当，DCB特性保证无丢包，需要网络支持DCB特性，但时延比IB交换机时延稍高一些</li>
<li>Ethernet模式可能存在丢包，而导致数据重传的延时</li>
</ul>
<h2 id="InfiniBand与Ethernet链路层切换"><a href="#InfiniBand与Ethernet链路层切换" class="headerlink" title="InfiniBand与Ethernet链路层切换"></a>InfiniBand与Ethernet链路层切换</h2><p>通过<code>ibstatus</code>命令可以查看当前网卡的工作模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Infiniband device 'mlx5_1' port 1 status:</span><br><span class="line">	default gid:	 fe80:0000:0000:0000:0e42:a1ff:fe41:2d37</span><br><span class="line">	base lid:	 0x0</span><br><span class="line">	sm lid:		 0x0</span><br><span class="line">	state:		 4: ACTIVE</span><br><span class="line">	phys state:	 5: LinkUp</span><br><span class="line">	rate:		 25 Gb/sec (1X EDR)</span><br><span class="line">	link_layer:	 Ethernet    （工作模式：IP模式）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>网卡现在处于<code>Ethernet</code>的工作模式，如果想要切换成<code>infiniband</code>模式</p>
</blockquote>
<p>参考：<a href="https://community.mellanox.com/s/article/howto-change-port-type-in-mellanox-connectx-3-adapter" target="_blank" rel="noopener">https://community.mellanox.com/s/article/howto-change-port-type-in-mellanox-connectx-3-adapter</a></p>
<p>ConnectX®-5 端口可以单独配置为用作<code>InfiniBand</code>或<code>Ethernet</code>端口，使用命令<code>mlxconfig</code></p>
<h3 id="启动mst工具"><a href="#启动mst工具" class="headerlink" title="启动mst工具"></a>启动mst工具</h3><p>需要安装官方驱动，以下配置用于ConnectX-4网卡。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mst</span><br></pre></td></tr></table></figure>
<p>查看mst设备<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mst status</span></span><br><span class="line">MST modules:</span><br><span class="line">------------</span><br><span class="line">    MST PCI module is not loaded</span><br><span class="line">    MST PCI configuration module loaded</span><br><span class="line"></span><br><span class="line">MST devices:</span><br><span class="line">------------</span><br><span class="line">/dev/mst/mt4117_pciconf0         - PCI configuration cycles access.</span><br><span class="line">                                   domain:bus:dev.fn=0000:f7:00.0 addr.reg=88 data.reg=92 cr_bar.gw_offset=-1</span><br><span class="line">                                   Chip revision is: 00</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>MST devices: /dev/mst/mt4117_pciconf0</p>
</blockquote>
<p>注：ConnectX-4网卡无法进行IB与eth模式之间切换，因为该网卡只支持Ethernet模式。只有VPI卡支持IB模式与以太网模式切换。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># lspci -s 02:00.0 -v</span><br><span class="line">02:00.0 Ethernet controller: Mellanox Technologies MT27710 Family [ConnectX-4 Lx]</span><br><span class="line">	Subsystem: Mellanox Technologies Stand-up ConnectX-4 Lx EN, 25GbE dual-port SFP28, PCIe3.0 x8, MCX4121A-ACAT</span><br><span class="line">	Physical Slot: 2</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 46, NUMA node 0</span><br><span class="line">	Memory at 38007a000000 (64-bit, prefetchable) [size=32M]</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>ConnectX-4 Lx EN</code>:代表以太网卡，只支持Ethernet模式，ConnectX®-4 Lx EN 支持 RDMA、叠加 (Overlay) 网络封装/解封等功能的1/10/25/40/50 Gb 以太网适配器卡<br> <a href="https://www.mellanox.com/files/doc-2020/pb-connectx-4-lx-en-card.pdf" target="_blank" rel="noopener">https://www.mellanox.com/files/doc-2020/pb-connectx-4-lx-en-card.pdf</a></p>
</blockquote>
<h3 id="查看网卡的配置信息"><a href="#查看网卡的配置信息" class="headerlink" title="查看网卡的配置信息"></a>查看网卡的配置信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mlxconfig -d /dev/mst/mt4117_pciconf0 q | grep <span class="string">"LINK"</span></span></span><br><span class="line">         KEEP_ETH_LINK_UP_P1                 True(1)         </span><br><span class="line">         KEEP_IB_LINK_UP_P1                  False(0)        </span><br><span class="line">         KEEP_LINK_UP_ON_BOOT_P1             False(0)        </span><br><span class="line">         KEEP_LINK_UP_ON_STANDBY_P1          False(0)        </span><br><span class="line">         AUTO_POWER_SAVE_LINK_DOWN_P1        False(0)        </span><br><span class="line">         KEEP_ETH_LINK_UP_P2                 True(1)         </span><br><span class="line">         KEEP_IB_LINK_UP_P2                  False(0)        </span><br><span class="line">         KEEP_LINK_UP_ON_BOOT_P2             False(0)        </span><br><span class="line">         KEEP_LINK_UP_ON_STANDBY_P2          False(0)        </span><br><span class="line">         AUTO_POWER_SAVE_LINK_DOWN_P2        False(0)</span><br></pre></td></tr></table></figure>
<h3 id="ConnectX-5网卡"><a href="#ConnectX-5网卡" class="headerlink" title="ConnectX-5网卡"></a>ConnectX-5网卡</h3><blockquote>
<p>注： 以下命令适用于<code>ConnectX-5</code>，只有VPI卡支持模式切换</p>
</blockquote>
<p>例如：ConnectX®-5 VPI 卡 100Gb/s InfiniBand 和以太网适配器卡</p>
<ul>
<li>Ethernet模式： <code>mlxconfig -d /dev/mst/mt4119_pciconf0 set LINK_TYPE_P1=2</code></li>
<li>IB模式： <code>mlxconfig -d /dev/mst/mt4119_pciconf0 set LINK_TYPE_P1=1</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://pc.nanog.org/static/published/meetings/NANOG76/1999/20190612_Cardona_Towards_Hyperscale_High_v1.pdf" target="_blank" rel="noopener">Towards Hyperscale High Performance Computing with RDMA</a></li>
<li><a href="https://www.infinibandta.org/roce-and-infiniband-which-should-i-choose/" target="_blank" rel="noopener">RoCE and InfiniBand: Which should I choose?</a></li>
<li><a href="https://blog.csdn.net/github_33873969/article/details/83017820" target="_blank" rel="noopener">RDMA简介相关内容</a></li>
<li><a href="https://mymellanox.force.com/mellanoxcommunity/s/article/howto-configure-roce-on-connectx-4" target="_blank" rel="noopener">HowTo Configure RoCE on ConnectX-4</a></li>
<li><a href="https://docs.mellanox.com/pages/viewpage.action?pageId=39284930" target="_blank" rel="noopener">RDMA over Converged Ethernet (RoCE)</a></li>
<li><a href="https://community.mellanox.com/s/article/rdma-roce-solutions" target="_blank" rel="noopener">RDMA/RoCE Solutions</a></li>
<li><a href="https://community.mellanox.com/s/article/recommended-network-configuration-examples-for-roce-deployment" target="_blank" rel="noopener">Recommended Network Configuration Examples for RoCE Deployment</a></li>
<li><a href="https://lenovopress.com/lp0098.pdf" target="_blank" rel="noopener">Mellanox ConnectX-4 Adapters</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>rdma</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8中的SIMD运算</title>
    <url>/post/13631.html</url>
    <content><![CDATA[<p><code>NEON</code>是一种压缩的SIMD架构，主要是给多媒体使用，结果并行计算的问题。</p>
<blockquote>
<p>NEON是ARMv7-A和ARMv7-R引入的特性，在后面的ARMv8-A和ARMv8-R中也扩展其功能.1288bit的向量运算</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">ARMv7-A/R</th>
<th style="text-align:center">ARMv8-A/R</th>
<th style="text-align:center">ARMv8-A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">AArch32</td>
<td style="text-align:center">AArch64</td>
</tr>
<tr>
<td style="text-align:center">Floating-point</td>
<td style="text-align:center">32-bit</td>
<td style="text-align:center">16-bit*/32-bit</td>
<td style="text-align:center">16-bit*/32-bit</td>
</tr>
<tr>
<td style="text-align:center">Integer</td>
<td style="text-align:center">8-bit/16-bit/32-bit</td>
<td style="text-align:center">8-bit/16-bit/32-bit/64-bit</td>
<td style="text-align:center">8-bit/16-bit/32-bit/64-bit</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="ARMv8与ARMv7的区别"><a href="#ARMv8与ARMv7的区别" class="headerlink" title="ARMv8与ARMv7的区别"></a>ARMv8与ARMv7的区别</h2><ul>
<li>1.与<code>通用寄存器</code>相同的助记符</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">CPU</th>
<th style="text-align:center">通用</th>
<th style="text-align:center">SIMD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ARMv7</td>
<td style="text-align:center">mul, r0, r0, r1</td>
<td style="text-align:center">vmul d0, d0, d1</td>
</tr>
<tr>
<td style="text-align:center">ARMv8</td>
<td style="text-align:center">mul x0, x0, x1</td>
<td style="text-align:center">mul v0.u8, v0.u8, v1.u8</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：在ARMv7中所有的SIMD汇编的操作码如<code>mul</code>的前缀都有<code>v</code>如vml</strong></p>
</blockquote>
<ul>
<li><p>2.ARMv8的寄存器是ARMv7的两倍</p>
<ul>
<li>ARMv8拥有<code>32</code>个128-bit寄存器</li>
<li>ARMv7拥有<code>16</code>个128-bit寄存器</li>
</ul>
</li>
<li><p>3.不同的指令语法</p>
</li>
</ul>
<h2 id="SIMD寄存器"><a href="#SIMD寄存器" class="headerlink" title="SIMD寄存器"></a>SIMD寄存器</h2><p><img src="/images/2019/03/armv8simd寄存器.png" alt="armv8SIMD寄存器"></p>
<table>
<thead>
<tr>
<th style="text-align:center">寄存器</th>
<th style="text-align:center">个数</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D寄存器（<code>D0-D31</code>）</td>
<td style="text-align:center">32个</td>
<td style="text-align:center">64-bit</td>
<td style="text-align:center">双字（double word）</td>
</tr>
<tr>
<td style="text-align:center">Q寄存器（<code>Q0-Q15</code>）</td>
<td style="text-align:center">16个</td>
<td style="text-align:center">128-bit</td>
<td style="text-align:center">四字</td>
</tr>
</tbody>
</table>
<h2 id="矢量寄存器V0-V31：包装"><a href="#矢量寄存器V0-V31：包装" class="headerlink" title="矢量寄存器V0-V31：包装"></a>矢量寄存器V0-V31：包装</h2><p><img src="/images/2019/03/armv8simd寄存器标识vx.png" alt="armv8SIMD寄存器标识vx"></p>
<p>打包V0-V31中的数据，方便数据操作</p>
<p><img src="/images/2019/03/armv8simd寄存器打包.png" alt="ARMv8SIMD寄存器打包"></p>
<h2 id="矢量包装"><a href="#矢量包装" class="headerlink" title="矢量包装"></a>矢量包装</h2><p><img src="/images/2019/03/armvc8.png" alt="ARMvc8"></p>
<p><strong>主要定义每一个矢量Vn的数据位宽</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标识</th>
<th style="text-align:center">位宽</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>b</code></td>
<td style="text-align:center">8bit</td>
<td style="text-align:center">char</td>
<td style="text-align:left">v0.8b,v0.16b: 8个bit16个bit</td>
</tr>
<tr>
<td style="text-align:center"><code>h</code></td>
<td style="text-align:center">16bit</td>
<td style="text-align:center">short</td>
<td style="text-align:left">v0.4h，v0.8h： 4或8个半字（short类型）</td>
</tr>
<tr>
<td style="text-align:center"><code>s</code></td>
<td style="text-align:center">32bit</td>
<td style="text-align:center">int</td>
<td style="text-align:left">v0.2s，v0.4s：2或4个字</td>
</tr>
<tr>
<td style="text-align:center"><code>d</code></td>
<td style="text-align:center">64bit</td>
<td style="text-align:center">long long</td>
<td style="text-align:left">v0.2d：2个double word</td>
</tr>
</tbody>
</table>
<h2 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h2><p><img src="/images/2019/03/armv8simd指令op.png" alt="ARMv8SIMD指令op"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ld4 &#123;v0.4h-v3.4h&#125;, [%0]</span><br></pre></td></tr></table></figure>
<p>等同于：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ld4 &#123;v0.4h, v1.4h, v2.4h, v3.4h&#125;, [%0]</span><br></pre></td></tr></table></figure></p>
<h2 id="内联函数编程"><a href="#内联函数编程" class="headerlink" title="内联函数编程"></a>内联函数编程</h2><p>NEON 内在函数在头文件<code>arm_neon.h</code>中定义。头文件既定义内在函数，也定义一组向量类型</p>
<blockquote>
<p><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0348bc/DUI0348BC_rvct_comp_ref_guide.pdf" target="_blank" rel="noopener">NEON操作函数</a></p>
<ul>
<li><a href="https://raw.githubusercontent.com/EmDepTeam/arm-linux-gnueabihf/master/lib/gcc/arm-linux-gnueabihf/7.3.1/include/arm_neon.h" target="_blank" rel="noopener">arm_neon.h
</a></li>
</ul>
</blockquote>
<h2 id="内嵌汇编编程"><a href="#内嵌汇编编程" class="headerlink" title="内嵌汇编编程"></a>内嵌汇编编程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asm volatile(</span><br><span class="line">    &quot;mnemonic+operand \n\t&quot;</span><br><span class="line">    &quot;mnemonic+operand \n\t&quot;</span><br><span class="line">    &quot;mnemonic+operand \n\t&quot;</span><br><span class="line"></span><br><span class="line">    : //output operand list  /*输出操作数列表*/</span><br><span class="line">    : //input operand list   /*输入操作数列表*/</span><br><span class="line">    : //Dirty registers etc  /*被改变资源列表*/</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="操作符-amp-修饰符"><a href="#操作符-amp-修饰符" class="headerlink" title="操作符&amp;修饰符"></a>操作符&amp;修饰符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asm volatile(</span><br><span class="line">        &quot;add %0, %1, %2&quot;</span><br><span class="line"></span><br><span class="line">        : &quot;=r&quot; (ret)</span><br><span class="line">        : &quot;r&quot; (a), &quot;r&quot; (b)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>操作符</strong></th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:center">通用寄存器</td>
</tr>
<tr>
<td style="text-align:center"><code>m</code></td>
<td style="text-align:center">一个有效的内存地址</td>
</tr>
<tr>
<td style="text-align:center"><code>I</code></td>
<td style="text-align:center">数据处理中的立即数</td>
</tr>
<tr>
<td style="text-align:center"><code>X</code></td>
<td style="text-align:center">被修饰的操作符只能作为输出</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>修饰符</strong></th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>无</code></td>
<td style="text-align:center">只读</td>
</tr>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center">只写</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">可读可写</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">只能作为输出</td>
</tr>
</tbody>
</table>
<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><h4 id="参数序列"><a href="#参数序列" class="headerlink" title="参数序列"></a>参数序列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asm volatile(</span><br><span class="line">        &quot;add %0, %1, %2&quot;</span><br><span class="line"></span><br><span class="line">        : &quot;=r&quot; (ret)</span><br><span class="line">        : &quot;r&quot; (a), &quot;r&quot; (b)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>ret</code>: <code>%0</code>, 第一个参数</li>
<li><code>a</code>  : <code>%1</code>, 第二个参数</li>
<li><code>b</code>  : <code>%2</code>, 第三个参数</li>
</ul>
</blockquote>
<h4 id="参数名"><a href="#参数名" class="headerlink" title="参数名"></a>参数名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asm volatile(</span><br><span class="line">        &quot;add %[result], %[a], %[b]&quot;</span><br><span class="line"></span><br><span class="line">        : [result] &quot;=r&quot; (ret)</span><br><span class="line">        : [a] &quot;r&quot; (a), [b] &quot;r&quot; (b)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>传入参数不依赖参数序列</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="4x4矩阵乘法"><a href="#4x4矩阵乘法" class="headerlink" title="4x4矩阵乘法"></a>4x4矩阵乘法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __aarch64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arm_neon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">uint16_t</span> **x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">uint16_t</span> *xx = (<span class="keyword">uint16_t</span> *)x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3d "</span>, *(xx + (i &lt;&lt; <span class="number">2</span>) + j));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matrix_mul_c</span><span class="params">(<span class="keyword">uint16_t</span> aa[][<span class="number">4</span>], <span class="keyword">uint16_t</span> bb[][<span class="number">4</span>], <span class="keyword">uint16_t</span> cc[][<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d\n"</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            cc[i][j] = aa[i][j] * bb[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __aarch64__</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matrix_mul_neon</span><span class="params">(<span class="keyword">uint16_t</span> **aa, <span class="keyword">uint16_t</span> **bb, <span class="keyword">uint16_t</span> **cc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d\n"</span>, __func__, __LINE__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">    <span class="keyword">uint16_t</span> (*a)[<span class="number">4</span>] = (<span class="keyword">uint16_t</span> (*)[<span class="number">4</span>])aa;</span><br><span class="line">    <span class="keyword">uint16_t</span> (*b)[<span class="number">4</span>] = (<span class="keyword">uint16_t</span> (*)[<span class="number">4</span>])bb;</span><br><span class="line">    <span class="keyword">uint16_t</span> (*c)[<span class="number">4</span>] = (<span class="keyword">uint16_t</span> (*)[<span class="number">4</span>])cc;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"aaaaaaaa\n"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _cc0;</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _cc1;</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _cc2;</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _cc3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16x4_t</span> _aa0 = vld1_u16((<span class="keyword">uint16_t</span>*)a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _aa1 = vld1_u16((<span class="keyword">uint16_t</span>*)a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _aa2 = vld1_u16((<span class="keyword">uint16_t</span>*)a[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _aa3 = vld1_u16((<span class="keyword">uint16_t</span>*)a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16x4_t</span> _bb0 = vld1_u16((<span class="keyword">uint16_t</span>*)b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _bb1 = vld1_u16((<span class="keyword">uint16_t</span>*)b[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _bb2 = vld1_u16((<span class="keyword">uint16_t</span>*)b[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _bb3 = vld1_u16((<span class="keyword">uint16_t</span>*)b[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    _cc0 = vmul_u16(_aa0, _bb0);</span><br><span class="line">    _cc1 = vmul_u16(_aa1, _bb1);</span><br><span class="line">    _cc2 = vmul_u16(_aa2, _bb2);</span><br><span class="line">    _cc3 = vmul_u16(_aa3, _bb3);</span><br><span class="line"></span><br><span class="line">    vst1_u16((<span class="keyword">uint16_t</span>*)c[<span class="number">0</span>], _cc0);</span><br><span class="line">    vst1_u16((<span class="keyword">uint16_t</span>*)c[<span class="number">1</span>], _cc1);</span><br><span class="line">    vst1_u16((<span class="keyword">uint16_t</span>*)c[<span class="number">2</span>], _cc2);</span><br><span class="line">    vst1_u16((<span class="keyword">uint16_t</span>*)c[<span class="number">3</span>], _cc3);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bbbbbbbb\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16x4_t</span> _aa[<span class="number">4</span>], _bb[<span class="number">4</span>], _cc[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> *a = (<span class="keyword">uint16_t</span>*)aa;</span><br><span class="line">    <span class="keyword">uint16_t</span> *b = (<span class="keyword">uint16_t</span>*)bb;</span><br><span class="line">    <span class="keyword">uint16_t</span> *c = (<span class="keyword">uint16_t</span>*)cc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        _aa[i] = vld1_u16(a + (i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">        _bb[i] = vld1_u16(b + (i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">        _cc[i] = vmul_u16(_aa[i], _bb[i]);</span><br><span class="line">        vst1_u16(c + (i &lt;&lt; <span class="number">2</span>), _cc[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matrix_mul_asm</span><span class="params">(<span class="keyword">uint16_t</span> **aa, <span class="keyword">uint16_t</span> **bb, <span class="keyword">uint16_t</span> **cc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d\n"</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> *a = (<span class="keyword">uint16_t</span>*)aa;</span><br><span class="line">    <span class="keyword">uint16_t</span> *b = (<span class="keyword">uint16_t</span>*)bb;</span><br><span class="line">    <span class="keyword">uint16_t</span> *c = (<span class="keyword">uint16_t</span>*)cc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ldr d3, [%0, #0]           \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ldr d2, [%0, #8]           \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ldr d1, [%0, #16]          \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ldr d0, [%0, #24]          \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ldr d7, [%1, #0]           \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ldr d6, [%1, #8]           \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ldr d5, [%1, #16]          \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ldr d4, [%1, #24]          \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v3.4h, v3.4h, v7.4h    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v2.4h, v2.4h, v6.4h    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v1.4h, v1.4h, v5.4h    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v0.4h, v0.4h, v4.4h    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">//"add v3.4h, v3.4h, v7.4h    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">//"add v2.4h, v2.4h, v6.4h    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">//"add v1.4h, v1.4h, v5.4h    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">//"add v0.4h, v0.4h, v4.4h    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"str d3, [%2,#0]            \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"str d2, [%2,#8]            \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"str d1, [%2,#16]           \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"str d0, [%2,#24]           \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"+r"</span>(a),   <span class="comment">//%0</span></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"+r"</span>(b),   <span class="comment">//%1</span></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"+r"</span>(c)    <span class="comment">//%2</span></span></span></span><br><span class="line"><span class="function"><span class="params">        :</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"cc"</span>, <span class="string">"memory"</span>, <span class="string">"d0"</span>, <span class="string">"d1"</span>, <span class="string">"d2"</span>, <span class="string">"d3"</span>, <span class="string">"d4"</span>, <span class="string">"d5"</span>, <span class="string">"d6"</span>, <span class="string">"d7"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// test, OK</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">//"ld4 &#123;v0.4h, v1.4h, v2.4h, v3.4h&#125;, [%0] \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ld4 &#123;v0.4h-v3.4h&#125;, [%0]                \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ld4 &#123;v4.4h, v5.4h, v6.4h, v7.4h&#125;, [%1] \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v3.4h, v3.4h, v7.4h                \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v2.4h, v2.4h, v6.4h                \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v1.4h, v1.4h, v5.4h                \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v0.4h, v0.4h, v4.4h                \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"st4 &#123;v0.4h, v1.4h, v2.4h, v3.4h&#125;, [%2] \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"+r"</span>(a),   <span class="comment">//%0</span></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"+r"</span>(b),   <span class="comment">//%1</span></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"+r"</span>(c)    <span class="comment">//%2</span></span></span></span><br><span class="line"><span class="function"><span class="params">        :</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"cc"</span>, <span class="string">"memory"</span>, <span class="string">"v0"</span>, <span class="string">"v1"</span>, <span class="string">"v2"</span>, <span class="string">"v3"</span>, <span class="string">"v4"</span>, <span class="string">"v5"</span>, <span class="string">"v6"</span>, <span class="string">"v7"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"nop"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> aa[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> bb[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> cc[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start_us = <span class="number">0</span>, end_us = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dump((<span class="keyword">uint16_t</span> **)aa);</span><br><span class="line">    dump((<span class="keyword">uint16_t</span> **)bb);</span><br><span class="line">    dump((<span class="keyword">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ******** C **********/</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    start_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line"></span><br><span class="line">    matrix_mul_c(aa, bb, cc);</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    end_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"aa[][]*bb[][] C time %lld us\n"</span>, end_us - start_us);</span><br><span class="line">    dump((<span class="keyword">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __aarch64__</span></span><br><span class="line">    <span class="comment">/* ******** NEON **********/</span></span><br><span class="line">    <span class="built_in">memset</span>(cc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>) * <span class="number">4</span> * <span class="number">4</span>);</span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    start_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line"></span><br><span class="line">    matrix_mul_neon((<span class="keyword">uint16_t</span> **)aa, (<span class="keyword">uint16_t</span> **)bb, (<span class="keyword">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    end_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"aa[][]*bb[][] neon time %lld us\n"</span>, end_us - start_us);</span><br><span class="line">    dump((<span class="keyword">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ******** asm **********/</span></span><br><span class="line">    <span class="built_in">memset</span>(cc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>) * <span class="number">4</span> * <span class="number">4</span>);</span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    start_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line"></span><br><span class="line">    matrix_mul_asm((<span class="keyword">uint16_t</span> **)aa, (<span class="keyword">uint16_t</span> **)bb, (<span class="keyword">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    end_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"aa[][]*bb[][] asm time %lld us\n"</span>, end_us - start_us);</span><br><span class="line">    dump((<span class="keyword">uint16_t</span> **)cc);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gcc -O3  matrix_4x4_mul.c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc –march=armv8-a [input file] -o [output file]</p>
</blockquote>
<h3 id="8x8矩阵乘法"><a href="#8x8矩阵乘法" class="headerlink" title="8x8矩阵乘法"></a>8x8矩阵乘法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matrix_mul_asm</span><span class="params">(<span class="keyword">uint16_t</span> **aa, <span class="keyword">uint16_t</span> **bb, <span class="keyword">uint16_t</span> **cc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"===&gt; func: %s, line: %d\n"</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> *a = (<span class="keyword">uint16_t</span>*)aa;</span><br><span class="line">    <span class="keyword">uint16_t</span> *b = (<span class="keyword">uint16_t</span>*)bb;</span><br><span class="line">    <span class="keyword">uint16_t</span> *c = (<span class="keyword">uint16_t</span>*)cc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ld4 &#123;v0.8h, v1.8h, v2.8h, v3.8h&#125;, [%0]     \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ld4 &#123;v8.8h, v9.8h, v10.8h, v11.8h&#125;, [%1]   \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v0.8h, v0.8h, v8.8h                    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v1.8h, v1.8h, v9.8h                    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v2.8h, v2.8h, v10.8h                   \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v3.8h, v3.8h, v11.8h                   \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"st4 &#123;v0.8h, v1.8h, v2.8h, v3.8h&#125;, [%2]     \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"add x1, %0, #64                            \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"add x2, %1, #64                            \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"add x3, %2, #64                            \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">//"ld4 &#123;v4.8h-v7.8h&#125;, [x1]                    \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ld4 &#123;v4.8h, v5.8h, v6.8h, v7.8h&#125;, [x1]     \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"ld4 &#123;v12.8h, v13.8h, v14.8h, v15.8h&#125;, [x2] \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v4.8h, v4.8h, v12.8h                   \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v5.8h, v5.8h, v13.8h                   \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v6.8h, v6.8h, v14.8h                   \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mul v7.8h, v7.8h, v15.8h                   \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"st4 &#123;v4.8h, v5.8h, v6.8h, v7.8h&#125;, [x3]     \n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"+r"</span>(a),   <span class="comment">//%0</span></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"+r"</span>(b),   <span class="comment">//%1</span></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"+r"</span>(c)    <span class="comment">//%2</span></span></span></span><br><span class="line"><span class="function"><span class="params">        :</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"cc"</span>, <span class="string">"memory"</span>, <span class="string">"x1"</span>, <span class="string">"x2"</span>, <span class="string">"x3"</span>, <span class="string">"v0"</span>, <span class="string">"v1"</span>, <span class="string">"v2"</span>, <span class="string">"v3"</span>, <span class="string">"v4"</span>, <span class="string">"v5"</span>, <span class="string">"v6"</span>, <span class="string">"v7"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"v8"</span>, <span class="string">"v9"</span>, <span class="string">"v10"</span>, <span class="string">"v11"</span>, <span class="string">"v12"</span>, <span class="string">"v13"</span>, <span class="string">"v14"</span>, <span class="string">"v15"</span></span></span></span><br><span class="line"><span class="function"><span class="params">      )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内嵌汇编实现方式<code>8x8</code></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.uio.no/studier/emner/matnat/ifi/INF5063/h16/pensumliste/armv8-neon-programming.pdf" target="_blank" rel="noopener">ARMv8 Neon Programming</a></li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dht0002a/DHT0002A_introducing_neon.pdf" target="_blank" rel="noopener">Introducing NEON</a></li>
<li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-1-load-and-stores" target="_blank" rel="noopener">Coding for NEON - Part 1: Load and Stores</a></li>
<li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-2-dealing-with-leftovers" target="_blank" rel="noopener">Coding for NEON - Part 2: Dealing With Leftovers</a></li>
<li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-3-matrix-multiplication" target="_blank" rel="noopener">Coding for NEON - Part 3: Matrix Multiplication</a></li>
<li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-4-shifting-left-and-right" target="_blank" rel="noopener">Coding for NEON - Part 4: Shifting Left and Right</a></li>
<li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-5-rearranging-vectors" target="_blank" rel="noopener">Coding for NEON - Part 5: Rearranging Vectors</a></li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.100095_0003_06_en/cortex_a72_mpcore_trm_100095_0003_06_en.pdf" target="_blank" rel="noopener">ARM® Cortex®-A72 MPCore Processor Technical Reference Manual</a></li>
</ul>
]]></content>
      <categories>
        <category>arm</category>
        <category>simd</category>
      </categories>
      <tags>
        <tag>simd</tag>
      </tags>
  </entry>
  <entry>
    <title>线程--pthread</title>
    <url>/post/8868.html</url>
    <content><![CDATA[<p>Linux系统下的多线程遵循<code>POSIX线程</code>接口，称为<code>pthread</code>。编写Linux下的多线程程序，需要使用头文件<code>&lt;pthread.h&gt;</code>，链接时需要使用库libpthread.so。Linux下pthread的实现是通过系统调用<code>clone()</code>来实现的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc pthread_create.c -o pthread_create -lpthread</span><br></pre></td></tr></table></figure>
<ul>
<li>pthread<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ldd pthread_create</span><br><span class="line">	linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff45dfe000</span>)</span><br><span class="line">	libpthread.so<span class="number">.0</span> =&gt; /lib/x86_64-linux-gnu/libpthread.so<span class="number">.0</span> (<span class="number">0x00007f5a42a08000</span>)</span><br><span class="line">	libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f5a42617000</span>)</span><br><span class="line">	/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f5a42e29000</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><code>进程</code>是程序执行时的一个<code>实例</code>，即它是程序已经执行到何种程度的数据结构的汇集。从内核的观点看，进程的目的就是担当<code>分配系统资源</code>（CPU时间、内存等）的基本单位。</p>
<p><code>线程</code>是进程的一个<code>执行流</code>，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。一个进程由几个线程组成（拥有很多相对独立的执行流的用户程序共享应用程序的大部分数据结构），线程与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<blockquote>
<p>“进程——资源分配的最小单位，线程——程序执行的最小单位”</p>
</blockquote>
<blockquote>
<p>进程有独立的地址空间，线程没有单独的地址空间（同一进程内的线程共享进程的地址空间）</p>
</blockquote>
<p>优点：</p>
<ul>
<li>提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。</li>
<li>使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li>
<li>改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。</li>
</ul>
<h2 id="使用多线程的理由"><a href="#使用多线程的理由" class="headerlink" title="使用多线程的理由"></a>使用多线程的理由</h2><ol>
<li><p>理由之一是和进程相比，它是一种非常”节俭”的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，<code>启动一个线程所花费的空间远远小于启动一个进程所花费的空间</code>，而且，<code>线程间彼此切换所需的时间也远远小于进程间切换所需要的时间</code>。据统计，总的说来，一个进程的开销大约是一个线程开销的<code>30倍</code>左右，当然，在具体的系统上，这个数据可能会有较大的区别。</p>
</li>
<li><p>理由之二是线程间方便的<code>通信机制</code>。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。</p>
</li>
</ol>
<p>从函数调用上来说，进程创建使用<code>fork()</code>操作；线程创建使用<code>clone()</code>操作。Richard Stevens大师这样说过：</p>
<blockquote>
<p>fork is expensive. Memory is copied from the parent to the child, all descriptors are duplicated in the child, and so on. Current implementations use a technique called copy-on-write, which avoids a copy of the parent’s data space to the child until the child needs its own copy. But, regardless of this optimization, fork is expensive.</p>
</blockquote>
<blockquote>
<p>IPC is required to pass information between the parent and child after the fork. Passing information from the parent to the child before the fork is easy, since the child starts with a copy of the parent’s data space and with a copy of all the parent’s descriptors. But, returning information from the child to the parent takes more work.</p>
</blockquote>
<blockquote>
<p>Threads help with both problems. Threads are sometimes called lightweight processes since a thread is “lighter weight” than a process. That is, thread creation can be 10–100 times faster than process creation.</p>
</blockquote>
<blockquote>
<p>All threads within a process share the same global memory. This makes the sharing of information easy between the threads, but along with this simplicity comes the problem of synchronization.</p>
</blockquote>
<h2 id="pthread接口"><a href="#pthread接口" class="headerlink" title="pthread接口"></a>pthread接口</h2><blockquote>
<p><code>#include &lt;pthread.h&gt;</code>  #/usr/include/pthread.h</p>
</blockquote>
<h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new thread, starting with execution of START-ROUTINE</span></span><br><span class="line"><span class="comment">   getting passed ARG.  Creation attributed come from ATTR.  The new</span></span><br><span class="line"><span class="comment">   handle is stored in *NEWTHREAD.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_create</span> <span class="params">(<span class="keyword">pthread_t</span> *__restrict __newthread,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *__restrict __attr,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">void</span> *(*__start_routine) (<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">void</span> *__restrict __arg)</span> __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">3</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>用于创建一个线程，成功返回0，否则返回Exxx（为正数）。</p>
<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Terminate calling thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The registered cleanup handlers are called via exception handling</span></span><br><span class="line"><span class="comment">   so we cannot mark this function with __THROW.*/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">pthread_exit</span> <span class="params">(<span class="keyword">void</span> *__retval)</span> __<span class="title">attribute__</span> <span class="params">((__noreturn__))</span></span>;</span><br></pre></td></tr></table></figure>
<p>用于终止线程，可以指定返回值，以便其他线程通过pthread_join函数获取该线程的返回值。</p>
<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Make calling thread wait for termination of the thread TH.  The</span></span><br><span class="line"><span class="comment">   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN</span></span><br><span class="line"><span class="comment">   is not NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_join</span> <span class="params">(<span class="keyword">pthread_t</span> __th, <span class="keyword">void</span> **__thread_return)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以<code>阻塞</code>的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。</p>
</blockquote>
<p>作用：</p>
<ul>
<li>主线程等待子线程的终止</li>
<li>在子线程调用了<code>pthread_join()`</code>方法后面的代码，只有等到子线程结束了才能执行。</li>
</ul>
<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.</span></span><br><span class="line"><span class="comment">   The resources of TH will therefore be freed immediately when it</span></span><br><span class="line"><span class="comment">   terminates, instead of waiting for another thread to perform PTHREAD_JOIN</span></span><br><span class="line"><span class="comment">   on it.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_detach</span> <span class="params">(<span class="keyword">pthread_t</span> __th)</span> __THROW</span>;</span><br></pre></td></tr></table></figure>
<p>用于是指定线程变为分离状态，就像进程脱离终端而变为后台进程类似。成功返回0，否则返回Exxx（为正数）。变为分离状态的线程，如果线程退出，它的所有资源将全部释放。而如果不是分离状态，线程必须保留它的线程ID，退出状态直到其它线程对它调用了pthread_join。</p>
<h3 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Obtain the identifier of the current thread.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">pthread_t</span> <span class="title">pthread_self</span> <span class="params">(<span class="keyword">void</span>)</span> __THROW __<span class="title">attribute__</span> <span class="params">((__const__))</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取线程自身的ID，该id由线程库维护，其id空间是各个进程独立的（即不同进程中的线程可能有相同的id）。</p>
<ul>
<li>比较两个线程ID<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare two thread identifiers.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_equal</span> <span class="params">(<span class="keyword">pthread_t</span> __thread1, <span class="keyword">pthread_t</span> __thread2)</span></span></span><br><span class="line"><span class="function">  __THROW __<span class="title">attribute__</span> <span class="params">((__const__))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>线程属性结构体<code>pthread_attr_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> etachstate;     <span class="comment">//线程的分离状态</span></span><br><span class="line">    <span class="keyword">int</span> schedpolicy;    <span class="comment">//线程的调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>　<span class="title">sched</span> <span class="title">schedparam</span>;</span><span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="keyword">int</span> inheritsched;   <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="keyword">int</span> scope;          <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="keyword">size_t</span> guardsize;   <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> stackaddr_set;  <span class="comment">//线程栈的设置</span></span><br><span class="line">    <span class="keyword">void</span>* stackaddr;    <span class="comment">//线程栈的启始位置</span></span><br><span class="line">    <span class="keyword">size_t</span> stacksize;   <span class="comment">//线程栈大小</span></span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>操作接口函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize thread attribute *ATTR with default attributes</span></span><br><span class="line"><span class="comment">   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,</span></span><br><span class="line"><span class="comment">    no user-provided stack).  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_attr_init</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *__attr)</span> __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy thread attribute *ATTR.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_attr_destroy</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *__attr)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get detach state attribute.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *__attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> *__detachstate)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set detach state attribute.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *__attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> __detachstate)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="线程之间互斥"><a href="#线程之间互斥" class="headerlink" title="线程之间互斥"></a>线程之间互斥</h3><p>互斥锁：</p>
<blockquote>
<p>使用互斥锁（互斥）可以使线程按顺序执行。通常，互斥锁通过确保一次只有一个线程执行代码的临界段来同步多个线程。互斥锁还可以保护单线程代码。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Mutex handling.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *__mutexattr)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try locking a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lock a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_mutex_lock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unlock a mutex.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the priority ceiling of MUTEX.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_mutex_getprioceiling</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutex_t</span> *</span></span></span><br><span class="line"><span class="function"><span class="params">                     __restrict __mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> *__restrict __prioceiling)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the priority ceiling of MUTEX to PRIOCEILING, return old</span></span><br><span class="line"><span class="comment">   priority ceiling value in *OLD_CEILING.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_mutex_setprioceiling</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__restrict __mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> __prioceiling,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> *__restrict __old_ceiling)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">3</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>临界资源保护：</p>
<ol>
<li>声明<code>pthread_mutex_t</code>类型的变量，并初始化<code>pthread_mutex_init</code></li>
<li>对临界资源加锁<code>pthread_mutex_lock</code></li>
<li>其他操作（Do something）</li>
<li>对临界资源解锁<code>pthread_mutex_unlock</code></li>
</ol>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>信号量：</p>
<blockquote>
<p>使用条件变量（信号量）可以以原子方式阻塞线程，直到某个特定条件为真为止。条件变量始终与互斥锁一起使用。对条件的测试是在互斥锁（互斥）的保护下进行的。如果条件为假，线程通常会基于条件变量阻塞，并以原子方式释放等待条件变化的互斥锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Functions for handling conditional variables.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize condition variable COND using attributes ATTR, or use</span></span><br><span class="line"><span class="comment">   the default values if later is NULL.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_cond_init</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__restrict __cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *__restrict __cond_attr)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy condition variable COND.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_cond_destroy</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wake up one thread waiting for condition variable COND.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_cond_signal</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wake up all threads waiting for condition variables COND.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for condition variable COND to be signaled or broadcast.</span></span><br><span class="line"><span class="comment">   MUTEX is assumed to be locked before.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_cond_wait</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__restrict __cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">pthread_mutex_t</span> *__restrict __mutex)</span></span></span><br><span class="line"><span class="function">     __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for condition variable COND to be signaled or broadcast until</span></span><br><span class="line"><span class="comment">   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an</span></span><br><span class="line"><span class="comment">   absolute time specification; zero is the beginning of the epoch</span></span><br><span class="line"><span class="comment">   (00:00:00 GMT, January 1, 1970).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__restrict __cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">pthread_mutex_t</span> *__restrict __mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> struct timespec *__restrict __abstime)</span></span></span><br><span class="line"><span class="function">     __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_cond_wait</code>用于等待某个特定的条件为真，<code>pthread_cond_signal</code>用于通知阻塞的线程某个特定的条件为真了。在调用者两个函数之前需要声明一个<code>pthread_cond_t</code>类型的变量，用于这两个函数的参数。</p>
<blockquote>
<p><code>pthread_cond_wait</code>只是唤醒等待某个条件变量的一个线程。如果需要唤醒所有等待某个条件变量的线程，需要调用：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="pthread-barrier-xxx"><a href="#pthread-barrier-xxx" class="headerlink" title="pthread_barrier_xxx"></a>pthread_barrier_xxx</h3><p>线程同步，<code>pthread_barrier_*</code>其实只做且只能做一件事，就是充当栏杆（barrier意为栏杆)。形象的说就是把先后到达的多个线程挡在同一栏杆前，直到所有线程到齐，然后撤下栏杆同时放行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize BARRIER with the attributes in ATTR.  The barrier is</span></span><br><span class="line"><span class="comment">   opened when COUNT waiters arrived.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_barrier_init</span> <span class="params">(<span class="keyword">pthread_barrier_t</span> *__restrict __barrier,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *__restrict</span></span></span><br><span class="line"><span class="function"><span class="params">                 __attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> __count)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy a previously dynamically initialized barrier BARRIER.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span> <span class="params">(<span class="keyword">pthread_barrier_t</span> *__barrier)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait on barrier BARRIER.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_barrier_wait</span> <span class="params">(<span class="keyword">pthread_barrier_t</span> *__barrier)</span></span></span><br><span class="line"><span class="function">     __THROWNL __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>init函数负责指定要等待的线程个数</li>
<li>wait()函数由每个线程主动调用，它告诉栏杆“我到起跑线前了”。<ul>
<li>wait(）执行末尾栏杆会检查是否所有人都到栏杆前了</li>
<li>如果是，栏杆就消失所有线程继续执行下一句代码</li>
<li>如果不是，则所有已到wait()的线程等待，剩下没执行到wait()的线程继续执行</li>
</ul>
</li>
<li>destroy函数释放init申请的资源。</li>
</ol>
<p>应用场景：</p>
<blockquote>
<p>比如A和B两人相约在某一个地点C集合去打猎，A和B都知道地方C，但是他们到达的时间不确定，因此谁先到就需要在C点等。</p>
</blockquote>
<h3 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Guarantee that the initialization function INIT_ROUTINE will be called</span></span><br><span class="line"><span class="comment">   only once, even if pthread_once is executed several times with the</span></span><br><span class="line"><span class="comment">   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or</span></span><br><span class="line"><span class="comment">   extern variable initialized to PTHREAD_ONCE_INIT.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initialization functions might throw exception which is why</span></span><br><span class="line"><span class="comment">   this function is not marked with __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_once</span> <span class="params">(<span class="keyword">pthread_once_t</span> *__once_control,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span> (*__init_routine) (<span class="keyword">void</span>))</span> __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>pthread_once能够保证<code>__init_routine</code>只被调用一次，具体在哪个线程中执行是不定的</p>
<ul>
<li>用法:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> once=PTHREAD_ONCE_INIT;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_once(&amp;once,once_init_routine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线程私有数据Thread-Specific-Data-TSD"><a href="#线程私有数据Thread-Specific-Data-TSD" class="headerlink" title="线程私有数据Thread Specific Data (TSD)"></a>线程私有数据Thread Specific Data (TSD)</h2><p>在单线程程序中，我们经常使用 “全局变量” 以实现多个函数间共享数据，在多线程环境下，由于数据空间是共享的，因此全局变量也为所有线程所共享。但有时应用程序设计中有必要提供<code>线程私有的全局变量</code>，仅在某个线程中有效，但却可以跨多个函数访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Functions for handling thread-specific data.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a key value identifying a location in the thread-specific</span></span><br><span class="line"><span class="comment">   data area.  Each thread maintains a distinct thread-specific data</span></span><br><span class="line"><span class="comment">   area.  DESTR_FUNCTION, if non-NULL, is called with the value</span></span><br><span class="line"><span class="comment">   associated to that key when the key is destroyed.</span></span><br><span class="line"><span class="comment">   DESTR_FUNCTION is not called if the value associated is NULL when</span></span><br><span class="line"><span class="comment">   the key is destroyed.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_key_create</span> <span class="params">(<span class="keyword">pthread_key_t</span> *__key,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> (*__destr_function) (<span class="keyword">void</span> *))</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy KEY.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_key_delete</span> <span class="params">(<span class="keyword">pthread_key_t</span> __key)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return current value of the thread-specific data slot identified by KEY.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">pthread_getspecific</span> <span class="params">(<span class="keyword">pthread_key_t</span> __key)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store POINTER in the thread-specific data slot identified by KEY. */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pthread_setspecific</span> <span class="params">(<span class="keyword">pthread_key_t</span> __key,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">void</span> *__pointer)</span> __THROW </span>;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote>
<p>/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Thread identifiers.  The structure of the attribute type is not</span></span><br><span class="line"><span class="comment">   exposed on purpose.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keys for thread-specific data */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">pthread_key_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Once-only execution */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __ONCE_ALIGNMENT <span class="keyword">pthread_once_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">pthread_attr_t</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __have_pthread_attr_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="keyword">pthread_attr_t</span> <span class="keyword">pthread_attr_t</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __have_pthread_attr_t 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">pthread_mutex_s</span> __<span class="title">data</span>;</span></span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_MUTEX_T];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_mutex_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">pthread_cond_s</span> __<span class="title">data</span>;</span></span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_COND_T];</span><br><span class="line">  __extension__ <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_cond_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li><a href="https://raw.githubusercontent.com/Winddoing/CodeWheel/master/C/pthread/pthread.c" target="_blank" rel="noopener">pthread.c</a></li>
<li><a href="https://github.com/Winddoing/CodeWheel/tree/master/C/pthread/threadpool" target="_blank" rel="noopener">threadpool</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/skynet/archive/2010/10/30/1865267.html" target="_blank" rel="noopener">Linux多线程编程（不限Linux)</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-pthred/#ibm-pcon" target="_blank" rel="noopener">pthreads 的基本用法</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>图像压缩编码——JPEG</title>
    <url>/post/59613.html</url>
    <content><![CDATA[<p><img src="/images/2019/05/jpeg_8x8_block.png" alt="jpeg_8x8_block"></p>
<blockquote>
<p>在JPEG中的数据处理单元是<code>8x8</code>block</p>
</blockquote>
<p>在JPEG中编码器和解码器是<code>互逆</code>的，因此在编解码过程中提供的表说明完全一致<br><a id="more"></a></p>
<h2 id="数据格式-YUV"><a href="#数据格式-YUV" class="headerlink" title="数据格式-YUV"></a>数据格式-YUV</h2><p>标准色彩空间：一个或三个组件。 对于三个组件，YCbCr</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><img src="/images/2019/05/jpeg_encoder.png" alt="jpeg_encoder"></p>
<h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p><img src="/images/2019/05/jpeg_decoder.png" alt="jpeg_decoder"></p>
<h2 id="DCT变换"><a href="#DCT变换" class="headerlink" title="DCT变换"></a>DCT变换</h2><p>在计算FDCT之前，对应输入数据进行<code>层平移</code>处理，即把输入数据变成带符号的2的补码表示。对于8位输入精度，层平移通过<code>减128</code>来完成。</p>
<ul>
<li>FDCT：</li>
</ul>
<p>$F(u, v) = \dfrac{1}{4}c(u)(v)\left[\sum_{i=0}^{7}\sum_{j=0}^{7}f(i, j)\cos\dfrac{(2i+1)u\pi}{16}\cos\dfrac{(2j+1)v\pi}{16}\right]$</p>
<ul>
<li>IDCT：</li>
</ul>
<p>$f(i, j) = \dfrac{1}{4}c(u)c(v)\left[\sum_{u=0}^{7}\sum_{v=0}^{7}F(u, v)\cos\dfrac{(2i+1)u\pi}{16}\cos\dfrac{(2j+i)v\pi}{16}\right]$</p>
<p>$Cu, Cv = 1/\sqrt{2}$  为  $u, v = 0$<br>$Cu, Cv = 1$  除此以外</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p>所谓量化就是用<code>像素值</code>÷<code>量化表对应值</code>所得的结果。由于量化表左上角的值较小，右上角的值较大，这样就起到了保持低频分量，抑制高频分量的目的。</p>
<blockquote>
<p>Y分量代表了亮度信息，UV分量代表了色差信息,因此量化表通常两张。</p>
</blockquote>
<ul>
<li>编码时</li>
</ul>
<p>$Sq_{vu}=round\left(\dfrac{S_{vu}}{Q_{vu}}\right)$</p>
<ul>
<li>解码时</li>
</ul>
<p>$R_{vu} = Sq_{vu} \times Q_{vu}$</p>
<h3 id="量化表"><a href="#量化表" class="headerlink" title="量化表"></a>量化表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//亮度分量量化表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> quant_y[<span class="number">8</span>][<span class="number">8</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">24</span>,  <span class="number">40</span>,  <span class="number">51</span>,  <span class="number">61</span>&#125;,</span><br><span class="line">    &#123;<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>,  <span class="number">58</span>,  <span class="number">60</span>,  <span class="number">55</span>&#125;,</span><br><span class="line">    &#123;<span class="number">14</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>,  <span class="number">57</span>,  <span class="number">69</span>,  <span class="number">56</span>&#125;,</span><br><span class="line">    &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">51</span>,  <span class="number">87</span>,  <span class="number">80</span>,  <span class="number">62</span>&#125;,</span><br><span class="line">    &#123;<span class="number">18</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">68</span>,  <span class="number">109</span>, <span class="number">103</span>, <span class="number">77</span>&#125;,</span><br><span class="line">    &#123;<span class="number">24</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">81</span>,  <span class="number">104</span>, <span class="number">113</span>, <span class="number">92</span>&#125;,</span><br><span class="line">    &#123;<span class="number">49</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>&#125;,</span><br><span class="line">    &#123;<span class="number">72</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">99</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//色度分量量化表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> quant_uv[<span class="number">8</span>][<span class="number">8</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">17</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">18</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">24</span>, <span class="number">26</span>, <span class="number">56</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">47</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所谓JPEG的有损压缩，损的是量化过程中的高频部分; 因为对于人眼而言<code>低频部分比高频部分要重要得多</code></p>
</blockquote>
<h2 id="8×8块样本与DCT系数的关系"><a href="#8×8块样本与DCT系数的关系" class="headerlink" title="8×8块样本与DCT系数的关系"></a>8×8块样本与DCT系数的关系</h2><p><img src="/images/2019/05/jpeg_8x8block与dct系数关系.png" alt="jpeg_8x8block与DCT系数关系"></p>
<h2 id="编码分类"><a href="#编码分类" class="headerlink" title="编码分类"></a>编码分类</h2><p><img src="/images/2019/05/zigzag.png" alt="zigzag"></p>
<ul>
<li>一类是每个8<em>8格子中的[0,0]位置上元素，即<code>DC</code>(直流分量)，代表8</em>8个子块的平均值,采用<code>差分编码DPCM</code><ul>
<li>$DIFF = DC_i - PRED$</li>
<li>在扫描行和每个重启动间隔的开始时，将DC系数的预测值(PRED)初始化为<code>0</code>.</li>
</ul>
</li>
<li>二类是每个8*8格子中的其余63个元素，即<code>AC</code>(交流分量)，采用<code>行程编码RLE</code><ul>
<li>为了保证低频分量先出现，高频分量后出现，以增加行程中连续“0”的个数，这63个元素采用了“Z”字型(Zig-Zag)的排列方法</li>
<li>如果“Z”序列中的剩余系数全为0，那么可直接使用块结束符（EOB）进行编码</li>
</ul>
</li>
</ul>
<h3 id="zigzag"><a href="#zigzag" class="headerlink" title="zigzag"></a>zigzag</h3><p><img src="/images/2019/05/jpeg_zig_zag_table.png" alt="jpeg_zig_zag_table"></p>
<h2 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h2><p>熵编码指熵保持编码，编码时，平均信息量保持不变。</p>
<h3 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h3><ul>
<li>对出现频率较高的符号，设计较短的码字，反之，用最长的码字</li>
<li>Huffman编码表事先定义好</li>
</ul>
<h4 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h4><ul>
<li>亮度<code>Y</code>的<code>DC</code> huffman码表</li>
<li>色度<code>U\V</code>的<code>DC</code> huffman码表</li>
<li>亮度<code>Y</code>的<code>AC</code> huffman码表</li>
<li>色度<code>U\V</code>的<code>AC</code> huffman码表</li>
</ul>
<blockquote>
<p><a href="http://www.cnblogs.com/dxs959229640/p/3853790.html" target="_blank" rel="noopener">JPEG Huffman Coding Table</a></p>
</blockquote>
<p>编码表的生成：<a href="https://raw.githubusercontent.com/Winddoing/CodeWheel/master/jpeg/jpeg_huffman_ac_dc_table.c" target="_blank" rel="noopener">https://raw.githubusercontent.com/Winddoing/CodeWheel/master/jpeg/jpeg_huffman_ac_dc_table.c</a></p>
<p>主要生成<code>EHUFSI</code>和<code>EHUFCO</code>两类表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">亮度DC系数:</span><br><span class="line">===&gt; size, EHUFSI_DC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    2     3     3     3     3     3     4     5     6     7     8     9</span><br><span class="line">&#125;</span><br><span class="line">===&gt; code, EHUFCO_DC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    0     2     3     4     5     6    14    30    62   126   254   510</span><br><span class="line">&#125;</span><br><span class="line">色差DC系数:</span><br><span class="line">===&gt; size, EHUFSI_DC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    2     2     2     3     4     5     6     7     8     9    10    11</span><br><span class="line">&#125;</span><br><span class="line">===&gt; code, EHUFCO_DC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    0     1     2     6    14    30    62   126   254   510  1022  2046</span><br><span class="line">&#125;</span><br><span class="line">亮度AC系数:</span><br><span class="line">===&gt; size, EHUFSI_AC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    4     2     2     3     4     5     7     8    10    16    16     0     0     0     0     0</span><br><span class="line">    0     4     5     7     9    11    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     5     8    10    12    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     6     9    12    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     6    10    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     7    11    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     7    12    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     8    12    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     9    15    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     9    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     9    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0    10    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0    10    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0    11    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0    16    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">   11    16    16    16    16    16    16    16    16    16    16</span><br><span class="line">&#125;</span><br><span class="line">===&gt; code, EHUFCO_AC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">   10     0     1     4    11    26   120   248  1014 65410 65411     0     0     0     0     0</span><br><span class="line">    0    12    27   121   502  2038 65412 65413 65414 65415 65416     0     0     0     0     0</span><br><span class="line">    0    28   249  1015  4084 65417 65418 65419 65420 65421 65422     0     0     0     0     0</span><br><span class="line">    0    58   503  4085 65423 65424 65425 65426 65427 65428 65429     0     0     0     0     0</span><br><span class="line">    0    59  1016 65430 65431 65432 65433 65434 65435 65436 65437     0     0     0     0     0</span><br><span class="line">    0   122  2039 65438 65439 65440 65441 65442 65443 65444 65445     0     0     0     0     0</span><br><span class="line">    0   123  4086 65446 65447 65448 65449 65450 65451 65452 65453     0     0     0     0     0</span><br><span class="line">    0   250  4087 65454 65455 65456 65457 65458 65459 65460 65461     0     0     0     0     0</span><br><span class="line">    0   504 32704 65462 65463 65464 65465 65466 65467 65468 65469     0     0     0     0     0</span><br><span class="line">    0   505 65470 65471 65472 65473 65474 65475 65476 65477 65478     0     0     0     0     0</span><br><span class="line">    0   506 65479 65480 65481 65482 65483 65484 65485 65486 65487     0     0     0     0     0</span><br><span class="line">    0  1017 65488 65489 65490 65491 65492 65493 65494 65495 65496     0     0     0     0     0</span><br><span class="line">    0  1018 65497 65498 65499 65500 65501 65502 65503 65504 65505     0     0     0     0     0</span><br><span class="line">    0  2040 65506 65507 65508 65509 65510 65511 65512 65513 65514     0     0     0     0     0</span><br><span class="line">    0 65515 65516 65517 65518 65519 65520 65521 65522 65523 65524     0     0     0     0     0</span><br><span class="line"> 2041 65525 65526 65527 65528 65529 65530 65531 65532 65533 65534</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h4><p>编码过程是根据一组扩展表<code>XHUFCO</code>和<code>XHUFSI</code>定义的，它们包含所有可能差值的完整霍夫曼CODE和SIZE集合</p>
<h5 id="DC系数Huffman编码"><a href="#DC系数Huffman编码" class="headerlink" title="DC系数Huffman编码"></a>DC系数Huffman编码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SIZE = XHUFSI(DIFF)</span><br><span class="line">CODE = XHUFCO(DIFF)</span><br><span class="line">code SIZE bits of CODE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>XHUFSI和XHUFCO从编码器表<code>EHUFSI</code>和<code>EHUFCO</code>产生， 使用DIFF作为两个表的索引。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Encode the DC coefficient difference per section F.1.2.1 */</span></span><br><span class="line"></span><br><span class="line">temp = temp2 = block[<span class="number">0</span>] - last_dc_val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is a well-known technique for obtaining the absolute value without a</span></span><br><span class="line"><span class="comment"> * branch.  It is derived from an assembly language technique presented in</span></span><br><span class="line"><span class="comment"> * "How to Optimize for the Pentium Processors", Copyright (c) 1996, 1997 by</span></span><br><span class="line"><span class="comment"> * Agner Fog.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">temp3 = temp &gt;&gt; (CHAR_BIT * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) - <span class="number">1</span>);</span><br><span class="line">temp ^= temp3;</span><br><span class="line">temp -= temp3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For a negative input, want temp2 = bitwise complement of abs(input) */</span></span><br><span class="line"><span class="comment">/* This code assumes we are on a two's complement machine */</span></span><br><span class="line">temp2 += temp3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the number of bits needed for the magnitude of the coefficient */</span></span><br><span class="line">nbits = JPEG_NBITS(temp); <span class="comment">//查表计算位宽</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Emit the Huffman-coded symbol for the number of bits */</span></span><br><span class="line">code = dctbl-&gt;ehufco[nbits];</span><br><span class="line"><span class="built_in">size</span> = dctbl-&gt;ehufsi[nbits];</span><br><span class="line">EMIT_BITS(code, <span class="built_in">size</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mask off any extra bits in code */</span></span><br><span class="line">temp2 &amp;= (((JLONG)<span class="number">1</span>) &lt;&lt; nbits) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Emit that number of bits of the value, if positive, */</span></span><br><span class="line"><span class="comment">/* or the complement of its magnitude, if negative. */</span></span><br><span class="line">EMIT_BITS(temp2, nbits)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>libjpeg-turbo: <a href="https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/jchuff.c" target="_blank" rel="noopener">jchuff.c</a></p>
</blockquote>
<h5 id="AC系数Huffman编码"><a href="#AC系数Huffman编码" class="headerlink" title="AC系数Huffman编码"></a>AC系数Huffman编码</h5><p>ZZ中的每个非零AC系数由一个复合的8位值RS描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RS = binary ’RRRRSSSS’</span><br></pre></td></tr></table></figure>
<ul>
<li>后面4个低有效位（<code>SSSS</code>）为ZZ中下一个非0系数的幅值定义类别</li>
<li>前面4个高有效位（<code>RRRR</code>）给出ZZ中相对与先前非0系数位置（也就是非0系数之间的0系数行程）</li>
</ul>
<p>由于0系数的行程可能超过15，故定义值<code>’RRRRSSSS‘ = ’0xf0‘</code>来表示行程为15的0系数组，后跟一0幅值的系数。另外，特殊值<code>’RRRRSSSS’ = ‘00000000’</code>用于对块结束符<code>EOB</code>进行编码（当块中的所有剩余系数为0时）。</p>
<p><img src="/images/2019/05/jpeg_huffman_ac_code.png" alt="jpeg_huffman_ac_code"></p>
<p><img src="/images/2019/05/jpeg_huffman_ac_code1.png" alt="jpeg_huffman_ac_code1"></p>
<p><img src="/images/2019/05/jpeg_huffman_ac_code2.png" alt="jpeg_huffman_ac_code2"></p>
<h2 id="示例：8x8block"><a href="#示例：8x8block" class="headerlink" title="示例：8x8block"></a>示例：8x8block</h2><p>一个8x8的量化后的亮度块，已完成zigzag排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系数： 12   5   -2   0   2   0   0   0   1    0     -1     0</span><br><span class="line">下标： 0    1    2   3   4   5   6   7   8  9 ~ 30  31  32 ~ 63</span><br></pre></td></tr></table></figure>
<h3 id="DC系数编码"><a href="#DC系数编码" class="headerlink" title="DC系数编码"></a>DC系数编码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DIFF = 12； //&apos;1100b&apos;</span><br><span class="line">SSSS = 4；  //12位宽表示类别</span><br><span class="line">SIZE = EHUFSI_DC(SSSS) = 3 = 11b</span><br><span class="line">CODE = EHUFCO_DC(SSSS) = 5 = 101b</span><br><span class="line">RESULT = `101b`</span><br><span class="line">RESULT += DIFF = `1011100`</span><br></pre></td></tr></table></figure>
<h3 id="AC系数编码"><a href="#AC系数编码" class="headerlink" title="AC系数编码"></a>AC系数编码</h3><ul>
<li>ZZ(1) = 5: 它与ZZ(0)之间无0系数R=0，RRRR=0；幅值5落入第3类，SSSS=3；即’RRRRSSSS‘ = ’0/3‘。查AC Huffman<a href="#编码表">编码表</a>为<code>100</code>。幅值5的编码为<code>101</code>，故ZZ(1)的编码为<code>100101</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZZ(1) = 5; //&apos;101b&apos;</span><br><span class="line">R = 0;     //R当前系数与前一个系数之间0的个数</span><br><span class="line">SSSS = CSIZE(ZZ(1)) = 3;</span><br><span class="line">RS = 16 * R + SSSS = 16*0 + 3 = 3;</span><br><span class="line">SIZE = EHUFSI_AC[RS] = 3 = 11b</span><br><span class="line">CODE = EHUFCO_AC[RS] = 4 = 100b</span><br><span class="line">RESULT = `100b`</span><br><span class="line">RESULT += ZZ(1) = `100101b`</span><br></pre></td></tr></table></figure>
<ul>
<li>ZZ(2) = -2, ‘RRRRSSSS’ = ‘0/2’, 查AC Huffman编码表是<code>01</code>，幅值-2落入第2类，ZZ(2) - 1 = -3, -3用补码表示并<code>取后两位</code>（-2除去符号位占两个位宽）为<code>01</code>， 因此ZZ(2)的编码<code>0101</code></li>
<li>ZZ(3) = 0</li>
<li>ZZ(4) = 2, 编码：<code>1101110</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZZ(4) = 2; //10b</span><br><span class="line">R = 1;</span><br><span class="line">SSSS = CSIZE(ZZ(4)) = 2;</span><br><span class="line">RS = 16 * R + SSSS = 16*1 + 2 = 18;</span><br><span class="line">SIZE = EHUFSI_AC[RS] = 5 = 101b</span><br><span class="line">CODE = EHUFCO_AC[RS] = 27 = 11011b</span><br><span class="line">RESULT = &apos;11011&apos;</span><br><span class="line">RESULT += ZZ(4) = &apos;1101110&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>ZZ(5) ~ ZZ(7) = 0</li>
<li>ZZ(8) = 1, 编码：<code>1110101</code></li>
<li>ZZ(0) ~ ZZ(30) = 0, ZZ(31) = -1;由于RRRR=22 &gt; 15,故先编一个F/0,huffman编码为<code>11111111001</code>。然后RRRR=22 - 16 = 6，这时RRRRSSSS=6/1， Huffman编码<code>1111011</code>；幅值-1在第1类，取（-1-1=-2）补码的最后一位<code>0</code>，最后编码<code>11110110</code></li>
<li>ZZ(32) ~ ZZ(63) = 0,直接用一个EOB(0/0)结束，编码<code>1010</code></li>
</ul>
<h2 id="JPEG文件"><a href="#JPEG文件" class="headerlink" title="JPEG文件"></a>JPEG文件</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>JPEG的每个标记都是由 2个字节组成，其前一个字节是固定值<code>0xFF</code>，每个标记之前还可以添加数目不限的0xFF填充字节(fill byte)</p>
<table>
<thead>
<tr>
<th style="text-align:center">标记</th>
<th style="text-align:center">数值</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOI（Start Of Image）</td>
<td style="text-align:center">0xD8</td>
<td style="text-align:center">图像开始</td>
</tr>
<tr>
<td style="text-align:center">APP0</td>
<td style="text-align:center">0xEO</td>
<td style="text-align:center">JFIF应用数据块</td>
</tr>
<tr>
<td style="text-align:center">APPn</td>
<td style="text-align:center">0xE1 ~ 0xEF</td>
<td style="text-align:center">其他的应用数据块(n, 1～15)</td>
</tr>
<tr>
<td style="text-align:center">DQT</td>
<td style="text-align:center">0xDB</td>
<td style="text-align:center">量化表</td>
</tr>
<tr>
<td style="text-align:center">SOF0(Start Of Frame)</td>
<td style="text-align:center">0xC0</td>
<td style="text-align:center">帧开始</td>
</tr>
<tr>
<td style="text-align:center">DHT</td>
<td style="text-align:center">0xC4</td>
<td style="text-align:center">霍夫曼(Huffman)表</td>
</tr>
<tr>
<td style="text-align:center">SOS</td>
<td style="text-align:center">0xDA</td>
<td style="text-align:center">扫描线开始</td>
</tr>
<tr>
<td style="text-align:center">EOI</td>
<td style="text-align:center">0xD9</td>
<td style="text-align:center">图像结束</td>
</tr>
</tbody>
</table>
<h3 id="jpeg文件解析示例"><a href="#jpeg文件解析示例" class="headerlink" title="jpeg文件解析示例"></a>jpeg文件解析示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frame 1: 345637 bytes on wire (2765096 bits), 345637 bytes captured (2765096 bits)</span><br><span class="line">MIME file</span><br><span class="line">JPEG File Interchange Format</span><br><span class="line">    Marker: Start of Image (0xffd8)</span><br><span class="line">    Marker segment: Reserved for application segments - 0 (0xFFE0)</span><br><span class="line">        Marker: Reserved for application segments - 0 (0xffe0)</span><br><span class="line">        Length: 16</span><br><span class="line">        Identifier: JFIF</span><br><span class="line">        Version: 1.1</span><br><span class="line">            Major Version: 1</span><br><span class="line">            Minor Version: 1</span><br><span class="line">        Units: Dots per inch (1)</span><br><span class="line">        Xdensity: 0</span><br><span class="line">        Ydensity: 0</span><br><span class="line">        Xthumbnail: 0</span><br><span class="line">        Ythumbnail: 0</span><br><span class="line">    Marker segment: Define quantization table(s) (0xFFDB)</span><br><span class="line">        Marker: Define quantization table(s) (0xffdb)</span><br><span class="line">        Length: 67</span><br><span class="line">        Remaining segment data: 65 bytes</span><br><span class="line">    Marker segment: Define quantization table(s) (0xFFDB)</span><br><span class="line">        Marker: Define quantization table(s) (0xffdb)</span><br><span class="line">        Length: 67</span><br><span class="line">        Remaining segment data: 65 bytes</span><br><span class="line">    Start of Frame header: Start of Frame (non-differential, Huffman coding) - Baseline DCT (0xFFC0)</span><br><span class="line">        Marker: Start of Frame (non-differential, Huffman coding) - Baseline DCT (0xffc0)</span><br><span class="line">        Length: 17</span><br><span class="line">        Sample Precision (bits): 8</span><br><span class="line">        Lines: 1080</span><br><span class="line">        Samples per line: 1920</span><br><span class="line">        Number of image components in frame: 3</span><br><span class="line">        Component identifier: 1</span><br><span class="line">        0010 .... = Horizontal sampling factor: 2</span><br><span class="line">        .... 0010 = Vertical sampling factor: 2</span><br><span class="line">        Quantization table destination selector: 0</span><br><span class="line">        Component identifier: 2</span><br><span class="line">        0001 .... = Horizontal sampling factor: 1</span><br><span class="line">        .... 0001 = Vertical sampling factor: 1</span><br><span class="line">        Quantization table destination selector: 1</span><br><span class="line">        Component identifier: 3</span><br><span class="line">        0001 .... = Horizontal sampling factor: 1</span><br><span class="line">        .... 0001 = Vertical sampling factor: 1</span><br><span class="line">        Quantization table destination selector: 1</span><br><span class="line">    Marker segment: Define Huffman table(s) (0xFFC4)</span><br><span class="line">        Marker: Define Huffman table(s) (0xffc4)</span><br><span class="line">        Length: 27</span><br><span class="line">        Remaining segment data: 25 bytes</span><br><span class="line">    Marker segment: Define Huffman table(s) (0xFFC4)</span><br><span class="line">        Marker: Define Huffman table(s) (0xffc4)</span><br><span class="line">        Length: 73</span><br><span class="line">        Remaining segment data: 71 bytes</span><br><span class="line">    Marker segment: Define Huffman table(s) (0xFFC4)</span><br><span class="line">        Marker: Define Huffman table(s) (0xffc4)</span><br><span class="line">        Length: 26</span><br><span class="line">        Remaining segment data: 24 bytes</span><br><span class="line">    Marker segment: Define Huffman table(s) (0xFFC4)</span><br><span class="line">        Marker: Define Huffman table(s) (0xffc4)</span><br><span class="line">        Length: 51</span><br><span class="line">        Remaining segment data: 49 bytes</span><br><span class="line">    Start of Segment header: Start of Scan (0xFFDA)</span><br><span class="line">        Marker: Start of Scan (0xffda)</span><br><span class="line">        Length: 12</span><br><span class="line">        Number of image components in scan: 3</span><br><span class="line">        Scan component selector: 1</span><br><span class="line">        0000 .... = DC entropy coding table destination selector: 0</span><br><span class="line">        .... 0000 = AC entropy coding table destination selector: 0</span><br><span class="line">        Scan component selector: 2</span><br><span class="line">        0001 .... = DC entropy coding table destination selector: 1</span><br><span class="line">        .... 0001 = AC entropy coding table destination selector: 1</span><br><span class="line">        Scan component selector: 3</span><br><span class="line">        0001 .... = DC entropy coding table destination selector: 1</span><br><span class="line">        .... 0001 = AC entropy coding table destination selector: 1</span><br><span class="line">        Start of spectral or predictor selection: 0</span><br><span class="line">        End of spectral selection: 63</span><br><span class="line">        0000 .... = Successive approximation bit position high: 0</span><br><span class="line">        .... 0000 = Successive approximation bit position low or point transform: 0</span><br><span class="line">    Entropy-coded segment (dissection is not yet implemented): f9354ef5d8ab0a2b96af8daa0006ad822804c0d54d18906a...</span><br><span class="line">    Marker: End of Image (0xffd9)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wireshark解析</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.w3.org/Graphics/JPEG/itu-t81.pdf" target="_blank" rel="noopener">itu-t81.pdf</a> —— 图像数字压缩和编码</li>
<li><a href="https://blog.csdn.net/my_happy_life/article/details/82997597" target="_blank" rel="noopener">JPEG图像编码</a></li>
<li><a href="https://www.w3.org/Graphics/JPEG/jfif3.pdf" target="_blank" rel="noopener">JPEG File Interchange Format，JFIF</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>编码</category>
      </categories>
      <tags>
        <tag>jpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>TGSI for Mesa</title>
    <url>/post/58638.html</url>
    <content><![CDATA[<blockquote>
<p><code>TGSI</code>    Tungsten Graphics Shader Infrastructure</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>In a Gallium driver, these are first transformed into TGSI by the state tracker and are then transformed into something that will run on the card by the driver.<a href="http://www.informit.com/articles/article.aspx?p=1554200&amp;seqNum=5" target="_blank" rel="noopener">^link</a></p>
</blockquote>
<blockquote>
<p>TGSI, Tungsten Graphics Shader Infrastructure, is an intermediate language for describing shaders. Since Gallium is inherently shaderful, shaders are an important part of the API. TGSI is the only intermediate representation used by all drivers.</p>
</blockquote>
<p><img src="/images/2019/09/shader_irs_2015.png" alt="shader_IRs_2015"><br><img src="/images/2019/09/new_shader_ir.png" alt="new_shader_ir"></p>
<p><img src="/images/2020/07/mesa_layers_of_crap_2016_for_ir.svg" alt="Mesa_layers_of_crap_2016_for_IR"></p>
<blockquote>
<p>来自:<a href="https://en.wikipedia.org/wiki/Mesa_(computer_graphics" target="_blank" rel="noopener">wikipedia mesa</a>)</p>
</blockquote>
<p>TGSI是Gallium框架中的所有驱动程序使用着色器的唯一中间表示形式,这里<code>特指</code>的是<code>着色器</code>的中间形式，着色器对驱动而言的所有格式将是TGSI。</p>
<h2 id="TGSI中间语言"><a href="#TGSI中间语言" class="headerlink" title="TGSI中间语言"></a>TGSI中间语言</h2><p>介于在着色器（GLSL）代码与GPU指令之间的一种中间语言，类似与C语言与CPU指令之间存在的汇编语言一样。</p>
<p>在Mesa上，GLSL首先被编译器翻译成tgsi中间语言，然后显卡特定的驱动将这些tgsi语言的代码编译成GPU指令。</p>
<p><img src="/images/2019/09/shader_tgsi.png" alt="shader_gtsi"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glxgears: shader</span><br><span class="line">FRAG</span><br><span class="line">PROPERTY FS_COLOR0_WRITES_ALL_CBUFS 1</span><br><span class="line">DCL IN[0], COLOR, COLOR</span><br><span class="line">DCL OUT[0], COLOR</span><br><span class="line">  0: MOV OUT[0], IN[0]</span><br><span class="line">  1: END</span><br><span class="line"></span><br><span class="line">glxgears: shader</span><br><span class="line">VERT</span><br><span class="line">DCL IN[0]</span><br><span class="line">DCL OUT[0], POSITION</span><br><span class="line">DCL OUT[1], COLOR</span><br><span class="line">DCL CONST[0..10]</span><br><span class="line">DCL TEMP[0..3]</span><br><span class="line">IMM[0] FLT32 &#123;0x00000000, 0x3f800000, 0x00000000, 0x00000000&#125;</span><br><span class="line">  0: MUL TEMP[0], IN[0].xxxx, CONST[0]</span><br><span class="line">  1: MAD TEMP[0], IN[0].yyyy, CONST[1], TEMP[0]</span><br><span class="line">  2: MAD TEMP[0], IN[0].zzzz, CONST[2], TEMP[0]</span><br><span class="line">  3: MAD OUT[0], IN[0].wwww, CONST[3], TEMP[0]</span><br><span class="line">  4: DP3 TEMP[1].x, CONST[4], CONST[4]</span><br><span class="line">  5: RSQ TEMP[1].x, |TEMP[1]|</span><br><span class="line">  6: MUL TEMP[0], CONST[4], TEMP[1].xxxx</span><br><span class="line">  7: MOV TEMP[2], CONST[5]</span><br><span class="line">  8: MOV_SAT OUT[1], TEMP[2]</span><br><span class="line">  9: DP3 TEMP[3], TEMP[0], CONST[6]</span><br><span class="line"> 10: MAX TEMP[1], IMM[0].xxxy, TEMP[3]</span><br><span class="line"> 11: SLT TEMP[1].z, IMM[0].xxxx, TEMP[3]</span><br><span class="line"> 12: ADD TEMP[2], CONST[8], TEMP[2]</span><br><span class="line"> 13: MAD TEMP[2], TEMP[1].yyyy, CONST[9], TEMP[2]</span><br><span class="line"> 14: MAD_SAT OUT[1].xyz, TEMP[1].zzzz, CONST[10], TEMP[2]</span><br><span class="line"> 15: END</span><br></pre></td></tr></table></figure>
<blockquote>
<p>glxgears在渲染中生成的部分TGSI代码</p>
<ul>
<li><a href="https://freedesktop.org/wiki/Software/gallium/tgsi-specification.pdf" target="_blank" rel="noopener">TGSI specification</a></li>
<li><a href="https://gallium.readthedocs.io/en/latest/tgsi.html#instruction-set" target="_blank" rel="noopener">TGSI Instruction Set</a></li>
</ul>
</blockquote>
<ul>
<li><code>FRAG</code>:fragment片元着色器</li>
<li><code>VERT</code>:vertex顶点着色器</li>
<li><code>DCL</code>: declaration 申明resources</li>
<li><code>IMM</code>: immediate 立即数</li>
<li><code>PROPERTY</code> : property 性质</li>
</ul>
<h2 id="着色器的编译链接"><a href="#着色器的编译链接" class="headerlink" title="着色器的编译链接"></a>着色器的编译链接</h2><p><img src="/images/2019/11/glsl_build_link.png" alt="glsl_build_link"></p>
<blockquote>
<p>GLSL中则通过两种对象——<code>着色器对象</code>和<code>着色器程序对象</code>——来分别处理编译过程和连接过程</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call glShaderSource(shader=58, count=3, )</span><br><span class="line">string[0]=&#123;#version 140</span><br><span class="line">#extension GL_ARB_shader_bit_encoding : require</span><br><span class="line">&#125;</span><br><span class="line">string[1]=&#123;in vec4 in_0;</span><br><span class="line">in vec4 in_1;</span><br><span class="line"></span><br><span class="line">  smooth                     out  vec4 vso_g0A0_f;</span><br><span class="line">uniform float winsys_adjust_y;</span><br><span class="line">vec4 temp0[1];</span><br><span class="line">uniform uvec4 vsconst0[8];</span><br><span class="line">&#125;</span><br><span class="line">string[2]=&#123;void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0] = vec4((((in_0.xxxx) * uintBitsToFloat(vsconst0[0]))));</span><br><span class="line">temp0[0] = vec4(((in_0.yyyy) * uintBitsToFloat(vsconst0[1]) +  temp0[0] ));</span><br><span class="line">temp0[0] = vec4(((in_0.zzzz) * uintBitsToFloat(vsconst0[2]) +  temp0[0] ));</span><br><span class="line">gl_Position = vec4(((in_0.wwww) * uintBitsToFloat(vsconst0[3]) +  temp0[0] ));</span><br><span class="line">temp0[0] = vec4((((in_1.xxxx) * uintBitsToFloat(vsconst0[4]))));</span><br><span class="line">temp0[0] = vec4(((in_1.yyyy) * uintBitsToFloat(vsconst0[5]) +  temp0[0] ));</span><br><span class="line">temp0[0] = vec4(((in_1.zzzz) * uintBitsToFloat(vsconst0[6]) +  temp0[0] ));</span><br><span class="line">vso_g0A0_f = vec4(((in_1.wwww) * uintBitsToFloat(vsconst0[7]) +  temp0[0] ));</span><br><span class="line">gl_Position.y = gl_Position.y * winsys_adjust_y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">call glCompileShader(58)</span><br><span class="line">call glGetShaderiv(shader=58, pname=0x8b81, params=1)</span><br><span class="line">call glCreateProgram(): 60</span><br><span class="line">call glAttachShader(program=60, shader=58)</span><br><span class="line">call glAttachShader(program=60, shader=59)</span><br><span class="line">call glBindAttribLocation(60, 0, in_0)</span><br><span class="line">call glBindAttribLocation(60, 1, in_1)</span><br><span class="line">call glLinkProgram(program=60)</span><br><span class="line">call glGetProgramiv(60, 0x8b82, 833648032)</span><br><span class="line">call glGetUniformLocation(program=60, name=winsys_adjust_y): val=0</span><br><span class="line">call glUseProgram(60)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>glShaderSource</code>: 替换着色器对象中的源代码</li>
<li><code>glCompileShader</code>: 编译一个着色器对象</li>
<li><code>glGetShaderiv</code>: 从着色器对象返回一个参数</li>
<li><code>glCreateProgram</code>: 创建一个空program对象并返回一个可以被引用的非零值（program ID）</li>
<li><code>glUseProgram</code>: 安装program对象作为当前渲染状态的一部分</li>
</ul>
<p><img src="/images/2019/11/shader_create_flowchart.png" alt="shader_create_flowchart"></p>
<h2 id="GLSL使用"><a href="#GLSL使用" class="headerlink" title="GLSL使用"></a>GLSL使用</h2><p>着色器代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> vertex_shader[] =</span><br><span class="line"><span class="string">"attribute vec3 position;\n"</span></span><br><span class="line"><span class="string">"attribute vec3 normal;\n"</span></span><br><span class="line"><span class="string">"\n"</span></span><br><span class="line"><span class="string">"uniform mat4 ModelViewProjectionMatrix;\n"</span></span><br><span class="line"><span class="string">"uniform mat4 NormalMatrix;\n"</span></span><br><span class="line"><span class="string">"uniform vec4 LightSourcePosition;\n"</span></span><br><span class="line"><span class="string">"uniform vec4 MaterialColor;\n"</span></span><br><span class="line"><span class="string">"\n"</span></span><br><span class="line"><span class="string">"varying vec4 Color;\n"</span></span><br><span class="line"><span class="string">"\n"</span></span><br><span class="line"><span class="string">"void main(void)\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"    // Transform the normal to eye coordinates\n"</span></span><br><span class="line"><span class="string">"    vec3 N = normalize(vec3(NormalMatrix * vec4(normal, 1.0)));\n"</span></span><br><span class="line"><span class="string">"\n"</span></span><br><span class="line"><span class="string">"    // The LightSourcePosition is actually its direction for directional light\n"</span></span><br><span class="line"><span class="string">"    vec3 L = normalize(LightSourcePosition.xyz);\n"</span></span><br><span class="line"><span class="string">"\n"</span></span><br><span class="line"><span class="string">"    // Multiply the diffuse value by the vertex color (which is fixed in this case)\n"</span></span><br><span class="line"><span class="string">"    // to get the actual color that we will use to draw this vertex with\n"</span></span><br><span class="line"><span class="string">"    float diffuse = max(dot(N, L), 0.0);\n"</span></span><br><span class="line"><span class="string">"    Color = diffuse * MaterialColor;\n"</span></span><br><span class="line"><span class="string">"\n"</span></span><br><span class="line"><span class="string">"    // Transform the position to clip coordinates\n"</span></span><br><span class="line"><span class="string">"    gl_Position = ModelViewProjectionMatrix * vec4(position, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> fragment_shader[] =</span><br><span class="line"><span class="string">"precision mediump float;\n"</span></span><br><span class="line"><span class="string">"varying vec4 Color;\n"</span></span><br><span class="line"><span class="string">"\n"</span></span><br><span class="line"><span class="string">"void main(void)\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"    gl_FragColor = Color;\n"</span></span><br><span class="line"><span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compile the vertex shader */</span></span><br><span class="line">p = vertex_shader;</span><br><span class="line">v = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(v, <span class="number">1</span>, &amp;p, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(v);</span><br><span class="line">glGetShaderInfoLog(v, <span class="keyword">sizeof</span> msg, <span class="literal">NULL</span>, msg);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"vertex shader info: %s\n"</span>, msg);</span><br></pre></td></tr></table></figure>
<p><code>glCompileShader</code>主要编译着色器的源代码（即vertex_shader中的GLSL代码）</p>
<ul>
<li>编译后的代码是TGSI中间代码？</li>
<li>如果是在哪个阶段进行的转换？</li>
<li>在virgl驱动中的着色器代码是否进行了转换？</li>
</ul>
<h3 id="glCompileShader"><a href="#glCompileShader" class="headerlink" title="glCompileShader"></a>glCompileShader</h3><blockquote>
<p><code>glCompileShader</code> compiles the source code strings that have been stored in the shader object specified by shader.</p>
</blockquote>
<p>在mesa中的函数调用流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_mesa_CompileShader (src/mesa/main/shaderapi.c)</span><br><span class="line"> \-&gt;_mesa_compile_shader</span><br><span class="line">     \-&gt;ensure_builtin_types</span><br><span class="line">     |-&gt;_mesa_glsl_compile_shader</span><br></pre></td></tr></table></figure>
<blockquote>
<p>版本：19.3.0-devel 237c7636ca4c429d4dbfce95b6e3281a8309eac7</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shader intermediate representation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if the driver requests something other than TGSI, it must</span></span><br><span class="line"><span class="comment"> * always be prepared to receive TGSI in addition to its preferred IR.</span></span><br><span class="line"><span class="comment"> * If the driver requests TGSI as its preferred IR, it will *always*</span></span><br><span class="line"><span class="comment"> * get TGSI.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that PIPE_SHADER_IR_TGSI should be zero for backwards compat with</span></span><br><span class="line"><span class="comment"> * state trackers that only understand TGSI.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> pipe_shader_ir</span><br><span class="line">&#123;</span><br><span class="line">   PIPE_SHADER_IR_TGSI = <span class="number">0</span>,</span><br><span class="line">   PIPE_SHADER_IR_NATIVE,</span><br><span class="line">   PIPE_SHADER_IR_NIR,</span><br><span class="line">   PIPE_SHADER_IR_NIR_SERIALIZED,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Plug in the program and shader-related device driver functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">st_init_program_functions(struct dd_function_table *functions)</span><br><span class="line">&#123;</span><br><span class="line">   functions-&gt;NewProgram = st_new_program;</span><br><span class="line">   functions-&gt;DeleteProgram = st_delete_program;</span><br><span class="line">   functions-&gt;ProgramStringNotify = st_program_string_notify;</span><br><span class="line">   functions-&gt;NewATIfs = st_new_ati_fs;</span><br><span class="line">   functions-&gt;LinkShader = st_link_shader;</span><br><span class="line">   functions-&gt;SetMaxShaderCompilerThreads = st_max_shader_compiler_threads;</span><br><span class="line">   functions-&gt;GetShaderProgramCompletionStatus =</span><br><span class="line">      st_get_shader_program_completion_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file:  src/mesa/state_tracker/st_cb_program.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link a shader.</span></span><br><span class="line"><span class="comment"> * Called via ctx-&gt;Driver.LinkShader()</span></span><br><span class="line"><span class="comment"> * This is a shared function that branches off to either GLSL IR -&gt; TGSI or</span></span><br><span class="line"><span class="comment"> * GLSL IR -&gt; NIR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">GLboolean</span><br><span class="line">st_link_shader(struct gl_context *ctx, struct gl_shader_program *prog)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: src/mesa/state_tracker/st_glsl_to_ir.cpp</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link a shader.</span></span><br><span class="line"><span class="comment"> * This actually involves converting GLSL IR into an intermediate TGSI-like IR</span></span><br><span class="line"><span class="comment"> * with code lowering and other optimizations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> GLboolean</span><br><span class="line"> st_link_tgsi(struct gl_context *ctx, struct gl_shader_program *prog)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: src/mesa/state_tracker/st_glsl_to_tgsi.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st_link_shader</span><br><span class="line">\/</span><br><span class="line">st_link_tgsi</span><br></pre></td></tr></table></figure>
<h2 id="virgl中着色器的转换"><a href="#virgl中着色器的转换" class="headerlink" title="virgl中着色器的转换"></a>virgl中着色器的转换</h2><p>amdgpu使用开源驱动</p>
<p><img src="/images/2019/11/virgl_shader_switch.png" alt="virgl_shader_switch"></p>
<blockquote>
<p>Then, 3D commands. These are close to what we can find in a API like Vulkan. We can setup a viewport, scissor state, create a VBO, and draw it. Shaders are also supported, but we first need to translate them to TGSI; an assembly-like representation. Once on the host, they will be re-translated to GLSL and sent to OpenGL.<br><a href="https://studiopixl.com/2017-08-27/3d-acceleration-using-virtio.html" target="_blank" rel="noopener">https://studiopixl.com/2017-08-27/3d-acceleration-using-virtio.html</a></p>
</blockquote>
<ul>
<li>在tgsi的传输中为什么不直接使用tgsi token进行传输，而要转换为text的形式传输？？？<ul>
<li>地址空间的不同是否相关？</li>
<li>tgsi text转换为tgsi token的过程中与当前使用到的纹理数据等其他资源进行关联？</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tgsi_instruction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">unsigned</span> Type       : <span class="number">4</span>;  <span class="comment">/* TGSI_TOKEN_TYPE_INSTRUCTION */</span></span><br><span class="line">   <span class="keyword">unsigned</span> NrTokens   : <span class="number">8</span>;  <span class="comment">/* UINT */</span></span><br><span class="line">   <span class="keyword">unsigned</span> Opcode     : <span class="number">8</span>;  <span class="comment">/* TGSI_OPCODE_ */</span></span><br><span class="line">   <span class="keyword">unsigned</span> Saturate   : <span class="number">1</span>;  <span class="comment">/* BOOL */</span></span><br><span class="line">   <span class="keyword">unsigned</span> NumDstRegs : <span class="number">2</span>;  <span class="comment">/* UINT */</span></span><br><span class="line">   <span class="keyword">unsigned</span> NumSrcRegs : <span class="number">4</span>;  <span class="comment">/* UINT */</span></span><br><span class="line">   <span class="keyword">unsigned</span> Label      : <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> Texture    : <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> Memory     : <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> Precise    : <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> Padding    : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tgsi_instruction_texture</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">unsigned</span> Texture  : <span class="number">8</span>;    <span class="comment">/* TGSI_TEXTURE_ */</span></span><br><span class="line">   <span class="keyword">unsigned</span> NumOffsets : <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> ReturnType : <span class="number">3</span>; <span class="comment">/* TGSI_RETURN_TYPE_x */</span></span><br><span class="line">   <span class="keyword">unsigned</span> Padding : <span class="number">17</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * If tgsi_instruction::Label is TRUE, tgsi_instruction_label follows.</span><br><span class="line"> *</span><br><span class="line"> * If tgsi_instruction::Texture is TRUE, tgsi_instruction_texture follows.</span><br><span class="line"> *   if texture instruction has a number of offsets,</span><br><span class="line"> *   then tgsi_instruction::Texture::NumOffset of tgsi_texture_offset follow.</span><br><span class="line"> *</span><br><span class="line"> * Then, tgsi_instruction::NumDstRegs of tgsi_dst_register follow.</span><br><span class="line"> *</span><br><span class="line"> * Then, tgsi_instruction::NumSrcRegs of tgsi_src_register follow.</span><br><span class="line"> *</span><br><span class="line"> * tgsi_instruction::NrTokens contains the total number of words that make the</span><br><span class="line"> * instruction, including the instruction word.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tgsi_instruction_texture:表明存在指令纹理，其与纹理资源数据之间的关系？</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glxgears: shader</span><br><span class="line">FRAG</span><br><span class="line">PROPERTY FS_COLOR0_WRITES_ALL_CBUFS 1</span><br><span class="line">DCL IN[0], COLOR, COLOR</span><br><span class="line">DCL OUT[0], COLOR</span><br><span class="line">  0: MOV OUT[0], IN[0]</span><br><span class="line">  1: END</span><br><span class="line"></span><br><span class="line">glxgears: GLSL:glxgears: #version 140</span><br><span class="line"></span><br><span class="line">   in  vec4 ex_c0;</span><br><span class="line">out vec4 fsout_c0;</span><br><span class="line">out vec4 fsout_c1;</span><br><span class="line">out vec4 fsout_c2;</span><br><span class="line">out vec4 fsout_c3;</span><br><span class="line">out vec4 fsout_c4;</span><br><span class="line">out vec4 fsout_c5;</span><br><span class="line">out vec4 fsout_c6;</span><br><span class="line">out vec4 fsout_c7;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">fsout_c0 = vec4(((ex_c0)));</span><br><span class="line">fsout_c1 = fsout_c0;</span><br><span class="line">fsout_c2 = fsout_c0;</span><br><span class="line">fsout_c3 = fsout_c0;</span><br><span class="line">fsout_c4 = fsout_c0;</span><br><span class="line">fsout_c5 = fsout_c0;</span><br><span class="line">fsout_c6 = fsout_c0;</span><br><span class="line">fsout_c7 = fsout_c0;</span><br><span class="line">&#125;</span><br><span class="line">glxgears:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TGSI转换成GLSL</p>
</blockquote>
<h2 id="amdgpu中着色器的转换"><a href="#amdgpu中着色器的转换" class="headerlink" title="amdgpu中着色器的转换"></a>amdgpu中着色器的转换</h2><p>在radeonsi用户空间驱动中tgsi的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setup actions for TGSI memory opcode, including texture opcodes.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TGSI与texture之间在渲染时，之间的联系？？</p>
</blockquote>
<h3 id="radeonsi-for-shader"><a href="#radeonsi-for-shader" class="headerlink" title="radeonsi for shader"></a>radeonsi for shader</h3><p>目前LLVM是amdgpu的后端编译器，在mesa19.3中使用<code>ACO</code>（AMD COmpiler）编译着色器代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TGSI-&gt;LLVM</span><br></pre></td></tr></table></figure>
<blockquote>
<p>It was just two days ago that Valve’s performance-focused “ACO” shader compiler was submitted for review to be included in Mesa for the “RADV” Radeon Vulkan driver. Just minutes ago that new shader compiler back-end was merged for Mesa 19.3.</p>
<p>ACO, short for the AMD COmpiler, is the effort led by Valve at creating a more performant and optimized shader compiler for the Radeon Linux graphics driver. Besides trying to generate the fastest shaders, ACO also aims to provide speedy shader compilation too, as an alternative to the AMDGPU LLVM shader compiler back-end. Initially ACO is for the RADV Vulkan driver but it may be brought to the RadeonSI OpenGL driver in the future. At the moment ACO is in good shape for Volcanic Islands through Vega while the Navi shader support is in primitive form.</p>
<ul>
<li><a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Mesa-19.3-Lands-RADV-ACO" target="_blank" rel="noopener">Valve’s ACO Shader Compiler For The Mesa Radeon Vulkan Driver Just Landed</a></li>
</ul>
</blockquote>
<h3 id="ISA-Code"><a href="#ISA-Code" class="headerlink" title="ISA Code"></a>ISA Code</h3><p>Instruction Set Architecture(指令集架构) —— ISA</p>
<blockquote>
<p>The AMDGPU backend provides <code>ISA code</code> generation for AMD GPUs, starting with the R600 family up until the current GCN families. It lives in the lib/Target/AMDGPU directory.</p>
</blockquote>
<blockquote>
<ul>
<li><a href="https://www.llvm.org/docs/AMDGPUUsage.html#amdgpu-intrinsics" target="_blank" rel="noopener">User Guide for AMDGPU Backend</a></li>
</ul>
</blockquote>
<ul>
<li><a href="https://rocm-documentation.readthedocs.io/en/latest/GCN_ISA_Manuals/testdocbook.html#testdocbook" target="_blank" rel="noopener">“Vega” Instruction Set Architecture</a></li>
<li><a href="https://rocm-documentation.readthedocs.io/en/latest/GCN_ISA_Manuals/GCN-ISA-Manuals.html" target="_blank" rel="noopener">GCN ISA Manuals</a></li>
</ul>
<h3 id="着色器形式的转换"><a href="#着色器形式的转换" class="headerlink" title="着色器形式的转换"></a>着色器形式的转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+     +---------+    +---------+     +------+     +------+    +-------+</span><br><span class="line">|       |     |         |    |         |     |      |     |      |    |       |</span><br><span class="line">| GLSL  +-----&gt; GLSL IR +----&gt;   NIR   +-----&gt; TGSI +-----&gt; LLVM +----&gt;  ISA  |</span><br><span class="line">|       |     |         |    |         |     |      |     |      |    |       |</span><br><span class="line">+--+----+     +---------+    +---------+     +--+---+     +------+    +----+--+</span><br><span class="line">   |                                            |                          |</span><br><span class="line">   |                                            |      radeonsi_dri.so     |</span><br><span class="line">   |                common                      |           amdgpu         |</span><br></pre></td></tr></table></figure>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="GLSL着色器"><a href="#GLSL着色器" class="headerlink" title="GLSL着色器"></a>GLSL着色器</h3><ul>
<li>vertex shader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//vertex顶点着色器</span><br><span class="line">varying vec3 lightDir, normal;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        lightDir = normalize(vec3(gl_LightSource[0].position));</span><br><span class="line">        normal = normalize(gl_NormalMatrix * gl_Normal);</span><br><span class="line"></span><br><span class="line">        gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fragment shader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//fragment片元着色器</span><br><span class="line">varying vec3 lightDir, normal;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        float intensity;</span><br><span class="line">        vec3 n;</span><br><span class="line">        vec4 color;</span><br><span class="line"></span><br><span class="line">        n = normalize(normal);</span><br><span class="line"></span><br><span class="line">        intensity = max(dot(lightDir,n),0.0);</span><br><span class="line">        color = vec4(1.0, 0, 1.0, 1) * intensity;</span><br><span class="line"></span><br><span class="line">        gl_FragColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TGSI-text"><a href="#TGSI-text" class="headerlink" title="TGSI text"></a>TGSI text</h3><p>通过mesa编译后生成的TGSI token进行dump出的text</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VIRGL_DEBUG=tgsi ./a.out</span><br></pre></td></tr></table></figure>
<ul>
<li>vertex shader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TGSI:</span><br><span class="line">---8&lt;---</span><br><span class="line">VERT</span><br><span class="line">DCL IN[0]</span><br><span class="line">DCL IN[1]</span><br><span class="line">DCL OUT[0], POSITION</span><br><span class="line">DCL OUT[1], GENERIC[9]</span><br><span class="line">DCL OUT[2].xy, GENERIC[10]</span><br><span class="line">DCL CONST[0..14]</span><br><span class="line">DCL TEMP[0..2], LOCAL</span><br><span class="line">  0: MUL TEMP[0].xyz, CONST[8].xyzz, IN[1].xxxx</span><br><span class="line">  1: MAD TEMP[0].xyz, CONST[9].xyzz, IN[1].yyyy, TEMP[0].xyzz</span><br><span class="line">  2: MAD TEMP[0].xyz, CONST[10].xyzz, IN[1].zzzz, TEMP[0].xyzz</span><br><span class="line">  3: DP3 TEMP[1].x, TEMP[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  4: RSQ TEMP[1].x, TEMP[1].xxxx</span><br><span class="line">  5: MUL TEMP[0].xyz, TEMP[0].xyzz, TEMP[1].xxxx</span><br><span class="line">  6: MUL TEMP[1], CONST[11], IN[0].xxxx</span><br><span class="line">  7: MAD TEMP[1], CONST[12], IN[0].yyyy, TEMP[1]</span><br><span class="line">  8: MAD TEMP[1], CONST[13], IN[0].zzzz, TEMP[1]</span><br><span class="line">  9: MAD TEMP[1], CONST[14], IN[0].wwww, TEMP[1]</span><br><span class="line"> 10: DP3 TEMP[2].x, CONST[3].xyzz, CONST[3].xyzz</span><br><span class="line"> 11: RSQ TEMP[2].x, TEMP[2].xxxx</span><br><span class="line"> 12: MUL TEMP[2].xyz, CONST[3].xyzz, TEMP[2].xxxx</span><br><span class="line"> 13: MOV TEMP[2].w, TEMP[0].xxxx</span><br><span class="line"> 14: MOV OUT[2].xy, TEMP[0].yzyy</span><br><span class="line"> 15: MOV OUT[0], TEMP[1]</span><br><span class="line"> 16: MOV OUT[1], TEMP[2]</span><br><span class="line"> 17: END</span><br><span class="line"></span><br><span class="line">---8&lt;---</span><br></pre></td></tr></table></figure>
<ul>
<li>fragment shader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TGSI:</span><br><span class="line">---8&lt;---</span><br><span class="line">FRAG</span><br><span class="line">PROPERTY FS_COLOR0_WRITES_ALL_CBUFS 1</span><br><span class="line">DCL IN[0], GENERIC[9], PERSPECTIVE</span><br><span class="line">DCL IN[1].xy, GENERIC[10], PERSPECTIVE</span><br><span class="line">DCL OUT[0], COLOR</span><br><span class="line">DCL TEMP[0..1], LOCAL</span><br><span class="line">IMM[0] FLT32 &#123;0x3f800000, 0x00000000, 0x00000000, 0x00000000&#125;</span><br><span class="line">  0: MOV TEMP[0].x, IN[0].wwww</span><br><span class="line">  1: MOV TEMP[0].yz, IN[1].yxyy</span><br><span class="line">  2: DP3 TEMP[1].x, TEMP[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  3: RSQ TEMP[1].x, TEMP[1].xxxx</span><br><span class="line">  4: MUL TEMP[0].xyz, TEMP[0].xyzz, TEMP[1].xxxx</span><br><span class="line">  5: DP3 TEMP[0].x, IN[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  6: MAX TEMP[0].x, TEMP[0].xxxx, IMM[0].yyyy</span><br><span class="line">  7: MUL TEMP[0], IMM[0].xyxx, TEMP[0].xxxx</span><br><span class="line">  8: MOV OUT[0], TEMP[0]</span><br><span class="line">  9: END</span><br><span class="line"></span><br><span class="line">---8&lt;---</span><br></pre></td></tr></table></figure>
<h3 id="TGSI转换GLSL"><a href="#TGSI转换GLSL" class="headerlink" title="TGSI转换GLSL"></a>TGSI转换GLSL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VREND_DEBUG=shader virgl_test_server</span><br></pre></td></tr></table></figure>
<ul>
<li>vertex shader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.out: shader</span><br><span class="line">VERT</span><br><span class="line">DCL IN[0]</span><br><span class="line">DCL IN[1]</span><br><span class="line">DCL OUT[0], POSITION</span><br><span class="line">DCL OUT[1], GENERIC[9]</span><br><span class="line">DCL OUT[2].xy, GENERIC[10]</span><br><span class="line">DCL CONST[0..14]</span><br><span class="line">DCL TEMP[0..2], LOCAL</span><br><span class="line">  0: MUL TEMP[0].xyz, CONST[8].xyzz, IN[1].xxxx</span><br><span class="line">  1: MAD TEMP[0].xyz, CONST[9].xyzz, IN[1].yyyy, TEMP[0].xyzz</span><br><span class="line">  2: MAD TEMP[0].xyz, CONST[10].xyzz, IN[1].zzzz, TEMP[0].xyzz</span><br><span class="line">  3: DP3 TEMP[1].x, TEMP[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  4: RSQ TEMP[1].x, TEMP[1].xxxx</span><br><span class="line">  5: MUL TEMP[0].xyz, TEMP[0].xyzz, TEMP[1].xxxx</span><br><span class="line">  6: MUL TEMP[1], CONST[11], IN[0].xxxx</span><br><span class="line">  7: MAD TEMP[1], CONST[12], IN[0].yyyy, TEMP[1]</span><br><span class="line">  8: MAD TEMP[1], CONST[13], IN[0].zzzz, TEMP[1]</span><br><span class="line">  9: MAD TEMP[1], CONST[14], IN[0].wwww, TEMP[1]</span><br><span class="line"> 10: DP3 TEMP[2].x, CONST[3].xyzz, CONST[3].xyzz</span><br><span class="line"> 11: RSQ TEMP[2].x, TEMP[2].xxxx</span><br><span class="line"> 12: MUL TEMP[2].xyz, CONST[3].xyzz, TEMP[2].xxxx</span><br><span class="line"> 13: MOV TEMP[2].w, TEMP[0].xxxx</span><br><span class="line"> 14: MOV OUT[2].xy, TEMP[0].yzyy</span><br><span class="line"> 15: MOV OUT[0], TEMP[1]</span><br><span class="line"> 16: MOV OUT[1], TEMP[2]</span><br><span class="line"> 17: END</span><br><span class="line"></span><br><span class="line">a.out: GLSL:a.out: #version 140</span><br><span class="line">#extension GL_ARB_shader_bit_encoding : require</span><br><span class="line">in vec4 in_0;</span><br><span class="line">in vec4 in_1;</span><br><span class="line"></span><br><span class="line">                             out  vec4 vso_g9A0_f;</span><br><span class="line"></span><br><span class="line">                             out  vec4 vso_g10A0_f;</span><br><span class="line">uniform float winsys_adjust_y;</span><br><span class="line">vec4 temp0[3];</span><br><span class="line">uniform uvec4 vsconst0[15];</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0].xyz = vec3(((uintBitsToFloat(vsconst0[8].xyzz) * (in_1.xxxx))).xyz);</span><br><span class="line">temp0[0].xyz = vec3((uintBitsToFloat(vsconst0[9].xyzz) * (in_1.yyyy) +  temp0[0].xyzz ).xyz);</span><br><span class="line">temp0[0].xyz = vec3((uintBitsToFloat(vsconst0[10].xyzz) * (in_1.zzzz) +  temp0[0].xyzz ).xyz);</span><br><span class="line">temp0[1].x = float(dot(vec3( temp0[0].xyzz ), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[1].x = float(inversesqrt( temp0[1].xxxx .x));</span><br><span class="line">temp0[0].xyz = vec3((( temp0[0].xyzz  *  temp0[1].xxxx )).xyz);</span><br><span class="line">temp0[1] = vec4(((uintBitsToFloat(vsconst0[11]) * (in_0.xxxx))));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[12]) * (in_0.yyyy) +  temp0[1] ));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[13]) * (in_0.zzzz) +  temp0[1] ));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[14]) * (in_0.wwww) +  temp0[1] ));</span><br><span class="line">temp0[2].x = float(dot(vec3(uintBitsToFloat(vsconst0[3].xyzz)), vec3(uintBitsToFloat(vsconst0[3].xyzz))));</span><br><span class="line">temp0[2].x = float(inversesqrt( temp0[2].xxxx .x));</span><br><span class="line">temp0[2].xyz = vec3(((uintBitsToFloat(vsconst0[3].xyzz) *  temp0[2].xxxx )).xyz);</span><br><span class="line">temp0[2].w = float(( temp0[0].xxxx .w));</span><br><span class="line">vso_g10A0_f.xy = vec2(( temp0[0].yzyy .xy));</span><br><span class="line">gl_Position = vec4(( temp0[1] ));</span><br><span class="line">vso_g9A0_f = vec4(( temp0[2] ));</span><br><span class="line">gl_Position.y = gl_Position.y * winsys_adjust_y;</span><br><span class="line">&#125;</span><br><span class="line">a.out:</span><br><span class="line">a.out: GLSL:a.out: #version 140</span><br><span class="line"></span><br><span class="line">smooth    in  vec4 vso_g9A0_f;</span><br><span class="line"></span><br><span class="line">smooth    in  vec4 vso_g10A0_f;</span><br><span class="line">out vec4 fsout_c0;</span><br><span class="line">out vec4 fsout_c1;</span><br><span class="line">out vec4 fsout_c2;</span><br><span class="line">out vec4 fsout_c3;</span><br><span class="line">out vec4 fsout_c4;</span><br><span class="line">out vec4 fsout_c5;</span><br><span class="line">out vec4 fsout_c6;</span><br><span class="line">out vec4 fsout_c7;</span><br><span class="line">vec4 temp0[2];</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0].x = float(((vso_g9A0_f.wwww).x));</span><br><span class="line">temp0[0].yz = vec2(((vso_g10A0_f.yxyy).yz));</span><br><span class="line">temp0[1].x = float(dot(vec3( temp0[0].xyzz ), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[1].x = float(inversesqrt( temp0[1].xxxx .x));</span><br><span class="line">temp0[0].xyz = vec3((( temp0[0].xyzz  *  temp0[1].xxxx )).xyz);</span><br><span class="line">temp0[0].x = float(dot(vec3((vso_g9A0_f.xyzz)), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[0].x = float((max( temp0[0].xxxx , (vec4(0,0,0,0)))).x);</span><br><span class="line">temp0[0] = vec4((((vec4(1,0,1,1)) *  temp0[0].xxxx )));</span><br><span class="line">fsout_c0 = vec4(( temp0[0] ));</span><br><span class="line">fsout_c1 = fsout_c0;</span><br><span class="line">fsout_c2 = fsout_c0;</span><br><span class="line">fsout_c3 = fsout_c0;</span><br><span class="line">fsout_c4 = fsout_c0;</span><br><span class="line">fsout_c5 = fsout_c0;</span><br><span class="line">fsout_c6 = fsout_c0;</span><br><span class="line">fsout_c7 = fsout_c0;</span><br><span class="line">&#125;</span><br><span class="line">a.out:</span><br><span class="line">a.out: GLSL:a.out: #version 140</span><br><span class="line">#extension GL_ARB_shader_bit_encoding : require</span><br><span class="line">in vec4 in_0;</span><br><span class="line">in vec4 in_1;</span><br><span class="line"></span><br><span class="line">  smooth                     out  vec4 vso_g9A0_f;</span><br><span class="line"></span><br><span class="line">  smooth                     out  vec4 vso_g10A0_f;</span><br><span class="line">uniform float winsys_adjust_y;</span><br><span class="line">vec4 temp0[3];</span><br><span class="line">uniform uvec4 vsconst0[15];</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0].xyz = vec3(((uintBitsToFloat(vsconst0[8].xyzz) * (in_1.xxxx))).xyz);</span><br><span class="line">temp0[0].xyz = vec3((uintBitsToFloat(vsconst0[9].xyzz) * (in_1.yyyy) +  temp0[0].xyzz ).xyz);</span><br><span class="line">temp0[0].xyz = vec3((uintBitsToFloat(vsconst0[10].xyzz) * (in_1.zzzz) +  temp0[0].xyzz ).xyz);</span><br><span class="line">temp0[1].x = float(dot(vec3( temp0[0].xyzz ), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[1].x = float(inversesqrt( temp0[1].xxxx .x));</span><br><span class="line">temp0[0].xyz = vec3((( temp0[0].xyzz  *  temp0[1].xxxx )).xyz);</span><br><span class="line">temp0[1] = vec4(((uintBitsToFloat(vsconst0[11]) * (in_0.xxxx))));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[12]) * (in_0.yyyy) +  temp0[1] ));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[13]) * (in_0.zzzz) +  temp0[1] ));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[14]) * (in_0.wwww) +  temp0[1] ));</span><br><span class="line">temp0[2].x = float(dot(vec3(uintBitsToFloat(vsconst0[3].xyzz)), vec3(uintBitsToFloat(vsconst0[3].xyzz))));</span><br><span class="line">temp0[2].x = float(inversesqrt( temp0[2].xxxx .x));</span><br><span class="line">temp0[2].xyz = vec3(((uintBitsToFloat(vsconst0[3].xyzz) *  temp0[2].xxxx )).xyz);</span><br><span class="line">temp0[2].w = float(( temp0[0].xxxx .w));</span><br><span class="line">vso_g10A0_f.xy = vec2(( temp0[0].yzyy .xy));</span><br><span class="line">gl_Position = vec4(( temp0[1] ));</span><br><span class="line">vso_g9A0_f = vec4(( temp0[2] ));</span><br><span class="line">gl_Position.y = gl_Position.y * winsys_adjust_y;</span><br><span class="line">&#125;</span><br><span class="line">a.out:</span><br></pre></td></tr></table></figure>
<ul>
<li>fragment shader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.out: shader</span><br><span class="line">FRAG</span><br><span class="line">PROPERTY FS_COLOR0_WRITES_ALL_CBUFS 1</span><br><span class="line">DCL IN[0], GENERIC[9], PERSPECTIVE</span><br><span class="line">DCL IN[1].xy, GENERIC[10], PERSPECTIVE</span><br><span class="line">DCL OUT[0], COLOR</span><br><span class="line">DCL TEMP[0..1], LOCAL</span><br><span class="line">IMM[0] FLT32 &#123;0x3f800000, 0x00000000, 0x00000000, 0x00000000&#125;</span><br><span class="line">  0: MOV TEMP[0].x, IN[0].wwww</span><br><span class="line">  1: MOV TEMP[0].yz, IN[1].yxyy</span><br><span class="line">  2: DP3 TEMP[1].x, TEMP[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  3: RSQ TEMP[1].x, TEMP[1].xxxx</span><br><span class="line">  4: MUL TEMP[0].xyz, TEMP[0].xyzz, TEMP[1].xxxx</span><br><span class="line">  5: DP3 TEMP[0].x, IN[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  6: MAX TEMP[0].x, TEMP[0].xxxx, IMM[0].yyyy</span><br><span class="line">  7: MUL TEMP[0], IMM[0].xyxx, TEMP[0].xxxx</span><br><span class="line">  8: MOV OUT[0], TEMP[0]</span><br><span class="line">  9: END</span><br><span class="line"></span><br><span class="line">a.out: GLSL:a.out: #version 140</span><br><span class="line"></span><br><span class="line">smooth    in  vec4 vso_g9A0_f;</span><br><span class="line"></span><br><span class="line">smooth    in  vec4 vso_g10A0_f;</span><br><span class="line">out vec4 fsout_c0;</span><br><span class="line">out vec4 fsout_c1;</span><br><span class="line">out vec4 fsout_c2;</span><br><span class="line">out vec4 fsout_c3;</span><br><span class="line">out vec4 fsout_c4;</span><br><span class="line">out vec4 fsout_c5;</span><br><span class="line">out vec4 fsout_c6;</span><br><span class="line">out vec4 fsout_c7;</span><br><span class="line">vec4 temp0[2];</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0].x = float(((vso_g9A0_f.wwww).x));</span><br><span class="line">temp0[0].yz = vec2(((vso_g10A0_f.yxyy).yz));</span><br><span class="line">temp0[1].x = float(dot(vec3( temp0[0].xyzz ), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[1].x = float(inversesqrt( temp0[1].xxxx .x));</span><br><span class="line">temp0[0].xyz = vec3((( temp0[0].xyzz  *  temp0[1].xxxx )).xyz);</span><br><span class="line">temp0[0].x = float(dot(vec3((vso_g9A0_f.xyzz)), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[0].x = float((max( temp0[0].xxxx , (vec4(0,0,0,0)))).x);</span><br><span class="line">temp0[0] = vec4((((vec4(1,0,1,1)) *  temp0[0].xxxx )));</span><br><span class="line">fsout_c0 = vec4(( temp0[0] ));</span><br><span class="line">fsout_c1 = fsout_c0;</span><br><span class="line">fsout_c2 = fsout_c0;</span><br><span class="line">fsout_c3 = fsout_c0;</span><br><span class="line">fsout_c4 = fsout_c0;</span><br><span class="line">fsout_c5 = fsout_c0;</span><br><span class="line">fsout_c6 = fsout_c0;</span><br><span class="line">fsout_c7 = fsout_c0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>打印着色器程序相关的所有参数和字段<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ST_DEBUG=mesa ./a.out</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Print all of a program&apos;s parameters/fields to stderr.</span><br><span class="line"> */</span><br><span class="line">void</span><br><span class="line">_mesa_print_program_parameters(struct gl_context *ctx, const struct gl_program *prog)</span><br><span class="line">&#123;</span><br><span class="line">   _mesa_fprint_program_parameters(stderr, ctx, prog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: mesa/program/prog_print.c</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://gallium.readthedocs.io/en/latest/tgsi.html" target="_blank" rel="noopener">TGSI</a></li>
<li><a href="https://freedesktop.org/wiki/Software/gallium/gallium3d-xds2007.pdf" target="_blank" rel="noopener">gallium3d-xds2007</a></li>
<li><a href="http://ndesh26.github.io/programming/2016/07/04/A-Beginners-guide-to-TGSI/" target="_blank" rel="noopener">A beginners guide to TGSI</a></li>
<li><a href="http://www.informit.com/articles/article.aspx?p=1554200" target="_blank" rel="noopener">The State of Open Source 3D</a></li>
<li><a href="https://learnopengl.com/Getting-started/Shaders" target="_blank" rel="noopener">learnopengl–Shaders</a>|<a href="https://learnopengl-cn.github.io/#" target="_blank" rel="noopener">【CN】</a></li>
<li><a href="https://www.cnblogs.com/shoemaker/p/linux_graphics11.html" target="_blank" rel="noopener">Linux环境下的图形系统和AMD R600显卡编程(11)——R600指令集</a></li>
<li><a href="https://www.x.org/wiki/Events/XDC2015/Program/turner_glsl_compiler.pdf" target="_blank" rel="noopener">GLSL compiler</a></li>
<li><a href="https://studiopixl.com/2017-08-27/3d-acceleration-using-virtio.html" target="_blank" rel="noopener">GSoC 2017 - 3D acceleration using VirtIOGPU</a></li>
<li><a href="https://blog.mecheye.net/2012/06/the-linux-graphics-stack/#rendering-stack" target="_blank" rel="noopener">The Linux Graphics Stack</a></li>
<li><a href="https://www.phoronix.com/scan.php?page=article&amp;item=glsl_to_tgsi&amp;num=1" target="_blank" rel="noopener">Testing Out Mesa’s GLSL-To-TGSI Translator</a></li>
<li><a href="https://www.researchgate.net/publication/232626644_Introduction_to_GPU_Programming_with_GLSL" target="_blank" rel="noopener">Introduction to GPU Programming with GLSL</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>mesa</category>
      </categories>
      <tags>
        <tag>mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL历史与API变化</title>
    <url>/post/32043.html</url>
    <content><![CDATA[<p>OpenGL API在不同的版本中的扩展。</p>
<a id="more"></a>
<h2 id="OpenGL-4-6-2017"><a href="#OpenGL-4-6-2017" class="headerlink" title="OpenGL 4.6 (2017)"></a>OpenGL 4.6 (2017)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions" target="_blank" rel="noopener">Core Extension</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>The <a href="https://www.khronos.org/opengl/wiki/SPIR-V" target="_blank" rel="noopener">SPIR-V</a> language can be used to define shaders.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/gl_spirv.txt" target="_blank" rel="noopener">ARB_gl_spirv</a>, <a href="http://www.opengl.org/registry/specs/ARB/spirv_extensions.txt" target="_blank" rel="noopener">ARB_spirv_extensions</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Vertex_Shader#Other_inputs" target="_blank" rel="noopener">Vertex shaders</a> can get the draw ID and base vertex/instance values from rendering commands.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shader_draw_parameters.txt" target="_blank" rel="noopener">ARB_shader_draw_parameters</a></td>
</tr>
<tr>
<td>Multi-draw indirect rendering commands that can fetch the number of draws from a buffer.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/indirect_parameters.txt" target="_blank" rel="noopener">ARB_indirect_parameters</a></td>
</tr>
<tr>
<td>Statistics and transform feedback overflow queries.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/pipeline_statistics_query.txt" target="_blank" rel="noopener">ARB_pipeline_statistics_query</a>, <a href="http://www.opengl.org/registry/specs/ARB/transform_feedback_overflow_query.txt" target="_blank" rel="noopener">ARB_transform_feedback_overflow_query</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Anisotropic_Filtering" target="_blank" rel="noopener">Anisotropic Filtering</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_filter_anisotropic.txt" target="_blank" rel="noopener">ARB_texture_filter_anisotropic</a></td>
</tr>
<tr>
<td>Clamping polygon offsets</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/polygon_offset_clamp.txt" target="_blank" rel="noopener">ARB_polygon_offset_clamp</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/OpenGL_Context" target="_blank" rel="noopener">OpenGL Contexts</a> can be created that <a href="https://www.khronos.org/opengl/wiki/OpenGL_Error#No_error_contexts" target="_blank" rel="noopener">do not report errors</a> of any kind.</td>
<td><a href="http://www.opengl.org/registry/specs/KHR/no_error.txt" target="_blank" rel="noopener">KHR_no_error</a></td>
</tr>
<tr>
<td>More operations for <a href="https://www.khronos.org/opengl/wiki/Atomic_Counter" target="_blank" rel="noopener">Atomic Counters</a>.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shader_atomic_counter_ops.txt" target="_blank" rel="noopener">ARB_shader_atomic_counter_ops</a></td>
</tr>
<tr>
<td>Avoiding divergent shader invocations, where they are unnecessary.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shader_group_vote.txt" target="_blank" rel="noopener">ARB_shader_group_vote</a></td>
</tr>
</tbody>
</table>
<p>Links:</p>
<ul>
<li><a href="https://khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf" target="_blank" rel="noopener">OpenGL 4.6 Core Profile Specification</a></li>
<li><a href="https://khronos.org/registry/OpenGL/specs/gl/glspec46.compatibility.pdf" target="_blank" rel="noopener">OpenGL 4.6 Compatibility Profile Specification</a></li>
<li><a href="https://khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.pdf" target="_blank" rel="noopener">OpenGL Shading Language 4.60 Specification</a></li>
</ul>
<h2 id="OpenGL-4-5-2014"><a href="#OpenGL-4-5-2014" class="headerlink" title="OpenGL 4.5 (2014)"></a>OpenGL 4.5 (2014)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions" target="_blank" rel="noopener">Core Extension</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Additional clip control modes to configure how clip space is mapped to window space.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/clip_control.txt" target="_blank" rel="noopener">ARB_clip_control</a></td>
</tr>
<tr>
<td>Adds a new GLSL gl_CullDistance shader output, similar to gl_ClipDistance, but used for whole primitive culling.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/cull_distance.txt" target="_blank" rel="noopener">ARB_cull_distance</a></td>
</tr>
<tr>
<td>Compatibility with OpenGL ES 3.1</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/ES3_1_compatibility.txt" target="_blank" rel="noopener">ARB_ES3_1_compatibility</a></td>
</tr>
<tr>
<td>Adds new modes to <a href="https://www.khronos.org/opengl/wiki/GLAPI/glBeginConditionalRender" target="_blank" rel="noopener">glBeginConditionalRender</a> which invert condition used to determine whether to draw or not.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/conditional_render_inverted.txt" target="_blank" rel="noopener">ARB_conditional_render_inverted</a></td>
</tr>
<tr>
<td>Provides control over the spacial granularity at which the underlying implementation computes derivatives.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/derivative_control.txt" target="_blank" rel="noopener">ARB_derivative_control</a></td>
</tr>
<tr>
<td>Allows <a href="https://www.khronos.org/opengl/wiki/Direct_State_Access" target="_blank" rel="noopener">modifying and querying object state without binding objects</a>.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/direct_state_access.txt" target="_blank" rel="noopener">ARB_direct_state_access</a></td>
</tr>
<tr>
<td>Adds a new function to get sub-regions of texture images.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/get_texture_sub_image.txt" target="_blank" rel="noopener">ARB_get_texture_sub_image</a></td>
</tr>
<tr>
<td>Upgrades the <a href="http://www.opengl.org/registry/specs/ARB/robustness.txt" target="_blank" rel="noopener">ARB_robustness</a> functionality to meet ES 3.1 standards.</td>
<td><a href="http://www.opengl.org/registry/specs/KHR/robustness.txt" target="_blank" rel="noopener">KHR_robustness</a></td>
</tr>
<tr>
<td>Provides GLSL built-in functions allowing shaders to query the number of samples of a texture.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shader_texture_image_samples.txt" target="_blank" rel="noopener">ARB_shader_texture_image_samples</a></td>
</tr>
<tr>
<td>Relaxes the restrictions on rendering to a currently bound texture and <a href="https://www.khronos.org/opengl/wiki/Texture_Barrier" target="_blank" rel="noopener">provides a mechanism to avoid read-after-write hazards</a>.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_barrier.txt" target="_blank" rel="noopener">ARB_texture_barrier</a></td>
</tr>
</tbody>
</table>
<p>Links:</p>
<ul>
<li><a href="http://www.opengl.org/registry/doc/glspec45.core.pdf" target="_blank" rel="noopener">OpenGL 4.5 Core Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/glspec45.compatibility.pdf" target="_blank" rel="noopener">OpenGL 4.5 Compatibility Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.50.pdf" target="_blank" rel="noopener">OpenGL Shading Language 4.50 Specification</a></li>
</ul>
<h2 id="OpenGL-4-4-2013"><a href="#OpenGL-4-4-2013" class="headerlink" title="OpenGL 4.4 (2013)"></a>OpenGL 4.4 (2013)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions" target="_blank" rel="noopener">Core Extension</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Immutable_Buffer_Storage" target="_blank" rel="noopener">Immutable storage for buffer objects,</a> including the ability to use buffers while they are mapped.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/buffer_storage.txt" target="_blank" rel="noopener">ARB_buffer_storage</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Clear_Texture" target="_blank" rel="noopener">Direct clearing of a texture image.</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/clear_texture.txt" target="_blank" rel="noopener">ARB_clear_texture</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL" target="_blank" rel="noopener">A number of enhancements to layout qualifiers:</a>) Integer layout qualifiers can take any <a href="https://www.khronos.org/opengl/wiki/Constant_Expression" target="_blank" rel="noopener">constant expression</a>, not just integer literals. <a href="https://www.khronos.org/opengl/wiki/Buffer_Backed_Interface_Block" target="_blank" rel="noopener">Explicit layout requests for buffer-backed interface blocks.</a> <a href="https://www.khronos.org/opengl/wiki/Layout_Component" target="_blank" rel="noopener">Tight packing of disparate input/output variables</a>. <a href="https://www.khronos.org/opengl/wiki/Feedback_In_Shader_Binding" target="_blank" rel="noopener">In-shader specification of transform feedback parameters.</a> <a href="https://www.khronos.org/opengl/wiki/Layout_Block_Member_Location" target="_blank" rel="noopener">Locations can be set on input/output interface blocks</a>, for packing purposes.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/enhanced_layouts.txt" target="_blank" rel="noopener">ARB_enhanced_layouts</a></td>
</tr>
<tr>
<td>Bind an <a href="https://www.khronos.org/opengl/wiki/Multibind" target="_blank" rel="noopener">array of objects of the same type to a sequential range of indexed binding targets</a> in one call.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/multi_bind.txt" target="_blank" rel="noopener">ARB_multi_bind</a></td>
</tr>
<tr>
<td>Values from Query Objects values can be written to a <a href="https://www.khronos.org/opengl/wiki/Query_Buffer_Object" target="_blank" rel="noopener">buffer object instead of directly to client memory.</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/query_buffer_object.txt" target="_blank" rel="noopener">ARB_query_buffer_object</a></td>
</tr>
<tr>
<td>A <a href="https://www.khronos.org/opengl/wiki/Edge_Sampling" target="_blank" rel="noopener">special clamping mode</a> that doubles the size of the texture in each dimension, mirroring it exactly once in the negative texture coordinate directions.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_mirror_clamp_to_edge.txt" target="_blank" rel="noopener">ARB_texture_mirror_clamp_to_edge</a></td>
</tr>
<tr>
<td>One of the <a href="https://www.khronos.org/opengl/wiki/Stencil_Image_Format" target="_blank" rel="noopener">stencil-only image formats</a> can be used for textures, and 8-bit stencil is a <a href="https://www.khronos.org/opengl/wiki/Required_Image_Format" target="_blank" rel="noopener">required format</a>.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_stencil8.txt" target="_blank" rel="noopener">ARB_texture_stencil8</a></td>
</tr>
<tr>
<td>Provides a packed, 3-component 11F/11F/10F format for <a href="https://www.khronos.org/opengl/wiki/Vertex_Format_Type" target="_blank" rel="noopener">vertex attributes</a>.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/vertex_type_10f_11f_11f_rev.txt" target="_blank" rel="noopener">ARB_vertex_type_10f_11f_11f_rev</a></td>
</tr>
</tbody>
</table>
<p>While a number of features made it into core OpenGL, a number of  other features were left to specific extensions. These offer certainly  functionality that lesser 4.x hardware would be unable to handle.</p>
<p>Links:</p>
<ul>
<li><a href="http://www.opengl.org/registry/doc/glspec44.core.pdf" target="_blank" rel="noopener">OpenGL 4.4 Core Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/glspec44.compatibility.pdf" target="_blank" rel="noopener">OpenGL 4.4 Compatibility Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf" target="_blank" rel="noopener">OpenGL Shading Language 4.40 Specification</a></li>
</ul>
<h2 id="OpenGL-4-3-2012"><a href="#OpenGL-4-3-2012" class="headerlink" title="OpenGL 4.3 (2012)"></a>OpenGL 4.3 (2012)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions" target="_blank" rel="noopener">Core Extension</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Debug_Output" target="_blank" rel="noopener">Debug messaging</a></td>
<td><a href="http://www.opengl.org/registry/specs/KHR/debug.txt" target="_blank" rel="noopener">KHR_debug</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Arrays_Of_Arrays" target="_blank" rel="noopener">GLSL multidimensional arrays</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/arrays_of_arrays.txt" target="_blank" rel="noopener">ARB_arrays_of_arrays</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Buffer_Clearing" target="_blank" rel="noopener">Clear Buffer Objects</a> to specific values, ala memset</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/clear_buffer_object.txt" target="_blank" rel="noopener">ARB_clear_buffer_object</a></td>
</tr>
<tr>
<td>Arbitrary <a href="https://www.khronos.org/opengl/wiki/Compute_Shader" target="_blank" rel="noopener">Compute Shaders</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/compute_shader.txt" target="_blank" rel="noopener">ARB_compute_shader</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Copy_Texture" target="_blank" rel="noopener">Arbitrary image copying</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/copy_image.txt" target="_blank" rel="noopener">ARB_copy_image</a></td>
</tr>
<tr>
<td>Compatibility with OpenGL ES 3.0</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/ES3_compatibility.txt" target="_blank" rel="noopener">ARB_ES3_compatibility</a></td>
</tr>
<tr>
<td>Specifying <a href="https://www.khronos.org/opengl/wiki/Layout_Uniform_Location" target="_blank" rel="noopener">uniform locations in a shader</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/explicit_uniform_location.txt" target="_blank" rel="noopener">ARB_explicit_uniform_location</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#System_inputs" target="_blank" rel="noopener">Layer and viewport indices</a> available from the fragment shader</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/fragment_layer_viewport.txt" target="_blank" rel="noopener">ARB_fragment_layer_viewport</a></td>
</tr>
<tr>
<td>Rendering to a <a href="https://www.khronos.org/opengl/wiki/Framebuffer_Object" target="_blank" rel="noopener">Framebuffer Object</a> that <a href="https://www.khronos.org/opengl/wiki/Empty_Framebuffer" target="_blank" rel="noopener">has no attachments</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/framebuffer_no_attachments.txt" target="_blank" rel="noopener">ARB_framebuffer_no_attachments</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Query_Image_Format" target="_blank" rel="noopener">Generalized queries for information</a> about <a href="https://www.khronos.org/opengl/wiki/Image_Format" target="_blank" rel="noopener">Image Formats</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/internalformat_query2.txt" target="_blank" rel="noopener">ARB_internalformat_query2</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Texture_Invalidation" target="_blank" rel="noopener">Texture</a>, <a href="https://www.khronos.org/opengl/wiki/Buffer_Invalidation" target="_blank" rel="noopener">buffer object</a>, and <a href="https://www.khronos.org/opengl/wiki/Framebuffer_Invalidation" target="_blank" rel="noopener">framebuffer</a> invalidation.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/invalidate_subdata.txt" target="_blank" rel="noopener">ARB_invalidate_subdata</a></td>
</tr>
<tr>
<td>Issuing <a href="https://www.khronos.org/opengl/wiki/Indirect_Drawing" target="_blank" rel="noopener">multiple indirect rendering commands</a> from a single drawing command.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/multi_draw_indirect.txt" target="_blank" rel="noopener">ARB_multi_draw_indirect</a></td>
</tr>
<tr>
<td>Improved API for <a href="https://www.khronos.org/opengl/wiki/Program_Interface_Query" target="_blank" rel="noopener">getting info about program object interfaces</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/program_interface_query.txt" target="_blank" rel="noopener">ARB_program_interface_query</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Image_Load_Store#Image_size" target="_blank" rel="noopener">Get size</a> of <a href="https://www.khronos.org/opengl/wiki/Image_Load_Store" target="_blank" rel="noopener">images</a> from GLSL</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shader_image_size.txt" target="_blank" rel="noopener">ARB_shader_image_size</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object" target="_blank" rel="noopener">Buffer object read-write access from shader</a>, via a uniform-block style mechanism</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shader_storage_buffer_object.txt" target="_blank" rel="noopener">ARB_shader_storage_buffer_object</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Stencil_Texturing" target="_blank" rel="noopener">Accessing the stencil values from a depth/stencil texture</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/stencil_texturing.txt" target="_blank" rel="noopener">ARB_stencil_texturing</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Buffer_Texture" target="_blank" rel="noopener">Buffer Textures</a> can now be <a href="https://www.khronos.org/opengl/wiki/Buffer_Texture#Buffer_texture_range" target="_blank" rel="noopener">bound to a range of a buffer object</a> rather than the whole thing</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_buffer_range.txt" target="_blank" rel="noopener">ARB_texture_buffer_range</a></td>
</tr>
<tr>
<td>GLSL can detect the available mipmap pyramid of a <a href="https://www.khronos.org/opengl/wiki/Sampler_(GLSL" target="_blank" rel="noopener">sampler</a>#Texture_mipmap_retrieval) or <a href="https://www.khronos.org/opengl/wiki/Image_Load_Store#Image_mipmap" target="_blank" rel="noopener">image</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_query_levels.txt" target="_blank" rel="noopener">ARB_texture_query_levels</a></td>
</tr>
<tr>
<td>Immutable storage for <a href="https://www.khronos.org/opengl/wiki/Immutable_Storage_Texture" target="_blank" rel="noopener">multisample textures</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_storage_multisample.txt" target="_blank" rel="noopener">ARB_texture_storage_multisample</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/View_texture" target="_blank" rel="noopener">The ability to create a new texture</a>, with a new internal format, that references an existing texture’s storage</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_view.txt" target="_blank" rel="noopener">ARB_texture_view</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Separate_Attribute_Format" target="_blank" rel="noopener">Separation of vertex format from buffer object</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/vertex_attrib_binding.txt" target="_blank" rel="noopener">ARB_vertex_attrib_binding</a></td>
</tr>
<tr>
<td>Addition</td>
<td>Promoted from</td>
</tr>
<tr>
<td>More robustness of API</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/robust_buffer_access_behavior.txt" target="_blank" rel="noopener">ARB_robust_buffer_access_behavior</a>, <a href="http://www.opengl.org/registry/specs/ARB/robustness_isolation.txt" target="_blank" rel="noopener">ARB_robustness_isolation</a>, <a href="http://www.opengl.org/registry/specs/ARB/wgl_robustness_isolation.txt" target="_blank" rel="noopener">WGL_ARB_robustness_isolation</a>, <a href="http://www.opengl.org/registry/specs/ARB/glx_robustness_isolation.txt" target="_blank" rel="noopener">GLX_ARB_robustness_isolation</a></td>
</tr>
<tr>
<td>EAC and ETC compressed image formats.</td>
</tr>
</tbody>
</table>
<p>Links:</p>
<ul>
<li><a href="http://www.opengl.org/registry/doc/glspec43.core.20130214.pdf" target="_blank" rel="noopener">OpenGL 4.3 Core Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/glspec43.compatibility.20130214.pdf" target="_blank" rel="noopener">OpenGL 4.3 Compatibility Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.30.8.pdf" target="_blank" rel="noopener">OpenGL Shading Language 4.30 Specification</a></li>
</ul>
<h2 id="OpenGL-4-2-2011"><a href="#OpenGL-4-2-2011" class="headerlink" title="OpenGL 4.2 (2011)"></a>OpenGL 4.2 (2011)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions" target="_blank" rel="noopener">Core Extension</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows atomically <a href="https://www.khronos.org/opengl/wiki/Atomic_Counter" target="_blank" rel="noopener">incrementing/decrementing and fetching of buffer object memory locations from shaders</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shader_atomic_counters.txt" target="_blank" rel="noopener">ARB_shader_atomic_counters</a></td>
</tr>
<tr>
<td>Allows shaders to <a href="https://www.khronos.org/opengl/wiki/Image_Load_Store" target="_blank" rel="noopener">read and write images</a>, with <a href="https://www.khronos.org/opengl/wiki/Incoherent_Memory_Access" target="_blank" rel="noopener">few but difficult restrictions</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shader_image_load_store.txt" target="_blank" rel="noopener">ARB_shader_image_load_store</a></td>
</tr>
<tr>
<td>Allows texture objects to have <a href="https://www.khronos.org/opengl/wiki/Immutable_Storage_Texture" target="_blank" rel="noopener">immutable storage, and allocating all mipmap levels and images in one call</a>. The storage becomes immutable, but the contents of the storage are not</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_storage.txt" target="_blank" rel="noopener">ARB_texture_storage</a></td>
</tr>
<tr>
<td>Allows <a href="https://www.khronos.org/opengl/wiki/Draw_Transform_Feedback" target="_blank" rel="noopener">instanced rendering of data written by transform feedback operations</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/transform_feedback_instanced.txt" target="_blank" rel="noopener">ARB_transform_feedback_instanced</a></td>
</tr>
<tr>
<td>Allows the setting of <a href="https://www.khronos.org/opengl/wiki/In-Shader_Uniform_Binding" target="_blank" rel="noopener">Uniform Buffer Object</a> and <a href="https://www.khronos.org/opengl/wiki/In-Shader_Texture_Unit" target="_blank" rel="noopener">sampler</a> binding points directly from GLSL, among <a href="https://www.khronos.org/opengl/wiki/Qualifier_Order" target="_blank" rel="noopener">many other</a> small changes</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shading_language_420pack.txt" target="_blank" rel="noopener">ARB_shading_language_420pack</a></td>
</tr>
<tr>
<td>Allows instanced rendering with a <a href="https://www.khronos.org/opengl/wiki/Instancing" target="_blank" rel="noopener">starting instance value</a>.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/base_instance.txt" target="_blank" rel="noopener">ARB_base_instance</a></td>
</tr>
<tr>
<td>Allows the user to <a href="https://www.khronos.org/opengl/wiki/Query_Image_Format" target="_blank" rel="noopener">detect the maximum number of samples possible</a> for a particular <a href="https://www.khronos.org/opengl/wiki/Image_Format" target="_blank" rel="noopener">image format</a> and <a href="https://www.khronos.org/opengl/wiki/Texture#Theory" target="_blank" rel="noopener">texture type</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/internalformat_query.txt" target="_blank" rel="noopener">ARB_internalformat_query</a></td>
</tr>
<tr>
<td>Allows for sub-rectangle selection when transferring compressed texture data.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/compressed_texture_pixel_storage.txt" target="_blank" rel="noopener">ARB_compressed_texture_pixel_storage</a></td>
</tr>
<tr>
<td>Allows unpacking 16-bit floats from a 32-bit unsigned integer value in shaders.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shading_language_packing.txt" target="_blank" rel="noopener">ARB_shading_language_packing</a></td>
</tr>
<tr>
<td>Allows querying of the <a href="https://www.khronos.org/opengl/wiki/Buffer_Object#Alignment" target="_blank" rel="noopener">alignment for pointers</a> returned from <a href="https://www.khronos.org/opengl/wiki/Map_Buffer_Range" target="_blank" rel="noopener">buffer object mapping operations</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/map_buffer_alignment.txt" target="_blank" rel="noopener">ARB_map_buffer_alignment</a></td>
</tr>
<tr>
<td>Allows explicitly defining how a <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader_Output" target="_blank" rel="noopener">fragment shader will modify the depth value</a>, so that the system can optimize these cases better</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/conservative_depth.txt" target="_blank" rel="noopener">ARB_conservative_depth</a></td>
</tr>
<tr>
<td>Addition</td>
<td>Promoted from</td>
</tr>
<tr>
<td>Allows the use of <a href="https://www.khronos.org/opengl/wiki/BPTC_Texture_Compression" target="_blank" rel="noopener">BPTC compressed image formats</a>.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_compression_bptc.txt" target="_blank" rel="noopener">ARB_texture_compression_BPTC</a></td>
</tr>
</tbody>
</table>
<p>Links:</p>
<ul>
<li><a href="http://www.opengl.org/registry/doc/glspec42.core.20110808.pdf" target="_blank" rel="noopener">OpenGL 4.2 Core Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/glspec42.compatibility.20110808.pdf" target="_blank" rel="noopener">OpenGL 4.2 Compatibility Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.6.clean.pdf" target="_blank" rel="noopener">OpenGL Shading Language 4.20.6 Specification</a></li>
</ul>
<h2 id="OpenGL-4-1-2010"><a href="#OpenGL-4-1-2010" class="headerlink" title="OpenGL 4.1 (2010)"></a>OpenGL 4.1 (2010)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions" target="_blank" rel="noopener">Core Extension</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Program_Binary" target="_blank" rel="noopener">Query and load a binary blob for program objects</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/get_program_binary.txt" target="_blank" rel="noopener">ARB_get_program_binary</a></td>
</tr>
<tr>
<td>Ability to <a href="https://www.khronos.org/opengl/wiki/GLSL_Object#Program_separation" target="_blank" rel="noopener">bind programs individually to programmable stages</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/separate_shader_objects.txt" target="_blank" rel="noopener">ARB_separate_shader_objects</a></td>
</tr>
<tr>
<td>Pulling missing functionality from <a href="https://www.khronos.org/opengl/wiki/OpenGL_ES" target="_blank" rel="noopener">OpenGL ES</a> 2.0 into OpenGL</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/ES2_compatibility.txt" target="_blank" rel="noopener">ARB_ES2_compatibility</a></td>
</tr>
<tr>
<td>Documents precision requirements for several FP operations</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/shader_precision.txt" target="_blank" rel="noopener">ARB_shader_precision</a></td>
</tr>
<tr>
<td>Provides <a href="https://www.khronos.org/opengl/wiki/Vertex_Format" target="_blank" rel="noopener">64-bit floating-point component vertex attributes</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/vertex_attrib_64bit.txt" target="_blank" rel="noopener">ARB_vertex_attrib_64_bit</a></td>
</tr>
<tr>
<td>Multiple <a href="https://www.khronos.org/opengl/wiki/Viewport" target="_blank" rel="noopener">Viewports</a> for the same rendering surface, or one per surface</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/viewport_array.txt" target="_blank" rel="noopener">ARB_viewport_array</a></td>
</tr>
</tbody>
</table>
<p>Links:</p>
<ul>
<li><a href="http://www.opengl.org/registry/doc/glspec41.core.20100725.pdf" target="_blank" rel="noopener">OpenGL 4.1 Core Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/glspec41.compatibility.20100725.pdf" target="_blank" rel="noopener">OpenGL 4.1 Compatibility Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.10.6.clean.pdf" target="_blank" rel="noopener">OpenGL Shading Language 4.10.6 Specification</a></li>
</ul>
<h2 id="OpenGL-4-0-2010"><a href="#OpenGL-4-0-2010" class="headerlink" title="OpenGL 4.0 (2010)"></a>OpenGL 4.0 (2010)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><a href="https://www.khronos.org/opengl/wiki/Extension#Core_Extensions" target="_blank" rel="noopener">Core Extension</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Shading language 4.00</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_query_lod.txt" target="_blank" rel="noopener">ARB_texture_query_lod</a>, <a href="http://www.opengl.org/registry/specs/ARB/gpu_shader5.txt" target="_blank" rel="noopener">ARB_gpu_shader5</a>, <a href="http://www.opengl.org/registry/specs/ARB/gpu_shader_fp64.txt" target="_blank" rel="noopener">ARB_gpu_shader_fp64</a>, <a href="http://www.opengl.org/registry/specs/ARB/shader_subroutine.txt" target="_blank" rel="noopener">ARB_shader_subroutine</a>, <a href="http://www.opengl.org/registry/specs/ARB/texture_gather.txt" target="_blank" rel="noopener">ARB_texture_gather</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Indirect_Drawing" target="_blank" rel="noopener">Indirect Drawing</a>, without multidraw</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/draw_indirect.txt" target="_blank" rel="noopener">ARB_draw_indirect</a></td>
</tr>
<tr>
<td>Request minimum number of fragment inputs</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/sample_shading.txt" target="_blank" rel="noopener">ARB_sample_shading</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Tessellation" target="_blank" rel="noopener">Tessellation</a>, with shader stages</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/tessellation_shader.txt" target="_blank" rel="noopener">ARB_tessellation_shader</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Buffer_Texture" target="_blank" rel="noopener">Buffer Texture</a> formats RGB32F, RGB32I, RGB32UI</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_buffer_object_rgb32.txt" target="_blank" rel="noopener">ARB_texture_buffer_object_rgb32</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Cubemap_Array_Texture" target="_blank" rel="noopener">Cubemap Array Texture</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/texture_cube_map_array.txt" target="_blank" rel="noopener">ARB_texture_cube_map_array</a></td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Transform_Feedback" target="_blank" rel="noopener">Transform Feedback</a> objects and multiple feedback stream output.</td>
<td><a href="http://www.opengl.org/registry/specs/ARB/transform_feedback2.txt" target="_blank" rel="noopener">ARB_transform_feedback2</a>, <a href="http://www.opengl.org/registry/specs/ARB/transform_feedback3.txt" target="_blank" rel="noopener">ARB_transform_feedback3</a></td>
</tr>
<tr>
<td>Addition</td>
<td>Promoted from</td>
</tr>
<tr>
<td><a href="https://www.khronos.org/opengl/wiki/Draw_Buffer_Blend" target="_blank" rel="noopener">Individual blend equations for each color output</a></td>
<td><a href="http://www.opengl.org/registry/specs/ARB/draw_buffers_blend.txt" target="_blank" rel="noopener">ARB_draw_buffers_blend</a></td>
</tr>
</tbody>
</table>
<p>Links:</p>
<ul>
<li><a href="http://www.opengl.org/registry/doc/glspec40.core.20100311.pdf" target="_blank" rel="noopener">OpenGL 4.0 Core Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/glspec40.compatibility.20100311.pdf" target="_blank" rel="noopener">OpenGL 4.0 Compatibility Profile Specification</a></li>
<li><a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.00.9.clean.pdf" target="_blank" rel="noopener">OpenGL Shading Language 4.00.9 Specification</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.khronos.org/opengl/wiki/History_of_OpenGL" target="_blank" rel="noopener">History of OpenGL</a></li>
<li><a href="https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.compatibility.withchanges.pdf" target="_blank" rel="noopener">OpenGL4.6规范</a></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>RDMA网络简介</title>
    <url>/post/f4fa9e36.html</url>
    <content><![CDATA[<p><code>RDMA</code>(Remote Direct Memory Access)全称<code>远程直接数据存取</code>，就是为了解决网络传输中服务器端数据处理的延迟而产生的。RDMA通过网络把资料直接传入计算机的存储区，将数据从一个系统快速移动到远程系统存储器中，而不对操作系统造成任何影响，这样就不需要用到多少计算机的处理功能。它消除了外部存储器复制和上下文切换的开销，因而能解放内存带宽和CPU周期用于改进应用系统性能。</p>
<a id="more"></a>
<h2 id="驱动下载"><a href="#驱动下载" class="headerlink" title="驱动下载"></a>驱动下载</h2><blockquote>
<p><a href="https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed" target="_blank" rel="noopener">https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed</a></p>
</blockquote>
<p>判断驱动是否安装成功：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ibdev2netdev</span></span><br><span class="line">mlx5_0 port 1 ==&gt; ens2f0 (Up)   #表示该网口插了网线</span><br><span class="line">mlx5_1 port 1 ==&gt; ens2f1 (Down) #表示该网口没有插网线</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>ibdev2netdev</code>命令输出以上类似信息表明网卡驱动安装成功</p>
</blockquote>
<h2 id="吞吐量测试"><a href="#吞吐量测试" class="headerlink" title="吞吐量测试"></a>吞吐量测试</h2><h3 id="写吞吐量"><a href="#写吞吐量" class="headerlink" title="写吞吐量"></a>写吞吐量</h3><p>在RDMA驱动安装时会安装一些RDMA工具，可以使用<code>ib_send_bw</code>测试写吞吐量</p>
<p>服务器A（server）：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ib_write_bw -a -d mlx5_0</span><br></pre></td></tr></table></figure></p>
<p>服务器B（client）：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ib_write_bw -a -d mlx5_0 192.168.2.1(server端ip)</span><br></pre></td></tr></table></figure></p>
<h3 id="读吞吐量"><a href="#读吞吐量" class="headerlink" title="读吞吐量"></a>读吞吐量</h3><p>读吞吐量的测试与写吞吐量测试相同，只是使用命令换为<code>ib_read_bw</code></p>
<h2 id="延时测试"><a href="#延时测试" class="headerlink" title="延时测试"></a>延时测试</h2><p>测试同样分为读写，测试工具为<code>ib_read_lat</code>、<code>ib_write_lat</code></p>
<ul>
<li><a href="https://community.mellanox.com/s/article/performance-tuning-for-mellanox-adapters" target="_blank" rel="noopener">Performance Tuning for Mellanox Adapters</a></li>
</ul>
<h2 id="带宽统计"><a href="#带宽统计" class="headerlink" title="带宽统计"></a>带宽统计</h2><p>在使用RDMA时，发送和接收的数据带宽可以在app中自己进行收集，这样我们的程序发送和接收的数据量会很清楚。<br>如果想知道当前RDMA网卡所发送和接收的带宽可以通过sysfs下的相关节点获取。</p>
<ul>
<li>发送数据量（byte）：<code>/sys/class/infiniband/mlx5_0/ports/1/counters/port_xmit_data</code></li>
<li>接收数据量（byte）：<code>/sys/class/infiniband/mlx5_0/ports/1/counters/port_rcv_data</code></li>
</ul>
<p><strong>注</strong>：<code>port_xmit_data</code>和<code>port_rcv_data</code>的数值是实际的1/4,因此实际的带宽是在其基础之上乘以<code>4</code>，应该是为了防止数据溢出</p>
<blockquote>
<p>port_xmit_data: (RO) Total number of data octets, divided by 4 (lanes), transmitted on all VLs. This is 64 bit counter<br>port_rcv_data: (RO) Total number of data octets, divided by 4 (lanes), received on all VLs. This is 64 bit counter.</p>
<blockquote>
<p>来自： <code>Documentation/ABI/stable/sysfs-class-infiniband</code></p>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pma_cnt_ext-&gt;port_xmit_data =</span><br><span class="line">    cpu_to_be64(MLX5_SUM_CNT(out, transmitted_ib_unicast.octets,</span><br><span class="line">                 transmitted_ib_multicast.octets) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">pma_cnt_ext-&gt;port_rcv_data =</span><br><span class="line">    cpu_to_be64(MLX5_SUM_CNT(out, received_ib_unicast.octets,</span><br><span class="line">                 received_ib_multicast.octets) &gt;&gt; <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: drivers/infiniband/hw/mlx5/mad.c</p>
</blockquote>
<h2 id="网络联通性测试"><a href="#网络联通性测试" class="headerlink" title="网络联通性测试"></a>网络联通性测试</h2><p>由于当前网卡只支持<code>Ethernet</code>模式，因此只能使用<code>ibv_rc_pingpong</code>进行ping测试。</p>
<ul>
<li><a href="https://community.mellanox.com/s/article/RoCE-Debug-Flow-for-Linux" target="_blank" rel="noopener">https://community.mellanox.com/s/article/RoCE-Debug-Flow-for-Linux</a></li>
</ul>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ibdev2netdev</span></span><br><span class="line">mlx4_0 port 1 ==&gt; enp1s0 (Down)</span><br><span class="line">mlx5_0 port 1 ==&gt; ens2f0 (Up)</span><br><span class="line">mlx5_1 port 1 ==&gt; ens2f1 (Up)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ibv_rc_pingpong -d mlx5_0 -g 0</span></span><br><span class="line">  local address:  LID 0x0000, QPN 0x00011a, PSN 0xd775ee, GID fe80::e42:a1ff:fe41:2d36</span><br><span class="line">  remote address: LID 0x0000, QPN 0x0009df, PSN 0xa7f02f, GID fe80::1e34:daff:fe79:c0d</span><br><span class="line">8192000 bytes in 0.01 seconds = 5126.01 Mbit/sec</span><br><span class="line">1000 iters in 0.01 seconds = 12.78 usec/iter</span><br></pre></td></tr></table></figure>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ibdev2netdev</span></span><br><span class="line">mlx5_0 port 1 ==&gt; p5p1 (Down)</span><br><span class="line">mlx5_1 port 1 ==&gt; p5p2 (Up)</span><br><span class="line">mlx5_2 port 1 ==&gt; p4p1 (Down)</span><br><span class="line">mlx5_3 port 1 ==&gt; p4p2 (Down)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ibv_rc_pingpong -d mlx5_1 -g 0 192.168.2.4</span></span><br><span class="line">  local address:  LID 0x0000, QPN 0x0009df, PSN 0xa7f02f, GID fe80::1e34:daff:fe79:c0d</span><br><span class="line">  remote address: LID 0x0000, QPN 0x00011a, PSN 0xd775ee, GID fe80::e42:a1ff:fe41:2d36</span><br><span class="line">8192000 bytes in 0.01 seconds = 5376.21 Mbit/sec</span><br><span class="line">1000 iters in 0.01 seconds = 12.19 usec/iter</span><br></pre></td></tr></table></figure>
<h2 id="mlx5计数器和状态参数"><a href="#mlx5计数器和状态参数" class="headerlink" title="mlx5计数器和状态参数"></a>mlx5计数器和状态参数</h2><p>在sysfs文件系统可以查看<code>/sys/class/infiniband/</code></p>
<blockquote>
<ul>
<li><a href="https://community.mellanox.com/s/article/understanding-mlx5-linux-counters-and-status-parameters" target="_blank" rel="noopener">Understanding mlx5 Linux Counters and Status Parameters</a></li>
<li><a href="https://mymellanox.force.com/mellanoxcommunity/s/article/infiniband-port-counters" target="_blank" rel="noopener">InfiniBand Port Counters</a></li>
</ul>
</blockquote>
<p>Linux内核说明文档：<a href="https://www.kernel.org/doc/html/latest/admin-guide/abi-stable.html#abi-file-stable-sysfs-class-infiniband" target="_blank" rel="noopener">https://www.kernel.org/doc/html/latest/admin-guide/abi-stable.html#abi-file-stable-sysfs-class-infiniband</a></p>
<h3 id="counters"><a href="#counters" class="headerlink" title="counters"></a>counters</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -lsh /sys/class/infiniband/mlx5_0/ports/1/counters/</span></span><br><span class="line">total 0</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 excessive_buffer_overrun_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 link_downed</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 link_error_recovery</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 local_link_integrity_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 multicast_rcv_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 multicast_xmit_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_constraint_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_data</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_remote_physical_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_switch_relay_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_constraint_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_data</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_discards</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_wait</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 symbol_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 unicast_rcv_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 unicast_xmit_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 VL15_dropped</span><br></pre></td></tr></table></figure>
<p>Counter Description:</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Counter</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
<th style="text-align:left"><strong>InfiniBand Spec Name</strong></th>
<th style="text-align:left"><strong>Group</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">port_rcv_data</td>
<td style="text-align:left">The total number of data octets, divided by 4, (counting in double words, 32 bits), received on all VLs from the port.</td>
<td style="text-align:left">PortRcvData</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_rcv_packets</td>
<td style="text-align:left">Total number of packets (this may include packets containing Errors. This is 64 bit counter.</td>
<td style="text-align:left">PortRcvPkts</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_multicast_rcv_packets</td>
<td style="text-align:left">Total number of multicast packets, including multicast packets containing errors.</td>
<td style="text-align:left">PortMultiCastRcvPkts</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_unicast_rcv_packets</td>
<td style="text-align:left">Total number of unicast packets, including unicast packets containing errors.</td>
<td style="text-align:left">PortUnicastRcvPkts</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_xmit_data</td>
<td style="text-align:left">The total number of data octets, divided by 4, (counting in double words, 32 bits), transmitted on all VLs from the port.</td>
<td style="text-align:left">PortXmitData</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_xmit_packetsport_xmit_packets_64</td>
<td style="text-align:left">Total number of packets transmitted on all VLs from this port. This may include packets with errors.This is 64 bit counter.</td>
<td style="text-align:left">PortXmitPkts</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_rcv_switch_relay_errors</td>
<td style="text-align:left">Total number of packets received on the port that were discarded because they could not be forwarded by the switch relay.</td>
<td style="text-align:left">PortRcvSwitchRelayErrors</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">port_rcv_errors</td>
<td style="text-align:left">Total number of packets containing an error that were received on the port.</td>
<td style="text-align:left">PortRcvErrors</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_rcv_constraint_errors</td>
<td style="text-align:left">Total number of packets received on the switch physical port that are discarded.</td>
<td style="text-align:left">PortRcvConstraintErrors</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">local_link_integrity_errors</td>
<td style="text-align:left">The number of times that the count of local physical errors exceeded the threshold specified by LocalPhyErrors.</td>
<td style="text-align:left">LocalLinkIntegrityErrors</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">port_xmit_wait</td>
<td style="text-align:left">The number of ticks during which the port had data to transmit but no data was sent during the entire tick (either because of insufficient credits or because of lack of arbitration).</td>
<td style="text-align:left">PortXmitWait</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_multicast_xmit_packets</td>
<td style="text-align:left">Total number of multicast packets transmitted on all VLs from the port. This may include multicast packets with errors.</td>
<td style="text-align:left">PortMultiCastXmitPkts</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_unicast_xmit_packets</td>
<td style="text-align:left">Total number of unicast packets transmitted on all VLs from the port. This may include unicast packets with errors.</td>
<td style="text-align:left">PortUnicastXmitPkts</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">port_xmit_discards</td>
<td style="text-align:left">Total number of outbound packets discarded by the port because the port is down or congested.</td>
<td style="text-align:left">PortXmitDiscards</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">port_xmit_constraint_errors</td>
<td style="text-align:left">Total number of packets not transmitted from the switch physical port.</td>
<td style="text-align:left">PortXmitConstraintErrors</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">port_rcv_remote_physical_errors</td>
<td style="text-align:left">Total number of packets marked with the EBP delimiter received on the port.</td>
<td style="text-align:left">PortRcvRemotePhysicalErrors</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">symbol_error</td>
<td style="text-align:left">Total number of minor link errors detected on one or more physical lanes.</td>
<td style="text-align:left">SymbolErrorCounter</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">VL15_dropped</td>
<td style="text-align:left">Number of incoming VL15 packets dropped due to resource limitations (e.g., lack of buffers) of the port.</td>
<td style="text-align:left">VL15Dropped</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">link_error_recovery</td>
<td style="text-align:left">Total number of times the Port Training state machine has successfully completed the link error recovery process.</td>
<td style="text-align:left">LinkErrorRecoveryCounter</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">link_downed</td>
<td style="text-align:left">Total number of times the Port Training state machine has failed the link error recovery process and downed the link.</td>
<td style="text-align:left">LinkDownedCounter</td>
<td style="text-align:left">Error</td>
</tr>
</tbody>
</table>
<h3 id="hw-counters"><a href="#hw-counters" class="headerlink" title="hw_counters"></a>hw_counters</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -lsh /sys/class/infiniband/mlx5_0/ports/1/hw_counters/</span></span><br><span class="line">total 0</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 duplicate_request</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 implied_nak_seq_err</span><br><span class="line">0 -rw-r--r-- 1 root root 4.0K 5月  28 16:42 lifespan</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 local_ack_timeout_err</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 np_cnp_sent</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 np_ecn_marked_roce_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 out_of_buffer</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 out_of_sequence</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 packet_seq_err</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 req_cqe_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 req_cqe_flush_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 req_remote_access_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 req_remote_invalid_request</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 resp_cqe_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 resp_cqe_flush_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 resp_local_length_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 resp_remote_access_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rnr_nak_retry_err</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rp_cnp_handled</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rp_cnp_ignored</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rx_atomic_requests</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rx_icrc_encapsulated</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rx_read_requests</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rx_write_requests</span><br></pre></td></tr></table></figure>
<p>HW Counters Description:</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Counter</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
<th style="text-align:left"><strong>Group</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">duplicate_request</td>
<td style="text-align:left">Number of received packets. A duplicate request is a request that had been previously executed.</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">implied_nak_seq_err</td>
<td style="text-align:left">Number of time the requested decided an ACK. with a PSN larger than the expected PSN for an RDMA read or response.</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">lifespan</td>
<td style="text-align:left">The maximum period in ms which defines the aging of the counter reads. Two consecutive reads within this period might return the same values</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">local_ack_timeout_err</td>
<td style="text-align:left">The number of times QP’s ack timer expired for RC, XRC, DCT QPs at the sender side.The QP retry limit was not exceed, therefore it is still recoverable error.</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">np_cnp_sent</td>
<td style="text-align:left">The number of CNP packets sent by the Notification Point when it noticed congestion experienced in the RoCEv2 IP header (ECN bits).The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">np_ecn_marked_roce_packets</td>
<td style="text-align:left">The number of RoCEv2 packets received by the notification point which were marked for experiencing the congestion (ECN bits where ‘11’ on the ingress RoCE traffic) .The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">out_of_buffer</td>
<td style="text-align:left">The number of drops occurred due to lack of WQE for the associated QPs.</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">out_of_sequence</td>
<td style="text-align:left">The number of out of sequence packets received.</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">packet_seq_err</td>
<td style="text-align:left">The number of received NAK sequence error packets. The QP retry limit was not exceeded.</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">req_cqe_error</td>
<td style="text-align:left">The number of times requester detected CQEs completed with errors.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">req_cqe_flush_error</td>
<td style="text-align:left">The number of times requester detected CQEs completed with flushed errors.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">req_remote_access_errors</td>
<td style="text-align:left">The number of times requester detected remote access errors.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">req_remote_invalid_request</td>
<td style="text-align:left">The number of times requester detected remote invalid request errors.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">resp_cqe_error</td>
<td style="text-align:left">The number of times responder detected CQEs completed with errors.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">resp_cqe_flush_error</td>
<td style="text-align:left">The number of times responder detected CQEs completed with flushed errors.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">resp_local_length_error</td>
<td style="text-align:left">The number of times responder detected local length errors.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">resp_remote_access_errors</td>
<td style="text-align:left">The number of times responder detected remote access errors.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">rnr_nak_retry_err</td>
<td style="text-align:left">The number of received RNR NAK packets. The QP retry limit was not exceeded.</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">rp_cnp_handled</td>
<td style="text-align:left">The number of CNP packets handled by the Reaction Point HCA to throttle the transmission rate.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">rp_cnp_ignored</td>
<td style="text-align:left">The number of CNP packets received and ignored by the Reaction Point HCA. This counter should not raise if RoCE Congestion Control was enabled in the network. If this counter raise, verify that ECN was enabled on the adapter. See <a href="https://community.mellanox.com/s/article/howto-configure-dcqcn--roce-cc--values-for-connectx-4--linux-x" target="_blank" rel="noopener">HowTo Configure DCQCN (RoCE CC) values for ConnectX-4 (Linux)</a>.The counters was added in MLNX_OFED 4.1</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">rx_atomic_requests</td>
<td style="text-align:left">The number of received ATOMIC request for the associated QPs.</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">rx_dct_connect</td>
<td style="text-align:left">The number of received connection request for the associated DCTs.</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">rx_read_requests</td>
<td style="text-align:left">The number of received READ requests for the associated QPs.</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">rx_write_requests</td>
<td style="text-align:left">The number of received WRITE requests for the associated QPs.</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">rx_icrc_encapsulated</td>
<td style="text-align:left">The number of RoCE packets with ICRC errors.This counter was added in MLNX_OFED 4.4 and kernel 4.19</td>
<td style="text-align:left">Error</td>
</tr>
<tr>
<td style="text-align:left">roce_adp_retrans</td>
<td style="text-align:left">Counts the number of adaptive retransmissions for RoCE trafficThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">roce_adp_retrans_to</td>
<td style="text-align:left">Counts the number of times RoCE traffic reached timeout due to adaptive retransmissionThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">roce_slow_restart</td>
<td style="text-align:left">Counts the number of times RoCE slow restart was usedThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">roce_slow_restart_cnps</td>
<td style="text-align:left">Counts the number of times RoCE slow restart generated CNP packetsThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td style="text-align:left">Informative</td>
</tr>
<tr>
<td style="text-align:left">roce_slow_restart_trans</td>
<td style="text-align:left">Counts the number of times RoCE slow restart changed state to slow restartThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td style="text-align:left">Informative</td>
</tr>
</tbody>
</table>
<ul>
<li><code>duplicate_request</code>:（Duplicated packets）接收报文数，重复请求是先前已执行的请求。</li>
<li><code>out_of_sequence</code>:（Drop out of sequence）接收到的乱序包的数量，说明此时已经产生了丢包</li>
<li><code>packet_seq_err</code>：（NAK sequence rcvd）接收到的NAK序列错误数据包的数量，未超过QP重试限制。</li>
</ul>
<h2 id="带宽监测工具——netdata"><a href="#带宽监测工具——netdata" class="headerlink" title="带宽监测工具——netdata"></a>带宽监测工具——netdata</h2><p><code>netdata</code>可以查看RDMA网卡的带宽，但是展示的发送和接收的数据是通过<code>/sys/class/infiniband</code>下的节点获取的，因此实际带宽数据是其展示数据的<code>4倍</code></p>
<p><img src="/images/2021/05/netdata_rdma_ib.png" alt="netdata_rdma_ib"></p>
<blockquote>
<p>插件源码：<a href="https://github.com/netdata/netdata/blob/master/collectors/proc.plugin/sys_class_infiniband.c" target="_blank" rel="noopener">https://github.com/netdata/netdata/blob/master/collectors/proc.plugin/sys_class_infiniband.c</a></p>
</blockquote>
<h2 id="网卡工作模式"><a href="#网卡工作模式" class="headerlink" title="网卡工作模式"></a>网卡工作模式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ibstatus</span></span><br><span class="line">Infiniband device 'mlx5_0' port 1 status:</span><br><span class="line">	default gid:	 fe80:0000:0000:0000:0e42:a1ff:fe41:2d36</span><br><span class="line">	base lid:	 0x0</span><br><span class="line">	sm lid:		 0x0</span><br><span class="line">	state:		 4: ACTIVE</span><br><span class="line">	phys state:	 5: LinkUp</span><br><span class="line">	rate:		 25 Gb/sec (1X EDR)</span><br><span class="line">	link_layer:	 Ethernet</span><br><span class="line"></span><br><span class="line">Infiniband device 'mlx5_1' port 1 status:</span><br><span class="line">	default gid:	 fe80:0000:0000:0000:0e42:a1ff:fe41:2d37</span><br><span class="line">	base lid:	 0x0</span><br><span class="line">	sm lid:		 0x0</span><br><span class="line">	state:		 4: ACTIVE</span><br><span class="line">	phys state:	 5: LinkUp</span><br><span class="line">	rate:		 25 Gb/sec (1X EDR)</span><br><span class="line">	link_layer:	 Ethernet</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link_layer</code>： 工作模式，Ethernet为IP模式，还有IB（infiniband）模式。</li>
<li>工作模式切换：<a href="https://community.mellanox.com/s/article/howto-change-port-type-in-mellanox-connectx-3-adapter" target="_blank" rel="noopener">HowTo Change Port Type in Mellanox ConnectX-3 Adapter</a></li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><code>ibstat</code>: 查询InfiniBand设备的基本状态</li>
<li><code>ibstatus</code>： 网卡信息</li>
<li><code>ibv_devinfo</code>：网卡设备信息（ibv_devinfo -d mlx5_0 -v）</li>
<li><code>ibv_devices</code>：查看本主机的infiniband设备</li>
<li><code>ibnodes</code>：查看网络中的infiniband设备</li>
<li><code>show_gids</code>：看看网卡支持的roce版本</li>
<li><code>show_counters</code>:网卡端口统计数据，比如发送接受数据大小</li>
<li><code>mlxconfig</code>: 网卡配置（mlxconfig -d mlx5_1 q查询网卡配置信息）</li>
</ul>
<h2 id="双网口作用"><a href="#双网口作用" class="headerlink" title="双网口作用"></a>双网口作用</h2><p><code>双网口</code>：指一个物理网卡上的两个网络接口</p>
<ol>
<li>可以捆绑，比单口效率高多了。同时上两个不同的网络网，有一个不同时，另一个也在同时工作实现网络备份。</li>
<li>服务器必备2个或2个以上的网口，一个用于网路接入，另一个作为输入。</li>
<li>家用PC机用2个的网口的网卡，可以实现服务器的初级功能，接入网络然后输入，并管理输入端的网路和数据。</li>
<li>双口的可以做负载均衡，单口的无此功能。</li>
<li>双口的可以连接两个网络，可以做网关，单口的直接无法做到此点。当然，如果用两个单口网卡，也可以实现某些双口网卡的同样效果，但在转换速度上还是和双口网卡略有差异。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/xztjhs/article/details/51487467" target="_blank" rel="noopener">infiniband带宽测试方法1 ib_read/write_bw/lat</a></li>
<li><a href="https://blog.csdn.net/ljlfather/article/details/102925954" target="_blank" rel="noopener">ib_write_bw 和 ib_read_bw 测试 RDMA 的读写处理确定带宽</a></li>
<li><a href="https://blog.csdn.net/QiangLi_strong/article/details/81021193" target="_blank" rel="noopener">ibverbs文档翻译</a></li>
<li><a href="https://insujang.github.io/2020-02-09/introduction-to-programming-infiniband/" target="_blank" rel="noopener">Introduction to Programming Infiniband RDMA</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/draft-talpey-nfsv4-rdma-sess-00" target="_blank" rel="noopener">NFSv4 RDMA and Session Extensions</a></li>
<li><a href="https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf" target="_blank" rel="noopener">RDMA_Aware_Programming_user_manual.pdf</a></li>
<li><a href="https://www.cnblogs.com/sctb/p/13179542.html" target="_blank" rel="noopener">infiniband网卡安装、使用总结</a></li>
<li><a href="https://docs.mellanox.com/display/VMAv883/Port+Type+Management" target="_blank" rel="noopener">Port Type Management</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>rdma</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC编译器内部预宏定义</title>
    <url>/post/37120.html</url>
    <content><![CDATA[<p>查看GCC编译器内部的预定义宏：</p>
<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E -dM - &lt;/dev/null</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gcc --version</span></span><br><span class="line">gcc (Ubuntu 7.3.0-16ubuntu3) 7.3.0</span><br><span class="line">Copyright (C) 2017 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">gcc -E -dM - &lt;/dev/null</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SSP_STRONG__ 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_MIN_EXP__ (-1021)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_MAX_EXP__ 1024</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_LEAST16_MAX__ 0xffff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ATOMIC_ACQUIRE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_MAX_10_EXP__ 4932</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_IEC_559_COMPLEX 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_LEAST8_TYPE__ unsigned char</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_FLOAT80__ 16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INTMAX_C(c) c <span class="comment">## L</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __CHAR_BIT__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT8_MAX__ 0xff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __WINT_MAX__ 0xffffffffU</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_MIN_EXP__ (-125)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ORDER_LITTLE_ENDIAN__ 1234</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZE_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __WCHAR_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_CHAR_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_IEC_559 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_DECIMAL_DIG__ 17</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_EVAL_METHOD__ 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __unix__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_DECIMAL_DIG__ 17</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __x86_64 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_FAST64_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIG_ATOMIC_TYPE__ int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_MIN_10_EXP__ (-307)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FINITE_MATH_ONLY__ 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GNUC_PATCHLEVEL__ 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_FAST8_MAX__ 0xff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __has_include(STR) __has_include__(STR)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC64_MAX_EXP__ 385</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT8_C(c) c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST8_WIDTH__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SHRT_MAX__ 0x7fff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_MAX_10_EXP__ 4932</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_LEAST8_MAX__ 0xff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_BOOL_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINTMAX_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __linux 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC32_EPSILON__ 1E-6DF</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_EVAL_METHOD_TS_18661_3__ 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __unix 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT32_MAX__ 0xffffffffU</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_MAX_EXP__ 16384</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_MIN_EXP__ (-16381)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __WINT_MIN__ 0U</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __linux__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_MIN_10_EXP__ (-4931)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST16_WIDTH__ 16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SCHAR_MAX__ 0x7f</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_MANT_DIG__ 113</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT64_C(c) c <span class="comment">## L</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_DIG__ 15</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_POINTER_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_MANT_DIG__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_INT__ 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_POINTER__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __USER_LABEL_PREFIX__</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __STDC_HOSTED__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_DIG__ 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SHRT_WIDTH__ 16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __STDC_UTF_16__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC32_MAX__ 9.999999E96DF</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT32_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_WIDTH__ 32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_LONG__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __STDC_IEC_559__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __STDC_ISO_10646__ 201706L</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT16_C(c) c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __PTRDIFF_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DECIMAL_DIG__ 21</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __gnu_linux__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INTMAX_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __has_include_next(STR) __has_include_next__(STR)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_MIN_10_EXP__ (-4931)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_MANT_DIG__ 53</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GNUC__ 7</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __pie__ 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __MMX__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_LONG_DOUBLE__ 16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __BIGGEST_ALIGNMENT__ 16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_MAX_10_EXP__ 308</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST32_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC32_MIN_EXP__ (-94)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INTPTR_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST16_TYPE__ long int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST32_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC32_MIN__ 1E-95DF</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_MAX_EXP__ 1024</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __WCHAR_WIDTH__ 32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC128_EPSILON__ 1E-33DL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SSE2_MATH__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ATOMIC_HLE_RELEASE 131072</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __PTRDIFF_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __amd64 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __STDC_NO_THREADS__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ATOMIC_HLE_ACQUIRE 65536</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LONG_LONG_MAX__ 0x7fffffffffffffffLL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_SIZE_T__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_MIN_EXP__ (-16381)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_WINT_T__ 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LONG_LONG_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_MAX_EXP__ 128</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_HAVE_DWARF2_CFI_ASM 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GXX_ABI_VERSION 1011</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_MIN_EXP__ (-125)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST64_TYPE__ long int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __PIE__ 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LP64__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DECIMAL_BID_FORMAT__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_MIN_EXP__ (-1021)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_MIN_10_EXP__ (-307)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_DECIMAL_DIG__ 21</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC128_MIN__ 1E-6143DL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __REGISTER_PREFIX__</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT16_MAX__ 0xffff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT8_TYPE__ unsigned char</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __NO_INLINE__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_MANT_DIG__ 24</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_DECIMAL_DIG__ 21</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __VERSION__ <span class="string">"7.3.0"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT64_C(c) c <span class="comment">## UL</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define _STDC_PREDEF_H 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_INT_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_MAX_EXP__ 16384</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_MANT_DIG__ 24</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __STDC_IEC_559_COMPLEX__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_DIG__ 33</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SCHAR_WIDTH__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT32_C(c) c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC64_EPSILON__ 1E-15DD</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ORDER_PDP_ENDIAN__ 3412</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC128_MIN_EXP__ (-6142)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_MAX_10_EXP__ 38</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST32_TYPE__ long int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_LEAST16_TYPE__ short unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define unix 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT16_MAX__ 0x7fff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZE_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT64_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_DIG__ 18</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT8_TYPE__ signed char</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ELF__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ASM_FLAG_OUTPUTS__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_RADIX__ 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST16_TYPE__ short int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINTMAX_C(c) c <span class="comment">## UL</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SSE_MATH__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __k8 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIG_ATOMIC_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_PTRDIFF_T__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_MANT_DIG__ 53</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __x86_64__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_MIN_EXP__ (-1021)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST16_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_DIG__ 15</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_FAST32_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_LEAST64_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_MAX_10_EXP__ 38</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LONG_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_FAST16_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC64_MAX__ 9.999999999999999E384DD</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST32_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __CHAR16_TYPE__ short unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __PRAGMA_REDEFINE_EXTNAME 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZE_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SEG_FS 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST16_MAX__ 0x7fff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC64_MANT_DIG__ 16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT64_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_LEAST32_MAX__ 0xffffffffU</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SEG_GS 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_LONG_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIG_ATOMIC_WIDTH__ 32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST64_TYPE__ long int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT16_TYPE__ short int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST8_TYPE__ signed char</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __STDC_VERSION__ 201112L</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC32_MAX_EXP__ 97</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST8_MAX__ 0x7f</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INTPTR_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define linux 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_MIN_10_EXP__ (-37)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SSE2__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_DIG__ 15</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_MANT_DIG__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __code_model_small__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __k8__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INTPTR_TYPE__ long int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT16_TYPE__ short unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __WCHAR_TYPE__ int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_FLOAT__ 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __pic__ 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINTPTR_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST64_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC64_MIN_EXP__ (-382)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_DECIMAL_DIG__ 9</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST64_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_DIG__ 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_MAX_EXP__ 16384</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_FAST64_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __amd64__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT64_TYPE__ long int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_MAX_EXP__ 128</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ORDER_BIG_ENDIAN__ 4321</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_MANT_DIG__ 53</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_FLOAT128__ 16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST64_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC64_MIN__ 1E-383DD</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __WINT_TYPE__ unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_LEAST32_TYPE__ unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_SHORT__ 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SSE__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_MIN_EXP__ (-16381)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __WINT_WIDTH__ 32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST8_MAX__ 0x7f</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_MAX_10_EXP__ 308</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_INT128__ 16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_MAX_10_EXP__ 4932</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ATOMIC_RELAXED 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define _LP64 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT8_C(c) c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_MAX_EXP__ 1024</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST32_TYPE__ int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_WCHAR_T__ 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT64_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST8_TYPE__ signed char</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GNUC_STDC_INLINE__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_DECIMAL_DIG__ 17</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __STDC_UTF_32__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST8_WIDTH__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FXSR__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC_EVAL_METHOD__ 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT32_C(c) c <span class="comment">## U</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INTMAX_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT8_MAX__ 0x7f</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LONG_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __PIC__ 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_FAST32_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __CHAR32_TYPE__ unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT32_TYPE__ int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_DOUBLE__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_MIN_10_EXP__ (-37)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST32_WIDTH__ 32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INTMAX_TYPE__ long int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC128_MAX_EXP__ 6145</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ATOMIC_CONSUME 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GNUC_MINOR__ 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_FAST16_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINTMAX_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC32_MANT_DIG__ 7</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DBL_MAX_10_EXP__ 308</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT16_C(c) c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __STDC__ 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __PTRDIFF_TYPE__ long int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ATOMIC_SEQ_CST 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT32_TYPE__ unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_MIN_10_EXP__ (-307)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINTPTR_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __DEC128_MANT_DIG__ 34</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_MIN_10_EXP__ (-4931)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __SIZEOF_LONG_LONG__ 8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT128_DECIMAL_DIG__ 36</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_LLONG_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __LDBL_DIG__ 18</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __FLT_DECIMAL_DIG__ 9</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_FAST16_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __GCC_ATOMIC_SHORT_LOCK_FREE 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __INT_LEAST64_WIDTH__ 64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __UINT_FAST8_TYPE__ unsigned char</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ATOMIC_ACQ_REL 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define __ATOMIC_RELEASE 3</span></span><br></pre></td></tr></table></figure>
<h2 id="Window系统"><a href="#Window系统" class="headerlink" title="Window系统"></a>Window系统</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">gcc -E -dM - &lt; <span class="built_in">NUL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:&gt;<span class="title">gcc</span> --<span class="title">version</span></span></span><br><span class="line"><span class="function"><span class="title">gcc.exe</span> (<span class="title">x86_64</span>-<span class="title">posix</span>-<span class="title">seh</span>-<span class="title">rev0</span>, <span class="title">Built</span> <span class="title">by</span> <span class="title">MinGW</span>-<span class="title">W64</span> <span class="title">project</span>) 8.1.0</span></span><br><span class="line"><span class="function"><span class="title">Copyright</span> (<span class="title">C</span>) 2018 <span class="title">Free</span> <span class="title">Software</span> <span class="title">Foundation</span>, <span class="title">Inc</span>.</span></span><br><span class="line"><span class="function"><span class="title">This</span> <span class="title">is</span> <span class="title">free</span> <span class="title">software</span>; <span class="title">see</span> <span class="title">the</span> <span class="title">source</span> <span class="title">for</span> <span class="title">copying</span> <span class="title">conditions</span>.  <span class="title">There</span> <span class="title">is</span> <span class="title">NO</span></span></span><br><span class="line"><span class="function"><span class="title">warranty</span>; <span class="title">not</span> <span class="title">even</span> <span class="title">for</span> <span class="title">MERCHANTABILITY</span> <span class="title">or</span> <span class="title">FITNESS</span> <span class="title">FOR</span> <span class="title">A</span> <span class="title">PARTICULAR</span> <span class="title">PURPOSE</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:&gt;<span class="title">gcc</span> -<span class="title">E</span> -<span class="title">dM</span> - &lt; <span class="title">NUL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MIN_EXP__</span> (-1021)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MAX_EXP__</span> 1024</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST16_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_ACQUIRE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MAX_10_EXP__</span> 4932</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MIN__</span> 1.17549435082228750796873653722224568<span class="title">e</span>-38<span class="title">F</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_IEC_559_COMPLEX</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST8_TYPE__</span> <span class="title">unsigned</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_FLOAT80__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_WIN32</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTMAX_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">LL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__CHAR_BIT__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT8_MAX__</span> 0<span class="title">xff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_WIN64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINT_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MIN_EXP__</span> (-125)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ORDER_LITTLE_ENDIAN__</span> 1234</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZE_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WCHAR_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_DENORM_MIN__</span> ((<span class="title">double</span>)4.94065645841246544176568792868221372<span class="title">e</span>-324<span class="title">L</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_CHAR_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_IEC_559</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_DECIMAL_DIG__</span> 17</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_EVAL_METHOD__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_DECIMAL_DIG__</span> 17</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_CHAR32_T_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__x86_64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST64_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIG_ATOMIC_TYPE__</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MIN_10_EXP__</span> (-307)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FINITE_MATH_ONLY__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GNUC_PATCHLEVEL__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST8_MAX__</span> 0<span class="title">xff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__has_include</span>(<span class="title">STR</span>) <span class="title">__has_include__</span>(<span class="title">STR</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_stdcall</span> <span class="title">__attribute__</span>((<span class="title">__stdcall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MAX_EXP__</span> 385</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT8_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST8_WIDTH__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST64_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SHRT_MAX__</span> 0<span class="title">x7fff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MAX__</span> 1.18973149535723176502126385303097021<span class="title">e</span>+4932<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MAX_10_EXP__</span> 4932</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST8_MAX__</span> 0<span class="title">xff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_BOOL_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_DENORM_MIN__</span> 6.47517511943802511092443895822764655<span class="title">e</span>-4966<span class="title">F128</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTMAX_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_EPSILON__</span> 1<span class="title">E</span>-6<span class="title">DF</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_EVAL_METHOD_TS_18661_3__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT32_MAX__</span> 0<span class="title">xffffffffU</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MAX_EXP__</span> 16384</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MIN_EXP__</span> (-16381)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINT_MIN__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MIN_10_EXP__</span> (-4931)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST16_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SCHAR_MAX__</span> 0<span class="title">x7f</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MANT_DIG__</span> 113</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WCHAR_MIN__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT64_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">LL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_DIG__</span> 15</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_POINTER_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MANT_DIG__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_INT__</span> 4</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_POINTER__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__USER_LABEL_PREFIX__</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_EPSILON__</span> 1.08420217248550443400745280086994171<span class="title">e</span>-19<span class="title">F64x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC_HOSTED__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WIN32</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WIN64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_DIG__</span> 6</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_EPSILON__</span> 1.19209289550781250000000000000000000<span class="title">e</span>-7<span class="title">F</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SHRT_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MIN__</span> 3.36210314311209350626267781732175260<span class="title">e</span>-4932<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC_UTF_16__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MAX__</span> 9.999999<span class="title">E96DF</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_DENORM_MIN__</span> 3.64519953188247460252840593361941982<span class="title">e</span>-4951<span class="title">F64x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__MINGW32__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT32_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_LONG__</span> 4</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT16_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PTRDIFF_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DECIMAL_DIG__</span> 21</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_EPSILON__</span> 2.22044604925031308084726333618164062<span class="title">e</span>-16<span class="title">F64</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTMAX_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__has_include_next</span>(<span class="title">STR</span>) <span class="title">__has_include_next__</span>(<span class="title">STR</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MIN_10_EXP__</span> (-4931)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MANT_DIG__</span> 53</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_REENTRANT</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GNUC__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_cdecl</span> <span class="title">__attribute__</span>((<span class="title">__cdecl__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__MMX__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_LONG_DOUBLE__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__BIGGEST_ALIGNMENT__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MAX_10_EXP__</span> 308</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MAX__</span> ((<span class="title">double</span>)1.79769313486231570814527423731704357<span class="title">e</span>+308<span class="title">L</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_thiscall</span> <span class="title">__attribute__</span>((<span class="title">__thiscall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST32_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINNT</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINNT__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MIN_EXP__</span> (-94)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTPTR_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST16_TYPE__</span> <span class="title">short</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_fastcall</span> <span class="title">__attribute__</span>((<span class="title">__fastcall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MAX__</span> 9.999999999999999999999999999999999<span class="title">E6144DL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST32_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MIN__</span> 1<span class="title">E</span>-95<span class="title">DF</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MAX_EXP__</span> 1024</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WCHAR_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MAX__</span> 3.40282346638528859811704183484516925<span class="title">e</span>+38<span class="title">F32</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_EPSILON__</span> 1<span class="title">E</span>-33<span class="title">DL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE2_MATH__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_HLE_RELEASE</span> 131072</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WIN32__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PTRDIFF_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__amd64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__tune_core2__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_HLE_ACQUIRE</span> 65536</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LONG_LONG_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_SIZE_T__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MIN_EXP__</span> (-16381)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_WINT_T__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LONG_LONG_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MAX_EXP__</span> 128</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GXX_ABI_VERSION</span> 1012</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MIN_EXP__</span> (-125)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_DENORM_MIN__</span> 4.94065645841246544176568792868221372<span class="title">e</span>-324<span class="title">F64</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MIN__</span> ((<span class="title">double</span>)2.22507385850720138309023271733240406<span class="title">e</span>-308<span class="title">L</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_EPSILON__</span> 2.22044604925031308084726333618164062<span class="title">e</span>-16<span class="title">F32x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DECIMAL_BID_FORMAT__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MIN_EXP__</span> (-1021)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GXX_TYPEINFO_EQUALITY_INLINE</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MIN_10_EXP__</span> (-307)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_DECIMAL_DIG__</span> 21</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MIN__</span> 1<span class="title">E</span>-6143<span class="title">DL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__REGISTER_PREFIX__</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT16_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__cdecl</span> <span class="title">__attribute__</span>((<span class="title">__cdecl__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MIN__</span> 1.17549435082228750796873653722224568<span class="title">e</span>-38<span class="title">F32</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT8_TYPE__</span> <span class="title">unsigned</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__NO_INLINE__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MANT_DIG__</span> 24</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_DECIMAL_DIG__</span> 21</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__VERSION__</span> "8.1.0"</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT64_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">ULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_INT_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MAX_EXP__</span> 16384</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MANT_DIG__</span> 24</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLOAT_WORD_ORDER__</span> <span class="title">__ORDER_LITTLE_ENDIAN__</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_DIG__</span> 33</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SCHAR_WIDTH__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT32_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_EPSILON__</span> 1<span class="title">E</span>-15<span class="title">DD</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ORDER_PDP_ENDIAN__</span> 3412</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MIN_EXP__</span> (-6142)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MAX_10_EXP__</span> 38</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST32_TYPE__</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST16_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT16_MAX__</span> 0<span class="title">x7fff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZE_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT64_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_DIG__</span> 18</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT8_TYPE__</span> <span class="title">signed</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ASM_FLAG_OUTPUTS__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_RADIX__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST16_TYPE__</span> <span class="title">short</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_EPSILON__</span> 1.08420217248550443400745280086994171<span class="title">e</span>-19<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTMAX_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">ULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE_MATH__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SEH__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIG_ATOMIC_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_WCHAR_T_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_PTRDIFF_T__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MANT_DIG__</span> 53</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__x86_64__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MIN_EXP__</span> (-1021)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_SUBNORMAL_MIN__</span> 0.000001<span class="title">E</span>-95<span class="title">DF</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__MSVCRT__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST16_MAX__</span> 0<span class="title">x7fff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_DIG__</span> 15</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST32_MAX__</span> 0<span class="title">xffffffffU</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MAX_10_EXP__</span> 38</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LONG_MAX__</span> 0<span class="title">x7fffffffL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_SUBNORMAL_MIN__</span> 0.000000000000000000000000000000001<span class="title">E</span>-6143<span class="title">DL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST16_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MAX__</span> 9.999999999999999<span class="title">E384DD</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST32_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__CHAR16_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PRAGMA_REDEFINE_EXTNAME</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZE_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SEG_FS</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST16_MAX__</span> 0<span class="title">x7fff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MANT_DIG__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT64_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST32_MAX__</span> 0<span class="title">xffffffffU</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SEG_GS</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_DENORM_MIN__</span> 1.40129846432481707092372958328991613<span class="title">e</span>-45<span class="title">F32</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_LONG_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIG_ATOMIC_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT16_TYPE__</span> <span class="title">short</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST8_TYPE__</span> <span class="title">signed</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC_VERSION__</span> 201710<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MAX_EXP__</span> 97</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST8_MAX__</span> 0<span class="title">x7f</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MAX__</span> 1.18973149535723176508575932662800702<span class="title">e</span>+4932<span class="title">F128</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTPTR_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GXX_MERGED_TYPEINFO_NAMES</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__stdcall</span> <span class="title">__attribute__</span>((<span class="title">__stdcall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MIN_10_EXP__</span> (-37)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE2__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_DIG__</span> 15</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MANT_DIG__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MAX__</span> 1.18973149535723176502126385303097021<span class="title">e</span>+4932<span class="title">F64x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIG_ATOMIC_MIN__</span> (-<span class="title">__SIG_ATOMIC_MAX__</span> - 1)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTPTR_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT16_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WCHAR_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_FLOAT__</span> 4</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__pic__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTPTR_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST64_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MIN_EXP__</span> (-382)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_DECIMAL_DIG__</span> 9</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST64_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_TEST_AND_SET_TRUEVAL</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_DIG__</span> 6</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MAX_EXP__</span> 16384</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__amd64__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WIN32</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__nocona</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__code_model_medium__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MAX_EXP__</span> 128</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WIN64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ORDER_BIG_ENDIAN__</span> 4321</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MANT_DIG__</span> 53</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_FLOAT128__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST64_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_CHAR16_T_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MIN__</span> 1<span class="title">E</span>-383<span class="title">DD</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINT_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST32_TYPE__</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_SHORT__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MIN_EXP__</span> (-16381)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MAX__</span> 1.79769313486231570814527423731704357<span class="title">e</span>+308<span class="title">F64</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINT_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST8_MAX__</span> 0<span class="title">x7f</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MAX_10_EXP__</span> 308</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_INT128__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MAX_10_EXP__</span> 4932</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_RELAXED</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_EPSILON__</span> ((<span class="title">double</span>)2.22044604925031308084726333618164062<span class="title">e</span>-16<span class="title">L</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__thiscall</span> <span class="title">__attribute__</span>((<span class="title">__thiscall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MIN__</span> 3.36210314311209350626267781732175260<span class="title">e</span>-4932<span class="title">F128</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT8_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MAX_EXP__</span> 1024</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST32_TYPE__</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_WCHAR_T__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST8_TYPE__</span> <span class="title">signed</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__fastcall</span> <span class="title">__attribute__</span>((<span class="title">__fastcall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MIN__</span> 3.36210314311209350626267781732175260<span class="title">e</span>-4932<span class="title">F64x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GNUC_STDC_INLINE__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_EPSILON__</span> 1.19209289550781250000000000000000000<span class="title">e</span>-7<span class="title">F32</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_DECIMAL_DIG__</span> 17</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC_UTF_32__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST8_WIDTH__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FXSR__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC_EVAL_METHOD__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MAX__</span> 1.79769313486231570814527423731704357<span class="title">e</span>+308<span class="title">F32x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__MINGW64__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT32_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">U</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTMAX_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__BYTE_ORDER__</span> <span class="title">__ORDER_LITTLE_ENDIAN__</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WINNT</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_DENORM_MIN__</span> 1.40129846432481707092372958328991613<span class="title">e</span>-45<span class="title">F</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT8_MAX__</span> 0<span class="title">x7f</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LONG_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PIC__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST32_TYPE__</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__CHAR32_TYPE__</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MAX__</span> 3.40282346638528859811704183484516925<span class="title">e</span>+38<span class="title">F</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT32_TYPE__</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_DOUBLE__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MIN_10_EXP__</span> (-37)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MIN__</span> 2.22507385850720138309023271733240406<span class="title">e</span>-308<span class="title">F64</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST32_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTMAX_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_INTEGRAL_MAX_BITS</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MAX_EXP__</span> 6145</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_CONSUME</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__nocona__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GNUC_MINOR__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST16_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTMAX_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MANT_DIG__</span> 7</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_DENORM_MIN__</span> 4.94065645841246544176568792868221372<span class="title">e</span>-324<span class="title">F32x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MAX_10_EXP__</span> 308</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_DENORM_MIN__</span> 3.64519953188247460252840593361941982<span class="title">e</span>-4951<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT16_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PTRDIFF_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_SEQ_CST</span> 5</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT32_TYPE__</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MIN_10_EXP__</span> (-307)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTPTR_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_SUBNORMAL_MIN__</span> 0.000000000000001<span class="title">E</span>-383<span class="title">DD</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MANT_DIG__</span> 34</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MIN_10_EXP__</span> (-4931)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_EPSILON__</span> 1.92592994438723585305597794258492732<span class="title">e</span>-34<span class="title">F128</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_LONG_LONG__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_DECIMAL_DIG__</span> 36</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_LLONG_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MIN__</span> 2.22507385850720138309023271733240406<span class="title">e</span>-308<span class="title">F32x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_DIG__</span> 18</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_DECIMAL_DIG__</span> 9</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST16_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_SHORT_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST64_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE3__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST8_TYPE__</span> <span class="title">unsigned</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WIN64__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_ACQ_REL</span> 4</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_RELEASE</span> 3</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__declspec</span>(<span class="title">x</span>) <span class="title">__attribute__</span>((<span class="title">x</span>))</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>wpa_supplicant源码分析--conf配置文件</title>
    <url>/post/50085.html</url>
    <content><![CDATA[<p>解析wpa_supplicant的配置文件，一般叫做 <code>wpa_supplicant.conf</code></p>
<p>在wpa_supplicant的源码中都有配置文件的示例<a href="http://w1.fi/cgit/hostap/plain/wpa_supplicant/wpa_supplicant.conf" target="_blank" rel="noopener">wpa_supplicant.conf</a></p>
<a id="more"></a>
<h2 id="wpa-supplicant-conf"><a href="#wpa-supplicant-conf" class="headerlink" title="wpa_supplicant.conf"></a>wpa_supplicant.conf</h2><p>当前项目中使用到的一个配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl_interface=/var/run/sockets</span><br><span class="line">driver_param=use_p2p_group_interface=1p2p_device=1</span><br><span class="line">update_config=1</span><br><span class="line">device_name=V_9ca2</span><br><span class="line">device_type=10-0050F204-5</span><br><span class="line">config_methods=virtual_push_button physical_display keypad</span><br><span class="line">p2p_go_intent=15</span><br><span class="line">p2p_ssid_postfix=-V_9ca2</span><br><span class="line">persistent_reconnect=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">  ssid=&quot;D-H-V_9ca2&quot;</span><br><span class="line">  bssid=ae:83:f3:b4:9c:a2</span><br><span class="line">  psk=&quot;00000000&quot;</span><br><span class="line">  proto=RSN</span><br><span class="line">  key_mgmt=WPA-PSK</span><br><span class="line">  pairwise=CCMP</span><br><span class="line">  auth_alg=OPEN</span><br><span class="line">  mode=3</span><br><span class="line">  disabled=2</span><br><span class="line">  p2p_client_list=1a:f0:e4:87:fb:74 ac:83:f3:b3:72:24 04:e6:76:c3:37:84</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该配置文件用于p2p</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpa_supplicant -iwlan0 -s -Dnl80211 -O/var/run/sockets -c/etc/wifi/p2p_supplicant.conf</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-D</code>: 指定使用的wifi驱动, nl80211 = Linux nl80211/cfg80211</li>
<li><code>-i</code>: 指定端口</li>
<li><code>-C</code>: 指定配置文件</li>
<li><code>-O</code>: 覆盖新接口的ctrl_interface参数</li>
</ul>
<h2 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h2><p>以下的数据结构都是从<code>wpa_supplicant_8</code>中的源码获取.</p>
<blockquote>
<p><code>8</code>支持建立热点(hostapd)</p>
</blockquote>
<h3 id="可配置参数"><a href="#可配置参数" class="headerlink" title="可配置参数"></a>可配置参数</h3><p>wpa_supplicant的所有参数都定义在struct wpa_config中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct wpa_config - wpa_supplicant configuration data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This data structure is presents the per-interface (radio) configuration</span></span><br><span class="line"><span class="comment"> * data. In many cases, there is only one struct wpa_config instance, but if</span></span><br><span class="line"><span class="comment"> * more than one network interface is being controlled, one instance is used</span></span><br><span class="line"><span class="comment"> * for each.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wpa_config</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ssid - Head of the global network list</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is the head for the list of all the configured networks.</span></span><br><span class="line"><span class="comment">	 * config文件中，存储所有network节点的链表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> *<span class="title">ssid</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pssid - Per-priority network lists (in priority order)</span></span><br><span class="line"><span class="comment">	 * 按照priority排列的network节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> **<span class="title">pssid</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * num_prio - Number of different priorities used in the pssid lists</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This indicates how many per-priority network lists are included in</span></span><br><span class="line"><span class="comment">	 * pssid.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> num_prio;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * cred - Head of the credential list</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is the head for the list of all the configured credentials.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_cred</span> *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * eapol_version - IEEE 802.1X/EAPOL version number</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * wpa_supplicant is implemented based on IEEE Std 802.1X-2004 which</span></span><br><span class="line"><span class="comment">	 * defines EAPOL version 2. However, there are many APs that do not</span></span><br><span class="line"><span class="comment">	 * handle the new version number correctly (they seem to drop the</span></span><br><span class="line"><span class="comment">	 * frames completely). In order to make wpa_supplicant interoperate</span></span><br><span class="line"><span class="comment">	 * with these APs, the version number is set to 1 by default. This</span></span><br><span class="line"><span class="comment">	 * configuration value can be used to set it to the new version (2).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> eapol_version;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ap_scan - AP scanning/selection</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, wpa_supplicant requests driver to perform AP</span></span><br><span class="line"><span class="comment">	 * scanning and then uses the scan results to select a</span></span><br><span class="line"><span class="comment">	 * suitable AP. Another alternative is to allow the driver to</span></span><br><span class="line"><span class="comment">	 * take care of AP scanning and selection and use</span></span><br><span class="line"><span class="comment">	 * wpa_supplicant just to process EAPOL frames based on IEEE</span></span><br><span class="line"><span class="comment">	 * 802.11 association information from the driver.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1: wpa_supplicant initiates scanning and AP selection (default).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0: Driver takes care of scanning, AP selection, and IEEE 802.11</span></span><br><span class="line"><span class="comment">	 * association parameters (e.g., WPA IE generation); this mode can</span></span><br><span class="line"><span class="comment">	 * also be used with non-WPA drivers when using IEEE 802.1X mode;</span></span><br><span class="line"><span class="comment">	 * do not try to associate with APs (i.e., external program needs</span></span><br><span class="line"><span class="comment">	 * to control association). This mode must also be used when using</span></span><br><span class="line"><span class="comment">	 * wired Ethernet drivers.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 2: like 0, but associate with APs using security policy and SSID</span></span><br><span class="line"><span class="comment">	 * (but not BSSID); this can be used, e.g., with ndiswrapper and NDIS</span></span><br><span class="line"><span class="comment">	 * drivers to enable operation with hidden SSIDs and optimized roaming;</span></span><br><span class="line"><span class="comment">	 * in this mode, the network blocks in the configuration are tried</span></span><br><span class="line"><span class="comment">	 * one by one until the driver reports successful association; each</span></span><br><span class="line"><span class="comment">	 * network block should have explicit security policy (i.e., only one</span></span><br><span class="line"><span class="comment">	 * option in the lists) for key_mgmt, pairwise, group, proto variables.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ap_scan;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_scan_offload - Disable automatic offloading of scan requests</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, %wpa_supplicant tries to offload scanning if the driver</span></span><br><span class="line"><span class="comment">	 * indicates support for this (sched_scan). This configuration</span></span><br><span class="line"><span class="comment">	 * parameter can be used to disable this offloading mechanism.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> disable_scan_offload;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ctrl_interface - Parameters for the control interface</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is specified, %wpa_supplicant will open a control interface</span></span><br><span class="line"><span class="comment">	 * that is available for external programs to manage %wpa_supplicant.</span></span><br><span class="line"><span class="comment">	 * The meaning of this string depends on which control interface</span></span><br><span class="line"><span class="comment">	 * mechanism is used. For all cases, the existence of this parameter</span></span><br><span class="line"><span class="comment">	 * in configuration is used to determine whether the control interface</span></span><br><span class="line"><span class="comment">	 * is enabled.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For UNIX domain sockets (default on Linux and BSD): This is a</span></span><br><span class="line"><span class="comment">	 * directory that will be created for UNIX domain sockets for listening</span></span><br><span class="line"><span class="comment">	 * to requests from external programs (CLI/GUI, etc.) for status</span></span><br><span class="line"><span class="comment">	 * information and configuration. The socket file will be named based</span></span><br><span class="line"><span class="comment">	 * on the interface name, so multiple %wpa_supplicant processes can be</span></span><br><span class="line"><span class="comment">	 * run at the same time if more than one interface is used.</span></span><br><span class="line"><span class="comment">	 * /var/run/wpa_supplicant is the recommended directory for sockets and</span></span><br><span class="line"><span class="comment">	 * by default, wpa_cli will use it when trying to connect with</span></span><br><span class="line"><span class="comment">	 * %wpa_supplicant.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Access control for the control interface can be configured</span></span><br><span class="line"><span class="comment">	 * by setting the directory to allow only members of a group</span></span><br><span class="line"><span class="comment">	 * to use sockets. This way, it is possible to run</span></span><br><span class="line"><span class="comment">	 * %wpa_supplicant as root (since it needs to change network</span></span><br><span class="line"><span class="comment">	 * configuration and open raw sockets) and still allow GUI/CLI</span></span><br><span class="line"><span class="comment">	 * components to be run as non-root users. However, since the</span></span><br><span class="line"><span class="comment">	 * control interface can be used to change the network</span></span><br><span class="line"><span class="comment">	 * configuration, this access needs to be protected in many</span></span><br><span class="line"><span class="comment">	 * cases. By default, %wpa_supplicant is configured to use gid</span></span><br><span class="line"><span class="comment">	 * 0 (root). If you want to allow non-root users to use the</span></span><br><span class="line"><span class="comment">	 * control interface, add a new group and change this value to</span></span><br><span class="line"><span class="comment">	 * match with that group. Add users that should have control</span></span><br><span class="line"><span class="comment">	 * interface access to this group.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When configuring both the directory and group, use following format:</span></span><br><span class="line"><span class="comment">	 * DIR=/var/run/wpa_supplicant GROUP=wheel</span></span><br><span class="line"><span class="comment">	 * DIR=/var/run/wpa_supplicant GROUP=0</span></span><br><span class="line"><span class="comment">	 * (group can be either group name or gid)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For UDP connections (default on Windows): The value will be ignored.</span></span><br><span class="line"><span class="comment">	 * This variable is just used to select that the control interface is</span></span><br><span class="line"><span class="comment">	 * to be created. The value can be set to, e.g., udp</span></span><br><span class="line"><span class="comment">	 * (ctrl_interface=udp).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For Windows Named Pipe: This value can be used to set the security</span></span><br><span class="line"><span class="comment">	 * descriptor for controlling access to the control interface. Security</span></span><br><span class="line"><span class="comment">	 * descriptor can be set using Security Descriptor String Format (see</span></span><br><span class="line"><span class="comment">	 * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/security_descriptor_string_format.asp).</span></span><br><span class="line"><span class="comment">	 * The descriptor string needs to be prefixed with SDDL=. For example,</span></span><br><span class="line"><span class="comment">	 * ctrl_interface=SDDL=D: would set an empty DACL (which will reject</span></span><br><span class="line"><span class="comment">	 * all connections).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *ctrl_interface;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ctrl_interface_group - Control interface group (DEPRECATED)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This variable is only used for backwards compatibility. Group for</span></span><br><span class="line"><span class="comment">	 * UNIX domain sockets should now be specified using GROUP=group in</span></span><br><span class="line"><span class="comment">	 * ctrl_interface variable.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *ctrl_interface_group;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * fast_reauth - EAP fast re-authentication (session resumption)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, fast re-authentication is enabled for all EAP methods</span></span><br><span class="line"><span class="comment">	 * that support it. This variable can be used to disable fast</span></span><br><span class="line"><span class="comment">	 * re-authentication (by setting fast_reauth=0). Normally, there is no</span></span><br><span class="line"><span class="comment">	 * need to disable fast re-authentication.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> fast_reauth;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * opensc_engine_path - Path to the OpenSSL engine for opensc</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an OpenSSL specific configuration option for loading OpenSC</span></span><br><span class="line"><span class="comment">	 * engine (engine_opensc.so); if %NULL, this engine is not loaded.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *opensc_engine_path;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pkcs11_engine_path - Path to the OpenSSL engine for PKCS#11</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an OpenSSL specific configuration option for loading PKCS#11</span></span><br><span class="line"><span class="comment">	 * engine (engine_pkcs11.so); if %NULL, this engine is not loaded.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *pkcs11_engine_path;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pkcs11_module_path - Path to the OpenSSL OpenSC/PKCS#11 module</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an OpenSSL specific configuration option for configuring</span></span><br><span class="line"><span class="comment">	 * path to OpenSC/PKCS#11 engine (opensc-pkcs11.so); if %NULL, this</span></span><br><span class="line"><span class="comment">	 * module is not loaded.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *pkcs11_module_path;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pcsc_reader - PC/SC reader name prefix</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If not %NULL, PC/SC reader with a name that matches this prefix is</span></span><br><span class="line"><span class="comment">	 * initialized for SIM/USIM access. Empty string can be used to match</span></span><br><span class="line"><span class="comment">	 * the first available reader.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *pcsc_reader;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pcsc_pin - PIN for USIM, GSM SIM, and smartcards</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This field is used to configure PIN for SIM/USIM for EAP-SIM and</span></span><br><span class="line"><span class="comment">	 * EAP-AKA. If left out, this will be asked through control interface.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *pcsc_pin;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * driver_param - Driver interface parameters</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This text string is passed to the selected driver interface with the</span></span><br><span class="line"><span class="comment">	 * optional struct wpa_driver_ops::set_param() handler. This can be</span></span><br><span class="line"><span class="comment">	 * used to configure driver specific options without having to add new</span></span><br><span class="line"><span class="comment">	 * driver interface functionality.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *driver_param;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dot11RSNAConfigPMKLifetime - Maximum lifetime of a PMK</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * dot11 MIB variable for the maximum lifetime of a PMK in the PMK</span></span><br><span class="line"><span class="comment">	 * cache (unit: seconds).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dot11RSNAConfigPMKLifetime;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dot11RSNAConfigPMKReauthThreshold - PMK re-authentication threshold</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * dot11 MIB variable for the percentage of the PMK lifetime</span></span><br><span class="line"><span class="comment">	 * that should expire before an IEEE 802.1X reauthentication occurs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dot11RSNAConfigPMKReauthThreshold;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dot11RSNAConfigSATimeout - Security association timeout</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * dot11 MIB variable for the maximum time a security association</span></span><br><span class="line"><span class="comment">	 * shall take to set up (unit: seconds).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dot11RSNAConfigSATimeout;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * update_config - Is wpa_supplicant allowed to update configuration</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This variable control whether wpa_supplicant is allow to re-write</span></span><br><span class="line"><span class="comment">	 * its configuration with wpa_config_write(). If this is zero,</span></span><br><span class="line"><span class="comment">	 * configuration data is only changed in memory and the external data</span></span><br><span class="line"><span class="comment">	 * is not overriden. If this is non-zero, wpa_supplicant will update</span></span><br><span class="line"><span class="comment">	 * the configuration data (e.g., a file) whenever configuration is</span></span><br><span class="line"><span class="comment">	 * changed. This update may replace the old configuration which can</span></span><br><span class="line"><span class="comment">	 * remove comments from it in case of a text file configuration.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> update_config;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * blobs - Configuration blobs</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_config_blob</span> *<span class="title">blobs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * uuid - Universally Unique IDentifier (UUID; see RFC 4122) for WPS</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 uuid[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * device_name - Device Name (WPS)</span></span><br><span class="line"><span class="comment">	 * User-friendly description of device; up to 32 octets encoded in</span></span><br><span class="line"><span class="comment">	 * UTF-8</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *device_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * manufacturer - Manufacturer (WPS)</span></span><br><span class="line"><span class="comment">	 * The manufacturer of the device (up to 64 ASCII characters)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *manufacturer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * model_name - Model Name (WPS)</span></span><br><span class="line"><span class="comment">	 * Model of the device (up to 32 ASCII characters)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *model_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * model_number - Model Number (WPS)</span></span><br><span class="line"><span class="comment">	 * Additional device description (up to 32 ASCII characters)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *model_number;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * serial_number - Serial Number (WPS)</span></span><br><span class="line"><span class="comment">	 * Serial number of the device (up to 32 characters)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *serial_number;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * device_type - Primary Device Type (WPS)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 device_type[WPS_DEV_TYPE_LEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * config_methods - Config Methods</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is a space-separated list of supported WPS configuration</span></span><br><span class="line"><span class="comment">	 * methods. For example, "label virtual_display virtual_push_button</span></span><br><span class="line"><span class="comment">	 * keypad".</span></span><br><span class="line"><span class="comment">	 * Available methods: usba ethernet label display ext_nfc_token</span></span><br><span class="line"><span class="comment">	 * int_nfc_token nfc_interface push_button keypad</span></span><br><span class="line"><span class="comment">	 * virtual_display physical_display</span></span><br><span class="line"><span class="comment">	 * virtual_push_button physical_push_button.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *config_methods;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * os_version - OS Version (WPS)</span></span><br><span class="line"><span class="comment">	 * 4-octet operating system version number</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 os_version[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * country - Country code</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is the ISO/IEC alpha2 country code for which we are operating</span></span><br><span class="line"><span class="comment">	 * in</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> country[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_cred_processing - Credential processing</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   0 = process received credentials internally</span></span><br><span class="line"><span class="comment">	 *   1 = do not process received credentials; just pass them over</span></span><br><span class="line"><span class="comment">	 *	ctrl_iface to external program(s)</span></span><br><span class="line"><span class="comment">	 *   2 = process received credentials internally and pass them over</span></span><br><span class="line"><span class="comment">	 *	ctrl_iface to external program(s)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> wps_cred_processing;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEC_DEVICE_TYPES 5</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * sec_device_types - Secondary Device Types (P2P)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 sec_device_type[MAX_SEC_DEVICE_TYPES][WPS_DEV_TYPE_LEN];</span><br><span class="line">	<span class="keyword">int</span> num_sec_device_types;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> p2p_listen_reg_class;</span><br><span class="line">	<span class="keyword">int</span> p2p_listen_channel;</span><br><span class="line">	<span class="keyword">int</span> p2p_oper_reg_class;</span><br><span class="line">	<span class="keyword">int</span> p2p_oper_channel;</span><br><span class="line">	<span class="keyword">int</span> p2p_go_intent;</span><br><span class="line">	<span class="keyword">char</span> *p2p_ssid_postfix;</span><br><span class="line">	<span class="keyword">int</span> persistent_reconnect;</span><br><span class="line">	<span class="keyword">int</span> p2p_intra_bss;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_p2p_pref_chan;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">p2p_channel</span> *<span class="title">p2p_pref_chan</span>;</span></span><br><span class="line">	<span class="keyword">int</span> p2p_ignore_shared_freq;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_vendor_ext_m1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_WPS_VENDOR_EXT 10</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_vendor_ext - Vendor extension attributes in WPS</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_vendor_ext</span>[<span class="title">MAX_WPS_VENDOR_EXT</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_group_idle - Maximum idle time in seconds for P2P group</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value controls how long a P2P group is maintained after there</span></span><br><span class="line"><span class="comment">	 * is no other members in the group. As a GO, this means no associated</span></span><br><span class="line"><span class="comment">	 * stations in the group. As a P2P client, this means no GO seen in</span></span><br><span class="line"><span class="comment">	 * scan results. The maximum idle time is specified in seconds with 0</span></span><br><span class="line"><span class="comment">	 * indicating no time limit, i.e., the P2P group remains in active</span></span><br><span class="line"><span class="comment">	 * state indefinitely until explicitly removed. As a P2P client, the</span></span><br><span class="line"><span class="comment">	 * maximum idle time of P2P_MAX_CLIENT_IDLE seconds is enforced, i.e.,</span></span><br><span class="line"><span class="comment">	 * this parameter is mainly meant for GO use and for P2P client, it can</span></span><br><span class="line"><span class="comment">	 * only be used to reduce the default timeout to smaller value. A</span></span><br><span class="line"><span class="comment">	 * special value -1 can be used to configure immediate removal of the</span></span><br><span class="line"><span class="comment">	 * group for P2P client role on any disconnection after the data</span></span><br><span class="line"><span class="comment">	 * connection has been established.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> p2p_group_idle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bss_max_count - Maximum number of BSS entries to keep in memory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bss_max_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bss_expiration_age - BSS entry age after which it can be expired</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value controls the time in seconds after which a BSS entry</span></span><br><span class="line"><span class="comment">	 * gets removed if it has not been updated or is not in use.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bss_expiration_age;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bss_expiration_scan_count - Expire BSS after number of scans</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If the BSS entry has not been seen in this many scans, it will be</span></span><br><span class="line"><span class="comment">	 * removed. A value of 1 means that entry is removed after the first</span></span><br><span class="line"><span class="comment">	 * scan in which the BSSID is not seen. Larger values can be used</span></span><br><span class="line"><span class="comment">	 * to avoid BSS entries disappearing if they are not visible in</span></span><br><span class="line"><span class="comment">	 * every scan (e.g., low signal quality or interference).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bss_expiration_scan_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * filter_ssids - SSID-based scan result filtering</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   0 = do not filter scan results</span></span><br><span class="line"><span class="comment">	 *   1 = only include configured SSIDs in scan results/BSS table</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> filter_ssids;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * filter_rssi - RSSI-based scan result filtering</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = do not filter scan results</span></span><br><span class="line"><span class="comment">	 * -n = filter scan results below -n dBm</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> filter_rssi;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * max_num_sta - Maximum number of STAs in an AP/P2P GO</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_num_sta;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * freq_list - Array of allowed scan frequencies or %NULL for all</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional zero-terminated array of frequencies in</span></span><br><span class="line"><span class="comment">	 * megahertz (MHz) to allow for narrowing scanning range.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> *freq_list;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * scan_cur_freq - Whether to scan only the current channel</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If true, attempt to scan only the current channel if any other</span></span><br><span class="line"><span class="comment">	 * VIFs on this radio are already associated on a particular channel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> scan_cur_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * changed_parameters - Bitmap of changed parameters since last update</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> changed_parameters;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disassoc_low_ack - Disassocicate stations with massive packet loss</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> disassoc_low_ack;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * interworking - Whether Interworking (IEEE 802.11u) is enabled</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> interworking;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * access_network_type - Access Network Type</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When Interworking is enabled, scans will be limited to APs that</span></span><br><span class="line"><span class="comment">	 * advertise the specified Access Network Type (0..15; with 15</span></span><br><span class="line"><span class="comment">	 * indicating wildcard match).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> access_network_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * hessid - Homogenous ESS identifier</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is set (any octet is non-zero), scans will be used to</span></span><br><span class="line"><span class="comment">	 * request response only from BSSes belonging to the specified</span></span><br><span class="line"><span class="comment">	 * Homogeneous ESS. This is used only if interworking is enabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 hessid[ETH_ALEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * hs20 - Hotspot 2.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> hs20;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pbc_in_m1 - AP mode WPS probing workaround for PBC with Windows 7</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Windows 7 uses incorrect way of figuring out AP's WPS capabilities</span></span><br><span class="line"><span class="comment">	 * by acting as a Registrar and using M1 from the AP. The config</span></span><br><span class="line"><span class="comment">	 * methods attribute in that message is supposed to indicate only the</span></span><br><span class="line"><span class="comment">	 * configuration method supported by the AP in Enrollee role, i.e., to</span></span><br><span class="line"><span class="comment">	 * add an external Registrar. For that case, PBC shall not be used and</span></span><br><span class="line"><span class="comment">	 * as such, the PushButton config method is removed from M1 by default.</span></span><br><span class="line"><span class="comment">	 * If pbc_in_m1=1 is included in the configuration file, the PushButton</span></span><br><span class="line"><span class="comment">	 * config method is left in M1 (if included in config_methods</span></span><br><span class="line"><span class="comment">	 * parameter) to allow Windows 7 to use PBC instead of PIN (e.g., from</span></span><br><span class="line"><span class="comment">	 * a label in the AP).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> pbc_in_m1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * autoscan - Automatic scan parameters or %NULL if none</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional set of parameters for automatic scanning</span></span><br><span class="line"><span class="comment">	 * within an interface in following format:</span></span><br><span class="line"><span class="comment">	 * &lt;autoscan module name&gt;:&lt;module parameters&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *autoscan;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_pw_from_config - NFC Device Password was read from config</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This parameter can be determined whether the NFC Device Password was</span></span><br><span class="line"><span class="comment">	 * included in the configuration (1) or generated dynamically (0). Only</span></span><br><span class="line"><span class="comment">	 * the former case is re-written back to the configuration file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> wps_nfc_pw_from_config;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_dev_pw_id - NFC Device Password ID for password token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> wps_nfc_dev_pw_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_dh_pubkey - NFC DH Public Key for password token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_nfc_dh_pubkey</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_dh_privkey - NFC DH Private Key for password token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_nfc_dh_privkey</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_dev_pw - NFC Device Password for password token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_nfc_dev_pw</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ext_password_backend - External password backend or %NULL if none</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * format: &lt;backend name&gt;[:&lt;optional backend parameters&gt;]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *ext_password_backend;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * p2p_go_max_inactivity - Timeout in seconds to detect STA inactivity</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This timeout value is used in P2P GO mode to clean up</span></span><br><span class="line"><span class="comment">	 * inactive stations.</span></span><br><span class="line"><span class="comment">	 * By default: 300 seconds.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> p2p_go_max_inactivity;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostapd_wmm_ac_params</span> <span class="title">wmm_ac_params</span>[4];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * auto_interworking - Whether to use network selection automatically</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = do not automatically go through Interworking network selection</span></span><br><span class="line"><span class="comment">	 *     (i.e., require explicit interworking_select command for this)</span></span><br><span class="line"><span class="comment">	 * 1 = perform Interworking network selection if one or more</span></span><br><span class="line"><span class="comment">	 *     credentials have been configured and scan did not find a</span></span><br><span class="line"><span class="comment">	 *     matching network block</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> auto_interworking;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_go_ht40 - Default mode for HT40 enable when operating as GO.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This will take effect for p2p_group_add, p2p_connect, and p2p_invite.</span></span><br><span class="line"><span class="comment">	 * Note that regulatory constraints and driver capabilities are</span></span><br><span class="line"><span class="comment">	 * consulted anyway, so setting it to 1 can't do real harm.</span></span><br><span class="line"><span class="comment">	 * By default: 0 (disabled)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> p2p_go_ht40;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_disabled - Whether P2P operations are disabled for this interface</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> p2p_disabled;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_no_group_iface - Whether group interfaces can be used</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, wpa_supplicant will create a separate interface for P2P</span></span><br><span class="line"><span class="comment">	 * group operations if the driver supports this. This functionality can</span></span><br><span class="line"><span class="comment">	 * be disabled by setting this parameter to 1. In that case, the same</span></span><br><span class="line"><span class="comment">	 * interface that was used for the P2P management operations is used</span></span><br><span class="line"><span class="comment">	 * also for the group operation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> p2p_no_group_iface;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * okc - Whether to enable opportunistic key caching by default</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, OKC is disabled unless enabled by the per-network</span></span><br><span class="line"><span class="comment">	 * proactive_key_caching=1 parameter. okc=1 can be used to change this</span></span><br><span class="line"><span class="comment">	 * default behavior.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> okc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pmf - Whether to enable/require PMF by default</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, PMF is disabled unless enabled by the per-network</span></span><br><span class="line"><span class="comment">	 * ieee80211w=1 or ieee80211w=2 parameter. pmf=1/2 can be used to change</span></span><br><span class="line"><span class="comment">	 * this default behavior.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">enum</span> mfp_options pmf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * sae_groups - Preference list of enabled groups for SAE</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default (if this parameter is not set), the mandatory group 19</span></span><br><span class="line"><span class="comment">	 * (ECC group defined over a 256-bit prime order field) is preferred,</span></span><br><span class="line"><span class="comment">	 * but other groups are also enabled. If this parameter is set, the</span></span><br><span class="line"><span class="comment">	 * groups will be tried in the indicated order.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> *sae_groups;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dtim_period - Default DTIM period in Beacon intervals</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This parameter can be used to set the default value for network</span></span><br><span class="line"><span class="comment">	 * blocks that do not specify dtim_period.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> dtim_period;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * beacon_int - Default Beacon interval in TU</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This parameter can be used to set the default value for network</span></span><br><span class="line"><span class="comment">	 * blocks that do not specify beacon_int.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> beacon_int;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ap_vendor_elements: Vendor specific elements for Beacon/ProbeResp</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This parameter can be used to define additional vendor specific</span></span><br><span class="line"><span class="comment">	 * elements for Beacon and Probe Response frames in AP/P2P GO mode. The</span></span><br><span class="line"><span class="comment">	 * format for these element(s) is a hexdump of the raw information</span></span><br><span class="line"><span class="comment">	 * elements (id+len+payload for one or more elements).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">ap_vendor_elements</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ignore_old_scan_res - Ignore scan results older than request</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The driver may have a cache of scan results that makes it return</span></span><br><span class="line"><span class="comment">	 * information that is older than our scan trigger. This parameter can</span></span><br><span class="line"><span class="comment">	 * be used to configure such old information to be ignored instead of</span></span><br><span class="line"><span class="comment">	 * allowing it to update the internal BSS table.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ignore_old_scan_res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * sched_scan_interval -  schedule scan interval</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sched_scan_interval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * tdls_external_control - External control for TDLS setup requests</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Enable TDLS mode where external programs are given the control</span></span><br><span class="line"><span class="comment">	 * to specify the TDLS link to get established to the driver. The</span></span><br><span class="line"><span class="comment">	 * driver requests the TDLS setup to the supplicant only for the</span></span><br><span class="line"><span class="comment">	 * specified TDLS peers.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> tdls_external_control;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="network节点"><a href="#network节点" class="headerlink" title="network节点"></a>network节点</h3><p>wpa_supplicant.conf文件中每个network节点都是一个保存的网络, 存储了网络的名称（ssid），密码（psk），加密方式（WPA_PSK），优先级（priority）</p>
<p>WIFI网络有多种加密方式，每种加密方式（wpa_psk，wep，open，wapi，各种eap等）的节点书写方式都不同，具体可以参考源代码中<a href="http://w1.fi/cgit/hostap/plain/wpa_supplicant/wpa_supplicant.conf" target="_blank" rel="noopener">wpa_supplicant.conf</a>文件</p>
<p>network节点的结构体<code>struct wpa_ssid</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct wpa_ssid - Network configuration data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure includes all the configuration variables for a network. This</span></span><br><span class="line"><span class="comment"> * data is included in the per-interface configuration data as an element of</span></span><br><span class="line"><span class="comment"> * the network list, struct wpa_config::ssid. Each network block in the</span></span><br><span class="line"><span class="comment"> * configuration is mapped to a struct wpa_ssid instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * next - Next network in global list</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This pointer can be used to iterate over all networks. The head of</span></span><br><span class="line"><span class="comment">	 * this list is stored in the ssid field of struct wpa_config.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pnext - Next network in per-priority list</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This pointer can be used to iterate over all networks in the same</span></span><br><span class="line"><span class="comment">	 * priority class. The heads of these list are stored in the pssid</span></span><br><span class="line"><span class="comment">	 * fields of struct wpa_config.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> *<span class="title">pnext</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * id - Unique id for the network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This identifier is used as a unique identifier for each network</span></span><br><span class="line"><span class="comment">	 * block when using the control interface. Each network is allocated an</span></span><br><span class="line"><span class="comment">	 * id when it is being created, either when reading the configuration</span></span><br><span class="line"><span class="comment">	 * file or when a new network is added through the control interface.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * priority - Priority group</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, all networks will get same priority group (0). If some</span></span><br><span class="line"><span class="comment">	 * of the networks are more desirable, this field can be used to change</span></span><br><span class="line"><span class="comment">	 * the order in which wpa_supplicant goes through the networks when</span></span><br><span class="line"><span class="comment">	 * selecting a BSS. The priority groups will be iterated in decreasing</span></span><br><span class="line"><span class="comment">	 * priority (i.e., the larger the priority value, the sooner the</span></span><br><span class="line"><span class="comment">	 * network is matched against the scan results). Within each priority</span></span><br><span class="line"><span class="comment">	 * group, networks will be selected based on security policy, signal</span></span><br><span class="line"><span class="comment">	 * strength, etc.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Please note that AP scanning with scan_ssid=1 and ap_scan=2 mode are</span></span><br><span class="line"><span class="comment">	 * not using this priority to select the order for scanning. Instead,</span></span><br><span class="line"><span class="comment">	 * they try the networks in the order that used in the configuration</span></span><br><span class="line"><span class="comment">	 * file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ssid - Service set identifier (network name)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is the SSID for the network. For wireless interfaces, this is</span></span><br><span class="line"><span class="comment">	 * used to select which network will be used. If set to %NULL (or</span></span><br><span class="line"><span class="comment">	 * ssid_len=0), any SSID can be used. For wired interfaces, this must</span></span><br><span class="line"><span class="comment">	 * be set to %NULL. Note: SSID may contain any characters, even nul</span></span><br><span class="line"><span class="comment">	 * (ASCII 0) and as such, this should not be assumed to be a nul</span></span><br><span class="line"><span class="comment">	 * terminated string. ssid_len defines how many characters are valid</span></span><br><span class="line"><span class="comment">	 * and the ssid field is not guaranteed to be nul terminated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 *ssid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ssid_len - Length of the SSID</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">size_t</span> ssid_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bssid - BSSID</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If set, this network block is used only when associating with the AP</span></span><br><span class="line"><span class="comment">	 * using the configured BSSID</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is a persistent P2P group (disabled == 2), this is the GO</span></span><br><span class="line"><span class="comment">	 * Device Address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 bssid[ETH_ALEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bssid_set - Whether BSSID is configured for this network</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> bssid_set;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * psk - WPA pre-shared key (256 bits)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 psk[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * psk_set - Whether PSK field is configured</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> psk_set;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * passphrase - WPA ASCII passphrase</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is set, psk will be generated using the SSID and passphrase</span></span><br><span class="line"><span class="comment">	 * configured for the network. ASCII passphrase must be between 8 and</span></span><br><span class="line"><span class="comment">	 * 63 characters (inclusive).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *passphrase;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ext_psk - PSK/passphrase name in external storage</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is set, PSK/passphrase will be fetched from external storage</span></span><br><span class="line"><span class="comment">	 * when requesting association with the network.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *ext_psk;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pairwise_cipher - Bitfield of allowed pairwise ciphers, WPA_CIPHER_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> pairwise_cipher;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * group_cipher - Bitfield of allowed group ciphers, WPA_CIPHER_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> group_cipher;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * key_mgmt - Bitfield of allowed key management protocols</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * WPA_KEY_MGMT_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> key_mgmt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bg_scan_period - Background scan period in seconds, 0 to disable, or</span></span><br><span class="line"><span class="comment">	 * -1 to indicate no change to default driver configuration</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> bg_scan_period;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * proto - Bitfield of allowed protocols, WPA_PROTO_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> proto;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * auth_alg -  Bitfield of allowed authentication algorithms</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * WPA_AUTH_ALG_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> auth_alg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * scan_ssid - Scan this SSID with Probe Requests</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * scan_ssid can be used to scan for APs using hidden SSIDs.</span></span><br><span class="line"><span class="comment">	 * Note: Many drivers do not support this. ap_mode=2 can be used with</span></span><br><span class="line"><span class="comment">	 * such drivers to use hidden SSIDs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> scan_ssid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IEEE8021X_EAPOL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EAPOL_FLAG_REQUIRE_KEY_UNICAST BIT(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EAPOL_FLAG_REQUIRE_KEY_BROADCAST BIT(1)</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * eapol_flags - Bit field of IEEE 802.1X/EAPOL options (EAPOL_FLAG_*)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> eapol_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * eap - EAP peer configuration for this network</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eap_peer_config</span> <span class="title">eap</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* IEEE8021X_EAPOL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_WEP_KEYS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_WEP_KEY_LEN 16</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wep_key - WEP keys</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 wep_key[NUM_WEP_KEYS][MAX_WEP_KEY_LEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wep_key_len - WEP key lengths</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">size_t</span> wep_key_len[NUM_WEP_KEYS];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wep_tx_keyidx - Default key index for TX frames using WEP</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> wep_tx_keyidx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * proactive_key_caching - Enable proactive key caching</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This field can be used to enable proactive key caching which is also</span></span><br><span class="line"><span class="comment">	 * known as opportunistic PMKSA caching for WPA2. This is disabled (0)</span></span><br><span class="line"><span class="comment">	 * by default unless default value is changed with the global okc=1</span></span><br><span class="line"><span class="comment">	 * parameter. Enable by setting this to 1.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Proactive key caching is used to make supplicant assume that the APs</span></span><br><span class="line"><span class="comment">	 * are using the same PMK and generate PMKSA cache entries without</span></span><br><span class="line"><span class="comment">	 * doing RSN pre-authentication. This requires support from the AP side</span></span><br><span class="line"><span class="comment">	 * and is normally used with wireless switches that co-locate the</span></span><br><span class="line"><span class="comment">	 * authenticator.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Internally, special value -1 is used to indicate that the parameter</span></span><br><span class="line"><span class="comment">	 * was not specified in the configuration (i.e., default behavior is</span></span><br><span class="line"><span class="comment">	 * followed).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> proactive_key_caching;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * mixed_cell - Whether mixed cells are allowed</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This option can be used to configure whether so called mixed cells,</span></span><br><span class="line"><span class="comment">	 * i.e., networks that use both plaintext and encryption in the same</span></span><br><span class="line"><span class="comment">	 * SSID, are allowed. This is disabled (0) by default. Enable by</span></span><br><span class="line"><span class="comment">	 * setting this to 1.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> mixed_cell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IEEE8021X_EAPOL</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * leap - Number of EAP methods using LEAP</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This field should be set to 1 if LEAP is enabled. This is used to</span></span><br><span class="line"><span class="comment">	 * select IEEE 802.11 authentication algorithm.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> leap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * non_leap - Number of EAP methods not using LEAP</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This field should be set to &gt;0 if any EAP method other than LEAP is</span></span><br><span class="line"><span class="comment">	 * enabled. This is used to select IEEE 802.11 authentication</span></span><br><span class="line"><span class="comment">	 * algorithm.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> non_leap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * eap_workaround - EAP workarounds enabled</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * wpa_supplicant supports number of "EAP workarounds" to work around</span></span><br><span class="line"><span class="comment">	 * interoperability issues with incorrectly behaving authentication</span></span><br><span class="line"><span class="comment">	 * servers. This is recommended to be enabled by default because some</span></span><br><span class="line"><span class="comment">	 * of the issues are present in large number of authentication servers.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Strict EAP conformance mode can be configured by disabling</span></span><br><span class="line"><span class="comment">	 * workarounds with eap_workaround = 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> eap_workaround;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* IEEE8021X_EAPOL */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * mode - IEEE 802.11 operation mode (Infrastucture/IBSS)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = infrastructure (Managed) mode, i.e., associate with an AP.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1 = IBSS (ad-hoc, peer-to-peer)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 2 = AP (access point)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 3 = P2P Group Owner (can be set in the configuration file)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 4 = P2P Group Formation (used internally; not in configuration</span></span><br><span class="line"><span class="comment">	 * files)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note: IBSS can only be used with key_mgmt NONE (plaintext and</span></span><br><span class="line"><span class="comment">	 * static WEP) and key_mgmt=WPA-NONE (fixed group key TKIP/CCMP). In</span></span><br><span class="line"><span class="comment">	 * addition, ap_scan has to be set to 2 for IBSS. WPA-None requires</span></span><br><span class="line"><span class="comment">	 * following network block options: proto=WPA, key_mgmt=WPA-NONE,</span></span><br><span class="line"><span class="comment">	 * pairwise=NONE, group=TKIP (or CCMP, but not both), and psk must also</span></span><br><span class="line"><span class="comment">	 * be set (either directly or using ASCII passphrase).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">enum</span> wpas_mode &#123;</span><br><span class="line">		WPAS_MODE_INFRA = <span class="number">0</span>,</span><br><span class="line">		WPAS_MODE_IBSS = <span class="number">1</span>,</span><br><span class="line">		WPAS_MODE_AP = <span class="number">2</span>,</span><br><span class="line">		WPAS_MODE_P2P_GO = <span class="number">3</span>,</span><br><span class="line">		WPAS_MODE_P2P_GROUP_FORMATION = <span class="number">4</span>,</span><br><span class="line">	&#125; mode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disabled - Whether this network is currently disabled</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = this network can be used (default).</span></span><br><span class="line"><span class="comment">	 * 1 = this network block is disabled (can be enabled through</span></span><br><span class="line"><span class="comment">	 * ctrl_iface, e.g., with wpa_cli or wpa_gui).</span></span><br><span class="line"><span class="comment">	 * 2 = this network block includes parameters for a persistent P2P</span></span><br><span class="line"><span class="comment">	 * group (can be used with P2P ctrl_iface commands)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> disabled;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disabled_for_connect - Whether this network was temporarily disabled</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This flag is used to reenable all the temporarily disabled networks</span></span><br><span class="line"><span class="comment">	 * after either the success or failure of a WPS connection.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> disabled_for_connect;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * peerkey -  Whether PeerKey handshake for direct links is allowed</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is only used when both RSN/WPA2 and IEEE 802.11e (QoS) are</span></span><br><span class="line"><span class="comment">	 * enabled.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = disabled (default)</span></span><br><span class="line"><span class="comment">	 * 1 = enabled</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> peerkey;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * id_str - Network identifier string for external scripts</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value is passed to external ctrl_iface monitors in</span></span><br><span class="line"><span class="comment">	 * WPA_EVENT_CONNECTED event and wpa_cli sets this as WPA_ID_STR</span></span><br><span class="line"><span class="comment">	 * environment variable for action scripts.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *id_str;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IEEE80211W</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ieee80211w - Whether management frame protection is enabled</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value is used to configure policy for management frame</span></span><br><span class="line"><span class="comment">	 * protection (IEEE 802.11w). 0 = disabled, 1 = optional, 2 = required.</span></span><br><span class="line"><span class="comment">	 * This is disabled by default unless the default value has been changed</span></span><br><span class="line"><span class="comment">	 * with the global pmf=1/2 parameter.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Internally, special value 3 is used to indicate that the parameter</span></span><br><span class="line"><span class="comment">	 * was not specified in the configuration (i.e., default behavior is</span></span><br><span class="line"><span class="comment">	 * followed).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">enum</span> mfp_options ieee80211w;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_IEEE80211W */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * frequency - Channel frequency in megahertz (MHz) for IBSS</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value is used to configure the initial channel for IBSS (adhoc)</span></span><br><span class="line"><span class="comment">	 * networks, e.g., 2412 = IEEE 802.11b/g channel 1. It is ignored in</span></span><br><span class="line"><span class="comment">	 * the infrastructure mode. In addition, this value is only used by the</span></span><br><span class="line"><span class="comment">	 * station that creates the IBSS. If an IBSS network with the</span></span><br><span class="line"><span class="comment">	 * configured SSID is already present, the frequency of the network</span></span><br><span class="line"><span class="comment">	 * will be used instead of this configured value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> frequency;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ht40;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wpa_ptk_rekey - Maximum lifetime for PTK in seconds</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value can be used to enforce rekeying of PTK to mitigate some</span></span><br><span class="line"><span class="comment">	 * attacks against TKIP deficiencies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> wpa_ptk_rekey;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * scan_freq - Array of frequencies to scan or %NULL for all</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional zero-terminated array of frequencies in</span></span><br><span class="line"><span class="comment">	 * megahertz (MHz) to include in scan requests when searching for this</span></span><br><span class="line"><span class="comment">	 * network. This can be used to speed up scanning when the network is</span></span><br><span class="line"><span class="comment">	 * known to not use all possible channels.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> *scan_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bgscan - Background scan and roaming parameters or %NULL if none</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional set of parameters for background scanning and</span></span><br><span class="line"><span class="comment">	 * roaming within a network (ESS) in following format:</span></span><br><span class="line"><span class="comment">	 * &lt;bgscan module name&gt;:&lt;module parameters&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *bgscan;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ignore_broadcast_ssid - Hide SSID in AP mode</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Send empty SSID in beacons and ignore probe request frames that do</span></span><br><span class="line"><span class="comment">	 * not specify full SSID, i.e., require stations to know SSID.</span></span><br><span class="line"><span class="comment">	 * default: disabled (0)</span></span><br><span class="line"><span class="comment">	 * 1 = send empty (length=0) SSID in beacon and ignore probe request</span></span><br><span class="line"><span class="comment">	 * for broadcast SSID</span></span><br><span class="line"><span class="comment">	 * 2 = clear SSID (ASCII 0), but keep the original length (this may be</span></span><br><span class="line"><span class="comment">	 * required with some clients that do not support empty SSID) and</span></span><br><span class="line"><span class="comment">	 * ignore probe requests for broadcast SSID</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ignore_broadcast_ssid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * freq_list - Array of allowed frequencies or %NULL for all</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional zero-terminated array of frequencies in</span></span><br><span class="line"><span class="comment">	 * megahertz (MHz) to allow for selecting the BSS. If set, scan results</span></span><br><span class="line"><span class="comment">	 * that do not match any of the specified frequencies are not</span></span><br><span class="line"><span class="comment">	 * considered when selecting a BSS.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> *freq_list;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_client_list - List of P2P Clients in a persistent group (GO)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is a list of P2P Clients (P2P Device Address) that have joined</span></span><br><span class="line"><span class="comment">	 * the persistent group. This is maintained on the GO for persistent</span></span><br><span class="line"><span class="comment">	 * group entries (disabled == 2).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 *p2p_client_list;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * num_p2p_clients - Number of entries in p2p_client_list</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">size_t</span> num_p2p_clients;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> P2P_MAX_STORED_CLIENTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P2P_MAX_STORED_CLIENTS 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* P2P_MAX_STORED_CLIENTS */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * psk_list - Per-client PSKs (struct psk_list_entry)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_list</span> <span class="title">psk_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_group - Network generated as a P2P group (used internally)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> p2p_group;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_persistent_group - Whether this is a persistent group</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> p2p_persistent_group;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * temporary - Whether this network is temporary and not to be saved</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> temporary;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * export_keys - Whether keys may be exported</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This attribute will be set when keys are determined through</span></span><br><span class="line"><span class="comment">	 * WPS or similar so that they may be exported.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> export_keys;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ANDROID_P2P</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * assoc_retry - Number of times association should be retried.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> assoc_retry;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HT_OVERRIDES</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_ht - Disable HT (IEEE 802.11n) for this network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, use it if it is available, but this can be configured</span></span><br><span class="line"><span class="comment">	 * to 1 to have it disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> disable_ht;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_ht40 - Disable HT40 for this network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, use it if it is available, but this can be configured</span></span><br><span class="line"><span class="comment">	 * to 1 to have it disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> disable_ht40;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_sgi - Disable SGI (Short Guard Interval) for this network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, use it if it is available, but this can be configured</span></span><br><span class="line"><span class="comment">	 * to 1 to have it disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> disable_sgi;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_max_amsdu - Disable MAX A-MSDU</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * A-MDSU will be 3839 bytes when disabled, or 7935</span></span><br><span class="line"><span class="comment">	 * when enabled (assuming it is otherwise supported)</span></span><br><span class="line"><span class="comment">	 * -1 (default) means do not apply any settings to the kernel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> disable_max_amsdu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ampdu_factor - Maximum A-MPDU Length Exponent</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Value: 0-3, see 7.3.2.56.3 in IEEE Std 802.11n-2009.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ampdu_factor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ampdu_density - Minimum A-MPDU Start Spacing</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Value: 0-7, see 7.3.2.56.3 in IEEE Std 802.11n-2009.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ampdu_density;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ht_mcs - Allowed HT-MCS rates, in ASCII hex: ffff0000...</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default (empty string): Use whatever the OS has configured.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> *ht_mcs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_HT_OVERRIDES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VHT_OVERRIDES</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_vht - Disable VHT (IEEE 802.11ac) for this network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, use it if it is available, but this can be configured</span></span><br><span class="line"><span class="comment">	 * to 1 to have it disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> disable_vht;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * vht_capa - VHT capabilities to use</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> vht_capa;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * vht_capa_mask - mask for VHT capabilities</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> vht_capa_mask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> vht_rx_mcs_nss_1, vht_rx_mcs_nss_2,</span><br><span class="line">	    vht_rx_mcs_nss_3, vht_rx_mcs_nss_4,</span><br><span class="line">	    vht_rx_mcs_nss_5, vht_rx_mcs_nss_6,</span><br><span class="line">	    vht_rx_mcs_nss_7, vht_rx_mcs_nss_8;</span><br><span class="line">	<span class="keyword">int</span> vht_tx_mcs_nss_1, vht_tx_mcs_nss_2,</span><br><span class="line">	    vht_tx_mcs_nss_3, vht_tx_mcs_nss_4,</span><br><span class="line">	    vht_tx_mcs_nss_5, vht_tx_mcs_nss_6,</span><br><span class="line">	    vht_tx_mcs_nss_7, vht_tx_mcs_nss_8;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_VHT_OVERRIDES */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ap_max_inactivity - Timeout in seconds to detect STA's inactivity</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This timeout value is used in AP mode to clean up inactive stations.</span></span><br><span class="line"><span class="comment">	 * By default: 300 seconds.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> ap_max_inactivity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dtim_period - DTIM period in Beacon intervals</span></span><br><span class="line"><span class="comment">	 * By default: 2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> dtim_period;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * beacon_int - Beacon interval (default: 100 TU)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> beacon_int;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * auth_failures - Number of consecutive authentication failures</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> auth_failures;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disabled_until - Network block disabled until this time if non-zero</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">os_time</span> <span class="title">disabled_until</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * parent_cred - Pointer to parent wpa_cred entry</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This pointer can be used to delete temporary networks when a wpa_cred</span></span><br><span class="line"><span class="comment">	 * that was used to create them is removed. This pointer should not be</span></span><br><span class="line"><span class="comment">	 * dereferences since it may not be updated in all cases.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> *parent_cred;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络</category>
        <category>wifi</category>
      </categories>
      <tags>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>「译」Linux DRM开发人员指南</title>
    <url>/post/3ac13ea3.html</url>
    <content><![CDATA[<p>最近在看DRM驱动相关的代码，但是总有一种盲人摸象的感觉，今天看到<a href="http://www.landley.net/kdocs/htmldocs/drm.html" target="_blank" rel="noopener">Linux DRM Developer’s Guide</a>文档，在这里简单翻译一下,可以对DRM驱动有一个整体的认识。</p>
<a id="more"></a>
<h1 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h1><p>Linux DRM层包含旨在满足复杂图形设备需求的代码，通常包含非常适合3D图形加速的可编程管线。 内核中的图形驱动程序可以利用DRM功能来简化诸如内存管理，中断处理和DMA之类的任务，并为应用程序提供统一的接口。</p>
<p>版本说明：本指南涵盖了DRM树中的功能，包括TTM内存管理器，输出配置和模式设置以及新的vblank内部，以及当前内核中的所有常规功能。</p>
<h1 id="第2章-DRM内部"><a href="#第2章-DRM内部" class="headerlink" title="第2章 DRM内部"></a>第2章 DRM内部</h1><p>本章介绍了与驱动程序作者和开发人员有关的DRM内部，这些工作人员和开发人员致力于为现有驱动程序添加对最新功能的支持。</p>
<p>首先，我们讨论一些典型的驱动程序初始化要求，例如设置命令缓冲区，创建初始输出配置以及初始化核心服务。 后续部分将更详细地介绍核心内部结构，并提供实施说明和示例。</p>
<p>DRM层为图形驱动程序提供了多种服务，其中许多服务是由它通过libdrm提供的应用程序接口驱动的，libdrm是包装大多数DRM ioctl的库。 其中包括vblank事件处理，内存管理，输出管理，帧缓冲区管理，命令提交和防护，挂起/恢复支持以及DMA服务。</p>
<h2 id="驱动程序初始化"><a href="#驱动程序初始化" class="headerlink" title="驱动程序初始化"></a>驱动程序初始化</h2><p>每个DRM驱动程序的核心是<code>drm_driver</code>结构。 驱动程序通常会静态初始化<code>drm_driver</code>结构，然后将其传递给<code>drm_*_init()</code>函数之一，以将其注册到DRM子系统。</p>
<p><code>drm_driver</code>结构包含描述驱动程序及其支持的功能的静态信息，以及指向DRM核心将调用以实现DRM API的方法的指针。 我们将首先浏览drm_driver静态信息字段，然后在以后的部分中详细描述各个操作。</p>
<h3 id="驱动信息"><a href="#驱动信息" class="headerlink" title="驱动信息"></a>驱动信息</h3><h4 id="驱动功能"><a href="#驱动功能" class="headerlink" title="驱动功能"></a>驱动功能</h4><p>驱动程序通过在<code>driver_features</code>字段中设置适当的标志来告知DRM核心其要求和支持的功能。 由于自注册以来，这些标志会影响DRM核心行为，因此必须将大多数标志设置为注册<code>drm_driver</code>实例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u32 driver_features;</span><br></pre></td></tr></table></figure>
<p>驱动程序功能标志：</p>
<ul>
<li><code>DRIVER_USE_AGP</code>： 驱动程序使用AGP接口，DRM核心将管理AGP资源。</li>
<li><code>DRIVER_REQUIRE_AGP</code>： 驱动程序需要AGP接口才能运行。 AGP初始化失败将成为致命错误。</li>
<li><code>DRIVER_PCI_DMA</code>：驱动程序具有PCI DMA的功能，将启用PCI DMA缓冲区到用户空间的映射。 不推荐使用。</li>
<li><code>DRIVER_SG</code>： 驱动程序可以执行scatter/gather DMA，将启用catter/gather缓冲区的分配和映射。 不推荐使用。</li>
<li><code>DRIVER_HAVE_DMA</code>： 驱动程序支持DMA，将支持用户空间DMA API。 不推荐使用。</li>
<li><code>DRIVER_HAVE_IRQ</code>： DRIVER_HAVE_IRQ指示驱动程序是否具有由DRM Core管理的IRQ处理程序。 设置该标志后，内核将支持简单的IRQ处理程序安装。 安装过程在“<a href="http://www.landley.net/kdocs/htmldocs/drm.html#drm-irq-registration" target="_blank" rel="noopener">IRQ注册</a>”一节中介绍。</li>
<li><code>DRIVER_IRQ_SHARED</code>：DRIVER_IRQ_SHARED指示设备和处理程序是否支持共享的IRQ（请注意，这是PCI驱动程序所必需的）。</li>
<li><code>DRIVER_GEM</code>: 驱动程序使用GEM内存管理器。</li>
<li><code>DRIVER_MODESET</code>: 驱动程序支持模式设置界面（KMS）。</li>
<li><code>DRIVER_PRIME</code>: 驱动程序实现DRM PRIME缓冲区共享。</li>
<li><code>DRIVER_RENDER</code>: 驱动程序支持专用渲染节点。</li>
</ul>
<h4 id="Major-Minor-and-Patchlevel"><a href="#Major-Minor-and-Patchlevel" class="headerlink" title="Major, Minor and Patchlevel"></a>Major, Minor and Patchlevel</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">char</span> *desc;</span><br><span class="line"><span class="keyword">char</span> *date;</span><br></pre></td></tr></table></figure>
<p>驱动程序名称在初始化时被打印到内核日志中，用于IRQ注册，并通过DRM_IOCTL_VERSION传递给用户空间。<br>驱动程序描述是通过DRM_IOCTL_VERSION ioctl传递给用户空间的纯信息字符串，否则由内核未使用。<br>格式为YYYYMMDD的驱动程序日期旨在标识对驱动程序的最新修改日期。 但是，由于大多数驱动程序无法更新它，因此它的值几乎没有用。 DRM内核在初始化时将其打印到内核日志，并通过DRM_IOCTL_VERSION ioctl将其传递到用户空间。</p>
<h3 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h3><p>加载方法是驱动程序和设备初始化的入口点。 该方法负责分配和初始化驱动程序私有数据，指定支持的性能计数器，执行资源分配和映射（例如，获取时钟，映射寄存器或分配命令缓冲区），初始化内存管理器（称为“内存管理”的部分），安装 IRQ处理程序（称为“ IRQ注册”的部分），设置垂直消隐处理（称为“垂直消隐”的部分），模式设置（称为“模式设置”的部分）和初始输出配置（称为“ KMS初始化”的部分） 和清理”）。</p>
<blockquote>
<p><strong>注</strong>:</p>
<p>如果需要考虑兼容性（例如将驱动程序从用户模式设置转换为内核模式设置），则必须小心以防止设备初始化和与当前活动的用户空间驱动程序不兼容的控制。 例如，如果正在使用用户级别模式设置驱动程序，则在加载时执行输出发现和配置会很成问题。 同样，如果使用了不了解内存管理的用户级驱动程序，则可能需要省略内存管理和命令缓冲区设置。 这些要求是特定于驱动程序的，因此必须注意使新旧应用程序和库均能正常工作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*load) (struct drm_device *, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br></pre></td></tr></table></figure>
<p>该方法有两个参数，一个指向新创建的<code>drm_device</code>的指针和标志。 这些标志用于传递与传递给<code>drm_*_init()</code>的设备相对应的设备ID的<code>driver_data</code>字段。 当前只有PCI设备使用此功能，USB和平台DRM驱动程序的加载方法称为标志0。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>现代Linux系统需要大量的图形内存来存储帧缓冲区，纹理，顶点和其他与图形相关的数据。考虑到许多数据的动态特性，因此有效管理图形内存对于图形堆栈至关重要，并且在DRM基础架构中发挥着核心作用。<br>DRM核心包括两个<code>内存管理器</code>，即<code>转换表映射（TTM）</code>和<code>图形执行管理器（GEM）</code>。 TTM是第一个开发的DRM内存管理器，并试图成为一种“千篇一律”的解决方案。它提供了一个单一的用户空间API，可满足所有硬件的需求，同时支持统一内存体系结构（UMA）设备和具有专用视频RAM的设备（即大多数离散视频卡）。这导致了一个庞大，复杂的代码片段，结果证明这些代码难以用于驱动程序开发。<br>GEM最初是由英特尔赞助的项目，以应对TTM的复杂性。它的设计理念是完全不同的：GEM没有为每个与图形内存相关的问题提供解决方案，而是确定了驱动程序之间的通用代码，并创建了一个共享它的支持库。与TTM相比，GEM的初始化和执行要求更简单，但它没有视频RAM管理功能，因此仅限于UMA设备。</p>
<h3 id="转换表管理器（TTM）"><a href="#转换表管理器（TTM）" class="headerlink" title="转换表管理器（TTM）"></a>转换表管理器（TTM）</h3><blockquote>
<p><strong>警告</strong></p>
<p>本节已过时。</p>
</blockquote>
<h3 id="图形执行管理器（GEM）"><a href="#图形执行管理器（GEM）" class="headerlink" title="图形执行管理器（GEM）"></a>图形执行管理器（GEM）</h3><p>GEM设计方法导致内存管理器无法在其用户空间或内核API中提供所有（甚至所有常见）用例的完整覆盖。 GEM向用户空间公开了一组与内存相关的标准操作，并向驱动程序提供了一组帮助程序功能，并允许驱动程序使用自己的私有API来实现特定于硬件的操作。<br>GEM-LWN上的<a href="https://lwn.net/Articles/283798/" target="_blank" rel="noopener">Graphics Execution Manager</a>文章中介绍了GEM用户空间API。尽管有些过时，但该文档很好地概述了GEM API原则。目前，使用特定于驱动程序的ioctl来实现缓冲区分配以及读写操作（作为通用GEM API的一部分进行描述）。<br>GEM与数据无关。它管理抽象缓冲区对象，而无需知道各个缓冲区包含哪些内容。因此，需要了解缓冲区内容或用途（例如缓冲区分配或同步原语）的API不在GEM的范围内，必须使用特定于驱动程序的ioctl来实现。</p>
<p>从根本上讲，GEM涉及以下几种操作：</p>
<ul>
<li>内存分配和释放</li>
<li>命令执行</li>
<li>执行命令时的光圈管理</li>
</ul>
<p>缓冲区对象分配相对简单，并且主要由Linux的shmem层提供，后者提供了用于备份每个对象的内存。</p>
<p>特定于设备的操作，例如命令执行，固定，缓冲区读写，映射和域所有权转移，留给特定于驱动程序的ioctl。</p>
<h4 id="GEM初始化"><a href="#GEM初始化" class="headerlink" title="GEM初始化"></a>GEM初始化</h4><p>使用GEM的驱动程序必须在<code>struct drm_driver</code> <code>driver_features</code>字段中设置<code>DRIVER_GEM</code>位。 然后，DRM内核将在调用装入操作之前自动初始化GEM内核。 在后台，这将创建DRM内存管理器对象，该对象提供用于对象分配的地址空间池。<br>在KMS配置中，如果硬件需要，驱动程序需要在核心GEM初始化之后分配和初始化<code>命令环缓冲区</code>。 UMA设备通常具有所谓的“被盗”存储区，该存储区为初始帧缓冲区和设备所需的大而连续的存储区提供了空间。 该空间通常不由GEM管理，必须单独初始化为它自己的DRM MM对象。</p>
<h4 id="GEM对象创建"><a href="#GEM对象创建" class="headerlink" title="GEM对象创建"></a>GEM对象创建</h4><p>GEM将GEM对象的创建和支持它们的内存分配分为两个不同的操作。</p>
<p>GEM对象由<code>struct drm_gem_object</code>的实例表示。 驱动程序通常需要使用私有信息来扩展GEM对象，从而创建特定于驱动程序的GEM对象结构类型，以嵌入<code>struct drm_gem_object</code>的实例。<br>要创建GEM对象，驱动程序会为其特定GEM对象类型的实例分配内存，并通过调用<code>drm_gem_object_init</code>初始化嵌入式结构<code>drm_gem_object</code>。 该函数获取指向DRM设备的指针，指向GEM对象的指针和缓冲区对象的大小（以字节为单位）。</p>
<p>GEM使用<code>shmem</code>分配匿名可分页内存。 <code>drm_gem_object_init</code>将创建所需大小的shmfs文件，并将其存储在<code>struct drm_gem_object filp</code>字段中。 当图形硬件直接使用系统内存时，该内存既可以用作对象的主要存储，也可以用作后备存储。<br>驱动程序负责通过为每个页面调用<code>shmem_read_mapping_page_gfp</code>来分配实际的物理页面。 请注意，它们可以在初始化GEM对象时决定分配页面，或延迟分配直到需要内存（例如，由于用户空间内存访问而导致页面错误，或者驱动程序需要启动涉及到DMA的传输时）。</p>
<p>例如，当硬件需要物理上连续的系统内存时（例如嵌入式设备中的常见情况），并不总是需要匿名的可分页内存分配。 驱动程序可以通过调用<code>drm_gem_private_object_init</code>而不是<code>drm_gem_object_init</code>来初始化没有shmfs支持的GEM对象（称为专用GEM对象）。 专用GEM对象的存储必须由驱动程序管理。</p>
<p>不需要使用私有信息扩展GEM对象的驱动程序可以调用<code>drm_gem_object_alloc</code>函数来分配和初始化结构<code>drm_gem_object</code>实例。 在使用<code>drm_gem_object_init</code>初始化GEM对象之后，GEM内核将调用可选的驱动程序<code>gem_init_object</code>操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*gem_init_object) (struct drm_gem_object *obj);</span><br></pre></td></tr></table></figure>
<p>私有GEM对象不存在alloc-and-init函数。</p>
<h4 id="GEM对象生命周期"><a href="#GEM对象生命周期" class="headerlink" title="GEM对象生命周期"></a>GEM对象生命周期</h4><p>所有GEM对象均由GEM内核<code>引用计数</code>。 可以通过分别调用<code>drm_gem_object_reference</code>和<code>drm_gem_object_unreference</code>来获取和释放引用。 调用者必须持有<code>drm_device struct_mutex</code>锁。 为了方便起见，GEM提供了可以在不持有锁的情况下调用的<code>drm_gem_object_reference_unlocked</code>和<code>drm_gem_object_unreference_unlocked</code>函数。</p>
<p>当释放对GEM对象的最后一个引用时，GEM内核将调用<code>drm_driver gem_free_object</code>操作。 该操作对于启用了GEM的驱动程序是必需的，并且必须释放GEM对象和所有关联的资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*gem_free_object) (struct drm_gem_object *obj);</span><br></pre></td></tr></table></figure>
<p>驱动程序负责释放所有GEM对象资源，包括GEM核心创建的资源。 如果已经为对象创建了<code>mmap</code>偏移量（在这种情况下，drm_gem_object::map_list::map不为NULL），则必须通过调用<code>drm_gem_free_mmap_offset</code>来释放它。 必须通过调用<code>drm_gem_object_release</code>释放shmfs后备存储（如果未创建任何shmfs后备存储，则可以安全地调用该函数）。</p>
<h4 id="GEM对象命名"><a href="#GEM对象命名" class="headerlink" title="GEM对象命名"></a>GEM对象命名</h4><p>用户空间和内核之间的通信使用本地句柄，全局名称或最近使用的文件描述符来引用GEM对象。 所有这些都是32位整数值。 通常的Linux内核限制适用于文件描述符。<br>GEM句柄是DRM文件本地的。 应用程序通过特定于驱动程序的ioctl获取GEM对象的句柄，并且可以使用该句柄引用其他标准或特定于驱动程序的ioctl中的GEM对象。 关闭DRM文件句柄将释放其所有GEM句柄并取消引用关联的GEM对象。</p>
<h5 id="DRM-PRIME辅助功能参考"><a href="#DRM-PRIME辅助功能参考" class="headerlink" title="DRM PRIME辅助功能参考"></a>DRM PRIME辅助功能参考</h5><h4 id="GEM对象映射"><a href="#GEM对象映射" class="headerlink" title="GEM对象映射"></a>GEM对象映射</h4><p>因为映射操作相当繁重，所以与通过将缓冲区映射到用户空间相比，GEM支持通过特定于驱动程序的ioctl实现对缓冲区的类似于读/写的访问。 但是，当需要随机访问缓冲区（例如执行软件渲染）时，直接访问对象可能会更有效率。<br>mmap系统调用不能直接用于映射GEM对象，因为它们没有自己的文件句柄。 当前共存在两种方法来将GEM对象映射到用户空间。 第一种方法使用特定于驱动程序的ioctl来执行映射操作，并在后台调用do_mmap。 这通常被认为是可疑的，似乎不建议使用支持GEM的新驱动程序，因此在此不再赘述。</p>
<h4 id="Dumb-GEM对象"><a href="#Dumb-GEM对象" class="headerlink" title="Dumb GEM对象"></a>Dumb GEM对象</h4><p>GEM API并未将GEM对象创建标准化，而是将其留给特定于驱动程序的ioctl。 对于包含特定于设备的用户空间组件（例如，在libdrm中）的完整图形堆栈来说，这不是一个问题，但此限制使基于DRM的早期启动图形不必要地复杂。<br><code>Dumb GEM</code>对象通过提供标准API来创建适合于扫描的哑缓冲区，从而部分缓解了该问题，然后可以将其用于创建KMS帧缓冲区。</p>
<h4 id="内存一致性-——-Memory-Coherency"><a href="#内存一致性-——-Memory-Coherency" class="headerlink" title="内存一致性 —— Memory Coherency"></a>内存一致性 —— Memory Coherency</h4><h4 id="命令执行-——-Command-Execution"><a href="#命令执行-——-Command-Execution" class="headerlink" title="命令执行 —— Command Execution"></a>命令执行 —— Command Execution</h4><h2 id="模式设置（Mode-Setting）"><a href="#模式设置（Mode-Setting）" class="headerlink" title="模式设置（Mode Setting）"></a>模式设置（Mode Setting）</h2><p>驱动程序必须通过在DRM设备上调用<code>drm_mode_config_init</code>来初始化模式设置核心。 该函数初始化<code>drm_device mode_config</code>字段，并且永不失败。 完成后，必须通过初始化以下字段来设置模式配置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> min_width, min_height;</span><br><span class="line"><span class="keyword">int</span> max_width, max_height;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>帧缓冲区的最小和最大宽度和高度，以像素为单位。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_config_funcs</span> *<span class="title">funcs</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>模式设定函数</p>
</blockquote>
<h3 id="帧缓冲区创建"><a href="#帧缓冲区创建" class="headerlink" title="帧缓冲区创建"></a>帧缓冲区创建</h3><h3 id="输出轮询——Output-Polling"><a href="#输出轮询——Output-Polling" class="headerlink" title="输出轮询——Output Polling"></a>输出轮询——Output Polling</h3><h3 id="锁定——Locking"><a href="#锁定——Locking" class="headerlink" title="锁定——Locking"></a>锁定——Locking</h3><p>除了某些具有自己的锁定的查找结构（隐藏在接口功能后面）之外，大多数模式集状态还受<code>dev-&gt;mode_config.lock</code>互斥锁以及逐个<code>crtc锁</code>的保护，以允许进行<code>光标更新</code>，<code>页面翻转</code>和后台任务（例如输出检测）同时发生的类似操作。 跨域的操作（例如完整模式集）始终会抓住所有锁。 那里的驱动程序需要通过额外的锁定来保护crtcs之间共享的资源。 如果modset功能碰到crtc状态，例如，如果他们碰到crtc状态，他们还需要小心以始终抓住相关的crtc锁。 用于负载检测（仅抓取<code>mode_config.lock</code>以允许实时crtcs上的并发屏幕更新）。</p>
<h2 id="KMS初始化和清理"><a href="#KMS初始化和清理" class="headerlink" title="KMS初始化和清理"></a>KMS初始化和清理</h2><p>KMS设备被抽象并作为一组平面，<code>CRTC</code>，<code>encoders</code>和<code>connectors</code>。 因此，KMS驱动程序必须在初始化模式设置后的加载时创建并初始化所有这些对象。</p>
<h3 id="CRTCs-struct-drm-crtc"><a href="#CRTCs-struct-drm-crtc" class="headerlink" title="CRTCs (struct drm_crtc)"></a>CRTCs (struct drm_crtc)</h3><p><code>CRTC</code>是代表芯片一部分的抽象，其中包含指向扫描缓冲区的指针。 因此，可用的CRTC数量决定了在任何给定时间可以激活多少个独立的扫描缓冲区。 CRTC结构包含几个字段来支持此操作：指向某些视频内存的指针（抽象为帧缓冲区对象），显示模式以及视频内存中的（x，y）偏移量以支持平移或配置，其中一个 视频存储器跨越多个CRTC。</p>
<h4 id="CRTC初始化"><a href="#CRTC初始化" class="headerlink" title="CRTC初始化"></a>CRTC初始化</h4><p>KMS设备必须创建并注册至少一个<code>struct drm_crtc</code>实例。 该实例可能由驱动程序分配并归零（可能是较大结构的一部分），并使用指向CRTC函数的指针通过调用<code>drm_crtc_init</code>进行注册。</p>
<h4 id="CRTC运作"><a href="#CRTC运作" class="headerlink" title="CRTC运作"></a>CRTC运作</h4><h5 id="Set-Configuration"><a href="#Set-Configuration" class="headerlink" title="Set Configuration"></a>Set Configuration</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*set_config)(struct drm_mode_set *<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure>
<p>将新的CRTC配置应用于设备。 该配置指定了CRTC，要从中扫描出的帧缓冲区，帧缓冲区中的（x，y）位置，显示模式以及连接器阵列（如果可能）以CRTC驱动。<br>如果配置中指定的帧缓冲区为NULL，则驱动程序必须分离所有连接到CRTC的编码器和所有连接到这些编码器的连接器，并禁用它们。<br>在保持模式配置锁定的情况下调用此操作。</p>
<blockquote>
<p><strong>注</strong>:</p>
<p>FIXME：set_config应该如何与DPMS交互？ 如果CRTC被暂停，是否应该恢复？</p>
</blockquote>
<h5 id="Page-Flipping"><a href="#Page-Flipping" class="headerlink" title="Page Flipping"></a>Page Flipping</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*page_flip)(struct drm_crtc *crtc, struct drm_framebuffer *fb,</span><br><span class="line">                   struct drm_pending_vblank_event *event);</span><br></pre></td></tr></table></figure>
<p>将<code>页面翻转</code>到CRTC的给定<code>帧缓冲区</code>。在保持模式配置互斥锁的情况下调用此操作。<br><code>页面翻转</code>是一种<code>同步机制</code>，可以在<code>垂直消隐期</code>(vblank)间将CRTC扫描出的帧缓冲区替换为新的帧缓冲区，从而避免撕裂。当应用程序请求页面翻转时，DRM内核将验证新的帧缓冲区是否足够大，以供CRTC在当前配置的模式下进行扫描，然后使用指向新帧缓冲区的指针调用CRTC page_flip操作。<br><code>page_flip</code>操作安排页面翻转。一旦完成了针对新帧缓冲区的任何暂挂渲染，CRTC将重新编程为在下一次垂直刷新后显示该帧缓冲区。该操作必须立即返回，而不必等待渲染或页面翻转完成，并且必须阻止任何新的渲染到帧缓冲区，直到页面翻转完成。<br>如果可以成功调度页面翻转，则驱动程序必须将<code>drm_crtc-&gt;fb</code>字段设置为fb指向的新帧缓冲区。这一点很重要，这样可以使基于帧缓冲区的引用计数保持平衡。<br>如果页面翻转已经挂起，则page_flip操作必须返回-EBUSY。</p>
<p>为了将页面翻转同步到<code>垂直消隐</code>，驱动程序可能需要启用<code>垂直消隐</code>中断。 为此，它应该调用<code>drm_vblank_get</code>，并在页面翻转完成后调用<code>drm_vblank_put</code>。<br>如果在翻页完成时请求通知应用程序，则将使用指向<code>drm_pending_vblank_event</code>实例的非NULL事件参数来调用<code>page_flip</code>操作。 翻页完成后，驱动程序必须调用<code>drm_send_vblank_event</code>填写事件并发送以唤醒所有等待的进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">...</span><br><span class="line">drm_send_vblank_event(dev, pipe, event);</span><br><span class="line">spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注</strong>:</p>
<p>FIXME：不需要等待渲染完成的驱动程序是否可以将事件添加到dev-&gt; vblank_event_list并让DRM内核处理所有事情，例如“常规”垂直消隐事件？</p>
</blockquote>
<p>在等待页面翻转完成时，驱动程序可以自由使用<code>event-&gt;base.link</code>列表头，以将未决事件存储在特定于驱动程序的列表中。<br>如果在发出事件信号之前关闭了文件句柄，则驱动程序必须注意在其预关闭操作中销毁该事件（如果需要，请调用<code>drm_vblank_put</code>）。</p>
<h5 id="Miscellaneous（其他）"><a href="#Miscellaneous（其他）" class="headerlink" title="Miscellaneous（其他）"></a>Miscellaneous（其他）</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*set_property)(struct drm_crtc *crtc,</span><br><span class="line">                     struct drm_property *property, <span class="keyword">uint64_t</span> value);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将给定的CRTC属性的值设置为value。 有关属性的更多信息，请参见“ KMS属性”一节。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,</span><br><span class="line">                        <span class="keyword">uint32_t</span> start, <span class="keyword">uint32_t</span> <span class="built_in">size</span>);</span><br><span class="line">&gt; 将灰度系数应用于设备。 该操作是可选的。</span><br><span class="line"></span><br><span class="line">``` C</span><br><span class="line"><span class="keyword">void</span> (*destroy)(struct drm_crtc *crtc);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不再需要时销毁CRTC。 请参阅“ KMS初始化和清理”部分。</p>
</blockquote>
<h3 id="Planes-struct-drm-plane"><a href="#Planes-struct-drm-plane" class="headerlink" title="Planes (struct drm_plane)"></a>Planes (struct drm_plane)</h3><p>平面(plane)表示可以在扫描过程中与CRTC<code>混合</code>或<code>叠加</code>在CRTC顶部的图像源。 平面与帧缓冲区关联，以裁剪图像存储器（源）的一部分，并可以选择将其缩放到目标大小。 然后将结果与CRTC混合或叠加在CRTC之上。</p>
<h4 id="Plane-Initialization"><a href="#Plane-Initialization" class="headerlink" title="Plane Initialization"></a>Plane Initialization</h4><p>平面是可选的。 要创建平面，KMS驱动程序会分配<code>struct drm_plane</code>实例（可能是较大结构的一部分）的实例并将其清零，并通过调用<code>drm_plane_init</code>对其进行注册。 该函数采用可与平面关联的CRTC的位掩码，指向平面函数的指针以及格式支持的格式的列表。</p>
<h4 id="Plane-Operations"><a href="#Plane-Operations" class="headerlink" title="Plane Operations"></a>Plane Operations</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*update_plane)(struct drm_plane *plane, struct drm_crtc *crtc,</span><br><span class="line">                        struct drm_framebuffer *fb, <span class="keyword">int</span> crtc_x, <span class="keyword">int</span> crtc_y,</span><br><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> crtc_w, <span class="keyword">unsigned</span> <span class="keyword">int</span> crtc_h,</span><br><span class="line">                        <span class="keyword">uint32_t</span> src_x, <span class="keyword">uint32_t</span> src_y,</span><br><span class="line">                        <span class="keyword">uint32_t</span> src_w, <span class="keyword">uint32_t</span> src_h);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启用并配置平面以使用给定的CRTC和帧缓冲区。</p>
</blockquote>
<p>帧缓冲存储器坐标中的源矩形由<code>src_x</code>，<code>src_y</code>，<code>src_w</code>和<code>src_h</code>参数（作为16.16定点值）给出。 不支持亚像素平面坐标的设备可以忽略小数部分。<br>CRTC坐标中的目标矩形由<code>crtc_x</code>，<code>crtc_y</code>，<code>crtc_w</code>和<code>crtc_h</code>参数（作为整数值）给出。 设备将源矩形缩放为目标矩形。 如果不支持缩放，并且源矩形大小与目标矩形大小不匹配，则驱动程序必须返回-EINVAL错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*disable_plane)(struct drm_plane *plane);</span><br></pre></td></tr></table></figure>
<p>禁用平面。 DRM内核会调用此方法，以响应将帧缓冲区ID设置为0，<code>DRM_IOCTL_MODE_SETPLANE</code> ioctl调用。CRTC不能处理禁用的平面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*destroy)(struct drm_plane *plane);</span><br></pre></td></tr></table></figure>
<p>不再需要时销毁平面。 请参阅“ KMS初始化和清理”部分。</p>
<h3 id="Encoders-struct-drm-encoder"><a href="#Encoders-struct-drm-encoder" class="headerlink" title="Encoders (struct drm_encoder)"></a>Encoders (struct drm_encoder)</h3><p><code>编码器</code>从CRTC提取像素数据，并将其转换为适合任何连接的<code>连接器</code>的格式。 在某些设备上，CRTC可能会向多个编码器发送数据。 在那种情况下，两个编码器都将从同一个扫描缓冲区接收数据，从而导致跨连接到每个编码器的连接器的“克隆”显示配置。</p>
<h4 id="Encoder-Initialization"><a href="#Encoder-Initialization" class="headerlink" title="Encoder Initialization"></a>Encoder Initialization</h4><p>对于CRTC，KMS驱动程序必须创建，初始化和注册至少一个<code>struct drm_encoder</code>实例。 该实例由驱动程序分配并归零，可能是较大结构的一部分。<br>驱动程序必须在注册编码器之前初始化<code>struct drm_encoder</code>可能的<code>_crtcs</code>和可能的克隆字段。 这两个字段分别是编码器可以连接到的CRTC的位掩码，并且是用于克隆的同级编码器。<br>初始化之后，必须使用对<code>drm_encoder_init</code>的调用来注册编码器。 该函数获取指向编码器功能和编码器类型的指针。 支持的类型是</p>
<ul>
<li>DRM_MODE_ENCODER_DAC用于VGA和DVI-I / DVI-A上的模拟</li>
<li>DRM_MODE_ENCODER_TMDS用于DVI，HDMI和（嵌入式）DisplayPort</li>
<li>DRM_MODE_ENCODER_LVDS用于显示面板</li>
<li>用于电视输出的DRM_MODE_ENCODER_TVDAC（复合，S视频，分量，SCART）</li>
<li>DRM_MODE_ENCODER_VIRTUAL用于虚拟机显示</li>
</ul>
<p><code>编码器</code>必须连接到<code>CRTC</code>才能使用。 DRM驱动程序在初始化时不附加编码器。 应用程序（或实现时的fbdev兼容性层）负责将要使用的编码器附加到CRTC。</p>
<h4 id="Encoder-Operations"><a href="#Encoder-Operations" class="headerlink" title="Encoder Operations"></a>Encoder Operations</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*destroy)(struct drm_encoder *encoder);</span><br></pre></td></tr></table></figure>
<p>在不再需要时调用以销毁编码器。 请参阅“ KMS初始化和清理”部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*set_property)(struct drm_plane *plane,</span><br><span class="line">                     struct drm_property *property, <span class="keyword">uint64_t</span> value);</span><br></pre></td></tr></table></figure>
<p>将给定平面属性的值设置为value。 有关属性的更多信息，请参见“ KMS属性”一节。</p>
<h3 id="Connectors-struct-drm-connector"><a href="#Connectors-struct-drm-connector" class="headerlink" title="Connectors (struct drm_connector)"></a>Connectors (struct drm_connector)</h3><p><code>连接器</code>是设备上像素数据的最终目标，并且通常直接连接到外部显示设备，例如监视器或笔记本电脑面板。 一次只能将一个连接器连接到一个编码器。 连接器也是保留有关附加显示器信息的结构，因此它包含显示数据，EDID数据，DPMS和连接状态以及有关附加显示器支持的模式的信息的字段。</p>
<h4 id="Connector-Initialization"><a href="#Connector-Initialization" class="headerlink" title="Connector Initialization"></a>Connector Initialization</h4><p>最后，KMS驱动程序必须创建，初始化，注册并附加至少一个<code>struct drm_connector</code>实例。 该实例将与其他KMS对象一起创建，并通过设置以下字段进行初始化。</p>
<ul>
<li><code>interlace_allowed</code>： 连接器是否可以处理隔行模式。</li>
<li><code>doublescan_allowed</code>：连接器是否可以处理双重扫描。</li>
<li><code>display_info</code>：当检测到显示时，显示信息由<code>EDID</code>信息填充。 对于嵌入式系统中的非热插拔显示器（如平板显示器），驱动程序应使用显示器的物理尺寸初始化<code>display_info.width_mm</code>和<code>display_info.height_mm</code>字段。</li>
<li><code>polled</code>： 连接器轮询模式，组合<ul>
<li><code>DRM_CONNECTOR_POLL_HPD</code>：连接器会生成热插拔事件，不需要定期进行轮询。 不能将<code>CONNECT和DISCONNECT</code>标志与<code>HPD</code>标志一起设置。</li>
<li><code>DRM_CONNECTOR_POLL_CONNECT</code>：定期轮询连接器以进行连接。</li>
<li><code>DRM_CONNECTOR_POLL_DISCONNECT</code>：定期轮询连接器是否断开连接。</li>
</ul>
</li>
</ul>
<p>对于不支持连接状态发现的连接器，设置为0。</p>
<p>然后，使用指向连接器功能和连接器类型的指针，调用<code>drm_connector_init</code>来注册连接器，并通过调用<code>drm_sysfs_connector_add</code>通过sysfs公开连接器。</p>
<p>支持的连接器类型为：</p>
<ul>
<li>DRM_MODE_CONNECTOR_VGA</li>
<li>DRM_MODE_CONNECTOR_DVII</li>
<li>DRM_MODE_CONNECTOR_DVID</li>
<li>DRM_MODE_CONNECTOR_DVIA</li>
<li>DRM_MODE_CONNECTOR_Composite</li>
<li>DRM_MODE_CONNECTOR_SVIDEO</li>
<li>DRM_MODE_CONNECTOR_LVDS</li>
<li>DRM_MODE_CONNECTOR_Component</li>
<li>DRM_MODE_CONNECTOR_9PinDIN</li>
<li>DRM_MODE_CONNECTOR_DisplayPort</li>
<li>DRM_MODE_CONNECTOR_HDMIA</li>
<li>DRM_MODE_CONNECTOR_HDMIB</li>
<li>DRM_MODE_CONNECTOR_TV</li>
<li>DRM_MODE_CONNECTOR_eDP</li>
<li>DRM_MODE_CONNECTOR_VIRTUAL</li>
</ul>
<p>必须将<code>connector</code>连接到<code>encoder</code>上才能使用。 对于将连接器映射到编码器1：1的设备，应在初始化时通过调用<code>drm_mode_connector_attach_encoder</code>来连接连接器。 驱动程序还必须将<code>drm_connector</code>编码器字段设置为指向附加的编码器。</p>
<p>最后，驱动程序必须通过调用<code>drm_kms_helper_poll_init</code>来初始化连接器状态更改检测。 如果至少一个连接器是可轮询的，但不能生成热插拔中断（由<code>DRM_CONNECTOR_POLL_CONNECT</code>和<code>DRM_CONNECTOR_POLL_DISCONNECT</code>连接器标志指示），则延迟的工作将自动排队，以定期轮询更改。 可以生成热插拔中断的连接器必须改用<code>DRM_CONNECTOR_POLL_HPD</code>标志进行标记，并且它们的中断处理程序必须调用<code>drm_helper_hpd_irq_event</code>。 该功能将使延迟的工作排队等待检查所有连接器的状态，但是不会进行定期轮询。</p>
<h4 id="Connector-Operations"><a href="#Connector-Operations" class="headerlink" title="Connector Operations"></a>Connector Operations</h4><blockquote>
<p><strong>注</strong>:</p>
<p>除非另有说明，否则所有操作都是强制性的。</p>
</blockquote>
<h5 id="DPMS-Display-Power-Management-Signaling"><a href="#DPMS-Display-Power-Management-Signaling" class="headerlink" title="DPMS(Display Power Management Signaling)"></a>DPMS(Display Power Management Signaling)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*dpms)(struct drm_connector *connector, <span class="keyword">int</span> mode);</span><br></pre></td></tr></table></figure>
<p>DPMS操作设置连接器的电源状态。 模式参数是以下之一</p>
<ul>
<li>DRM_MODE_DPMS_ON</li>
<li>DRM_MODE_DPMS_STANDBY</li>
<li>DRM_MODE_DPMS_SUSPEND</li>
<li>DRM_MODE_DPMS_OFF</li>
</ul>
<p>在除DPMS_ON模式以外的所有模式下，连接器所连接的编码器均应通过适当地驱动其信号，将显示器置于低功耗模式。 如果编码器上连接了多个连接器，则应注意不要改变其他显示器的电源状态。 当所有相关的连接器都置于低功耗模式时，应将低功耗模式传播到编码器和CRTC。</p>
<h5 id="Modes"><a href="#Modes" class="headerlink" title="Modes"></a>Modes</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fill_modes)(struct drm_connector *connector, <span class="keyword">uint32_t</span> max_width,</span><br><span class="line">                      <span class="keyword">uint32_t</span> max_height);</span><br></pre></td></tr></table></figure>
<p>用连接器所有受支持的模式填充模式列表。 如果<code>max_width</code>和<code>max_height</code>参数不为零，则实现必须忽略所有大于<code>max_width</code>或大于<code>max_height</code>的模式。</p>
<p>连接器还必须使用连接的显示器物理尺寸（以毫米为单位）填写此操作的<code>display_info width_mm</code>和<code>height_mm</code>字段。 如果该值未知或不适用（例如，对于投影仪设备），则应将字段设置为0。</p>
<h5 id="Connection-Status"><a href="#Connection-Status" class="headerlink" title="Connection Status"></a>Connection Status</h5><p>如果支持，则通过轮询或热插拔事件更新连接状态（请参阅<a href>polled</a>）。 状态值通过ioctls报告给用户空间，并且不能在驱动程序内部使用，因为状态值只能通过从用户空间调用drm_mode_getconnector进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> <span class="title">drm_connector_status</span> <span class="params">(*detect)</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">bool</span> force)</span></span>;</span><br></pre></td></tr></table></figure>
<p>检查是否有任何东西连接到连接器。 由于用户请求，在轮询时将<code>force</code>参数设置为false，或者在检查连接器时将<code>force</code>参数设置为true。 驾驶员可以使用这种力来避免自动探测过程中昂贵的破坏性操作。<br>如果连接器已连接某些东西，则返回<code>connector_status_connected</code>；如果未连接任何东西，则返回<code>connector_status_disconnected</code>；如果连接状态未知，则返回<code>connector_status_unknown</code>。<br>如果确实已将连接状态探测为已连接，则驱动程序仅应返回connector_status_connected。 无法检测到连接状态的连接器或失败的连接状态探测，应返回connector_status_unknown。</p>
<h5 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*set_property)(struct drm_connector *connector,</span><br><span class="line">                     struct drm_property *property, <span class="keyword">uint64_t</span> value);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将给定的连接器属性的值设置为value。 有关属性的更多信息，请参见“ KMS属性”一节。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*destroy)(struct drm_connector *connector);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不再需要时销毁连接器。 请参阅“ KMS初始化和清理”部分。</p>
</blockquote>
<h3 id="Cleanup"><a href="#Cleanup" class="headerlink" title="Cleanup"></a>Cleanup</h3><p>DRM核心管理其对象的生存期。 当不再需要某个对象时，内核调用其destroy函数，该函数必须清除并释放为该对象分配的所有资源。 每个<code>drm_*_init</code>调用必须与相应的<code>drm_*_cleanup</code>调用匹配，以清理CRTC（drm_crtc_cleanup），平面（drm_plane_cleanup），编码器（drm_encoder_cleanup）和连接器（drm_connector_cleanup）。 此外，在调用<code>drm_connector_cleanup</code>之前，必须通过调用<code>drm_sysfs_connector_remove</code>来删除已添加到sysfs的连接器。</p>
<p>必须通过调用<code>drm_kms_helper_poll_fini</code>清除连接器状态更改检测。</p>
<h3 id="Output-discovery-and-initialization-example"><a href="#Output-discovery-and-initialization-example" class="headerlink" title="Output discovery and initialization example"></a>Output discovery and initialization example</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intel_crt_init</span><span class="params">(struct drm_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">intel_output</span> *<span class="title">intel_output</span>;</span></span><br><span class="line"></span><br><span class="line">	intel_output = kzalloc(<span class="keyword">sizeof</span>(struct intel_output), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!intel_output)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	connector = &amp;intel_output-&gt;base;</span><br><span class="line">	drm_connector_init(dev, &amp;intel_output-&gt;base,</span><br><span class="line">			   &amp;intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);</span><br><span class="line"></span><br><span class="line">	drm_encoder_init(dev, &amp;intel_output-&gt;enc, &amp;intel_crt_enc_funcs,</span><br><span class="line">			 DRM_MODE_ENCODER_DAC);</span><br><span class="line"></span><br><span class="line">	drm_mode_connector_attach_encoder(&amp;intel_output-&gt;base,</span><br><span class="line">					  &amp;intel_output-&gt;enc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up the DDC bus. */</span></span><br><span class="line">	intel_output-&gt;ddc_bus = intel_i2c_create(dev, GPIOA, <span class="string">"CRTDDC_A"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!intel_output-&gt;ddc_bus) &#123;</span><br><span class="line">		dev_printk(KERN_ERR, &amp;dev-&gt;pdev-&gt;dev, <span class="string">"DDC bus registration "</span></span><br><span class="line">			   <span class="string">"failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	intel_output-&gt;type = INTEL_OUTPUT_ANALOG;</span><br><span class="line">	connector-&gt;interlace_allowed = <span class="number">0</span>;</span><br><span class="line">	connector-&gt;doublescan_allowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	drm_encoder_helper_add(&amp;intel_output-&gt;enc, &amp;intel_crt_helper_funcs);</span><br><span class="line">	drm_connector_helper_add(connector, &amp;intel_crt_connector_helper_funcs);</span><br><span class="line"></span><br><span class="line">	drm_sysfs_connector_add(connector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例（取自i915驱动程序）中，创建了CRTC，连接器和编码器组合。 还创建了特定于设备的i2c总线，以获取EDID数据并执行监视器检测。 该过程完成后，将向sysfs注册新的连接器，以使其属性可用于应用程序。</p>
<h3 id="KMS-API-Functions"><a href="#KMS-API-Functions" class="headerlink" title="KMS API Functions"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp5132320" target="_blank" rel="noopener">KMS API Functions</a></h3><h2 id="Mode-Setting-Helper-Functions"><a href="#Mode-Setting-Helper-Functions" class="headerlink" title="Mode Setting Helper Functions"></a>Mode Setting Helper Functions</h2><p>驱动程序提供的<code>CRTC</code>，<code>编码器</code>和<code>连接器</code>功能实现DRM API。它们由DRM核心和ioctl处理程序调用以处理设备状态更改和配置请求。由于实现这些功能通常需要特定于驱动程序的逻辑，因此可以使用中间层帮助程序功能来避免重复样板代码。</p>
<p>DRM核心包含一个<code>中间层(mid-layer)</code>实现。中间层提供了几种<code>CRTC</code>，<code>编码器</code>和<code>连接器</code>功能的实现（从中间层的顶部调用），这些功能可预处理请求并调用驱动程序提供的较低级功能（在中间层的底部） 。例如，<code>drm_crtc_helper_set_config</code>函数可用于填充结构<code>drm_crtc_funcs set_config</code>字段。调用时，它将<code>set_config</code>操作拆分为更小，更简单的操作，并调用驱动程序进行处理。</p>
<p>要使用中间层，驱动程序调用<code>drm_crtc_helper_add</code>，<code>drm_encoder_helper_add</code>和<code>drm_connector_helper_add</code>函数以安装其中间层底层操作处理程序，并使用指向中间层顶层API的指针填充drm_crtc_funcs，drm_encoder_funcs和drm_connector_funcs结构。最好在注册相应的KMS对象之后立即完成中间层底部操作处理程序的安装。</p>
<p><code>mid-layer</code>未在<code>CRTC</code>，<code>encoder</code>和<code>connector</code>操作之间划分。要使用它，驱动程序必须为所有三个KMS实体提供底层功能。</p>
<h3 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drm_crtc_helper_set_config</span><span class="params">(struct drm_mode_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>drm_crtc_helper_set_config</code>帮助器函数是CRTC <code>set_config</code>实现。它首先尝试通过调用连接器<code>best_encoder</code>帮助程序操作来找到每个连接器的最佳编码器。</p>
<p>找到合适的编码器后，帮助器函数将调用<code>mode_fixup</code>编码器和CRTC帮助器操作来调整请求的模式，或者完全拒绝该模式，在这种情况下，错误将返回给应用程序。如果模式调整后的新配置与当前配置相同，则辅助功能将返回而无需执行任何其他操作。</p>
<p>如果调整后的模式与当前模式相同，但是需要对帧缓冲区进行更改，则<code>drm_crtc_helper_set_config</code>函数将调用CRTC <code>mode_set_base</code>帮助程序操作。如果调整后的模式不同于当前模式，或者如果未提供<code>mode_set_base</code>辅助操作，则辅助功能通过按此顺序调用prepare，mode_set以及commit CRTC和编码器辅助操作来执行完整模式设置序列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drm_helper_connector_dpms</span><span class="params">(struct drm_connector *connector, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>drm_helper_connector_dpms</code>帮助器函数是一个连接器dpms实现，可跟踪连接器的电源状态。 要使用该功能，驱动程序必须为CRTC和编码器提供dpms帮助程序操作，以将DPMS状态应用于设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drm_helper_probe_single_connector_modes</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">uint32_t</span> maxX, <span class="keyword">uint32_t</span> maxY)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>drm_helper_probe_single_connector_modes</code>帮助器函数是连接器<code>fill_modes</code>实现，该实现更新连接器的连接状态，然后通过调用连接器<code>get_modes</code>帮助器操作来检索模式列表。</p>
<p>如果指定，该函数将滤除大于max_width和max_height的模式。 然后，它为所探测列表中的每个模式调用连接器mode_valid helper操作，以检查该模式是否对连接器有效。</p>
<h3 id="CRTC-Helper-Operations"><a href="#CRTC-Helper-Operations" class="headerlink" title="CRTC Helper Operations"></a>CRTC Helper Operations</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*mode_fixup)(struct drm_crtc *crtc,</span><br><span class="line">                       <span class="keyword">const</span> struct drm_display_mode *mode,</span><br><span class="line">                       struct drm_display_mode *adjusted_mode);</span><br></pre></td></tr></table></figure>
<p>让CRTC调整请求的模式或完全拒绝它。 如果模式被接受（可能在调整之后），则此操作返回true；如果模式被拒绝，则返回false。</p>
<p>如果无法合理使用<code>mode_fixup</code>操作，则应拒绝该模式。 在这种情况下，“合理”的定义目前是模糊的。 一种可能的行为是，当将固定模式面板与能够缩放的硬件一起使用时，将调整后的模式设置为面板定时。 另一行为是接受任何输入模式并将其调整为硬件支持的最接近模式（FIXME：这需要澄清）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*mode_set_base)(struct drm_crtc *crtc, <span class="keyword">int</span> x, <span class="keyword">int</span> y,</span><br><span class="line">                     struct drm_framebuffer *old_fb)</span><br></pre></td></tr></table></figure>
<p>将当前帧缓冲区（存储在crtc-&gt; fb中）上的CRTC移到位置（x，y）。 帧缓冲区，x位置或y位置中的任何一个都可能已被修改。<br>此帮助程序操作是可选的。 如果未提供，则<code>drm_crtc_helper_set_config</code>函数将退回到<code>mode_set</code>帮助程序操作。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>FIXME：为什么将x和y作为参数传递，因为可以通过<code>crtc-&gt;x</code>和<code>crtc-&gt;y</code>来访问它们？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="built_in">prepare</span>)(struct drm_crtc *crtc);</span><br></pre></td></tr></table></figure>
<p>准备CRTC以进行模式设置。 验证请求的模式后，将调用此操作。 驱动程序使用它来执行设置新模式之前所需的设备特定操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*mode_set)(struct drm_crtc *crtc, struct drm_display_mode *mode,</span><br><span class="line">                struct drm_display_mode *adjusted_mode, <span class="keyword">int</span> x, <span class="keyword">int</span> y,</span><br><span class="line">                struct drm_framebuffer *old_fb);</span><br></pre></td></tr></table></figure>
<p>设置新的模式，位置和帧缓冲区。 取决于设备要求，该模式可以由驱动程序在内部存储，并在<code>commit</code>操作中应用，或立即编程到硬件。<br>成功时，<code>mode_set</code>操作将返回0，如果发生错误，则返回负错误代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*commit)(struct drm_crtc *crtc);</span><br></pre></td></tr></table></figure>
<p>提交模式。 设置新模式后将调用此操作。 返回时，设备必须使用新模式并可以完全操作。</p>
<h3 id="Encoder-Helper-Operations"><a href="#Encoder-Helper-Operations" class="headerlink" title="Encoder Helper Operations"></a>Encoder Helper Operations</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*mode_fixup)(struct drm_encoder *encoder,</span><br><span class="line">                       <span class="keyword">const</span> struct drm_display_mode *mode,</span><br><span class="line">                       struct drm_display_mode *adjusted_mode);</span><br></pre></td></tr></table></figure>
<p>让编码器调整请求的模式或完全拒绝它。 如果模式被接受（可能在调整之后），则此操作返回true；如果模式被拒绝，则返回false。 有关允许的调整的说明，请参见mode_fixup CRTC帮助器操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="built_in">prepare</span>)(struct drm_encoder *encoder);</span><br></pre></td></tr></table></figure>
<p>准备编码器以进行模式设置。 验证请求的模式后，将调用此操作。 驱动程序使用它来执行设置新模式之前所需的设备特定操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*mode_set)(struct drm_encoder *encoder,</span><br><span class="line">                 struct drm_display_mode *mode,</span><br><span class="line">                 struct drm_display_mode *adjusted_mode);</span><br></pre></td></tr></table></figure>
<p>设置新模式。 取决于设备要求，该模式可以由驱动程序在内部存储，并在<code>commit</code>操作中应用，或立即编程到硬件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*commit)(struct drm_encoder *encoder);</span><br></pre></td></tr></table></figure>
<p>提交模式。 设置新模式后将调用此操作。 返回时，设备必须使用新模式并可以完全操作。</p>
<h3 id="Connector-Helper-Operations"><a href="#Connector-Helper-Operations" class="headerlink" title="Connector Helper Operations"></a>Connector Helper Operations</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> *(*<span class="title">best_encoder</span>)(<span class="title">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>);</span></span><br></pre></td></tr></table></figure>
<p>将指针返回到连接器的最佳编码器。 将连接器映射到编码器1：1的设备只需将指针返回到关联的编码器即可。 此操作是强制性的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> *(*<span class="title">best_encoder</span>)(<span class="title">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>);</span></span><br></pre></td></tr></table></figure>
<p>通过使用<code>drm_add_edid_modes</code>解析EDID数据或直接为每种受支持的模式调用<code>drm_mode_probed_add</code>来填充连接器的<code>probed_modes</code>列表，并返回其检测到的模式数。 此操作是强制性的。</p>
<p>手动添加模式时，驱动程序通过调用<code>drm_mode_create</code>来创建每种模式，并且必须填写以下字段。</p>
<ul>
<li><code>__u32 type;</code><ul>
<li><code>DRM_MODE_TYPE_PREFERRED</code> —— 连接器的首选模式（一般设置该值）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*mode_valid)(struct drm_connector *connector,</span><br><span class="line">		  struct drm_display_mode *mode);</span><br></pre></td></tr></table></figure>
<p>验证模式对于连接器是否有效。 对于支持的模式，返回<code>MODE_OK</code>；对于不支持的模式，返回枚举<code>drm_mode_status</code>值（MODE_ *）之一。 此操作是强制性的。</p>
<p>由于当前不使用模式拒绝原因来立即删除不受支持的模式，因此无论该模式无效的确切原因如何，实现都可以返回MODE_BAD。</p>
<blockquote>
<p><strong>注意:</strong></p>
<p>请注意，仅针对设备检测到的模式调用<code>mode_valid helper</code>操作，而不针对用户通过CRTC <code>set_config</code>操作设置的模式。</p>
</blockquote>
<h3 id="Modeset-Helper-Functions-Reference"><a href="#Modeset-Helper-Functions-Reference" class="headerlink" title="Modeset Helper Functions Reference"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp5732240" target="_blank" rel="noopener">Modeset Helper Functions Reference</a></h3><h3 id="fbdev-Helper-Functions-Reference"><a href="#fbdev-Helper-Functions-Reference" class="headerlink" title="fbdev Helper Functions Reference"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp5876896" target="_blank" rel="noopener">fbdev Helper Functions Reference</a></h3><h3 id="Display-Port-Helper-Functions-Reference"><a href="#Display-Port-Helper-Functions-Reference" class="headerlink" title="Display Port Helper Functions Reference"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp6119632" target="_blank" rel="noopener">Display Port Helper Functions Reference</a></h3><h3 id="EDID-Helper-Functions-Reference"><a href="#EDID-Helper-Functions-Reference" class="headerlink" title="EDID Helper Functions Reference"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp6149392" target="_blank" rel="noopener">EDID Helper Functions Reference</a></h3><h3 id="Rectangle-Utilities-Reference"><a href="#Rectangle-Utilities-Reference" class="headerlink" title="Rectangle Utilities Reference"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp6391776" target="_blank" rel="noopener">Rectangle Utilities Reference</a></h3><h3 id="Flip-work-Helper-Reference"><a href="#Flip-work-Helper-Reference" class="headerlink" title="Flip-work Helper Reference"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp6706608" target="_blank" rel="noopener">Flip-work Helper Reference</a></h3><h3 id="VMA-Offset-Manager"><a href="#VMA-Offset-Manager" class="headerlink" title="VMA Offset Manager"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp6798544" target="_blank" rel="noopener">VMA Offset Manager</a></h3><h2 id="KMS-Properties"><a href="#KMS-Properties" class="headerlink" title="KMS Properties"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#drm-kms-properties" target="_blank" rel="noopener">KMS Properties</a></h2><h2 id="Vertical-Blanking"><a href="#Vertical-Blanking" class="headerlink" title="Vertical Blanking"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#drm-vertical-blank" target="_blank" rel="noopener">Vertical Blanking</a></h2><h2 id="Open-Close-File-Operations-and-IOCTLs"><a href="#Open-Close-File-Operations-and-IOCTLs" class="headerlink" title="Open/Close, File Operations and IOCTLs"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp7217408" target="_blank" rel="noopener">Open/Close, File Operations and IOCTLs</a></h2><h3 id="Open-and-Close"><a href="#Open-and-Close" class="headerlink" title="Open and Close"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp7218096" target="_blank" rel="noopener">Open and Close</a></h3><h3 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp7232368" target="_blank" rel="noopener">File Operations</a></h3><h3 id="IOCTLs"><a href="#IOCTLs" class="headerlink" title="IOCTLs"></a><a href="http://www.landley.net/kdocs/htmldocs/drm.html#idp7244832" target="_blank" rel="noopener">IOCTLs</a></h3><h1 id="第3章-用户态接口"><a href="#第3章-用户态接口" class="headerlink" title="第3章 用户态接口"></a>第3章 用户态接口</h1><h2 id="VBlank事件处理"><a href="#VBlank事件处理" class="headerlink" title="VBlank事件处理"></a>VBlank事件处理</h2><p>DRM核心公开了两个垂直的空白相关的ioctl：</p>
<ul>
<li><code>DRM_IOCTL_WAIT_VBLANK</code>: 它以struct drm_wait_vblank结构作为其参数，并在发生指定的vblank事件时用于阻止或请求信号。</li>
<li><code>DRM_IOCTL_MODESET_CTL</code>: 在模式设置之前和之后，应由应用程序级别的驱动程序调用此方法，因为在许多设备上，垂直空白计数器会在那时重置。 在内部，当使用_DRM_PRE_MODESET命令调用ioctl时，DRM会对最后的vblank计数进行快照，以使计数器不会向后移动（使用_DRM_POST_MODESET时将进行处理）。</li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>drm</tag>
      </tags>
  </entry>
</search>
