# 链表反转

## 问题描述

不申请多余空间的情况下，实现链表的反转


## 思路

![链表反转](images/链表反转.jpg)

## 实现

```c
static node* list_reversal(node *L)
{
//#define LIST_HEAD_JOIN //第一个节点存储的链表长度不参与反转
    node *pre = NULL;
#if LIST_HEAD_JOIN
    node *cur = L->next;
#else
    node *cur = L;
#endif
    /* next: 用来保存cur后面一个的节点，防止链表在中间断开，然后pre与cur往下遍历 */
    node *next = NULL; //保存下一个节点的值

    while(cur) {
        next = cur->next;
        cur->next = pre;

        pre = cur;
        cur = next;
    }

#if LIST_HEAD_JOIN
    L->next = pre;
    return L;
#else
    return pre;
#endif
}
```




## 参考

* [链表反转示意图](https://www.processon.com/view/5c879a28e4b0afc7440ecfdb)
