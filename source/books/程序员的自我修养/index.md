---
title: 程序员的自我修养
date: 2018-09-17 10:07:24
comments: false
---

{% centerquote %} 程序员的自我修养  链接、装载与库 {% endcenterquote %}


# 温故而知新

## 内存不够怎么办

> 任何将计算机上有限的物理内存分配给多个程序使用

如果采用直接使用物理内存空间执行程序,存在一下问题:

1. 地址空间不隔离
>所有程序直接访问物理地址,程序所使用的内存空间不是相互隔离的,程序容易被有意或者无意的修改,使其崩溃.

2. 内存使用率低
>整个程序都加载到内存中占用大量空间,执行新的程序空间不足时,也需要换入换出大量数据.

3. 程序运行地址不确定
> 程序在编写时,其实是编译成可执行文件时,它访问数据和指令跳转时的目的地址很多都是固定的,地址不确定会造成很大麻烦.

** 解决方法: `增加中间层`** 使用一种间接的地址访问方法 --- `虚拟地址(Virtual Address)`

把程序给出的地址看作是一种虚拟地址,然后通过某些映射方法,将这个虚拟地址转换成实际的物理地址.


## 隔离

地址空间: 所谓地址空间是个比较抽象的概念,你可以把它想象成一个很大的数组,每个数组的元素是一个字节,而这个数组大小由地址空间的地址长度(地址线的个数)决定,比如32位地址空间大小为2^32=4 294 967 296字节,即4G

虚拟地址空间:指虚拟的,人们想象出来的地址空间,其实它并不存在,每一个进程都有自己独立的虚拟地址空间,而且每个进程只能访问自己的地址空间,这样就有效的做到了`进程的隔离`

### 分段(Segmentation)

> 基本思路: 把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间

```
                                           +-------------------+
                                           |                   |
                                           |                   |
0x0640 0000+----------------XX             |                   |
           |                | XXXX         |                   |
           |                |    XXXXXXXXXXX-------------------+0x7000 0000
           |                |              |                   |         +
           |                |              |                   |         |
           |                |              |                   |         |
           |  Virtual Addr  |              |                   |         |
           |  Space of B    |              |      Physical     |         |
           |                |              |  Address Space    |         |
           |                |    map       |      of B         |         |
           |                |              |                   |         v
           |                |              |                   |       100MB
           |                |              |                   |         ^
           |                |              |                   |         |
           |                |              |                   |         |
           |                |              |                   |         |
0x0000 0000+----------------XXX            |                   |         |
                               XXXX        |                   |         |
                                  XXXX     |                   |         +
0x00A0 0000+----------------XX       XXXXXX+-------------------+0x00c0 0000
           |  Virtual Addr  |XXX           |                   |
           |  Apace of A    |  XXXXXXXXXXXXX-------------------+0x00B0 0000
           |                |              | Physical Address  |
0x0000 0000+----------------X    map       |    Space of A     |        10MB
                            XXXXX          |                   |
                                 XXXXXXXXXXX-------------------+0x0010 0000
                                           |                   |
                                           |                   |
                                           +-------------------+0x0000 0000
```

分段可以解决第一个和第三个问题.

1. **地址隔离**: 程序A和程序被映射到两块不同的物理空间区域，他们之间没有任何重叠．如果程序Ａ访问访问虚拟空间的地址超过了0x00A0 0000这个范围，那么硬件就会判断这是一个非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或监控程序，由它决定处理．
2. **固定程序运行地址**：每个程序而言不需要关心虚拟地址与物理地址之间的映射，相当于其透明的，程序编写只需要按照从地址0x0000 0000到0x00A0 0000来编写程序，放置变量，程序不需要重定位．

### 分页(Paging)

分段是对整个程序而言，其换入换出将增加大量的磁盘访问操作,从而严重影响速度,因此利用`程序的局部性原理`使用更小粒度的内存分割和映射方法,就是`分页(Paging)`

> 分页的基本方法是把地址空间人为的等分成固定大小的页,每一页的大小由硬件决定,或硬件支持多种大小的页,由操作系统选择决定页的大小

页大小: MIPS 8K

#### Page Fault

![page_fault_flow](/images/2018/12/page_fault_flow.png)

> 进程的虚拟地址空间按`页`进行分割后,把常用的数据和代码页装载到内存中,把不常用的数据和代码页保存在磁盘中,当需要用到的时候再把它从磁盘中取出来即可.

假设进程`Process1`,`Process2`,他们进程中的部分虚拟页面被映射到了物理页面,比如VP0,VP1和VP7映射到PP0,PP2和PP3,但是一部分在磁盘中比如DP0,DP1.
- 如果程序运行时,只是有到了VP0,VP1和VP7的页空间,将不存在任何异常,程序正常运行
- 如果程序运行是,访问到了VP2和VP3的页空间,由于这两个页不在内存中,在磁盘中DP0和DP1中,因此硬件会捕获到这个信息,这就是`段错误(Page Fault)`

#### 页映射--数据保护

>在页映射时,可以对每个页设置权限属性,谁可以修改,谁可以访问,而只有操作系统有修改页属性的权利

> **Linux内核中如何实现???**

#### MMU (Memory Management Unit)

> CPU内部集成的一个硬件部件

```
+-------------+               +-----------+              +----------------+
|             |    Virtual    |           |   Physical   |    Physical    |
|     CPU     +--------------->    MMU    +-------------->     Memory     |
|             |    Address    |           |   Address    |                |
+-------------+               +-----------+              +----------------+
```
- 所谓CPU的`总线地址`大多数情况下就是指`物理地址`


## 线程 -- Thread

> **线程**: `执行流的最小单元`,有时也称`轻量级进程`,

- 一个标准的线程由`线程ID`,`当前指令指针(PC)`,`寄存器集合`和`堆栈`组成
- 通常,一个进程由一个到多个线程组成,各个线程之间共享程序的内存空间(包括代码段,数据段,堆等)及一些进程级资源(如打开文件和信号)

```
+--------------------------------------------------------------+
| +----------------------------------------------------------+ |
| |    代码     |     数据     |    进程空间      |   打开文件   | |
| +------------+--------------+----------------+-------------+ |
|                                                              |
|  +-------------+     +-------------+    +--------------+     |
|  | +---------+ |     | +---------+ |    | +----------+ |     |
|  | |  寄存器  | |     | | 寄存器   | |    | |  寄存器   | |     |
|  | +---------+ |     | +---------+ |    | +----------+ |     |
|  |             |     |             |    |              |     |
|  | +---------+ |     | +---------+ |    | +----------+ |     |
|  | |   栈    | |     | |    栈    | |    | |   栈     | |     |
|  | +---------+ |     | +---------+ |    | +----------+ |     |
|  |             |     |             |    |              |     |
|  |             |     |             |    |              |     |
|  |             |     |             |    |              |     |
|  |             |     |             |    |              |     |
|  |             |     |             |    |              |     |
|  |             |     |             |    |              |     |
|  |             |     |             |    |              |     |
|  |             |     |             |    |              |     |
|  |             |     |             |    |              |     |
|  |             |     |             |    |              |     |
|  | Main Thread |     |   Thread 1  |    |   Thread 2   |     |
|  +-------------+     +-------------+    +--------------+     |
+--------------------------------------------------------------+
```

### 线程的访问权限

| 线程私有 | 线程之间共享(进程所有)                      |
|:--------:|:--------------------------------------------|
| 局部变量 | 全局变量                                    |
| 函数参数 | 堆上的数据                                  |
| TLS数据  | 函数里的静态变量                            |
|    -     | 程序代码,任何线程都有权利读取并执行任何代码 |
|    -     | 打开的文件, A线程打开的文件可以由线程B读写  |

### 线程调度

线程的三种状态:
- **运行(Runing)**: 此时线程正在执行
- **就绪(Ready)**: 此时线程可以立刻运行,但是CPU已经被占用
- **等待(Wait)**: 此时线程正在等待某一事件(通常指I/O或同步)发生,无法执行

```
                 无运行线程,且本线程被选中
     +------------------------------------------+
     |                                          |
     |                                          |
     |                                          |
     |                                          |
+----v-----+                              +-----+-----+
|          |         时间片用尽             |           |
|  Runing  +------------------------------>   Ready   |
|          |                              |           |
+----+-----+                              +-----^-----+
     |                                          |
     |                                          |
 开始等待                                      等待结束
     |                                          |
     |             +----------+                 |
     |             |          |                 |
     +------------->   Wait   +-----------------+
                   |          |
                   +----------+
```

### 线程安全

>多线程并发执行时,数据的一致性

#### 竞争与原子操作

- 原子(Atomic):指单指令操作

#### 锁与同步

1. **二元信号量**: 最简单的一种锁,它只有两种状态:`占用`与`非占用`.适用只能被唯一一个线程独占访问的资源
2. **互斥量(Mutex)**:与二元信号量类似,资源仅同时允许一个线程访问,但是互斥量是哪个线程获取互斥量,必须哪个线程释放互斥量
3. **临界区**:互斥量保护的范围,就是临界区
4. **读写锁**:读写锁两种获取方式`共享的(Shared)`和`独占的(Exclusive)`,适用频繁读取,只是偶尔写入的场景
5. **条件变量**: 类似于一个栅栏,一个条件变量可以被多个线程等待,当时间发生时(条件变量被唤醒),所有线程可以一起恢复执行

### 可重入(Reentrant)与线程安全

一个函数可重入的**特点**:

1. 不使用任何(局部)静态或全局的非const变量
2. 不使用任何(局部)静态或全局的非const变量的变量
3. 仅依赖调用函数提供的参数
4. 不依赖任何单个资源的锁(mutex等)
5. 不调用任何不可重入函数


### 过度优化

过度优化带来的问题:
1. `编译器调整顺序`:编译器为提高执行速度,将一些结果保存临时寄存器中
2. `CPU动态调度换序`: CPU的动态调度,在执行过程中,为了提高效率,几个互补相关的指令,可能被交换执行,或者同时执行

解决方法:
1. `volatile`关键字阻止过度优化
    - 阻止编译器为了提高速度将一个变量缓存到寄存器不写回
    - 阻止编译器调整操作volatile变量的指令顺序
2. `barrier`指令, 一条barrier指令会阻止CPU将该指令之前的指令交换到barrier指令之后,也就是说CPU执行到barrier指令时,前面的所有指令已经执行完成


***
# 静态链接


***
# 装载与动态链接


***
# 库与运行库


***
