---
title: 程序员的自我修养
date: 2018-09-17 10:07:24
comments: false
---

{% centerquote %} 程序员的自我修养  链接、装载与库 {% endcenterquote %}


# 温故而知新

## 内存不够怎么办

> 任何将计算机上有限的物理内存分配给多个程序使用

如果采用直接使用物理内存空间执行程序,存在一下问题:

1. 地址空间不隔离
>所有程序直接访问物理地址,程序所使用的内存空间不是相互隔离的,程序容易被有意或者无意的修改,使其崩溃.

2. 内存使用率低
>整个程序都加载到内存中占用大量空间,执行新的程序空间不足时,也需要换入换出大量数据.

3. 程序运行地址不确定
> 程序在编写时,其实是编译成可执行文件时,它访问数据和指令跳转时的目的地址很多都是固定的,地址不确定会造成很大麻烦.

** 解决方法: `增加中间层`** 使用一种间接的地址访问方法 --- `虚拟地址(Virtual Address)`

把程序给出的地址看作是一种虚拟地址,然后通过某些映射方法,将这个虚拟地址转换成实际的物理地址.


## 隔离

地址空间: 所谓地址空间是个比较抽象的概念,你可以把它想象成一个很大的数组,每个数组的元素是一个字节,而这个数组大小由地址空间的地址长度(地址线的个数)决定,比如32位地址空间大小为2^32=4 294 967 296字节,即4G

虚拟地址空间:指虚拟的,人们想象出来的地址空间,其实它并不存在,每一个进程都有自己独立的虚拟地址空间,而且每个进程只能访问自己的地址空间,这样就有效的做到了`进程的隔离`

### 分段(Segmentation)

> 基本思路: 把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间

```
                                           +-------------------+
                                           |                   |
                                           |                   |
0x0640 0000+----------------XX             |                   |
           |                | XXXX         |                   |
           |                |    XXXXXXXXXXX-------------------+0x7000 0000
           |                |              |                   |         +
           |                |              |                   |         |
           |                |              |                   |         |
           |  Virtual Addr  |              |                   |         |
           |  Space of B    |              |      Physical     |         |
           |                |              |  Address Space    |         |
           |                |    map       |      of B         |         |
           |                |              |                   |         v
           |                |              |                   |       100MB
           |                |              |                   |         ^
           |                |              |                   |         |
           |                |              |                   |         |
           |                |              |                   |         |
0x0000 0000+----------------XXX            |                   |         |
                               XXXX        |                   |         |
                                  XXXX     |                   |         +
0x00A0 0000+----------------XX       XXXXXX+-------------------+0x00c0 0000
           |  Virtual Addr  |XXX           |                   |
           |  Apace of A    |  XXXXXXXXXXXXX-------------------+0x00B0 0000
           |                |              | Physical Address  |
0x0000 0000+----------------X    map       |    Space of A     |        10MB
                            XXXXX          |                   |
                                 XXXXXXXXXXX-------------------+0x0010 0000
                                           |                   |
                                           |                   |
                                           +-------------------+0x0000 0000
```

分段可以解决第一个和第三个问题.

1. 地址隔离: 程序A和程序被映射到两块不同的物理空间区域，他们之间没有任何重叠．如果程序Ａ访问访问虚拟空间的地址超过了0x00A0 0000这个范围，那么硬件就会判断这是一个非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或监控程序，由它决定处理．
2. 固定程序运行地址：每个程序而言不需要关心虚拟地址与物理地址之间的映射，相当于其透明的，程序编写只需要按照从地址0x0000 0000到0x00A0 0000来编写程序，放置变量，程序不需要重定位．

### 分页(Paging)

分段是对整个程序而言，其换入换出将增加大量的磁盘访问操作,从而严重影响速度,因此利用`程序的局部性原理`使用更小粒度的内存分割和映射方法,就是`分页(Paging)`

> 分页的基本方法是把地址空间人为的等分成固定大小的页,每一页的大小由硬件决定,或硬件支持多种大小的页,由操作系统选择决定页的大小

页大小: MIPS 8K

#### Page Fault

![page_fault_flow](/images/2018/12/page_fault_flow.png)

***
# 静态链接


***
# 装载与动态链接


***
# 库与运行库


***
