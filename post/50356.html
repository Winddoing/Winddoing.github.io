<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="baidu-site-verification" content="WIIeufYjj6"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://winddoing.github.io").hostname,root:"/",scheme:"Mist",version:"7.7.0",exturl:!1,sidebar:{position:"right",width:300,display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"输入关键词",hits_empty:"没有找到与「${query}」相关的内容",hits_stats:"${hits} 条相关记录，共耗时 ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结"><meta name="keywords" content="audio,alsa,驱动"><meta property="og:type" content="article"><meta property="og:title" content="Audio驱动总结--ALSA"><meta property="og:url" content="https://winddoing.github.io/post/50356.html"><meta property="og:site_name" content="Winddoing&#39;s Notes"><meta property="og:description" content="接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://winddoing.github.io/images/audio/alsa/alsa-hardware-link.png"><meta property="og:image" content="https://winddoing.github.io/images/audio/alsa/audio-hardware.png"><meta property="og:image" content="https://winddoing.github.io/images/audio/alsa/alsa-struct.png"><meta property="og:image" content="https://winddoing.github.io/images/audio/alsa/alas-asoc-arch.png"><meta property="og:updated_time" content="2021-07-14T09:13:21.857Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Audio驱动总结--ALSA"><meta name="twitter:description" content="接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结"><meta name="twitter:image" content="https://winddoing.github.io/images/audio/alsa/alsa-hardware-link.png"><link rel="canonical" href="https://winddoing.github.io/post/50356.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>#needsharebutton-postbottom{cursor:pointer;height:26px;margin-top:10px;position:relative}#needsharebutton-postbottom .btn{border:1px solid $btn-default-border-color;border-radius:3px;display:initial;padding:1px 4px}</style><title>Audio驱动总结--ALSA | Winddoing's Notes</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?38fa95924670925239ef842cb0c8722b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Winddoing's Notes</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Follow Excellent, Success will Chase you</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://winddoing.github.io/post/50356.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/Winddoing.jpg"><meta itemprop="name" content="Winddoing"><meta itemprop="description" content="失败缘于忽视细处，成功始于重视小事。"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Winddoing's Notes"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> Audio驱动总结--ALSA</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-07-10 23:07:24" itemprop="dateCreated datePublished" datetime="2017-07-10T23:07:24+08:00">2017-07-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/设备驱动/" itemprop="url" rel="index"><span itemprop="name">设备驱动</span></a></span></span><span id="/post/50356.html" class="post-meta-item leancloud_visitors" data-flag-title="Audio驱动总结--ALSA" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>22k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>20 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结</p><a id="more"></a><h2 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h2><ul><li>Sample：样本长度(位宽)，音频数据最基本的单位，常见的有8位和16位。</li><li>Channel：声道数，分为单声道mono和立体声stereo。</li><li>Frame：帧，构成一个声音单元，Frame = Sample <em>channel, sample</em>channel/8 Byte。</li><li>Rate：又称Sample rate，采样率，即每秒的采样次数，针对帧而言。</li><li>Interleaved：交错模式，一种音频数据的记录方式，在交错模式下，数据以连续桢的形式存放，即首先记录完桢1的左声道样本和右声道样本（假设为立体声），再开始桢2的记录。而在非交错模式下，首先记录的是一个周期内所有桢的左声道样本，再记录右声道样本，数据是以连续通道的方式存储。多数情况下使用交错模式。</li><li>Period size：周期，每次硬件中断处理音频数据的帧数，对于音频设备的数据读写，以此为单位。</li><li>Buffer size：数据缓冲区大小，这里特指runtime的buffer size，而不是snd_pcm_hardware定义的buffer_bytes_max。</li><li>码率: (编码速率), 码率 = 采样频率 <em>位宽</em> 声道个数</li></ul><p><strong><em>采样率和实际的分频误差在5%左右</em></strong></p><blockquote><p><strong>Period</strong></p><p>The interval between interrupts from the hardware. This defines the input latency, since the CPU will not have any idea that there is data waiting until the audio interface interrupts it.</p><p>The audio interface has a “pointer” that marks the current position for read/write in its h/w buffer. The pointer circles around the buffer as long as the interface is running.</p><p>Typically, there are an integral number of periods per traversal of the h/w buffer, but not always. There is at least one card (ymfpci)<br>that generates interrupts at a fixed rate indepedent of the buffer size (which can be changed), resulting in some “odd” effects compared to more traditional designs.</p><p>Note: h/w generally defines the interrupt in frames, though not always.</p><p>Alsa’s period size setting will affect how much work the CPU does. if you set the period size low, there will be more interrupts and the work that is done every interrupt will be done more often. So, if you don’t care about low latency,<br>set the period size large as possible and you’ll have more CPU cycles for other things. The defaults that ALSA provides are in the middle of the range, typically.</p><p>(from an old AlsaDevel thread[1], quoting Paul Davis)</p><p>Retrieved from “<a href="http://alsa.opensrc.org/Period&quot;" target="_blank" rel="noopener">http://alsa.opensrc.org/Period&quot;</a></p><p>来自：<a href="http://alsa.opensrc.org/Period" target="_blank" rel="noopener">http://alsa.opensrc.org/Period</a></p><p><strong>FramesPeriods</strong></p><p>A frame is equivalent of one sample being played, irrespective of the number of channels or the number of bits. e.g.</p><ul><li>1 frame of a Stereo 48khz 16bit PCM stream is 4 bytes.</li><li>1 frame of a 5.1 48khz 16bit PCM stream is 12 bytes.<br>A period is the number of frames in between each hardware interrupt. The poll() will return once a period.<br>The buffer is a ring buffer. The buffer size always has to be greater than one period size. Commonly this is 2*period size, but some hardware can do 8 periods per buffer. It is also possible for the buffer size to not be an integer multiple of the period size.<br>Now, if the hardware has been set to 48000Hz , 2 periods, of 1024 frames each, making a buffer size of 2048 frames. The hardware will interrupt 2 times per buffer. ALSA will endeavor to keep the buffer as full as possible. Once the first period of samples has<br>been played, the third period of samples is transfered into the space the first one occupied while the second period of samples is being played. (normal ring buffer behaviour).</li></ul><p>Additional example</p><p>Here is an alternative example for the above discussion.<br>Say we want to work with a stereo, 16-bit, 44.1 KHz stream, one-way (meaning, either in playback or in capture direction). Then we have:</p><ul><li>‘stereo’ = number of channels: 2</li><li>1 analog sample is represented with 16 bits = 2 bytes</li><li>1 frame represents 1 analog sample from all channels; here we have 2 channels, and so:<ul><li>1 frame = (num_channels) <em>(1 sample in bytes) = (2 channels)</em> (2 bytes (16 bits) per sample) = 4 bytes (32 bits)</li></ul></li><li>To sustain 2x 44.1 KHz analog rate - the system must be capable of data transfer rate, in Bytes/sec:<ul><li>Bps_rate = (num_channels) <em>(1 sample in bytes)</em> (analog_rate) = (1 frame) <em>(analog_rate) = ( 2 channels )</em> (2 bytes/sample) <em>(44100 samples/sec) = 2</em>2*44100 = 176400 Bytes/sec<br>Now, if ALSA would interrupt each second, asking for bytes - we’d need to have 176400 bytes ready for it (at end of each second), in order to sustain analog 16-bit stereo @ 44.1Khz.</li></ul></li><li>If it would interrupt each half a second, correspondingly for the same stream we’d need 176400/2 = 88200 bytes ready, at each interrupt;</li><li>if the interrupt hits each 100 ms, we’d need to have 176400*(0.1/1) = 17640 bytes ready, at each interrupt.<br>We can control when this PCM interrupt is generated, by setting a period size, which is set in frames.</li><li>Thus, if we set 16-bit stereo @ 44.1Khz, and the period_size to 4410 frames =&gt; (for 16-bit stereo @ 44.1Khz, 1 frame equals 4 bytes - so 4410 frames equal 4410*4 = 17640 bytes) =&gt; an interrupt will be generated each 17640 bytes - that is, each 100 ms.</li><li>Correspondingly, buffer_size should be at least 2<em>period_size = 2</em>4410 = 8820 frames (or 8820*4 = 35280 bytes).<br>It seems (writing-an-alsa-driver.pdf), however, that it is the ALSA runtime that decides on the actual buffer_size and period_size, depending on: the requested number of channels, and their respective properties (rate and sampling resolution) - as well as the<br>parameters set in the snd_pcm_hardware structure (in the driver).<br>Also, the following quote may be relevant, from <a href="http://mailman.alsa-project.org/pipermail/alsa-devel/2007-April/000474.html" target="_blank" rel="noopener">http://mailman.alsa-project.org/pipermail/alsa-devel/2007-April/000474.html</a>:</li></ul><blockquote><blockquote><p>The “frame” represents the unit, 1 frame = # channels x sample_bytes.<br>In your case, 1 frame corresponds to 2 channels x 16 bits = 4 bytes.</p><p>The periods is the number of periods in a ring-buffer. In OSS, called<br>as “fragments”.</p><p>So,</p><ul><li>buffer_size = period_size * periods</li><li>period_bytes = period_size * bytes_per_frame</li><li>bytes_per_frame = channels * bytes_per_sample</li></ul></blockquote><p>I still don’t understand what ‘period_size’ and a ‘period’ is?</p></blockquote><p>The “period” defines the frequency to update the status, usually viathe invokation of interrupts. The “period_size” defines the frame sizes corresponding to the “period time”. This term corresponds to the “fragment size” on OSS. On major sound hardwares,<br>a ring-buffer is divided to several parts and an irq is issued on each boundary. The period_size defines the size of this chunk.</p><p>On some hardwares, the irq is controlled on the basis of a timer. In this case, the period is defined as the timer frequency to invoke an irq.</p><p>来自：<a href="http://alsa-project.org/main/index.php/FramesPeriods" target="_blank" rel="noopener">http://alsa-project.org/main/index.php/FramesPeriods</a></p></blockquote><h2 id="音频处理软件"><a href="#音频处理软件" class="headerlink" title="音频处理软件"></a>音频处理软件</h2><blockquote><p> Audacity 2.0.5</p></blockquote><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>主要由音频总线(I2S,PCM)和控制总线(I2C或SPI)组成。</p><p><img src="/images/audio/alsa/alsa-hardware-link.png" alt="alsa-hardware-link"></p><p><img src="/images/audio/alsa/audio-hardware.png" alt="audio-hardware"></p><h2 id="alsa-ASOC"><a href="#alsa-ASOC" class="headerlink" title="alsa - ASOC"></a>alsa - ASOC</h2><p>在内核设备驱动层，ALSA提供了alsa-driver，同时在应用层，ALSA为我们提供了alsa-lib，应用程序只要调用alsa-lib提供的API，即可以完成对底层音频硬件的控制。</p><p><img src="/images/audio/alsa/alsa-struct.png" alt="alsa-struct"></p><p>ASoC被分为<code>Machine</code>、<code>Platform</code>和<code>Codec</code>三大部分。其中的Machine驱动负责Platform和Codec之间的耦合和设备或板子特定的代码。Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。</p><ul><li>machine<br>用于描述设备组件信息和特定的控制如耳机/外放等。</li></ul><blockquote><p>是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个<code>载体</code>。</p></blockquote><p>这一部分将平台驱动和Codec驱动绑定在一起，描述了板级的硬件特征。主要负责Platform和Codec之间的耦合以及部分和设备或板子特定的代码。Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。ASoC的一切都从Machine驱动开始，包括声卡的注册，绑定Platform和Codec驱动等等</p><ul><li>Platform<br>用于实现平台相关的DMA驱动和音频接口等。</li></ul><blockquote><p>一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。</p></blockquote><p>这一部分只关心CPU本身，不关心Codec。主要处理两个问题：<code>DMA引擎</code>和<code>SoC集成的PCM、I2S或AC &#39;97数字接口控制</code>。主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：<code>snd_soc_platform_driver</code>和<code>snd_soc_dai_driver</code>。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。</p><ul><li>Codec<br>用于实现平台无关的功能，如寄存器读写接口，音频接口，各widgets的控制接口和DAPM的实现等</li></ul><blockquote><p>字面上的意思就是编解码器，Codec里面包含了I2S接口、D/A、A/D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。</p></blockquote><p>这一部分只关心Codec本身，与CPU平台相关的特性不由此部分操作。在移动设备中，Codec的作用可以归结为4种，分别是：</p><ol><li>对PCM等信号进行D/A转换，把数字的音频信号转换为模拟信号。</li><li>对Mic、Linein或者其他输入源的模拟信号进行A/D转换，把模拟的声音信号转变CPU能够处理的数字信号。</li><li>对音频通路进行控制，比如播放音乐，收听调频收音机，又或者接听电话时，音频信号在codec内的流通路线是不一样的。</li><li>对音频信号做出相应的处理，例如音量控制，功率放大，EQ控制等等。</li></ol><p>ASoC对Codec的这些功能都定义好了一些列相应的接口，以方便地对Codec进行控制。ASoC对Codec驱动的一个基本要求是：<code>驱动程序的代码必须要做到平台无关性，以方便同一个Codec的代码不经修改即可用在不同的平台上</code>。</p><p><img src="/images/audio/alsa/alas-asoc-arch.png" alt="alsa-asoc-arch"></p><p>ASoC对于Alsa来说，就是分别注册PCM/CONTROL类型的snd_device设备，并实现相应的操作方法集。图中DAI是数字音频接口，用于配置音频数据格式等。</p><ul><li>Codec驱动向ASoC注册<code>snd_soc_codec</code>和<code>snd_soc_dai</code>设备。</li><li>Platform驱动向ASoC注册<code>snd_soc_platform</code>和<code>snd_soc_dai</code>设备。</li><li>Machine驱动通过<code>snd_soc_dai_link</code>绑定codec/dai/platform.</li></ul><p>Widget是各个组件内部的小单元。处在活动通路上电，不在活动通路下电。ASoC的DAPM正是通过控制这些Widget的上下电达到动态电源管理的效果。</p><ul><li>path描述与其它widget的连接关系。</li><li>event用于通知该widget的上下电状态。</li><li>power指示当前的上电状态。</li><li>control实现空间用户接口用于控制widget的音量/通路切换等。</li></ul><p>对驱动开者来说，就可以很好的解耦了：</p><ul><li>codec驱动的开发者，实现codec的IO读写方法，描述DAI支持的数据格式/操作方法和Widget的连接关系就可以了;</li><li>soc芯片的驱动开发者，Platform实现snd_pcm的操作方法集和DAI的配置如操作 DMA，I2S/AC97/PCM的设定等;</li><li>板级的开发者，描述Machine上codec与platform之间的总线连接， earphone/Speaker的布线情况就可以了。</li></ul><h3 id="DAPM"><a href="#DAPM" class="headerlink" title="DAPM"></a>DAPM</h3><h3 id="DPCM"><a href="#DPCM" class="headerlink" title="DPCM"></a>DPCM</h3><blockquote><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/sound/soc/dpcm.rst?h=v4.16-rc5" target="_blank" rel="noopener">Dynamic PCM</a></p></blockquote><h2 id="PCM设备"><a href="#PCM设备" class="headerlink" title="PCM设备"></a>PCM设备</h2><h3 id="放音-–-应用"><a href="#放音-–-应用" class="headerlink" title="放音 – 应用"></a>放音 – 应用</h3><blockquote><p><code>tinyplay</code>播放音乐</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># strace  tinyplay  pcmrec.wav</span></span><br><span class="line">execve(<span class="string">"/usr/bin/tinyplay"</span>, [<span class="string">"tinyplay"</span>, <span class="string">"pcmrec.wav"</span>], [<span class="comment">/* 16 vars */</span>]) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">"pcmrec.wav"</span>, O_RDONLY)            = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//读取wav格式的音频文件的头数据</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"RIFF$\342\4\0WAVEfmt \20\0\0\0\1\0\2\0@\37\0\0\0&#125;\0\0"</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次打开`pcmC0D0p`设备节点, 重新设置硬件参数</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">"/dev/snd/pcmC0D0p"</span>, O_RDWR)       = <span class="number">4</span></span><br><span class="line"><span class="comment">//ioctl - cmd=SNDRV_PCM_IOCTL_HW_REFINE</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0xc25c4110</span>, <span class="number">0x412178</span>)          = <span class="number">0</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次打开`pcmC0D0p`设备节点, 进行音频播放的准备工作和播放</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">"/dev/snd/pcmC0D0p"</span>, O_RDWR)       = <span class="number">4</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_INFO`</span></span><br><span class="line">ioctl(<span class="number">4</span>, AGPIOC_ACQUIRE <span class="keyword">or</span> APM_IOC_STANDBY, <span class="number">0x7f83f3cc</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_HW_PARAMS`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0xc25c4111</span>, <span class="number">0x7f83f170</span>)        = <span class="number">0</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_SW_PARAMS`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0xc0684113</span>, <span class="number">0x7f83f5ec</span>)        = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在播放期间响应Ctrl+C的中断信号</span></span><br><span class="line">rt_sigaction(SIGINT, &#123;<span class="number">0x10000000</span>, [RT_65 RT_67], <span class="number">0x401240</span> <span class="comment">/* SA_??? */</span>&#125;, &#123;SIG_DFL, [RT_67 RT_68 RT_72 RT_74 RT_75 RT_77 RT_81 RT_89 RT_90 RT_91 RT_93 RT_94], <span class="number">0</span>&#125;, <span class="number">16</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ioctl - cmd=`SNDRV_PCM_IOCTL_SYNC_PTR`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\320\367\200\367\370\370`\370\220\370\330\370@\372h\371\240\371\320\374\230\373\240\374\341\5\301\1\241\5\221\25"</span>..., <span class="number">12288</span>) = <span class="number">12288</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"a\0361\36\241\f\10\376\300\374\320\375\30\375\360\375\340\375\0\377\320\377(\377\370\376p\375p\374\321\0"</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_PREPARE`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x20004140</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_WRITEI_FRAMES`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\201\21\301\27q\30\261\25\301\20Q\6x\375h\373\370\373\230\374\210\374x\374p\374\220\374\30\375 \375"</span>..., <span class="number">12288</span>) = <span class="number">12288</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\201\35\1%\241'\301\32\341\t@\377\250\374\220\372\20\373\30\374\340\373X\374H\374X\376\201\v\321\32"</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">//while()&#123; 循环读取播放 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\370\375\10\376 \376\210\376X\376x\376\250\376\350\376\360\376\260\376(\377H\377q\0\301\5\1\vq\21"</span>..., <span class="number">12288</span>) = <span class="number">12288</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\221\0021\n\21\f\241\5x\376\30\377\300\377(\377\1\1!\3q\4Q\3\301\4\240\377h\376\210\377"</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"P\377\0\377!\0\361\6Q\t\230\377@\376\250\377X\377\361\3\1\16\241\n!\0!\6A\16\241\v"</span>..., <span class="number">12288</span>) = <span class="number">4652</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">""</span>, <span class="number">4096</span>)                       = <span class="number">0</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">""</span>, <span class="number">16384</span>)                      = <span class="number">0</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x76fe9000</span>, <span class="number">65536</span>)               = <span class="number">0</span></span><br><span class="line"><span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"Playing sample: 2 ch, 8000 hz, 1"</span>..., <span class="number">38</span>) = <span class="number">38</span>  <span class="comment">//printf</span></span><br><span class="line">exit_group(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="为什么open两次pcmC0D0p设备节点"><a href="#为什么open两次pcmC0D0p设备节点" class="headerlink" title="为什么open两次pcmC0D0p设备节点"></a>为什么open两次pcmC0D0p设备节点</h4><ol><li>第一次打开<code>pcmC0D0p</code>,主要为了重新规范硬件<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_hw_params</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_mask</span> <span class="title">masks</span>[<span class="title">SNDRV_PCM_HW_PARAM_LAST_MASK</span> -</span></span><br><span class="line"><span class="class">                   <span class="title">SNDRV_PCM_HW_PARAM_FIRST_MASK</span> + 1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_mask</span> <span class="title">mres</span>[5];</span>    <span class="comment">/* reserved masks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_interval</span> <span class="title">intervals</span>[<span class="title">SNDRV_PCM_HW_PARAM_LAST_INTERVAL</span> -</span></span><br><span class="line"><span class="class">                        <span class="title">SNDRV_PCM_HW_PARAM_FIRST_INTERVAL</span> + 1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_interval</span> <span class="title">ires</span>[9];</span>    <span class="comment">/* reserved intervals */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rmask;     <span class="comment">/* W: requested masks */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cmask;     <span class="comment">/* R: changed masks */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> info;      <span class="comment">/* R: Info flags for returned setup */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> msbits;        <span class="comment">/* R: used most significant bits */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rate_num;      <span class="comment">/* R: rate numerator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rate_den;      <span class="comment">/* R: rate denominator */</span></span><br><span class="line">    <span class="keyword">snd_pcm_uframes_t</span> fifo_size;    <span class="comment">/* R: chip FIFO size in frames */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> reserved[<span class="number">64</span>]; <span class="comment">/* reserved for future */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>file: include/uapi/sound/asound.h</p></blockquote><p>主要是将用户空间的snd_pcm_hw_params信息和内核空间的进行对比和规范化</p><ol start="2"><li>第二次打开<code>pcmC0D0p</code>,主要为了进行音频播放的准备和播放音频信号</li></ol><h4 id="为什么read音频文件两次-并且读的数据大小不一致"><a href="#为什么read音频文件两次-并且读的数据大小不一致" class="headerlink" title="为什么read音频文件两次,并且读的数据大小不一致"></a>为什么read音频文件两次,并且读的数据大小不一致</h4><p>tinyplay中播放时,每次只读取一部分(16KB)的音频文件进行播放<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span> = pcm_frames_to_bytes(pcm, pcm_get_buffer_size(pcm)); <span class="comment">//size=16384Byte=16KB</span></span><br><span class="line"><span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="comment">//buffer 临时存放音频文件的数据的buf</span></span><br><span class="line">	<span class="comment">//size   一次读取的大小(16384Byte)</span></span><br><span class="line">	<span class="comment">//file   打开的音频文件描述符</span></span><br><span class="line">    num_read = fread(<span class="built_in">buffer</span>, <span class="number">1</span>, <span class="built_in">size</span>, file);</span><br><span class="line">    <span class="keyword">if</span> (num_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pcm_write(pcm, <span class="built_in">buffer</span>, num_read)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error playing sample\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num_read == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">if</span>(pcm_write(pcm, <span class="built_in">buffer</span>, <span class="built_in">size</span>))&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error playing sample\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (!<span class="built_in">close</span> &amp;&amp; num_read &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p></p><p>在进行strace时,一次播放进行了两次的read系统调用,将每一次read数据的大小相加(12288+4096=16384Byte),正好与malloc的buffer大小一致.因此两次的read是由用户空间的函数进行数据分割的.</p><h4 id="用户空间申请buffer大小的依据"><a href="#用户空间申请buffer大小的依据" class="headerlink" title="用户空间申请buffer大小的依据"></a>用户空间申请buffer大小的依据</h4><p>在播放当前歌曲时,所申请的buffer大小为16KB,为什么申请16K?</p><p>音频信息:</p><table><thead><tr><th style="text-align:center">采样率</th><th style="text-align:center">通道</th><th style="text-align:center">位宽(format)</th></tr></thead><tbody><tr><td style="text-align:center">44100Hz</td><td style="text-align:center">2</td><td style="text-align:center">16bit</td></tr></tbody></table><blockquote><p>4KB的buffer大小为<code>tinyplay</code>默认大小,<code>period_size = 1024</code>, <code>period_count = 4</code>决定了buffer大小,而<code>period_size</code>可以进行修改默认大小.</p></blockquote><p>需要申请buffer的大小: 1024 <em>4</em> 2 * (16 / 8) = 16384</p><h3 id="放音-–-内核"><a href="#放音-–-内核" class="headerlink" title="放音 – 内核"></a>放音 – 内核</h3><h4 id="ASOC接口"><a href="#ASOC接口" class="headerlink" title="ASOC接口"></a>ASOC接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create a new pcm */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">soc_new_pcm</span><span class="params">(struct snd_soc_pcm_runtime *rtd, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* ASoC PCM operations */</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic) &#123;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">open</span>       = dpcm_fe_dai_open;</span><br><span class="line">		rtd-&gt;ops.hw_params  = dpcm_fe_dai_hw_params;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">prepare</span>    = dpcm_fe_dai_prepare;</span><br><span class="line">		rtd-&gt;ops.trigger    = dpcm_fe_dai_trigger;</span><br><span class="line">		rtd-&gt;ops.hw_free    = dpcm_fe_dai_hw_free;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">close</span>      = dpcm_fe_dai_close;</span><br><span class="line">		rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class="line">		rtd-&gt;ops.ioctl      = soc_pcm_ioctl;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//回调函数</span></span><br><span class="line">		rtd-&gt;ops.<span class="built_in">open</span>       = soc_pcm_open;</span><br><span class="line">		rtd-&gt;ops.hw_params  = soc_pcm_hw_params;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">prepare</span>    = soc_pcm_prepare;</span><br><span class="line">		rtd-&gt;ops.trigger    = soc_pcm_trigger;</span><br><span class="line">		rtd-&gt;ops.hw_free    = soc_pcm_hw_free;</span><br><span class="line">		rtd-&gt;ops.<span class="built_in">close</span>      = soc_pcm_close;</span><br><span class="line">		rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class="line">		rtd-&gt;ops.ioctl      = soc_pcm_ioctl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops) &#123;</span><br><span class="line">		rtd-&gt;ops.ack        = platform-&gt;driver-&gt;ops-&gt;ack;</span><br><span class="line">		rtd-&gt;ops.copy       = platform-&gt;driver-&gt;ops-&gt;copy;</span><br><span class="line">		rtd-&gt;ops.silence    = platform-&gt;driver-&gt;ops-&gt;silence;</span><br><span class="line">		rtd-&gt;ops.page       = platform-&gt;driver-&gt;ops-&gt;page;</span><br><span class="line">		rtd-&gt;ops.mmap       = platform-&gt;driver-&gt;ops-&gt;mmap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (playback)</span><br><span class="line">		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (capture)</span><br><span class="line">		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>file: sound/soc/soc-pcm.c</p></blockquote><h5 id="soc-pcm-open"><a href="#soc-pcm-open" class="headerlink" title="soc_pcm_open"></a>soc_pcm_open</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int soc_pcm_open(struct snd_pcm_substream *substream)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	// CPU &lt;I2S&gt; : jz_i2s_startup</span><br><span class="line">	if (cpu_dai-&gt;driver-&gt;ops-&gt;startup) &#123;</span><br><span class="line">		 ret = cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai);</span><br><span class="line">	&#125;</span><br><span class="line">	// Platform &lt;DMA&gt; : jz_pcm_open</span><br><span class="line">	if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;open) &#123;</span><br><span class="line">		 ret = platform-&gt;driver-&gt;ops-&gt;open(substream);</span><br><span class="line">	&#125;</span><br><span class="line">	// Codec &lt;idec_d3&gt; : jz_icdc_startup</span><br><span class="line">	if (codec_dai-&gt;driver-&gt;ops-&gt;startup) &#123;</span><br><span class="line">		 ret = codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai);</span><br><span class="line">	&#125;</span><br><span class="line"> 	// Machine &lt;link&gt; : phoenix_spk_sup  file:sound/soc/ingenic/asoc-board/phoenix_icdc.c</span><br><span class="line">	if (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;startup) &#123;</span><br><span class="line">		 ret = rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="soc-pcm-hw-params"><a href="#soc-pcm-hw-params" class="headerlink" title="soc_pcm_hw_params"></a>soc_pcm_hw_params</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_hw_params</span><span class="params">(struct snd_pcm_substream *substream,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct snd_pcm_hw_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 ...</span><br><span class="line">	 <span class="comment">// Machine &lt;link&gt; : phoenix_i2s_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = rtd-&gt;dai_link-&gt;ops-&gt;hw_params(substream, params);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">// Codec &lt;idec_d3&gt; : icdc_d3_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = codec_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, codec_dai);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">// CPU &lt;I2S&gt; : jz_i2s_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = cpu_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, cpu_dai);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">// Platform &lt;DMA&gt; : jz_pcm_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = platform-&gt;driver-&gt;ops-&gt;hw_params(substream, params);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="soc-pcm-prepare"><a href="#soc-pcm-prepare" class="headerlink" title="soc_pcm_prepare"></a>soc_pcm_prepare</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_prepare</span><span class="params">(struct snd_pcm_substream *substream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Machine &lt;link&gt; : phoenix_i2s_hw_params</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;<span class="built_in">prepare</span>) &#123;</span><br><span class="line">		ret = rtd-&gt;dai_link-&gt;ops-&gt;<span class="built_in">prepare</span>(substream);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; :	jz_pcm_prepare</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>) &#123;</span><br><span class="line">		ret = platform-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>(substream);</span><br><span class="line">	&#125;</span><br><span class="line">   	<span class="comment">// Codec &lt;idec_d3&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>) &#123;</span><br><span class="line">		ret = codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>(substream, codec_dai);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// CPU &lt;I2S&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>) &#123;</span><br><span class="line">		ret = cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">prepare</span>(substream, cpu_dai);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="soc-pcm-trigger"><a href="#soc-pcm-trigger" class="headerlink" title="soc_pcm_trigger"></a>soc_pcm_trigger</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_trigger</span><span class="params">(struct snd_pcm_substream *substream, <span class="keyword">int</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Codec &lt;idec_d3&gt; : icdc_d3_trigger</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class="line">		ret = codec_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, codec_dai);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; :	jz_pcm_trigger</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class="line">		ret = platform-&gt;driver-&gt;ops-&gt;trigger(substream, cmd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// CPU &lt;I2S&gt; : jz_i2s_trigger</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class="line">		ret = cpu_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, cpu_dai);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="soc-pcm-hw-free"><a href="#soc-pcm-hw-free" class="headerlink" title="soc_pcm_hw_free"></a>soc_pcm_hw_free</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_hw_free</span><span class="params">(struct snd_pcm_substream *substream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* free any machine hw params */</span></span><br><span class="line">	<span class="comment">// Machine &lt;link&gt; : phoenix_i2s_hw_free</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_free)</span><br><span class="line">		rtd-&gt;dai_link-&gt;ops-&gt;hw_free(substream);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free any DMA resources */</span></span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; : snd_pcm_lib_free_pages</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class="line">		platform-&gt;driver-&gt;ops-&gt;hw_free(substream);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now free hw params for the DAIs  */</span></span><br><span class="line">	<span class="comment">// Codec &lt;idec_d3&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class="line">		codec_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, codec_dai);</span><br><span class="line">	<span class="comment">// CPU &lt;I2S&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class="line">		cpu_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, cpu_dai);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="soc-pcm-pointer"><a href="#soc-pcm-pointer" class="headerlink" title="soc_pcm_pointer"></a>soc_pcm_pointer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">snd_pcm_uframes_t</span> <span class="title">soc_pcm_pointer</span><span class="params">(struct snd_pcm_substream *substream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Platform &lt;DMA&gt; :</span></span><br><span class="line">    <span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;pointer)</span><br><span class="line">        offset = platform-&gt;driver-&gt;ops-&gt;pointer(substream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">delay</span>)</span><br><span class="line">        <span class="built_in">delay</span> += cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">delay</span>(substream, cpu_dai);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">delay</span>)</span><br><span class="line">        <span class="built_in">delay</span> += codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">delay</span>(substream, codec_dai);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (platform-&gt;driver-&gt;<span class="built_in">delay</span>)</span><br><span class="line">        <span class="built_in">delay</span> += platform-&gt;driver-&gt;<span class="built_in">delay</span>(substream, codec_dai);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="soc-pcm-close"><a href="#soc-pcm-close" class="headerlink" title="soc_pcm_close"></a>soc_pcm_close</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soc_pcm_close</span><span class="params">(struct snd_pcm_substream *substream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="comment">// CPU &lt;I2S&gt; : jz_i2s_shutdown</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">shutdown</span>)</span><br><span class="line">		cpu_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">shutdown</span>(substream, cpu_dai);</span><br><span class="line">	<span class="comment">// Codec &lt;idec_d3&gt; : jz_icdc_shutdown</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">shutdown</span>)</span><br><span class="line">		codec_dai-&gt;driver-&gt;ops-&gt;<span class="built_in">shutdown</span>(substream, codec_dai);</span><br><span class="line">	<span class="comment">// Machine &lt;link&gt; : phoenix_spk_sdown</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;<span class="built_in">shutdown</span>)</span><br><span class="line">		rtd-&gt;dai_link-&gt;ops-&gt;<span class="built_in">shutdown</span>(substream);</span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; :	jz_pcm_close</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;<span class="built_in">close</span>)</span><br><span class="line">		platform-&gt;driver-&gt;ops-&gt;<span class="built_in">close</span>(substream);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">|(sound/core/pcm_native.c )</span><br><span class="line">|-&gt; snd_pcm_playback_open</span><br><span class="line">  \</span><br><span class="line">  |-&gt; snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);</span><br><span class="line">    \</span><br><span class="line">    |-&gt; <span class="keyword">while</span>(<span class="number">1</span>)&#123; snd_pcm_open_file(file, pcm, stream); schedule(); &#125;</span><br><span class="line">      \</span><br><span class="line">      |-&gt; snd_pcm_open_substream</span><br><span class="line">		\</span><br><span class="line">		|-&gt; substream-&gt;ops-&gt;<span class="built_in">open</span>(substream)</span><br><span class="line">		  |(sound/soc/soc-pcm.c)</span><br><span class="line">		  |-&gt; soc_pcm_open</span><br><span class="line">			\</span><br><span class="line">			|-&gt; cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai);</span><br><span class="line">			  \_**snd_soc_register_component** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_i2s_startup)</span><br><span class="line">			|-&gt; codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai);</span><br><span class="line">			  \_**snd_soc_register_codec** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_icdc_startup)</span><br><span class="line">			|-&gt; rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);</span><br><span class="line">			  \_ **snd_soc_register_card** -&gt; snd_soc_dai_link -&gt; snd_soc_ops (.startup = phoenix_spk_sup)</span><br></pre></td></tr></table></figure><h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><blockquote><p>ioctl幻数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取声卡信息返回给用户空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_INFO _IOR(<span class="meta-string">'A'</span>, 0x01, struct snd_pcm_info)</span></span><br><span class="line"><span class="comment">//硬件参数重新规范</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_HW_REFINE _IOWR(<span class="meta-string">'A'</span>, 0x10, struct snd_pcm_hw_params)</span></span><br><span class="line"><span class="comment">//设置硬件参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_HW_PARAMS _IOWR(<span class="meta-string">'A'</span>, 0x11, struct snd_pcm_hw_params)</span></span><br><span class="line"><span class="comment">//设置软件参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_SW_PARAMS _IOWR(<span class="meta-string">'A'</span>, 0x13, struct snd_pcm_sw_params)</span></span><br><span class="line"><span class="comment">//准备操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_PREPARE _IO(<span class="meta-string">'A'</span>, 0x40)</span></span><br><span class="line"><span class="comment">//从用户空间把音频数据拿过来，从wav文件中读出数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDRV_PCM_IOCTL_WRITEI_FRAMES _IOW(<span class="meta-string">'A'</span>, 0x50, struct snd_xferi)</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(`sound/core/pcm_native.c`)</span><br><span class="line">|-&gt;	snd_pcm_playback_ioctl</span><br><span class="line">|</span><br><span class="line">|-&gt; snd_pcm_playback_ioctl1 --&gt; 判断cmd &lt;SNDRV_PCM_IOCTL_WRITEI_FRAMES&gt;</span><br><span class="line">|(`sound/core/pcm_lib.c`)</span><br><span class="line">|-&gt; snd_pcm_lib_write --- &gt; struct snd_pcm_substream *substream</span><br><span class="line">|</span><br><span class="line">|-&gt; snd_pcm_lib_write1</span><br><span class="line">		|_call_back--&gt;snd_pcm_lib_write_transfer(数据传输:copy和map)</span><br><span class="line">			|_.(内存和DMA之间的数据传递, 循环搬送直到播放完毕)</span><br><span class="line">					char *hwbuf = runtime-&gt;dma_area + frames_to_bytes(runtime, hwoff);</span><br><span class="line">					if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))</span><br><span class="line">		|</span><br><span class="line">		|-&gt; snd_pcm_start(substream) //**启动传输(只是在开始时,调用一次)**</span><br><span class="line">			|</span><br><span class="line">			|-&gt; snd_pcm_action</span><br><span class="line">				|</span><br><span class="line">				|-&gt; snd_pcm_action_single</span><br><span class="line">					|</span><br><span class="line">					|-&gt; &#123;</span><br><span class="line">							res = ops-&gt;pre_action(substream, state);</span><br><span class="line">							if (res &lt; 0)</span><br><span class="line"> 						   		return res;</span><br><span class="line">							res = ops-&gt;do_action(substream, state);</span><br><span class="line">							if (res == 0)</span><br><span class="line"> 						   		ops-&gt;post_action(substream, state);</span><br><span class="line">							else if (ops-&gt;undo_action)</span><br><span class="line">						    	ops-&gt;undo_action(substream, state);</span><br><span class="line">						&#125;</span><br></pre></td></tr></table></figure><blockquote><p>file: sound/core/pcm_native.c</p></blockquote><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>通过系统调用close, 到release进行关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.release =      snd_pcm_release</span><br><span class="line"></span><br><span class="line">snd_pcm_release</span><br><span class="line">  |</span><br><span class="line">  |-&gt; snd_pcm_release_substream</span><br><span class="line">	|</span><br><span class="line">	|-&gt; snd_pcm_drop</span><br><span class="line">	  |</span><br><span class="line">	  |-&gt; snd_pcm_stop</span><br><span class="line">		|</span><br><span class="line">		|-&gt; snd_pcm_action(&amp;snd_pcm_action_stop, substream, state)</span><br><span class="line">	|</span><br><span class="line">	|-&gt; substream-&gt;ops-&gt;hw_free(substream)</span><br><span class="line">	|-&gt; substream-&gt;ops-&gt;close(substream)</span><br></pre></td></tr></table></figure><h2 id="control设备"><a href="#control设备" class="headerlink" title="control设备"></a>control设备</h2><h2 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h2><h2 id="数据路由"><a href="#数据路由" class="headerlink" title="数据路由"></a>数据路由</h2><h2 id="amixer的设置"><a href="#amixer的设置" class="headerlink" title="amixer的设置"></a>amixer的设置</h2><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>ASoC添加了debugfs和ftrace的调试支持。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs none /mnt/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat available_events | grep <span class="string">"asoc"</span></span></span><br><span class="line">asoc:snd_soc_cache_sync</span><br><span class="line">asoc:snd_soc_jack_notify</span><br><span class="line">asoc:snd_soc_jack_report</span><br><span class="line">asoc:snd_soc_jack_irq</span><br><span class="line">asoc:snd_soc_dapm_connected</span><br><span class="line">asoc:snd_soc_dapm_input_path</span><br><span class="line">asoc:snd_soc_dapm_output_path</span><br><span class="line">asoc:snd_soc_dapm_walk_done</span><br><span class="line">asoc:snd_soc_dapm_widget_event_done</span><br><span class="line">asoc:snd_soc_dapm_widget_event_start</span><br><span class="line">asoc:snd_soc_dapm_widget_power</span><br><span class="line">asoc:snd_soc_dapm_done</span><br><span class="line">asoc:snd_soc_dapm_start</span><br><span class="line">asoc:snd_soc_bias_level_done</span><br><span class="line">asoc:snd_soc_bias_level_start</span><br><span class="line">asoc:snd_soc_preg_read</span><br><span class="line">asoc:snd_soc_preg_write</span><br><span class="line">asoc:snd_soc_reg_read</span><br><span class="line">asoc:snd_soc_reg_write</span><br></pre></td></tr></table></figure><ul><li>在DEBUGFS下，可以查看一个各个组件及widgets的状态。</li><li>在FTRACE下，<code>echo asoc &gt; tracing/set_event</code>打开调试，就可以<code>cat /mnt/tracing/trace</code>查看widget的上下电顺序， 通路的切换等。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="频响"><a href="#频响" class="headerlink" title="频响"></a>频响</h3><blockquote><p>频率响应 简称频响，英文名称是<code>Frequency Response</code>，在电子学上用来描述一台仪器对于不同频率的信号的处理能力的差异。</p></blockquote><h3 id="扫频"><a href="#扫频" class="headerlink" title="扫频"></a>扫频</h3><blockquote><p>利用正弦波信号的频率随时间在一定范围内反复扫描</p></blockquote></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/post/6516.html" rel="bookmark">Audio ALSA数据传输</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/post/14697.html" rel="bookmark">ASOC之DPCM</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/post/25782.html" rel="bookmark">音频接口I2S</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/post/51792.html" rel="bookmark">块设备驱动</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/post/47803.html" rel="bookmark">Linux内核中驱动注册的先后顺序</a></div></li></ul><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div><div style="text-align:center;color:#ccc;font-size:16px"><script type="text/javascript" src="https://api.imjad.cn/hitokoto/?cat=&charset=utf-8&length=50&encode=js&fun=sync&source="></script><div id="hitokoto"><script>hitokoto()</script></div></div><div class="reward-container"><div></div> <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';"> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/images/alipay.jpg" alt="Winddoing 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> Winddoing</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://winddoing.github.io/post/50356.html" title="Audio驱动总结--ALSA">https://winddoing.github.io/post/50356.html</a></li><li class="post-copyright-statement"> <strong>作者声明：</strong> 本博文为个人笔记, 由于个人能力有限，难免出现错误，欢迎大家批评指正。</li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/audio/" rel="tag"><i class="fa fa-tag"></i> audio</a><a href="/tags/alsa/" rel="tag"><i class="fa fa-tag"></i> alsa</a><a href="/tags/驱动/" rel="tag"><i class="fa fa-tag"></i> 驱动</a></div><div class="post-nav"><div class="post-nav-item"><a href="/post/32902.html" rel="prev" title="状态机"><i class="fa fa-chevron-left"></i> 状态机</a></div><div class="post-nav-item"> <a href="/post/59553.html" rel="next" title="Linux内核中的read_mostly">Linux内核中的read_mostly<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#音频参数"><span class="nav-number">1.</span> <span class="nav-text">音频参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#音频处理软件"><span class="nav-number">2.</span> <span class="nav-text">音频处理软件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件"><span class="nav-number">3.</span> <span class="nav-text">硬件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#alsa-ASOC"><span class="nav-number">4.</span> <span class="nav-text">alsa - ASOC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DAPM"><span class="nav-number">4.1.</span> <span class="nav-text">DAPM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DPCM"><span class="nav-number">4.2.</span> <span class="nav-text">DPCM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PCM设备"><span class="nav-number">5.</span> <span class="nav-text">PCM设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#放音-–-应用"><span class="nav-number">5.1.</span> <span class="nav-text">放音 – 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么open两次pcmC0D0p设备节点"><span class="nav-number">5.1.1.</span> <span class="nav-text">为什么open两次pcmC0D0p设备节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么read音频文件两次-并且读的数据大小不一致"><span class="nav-number">5.1.2.</span> <span class="nav-text">为什么read音频文件两次,并且读的数据大小不一致</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户空间申请buffer大小的依据"><span class="nav-number">5.1.3.</span> <span class="nav-text">用户空间申请buffer大小的依据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#放音-–-内核"><span class="nav-number">5.2.</span> <span class="nav-text">放音 – 内核</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ASOC接口"><span class="nav-number">5.2.1.</span> <span class="nav-text">ASOC接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#soc-pcm-open"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">soc_pcm_open</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#soc-pcm-hw-params"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">soc_pcm_hw_params</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#soc-pcm-prepare"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">soc_pcm_prepare</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#soc-pcm-trigger"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">soc_pcm_trigger</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#soc-pcm-hw-free"><span class="nav-number">5.2.1.5.</span> <span class="nav-text">soc_pcm_hw_free</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#soc-pcm-pointer"><span class="nav-number">5.2.1.6.</span> <span class="nav-text">soc_pcm_pointer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#soc-pcm-close"><span class="nav-number">5.2.1.7.</span> <span class="nav-text">soc_pcm_close</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#open"><span class="nav-number">5.2.2.</span> <span class="nav-text">open</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ioctl"><span class="nav-number">5.2.3.</span> <span class="nav-text">ioctl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#close"><span class="nav-number">5.2.4.</span> <span class="nav-text">close</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#control设备"><span class="nav-number">6.</span> <span class="nav-text">control设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#codec"><span class="nav-number">7.</span> <span class="nav-text">codec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据路由"><span class="nav-number">8.</span> <span class="nav-text">数据路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#amixer的设置"><span class="nav-number">9.</span> <span class="nav-text">amixer的设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试"><span class="nav-number">10.</span> <span class="nav-text">调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能"><span class="nav-number">11.</span> <span class="nav-text">性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#频响"><span class="nav-number">11.1.</span> <span class="nav-text">频响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扫频"><span class="nav-number">11.2.</span> <span class="nav-text">扫频</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Winddoing" src="/images/Winddoing.jpg"><p class="site-author-name" itemprop="name">Winddoing</p><div class="site-description" itemprop="description">失败缘于忽视细处，成功始于重视小事。</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">301</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">62</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">245</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Winddoing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Winddoing" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://gitee.com/winddoing" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;winddoing" rel="noopener" target="_blank"><i class="fa fa-fw fa-codiepie"></i> Gitee</a></span><span class="links-of-author-item"><a href="mailto:winddoing@sina.cn" title="E-Mail → mailto:winddoing@sina.cn" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://stackoverflow.com/users/9567361/winddoing" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9567361&#x2F;winddoing" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i> StackOverflow</a></span><span class="links-of-author-item"><a href="https://travis-ci.com/Winddoing/Winddoing.github.io" title="Travis CI → https:&#x2F;&#x2F;travis-ci.com&#x2F;Winddoing&#x2F;Winddoing.github.io" rel="noopener" target="_blank"><i class="fa fa-fw fa-terminal"></i> Travis CI</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://winddoing.gitbooks.io/embedded_notes/content/" title="https:&#x2F;&#x2F;winddoing.gitbooks.io&#x2F;embedded_notes&#x2F;content&#x2F;" rel="noopener" target="_blank">嵌入式相关</a></li><li class="links-of-blogroll-item"> <a href="http://blog.csdn.net/sdreamq" title="http:&#x2F;&#x2F;blog.csdn.net&#x2F;sdreamq" rel="noopener" target="_blank">CSDN</a></li><li class="links-of-blogroll-item"> <a href="http://www.wowotech.net/" title="http:&#x2F;&#x2F;www.wowotech.net&#x2F;" rel="noopener" target="_blank">蜗窝科技</a></li><li class="links-of-blogroll-item"> <a href="https://blog.csdn.net/xiongxianze" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;xiongxianze" rel="noopener" target="_blank">xiongxianze</a></li></ul></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("02/26/2014 15:00:00"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script><script type="text/javascript" src="//rf.revolvermaps.com/0/0/5.js?i=5bivipiu0pu&amp;m=8&amp;c=ff0000&amp;cr1=ffffff" async="async"></script></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 – <span itemprop="copyrightYear">2021</span><span class="with-love" id="heart"><i class="fa fa-heartbeat"></i></span> <span class="author" itemprop="copyrightHolder">Winddoing</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">815k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">12:21</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div style="display:inline"><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1254703532'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s95.cnzz.com/z_stat.php%3Fid%3D1254703532%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"))</script></div><script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=Q8qpjA3fOO7FEUBqcmcQFptF-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'Q8qpjA3fOO7FEUBqcmcQFptF-gzGzoHsz',
            'X-LC-Key': 'tgUTq5bX3fVmn916EMRe65eJ',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/cplpkwr9o7xrystu5jnasyygclahnuoj.js"></script><script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script><script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={iconStyle:"default",boxForm:"horizontal",position:"bottomCenter",networks:"Weibo,Wechat,QQZone,Twitter,Facebook,Evernote"},new needShareButton("#needsharebutton-postbottom",pbOptions)</script></body></html>